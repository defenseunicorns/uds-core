# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

variables:
  - name: BASE_REPO
    default: "ghcr.io/defenseunicorns/packages"
  - name: FLAVOR
    default: "upstream"
  - name: SNAPSHOT
    description: Whether this is a snapshot release
    default: "false"
  - name: CA_PRIVATE_KEY
    description: "Base64 encoded private key for the UDS CA (optional, will generate new CA if not provided)"
    default: ""

tasks:
  - name: determine-repo
    actions:
      - description: "Determine repository for the given flavor/type of release"
        cmd: |
          repo="${BASE_REPO}"
          # unicorn flavor = private repository
          if [ "${FLAVOR}" = "unicorn" ]; then
            repo="${repo}/private"
          fi
          repo="${repo}/uds"
          # snapshots = snapshot repository
          if [ "${SNAPSHOT}" = "true" ]; then
            repo="${repo}/snapshots"
          fi
          echo "${repo}"
        mute: true
        setVariables:
          - name: TARGET_REPO

  - name: aks-coredns-setup
    actions:
      - description: Setup Custom ConfigMap for Core DNS
        cmd: |
          uds zarf tools kubectl apply -f - <<EOF
          apiVersion: v1
          data:
            uds.override: |
              rewrite stop {
                name regex (.*\.admin\.uds\.dev) admin-ingressgateway.istio-admin-gateway.svc.cluster.local answer auto
              }
              rewrite stop {
                name regex (.*\.uds\.dev) tenant-ingressgateway.istio-tenant-gateway.svc.cluster.local answer auto
              }
          kind: ConfigMap
          metadata:
            name: coredns-custom
            namespace: kube-system
          EOF
            uds zarf tools kubectl -n kube-system rollout restart deployment coredns

  - name: eks-storageclass-setup
    actions:
      - description: Setup GP3 Storage Class
        cmd: |
          uds zarf tools kubectl apply -f - <<EOF
            apiVersion: storage.k8s.io/v1
            kind: StorageClass
            metadata:
              name: gp3
              annotations:
                storageclass.kubernetes.io/is-default-class: "true"
            provisioner: ebs.csi.aws.com
            allowVolumeExpansion: true
            reclaimPolicy: Delete
            volumeBindingMode: WaitForFirstConsumer
            parameters:
              encrypted: "true"
              fsType: ext4
              type: gp3
          EOF

  - name: admin-gw-ip
    actions:
      - description: Fetch Admin Gateway IP Address
        cmd: |
          IP_ADDR=$(uds zarf tools kubectl get service -n istio-admin-gateway admin-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -z $IP_ADDR ]; then
            HOSTNAME=$(uds zarf tools kubectl get service -n istio-admin-gateway admin-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            IP_ADDR=$(dig +short $HOSTNAME | head -n1)
          fi; echo $IP_ADDR
        mute: true
        setVariables:
          - name: ADMIN_GW_IP

  - name: tenant-gw-ip
    actions:
      - description: Fetch Tenant Gateway IP Address
        cmd: |
          IP_ADDR=$(uds zarf tools kubectl get service -n istio-tenant-gateway tenant-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -z $IP_ADDR ]; then
            HOSTNAME=$(uds zarf tools kubectl get service -n istio-tenant-gateway tenant-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            IP_ADDR=$(dig +short $HOSTNAME | head -n1)
          fi; echo $IP_ADDR
        mute: true
        setVariables:
          - name: TENANT_GW_IP

  - name: setup-hosts
    actions:
      - task: admin-gw-ip
      - task: tenant-gw-ip
      - description: Adds Cluster LoadBalancer IP Addresses to match appropriate hosts names in /etc/hosts
        mute: true
        cmd: |
          echo "$ADMIN_GW_IP keycloak.admin.uds.dev neuvector.admin.uds.dev grafana.admin.uds.dev demo.admin.uds.dev\n$TENANT_GW_IP sso.uds.dev demo-8080.uds.dev demo-8081.uds.dev protected.uds.dev ambient-protected.uds.dev ambient2-protected.uds.dev" | sudo tee -a /etc/hosts

  - name: rename-flavored-packages
    description: "Rename flavored package files by removing the flavor suffix"
    actions:
      - description: Rename flavored package files
        cmd: |
          for FLAVORED_PACKAGE in $(find build/ -maxdepth 1 -name "zarf-package-*${FLAVOR}.tar.zst" 2>/dev/null || echo ""); do
            BASE_NAME=$(echo "${FLAVORED_PACKAGE}" | sed "s/-${FLAVOR}\.tar\.zst/.tar.zst/")
            mv -v "${FLAVORED_PACKAGE}" "${BASE_NAME}"
          done

  - name: check-multiarch-images
    description: "Script to check if/what Unicorn and Registry1 images are missing from registry."
    actions:
      - description: Check Unicorn and Registry1 Multi-Arch images
        cmd: ./scripts/check-multiarch.sh

  - name: generate-certs
    description: "Generate *.uds.dev and *.admin.uds.dev certificates using mkcert and templates them into the necessary places"
    actions:
      - description: Generate certificates and update Istio gateway values
        cmd: |
          # Create certs directory
          mkdir -p certs

          # Handle CA private key from environment variable or existing file
          if [ -n "$CA_PRIVATE_KEY" ]; then
            echo "Using CA private key from environment variable..."
            # Decode base64 CA private key and write to certs directory
            echo "$CA_PRIVATE_KEY" | base64 -d > certs/rootCA-key.pem
            chmod 600 certs/rootCA-key.pem

            # Generate CA certificate from the provided private key
            openssl req -new -x509 -days 3650 -key certs/rootCA-key.pem -out certs/rootCA.pem \
              -subj "/C=US/ST=Local/L=Local/O=UDS/OU=UDS/CN=UDS Local CA"
            chmod 644 certs/rootCA.pem

            echo "Generated CA certificate from provided private key"
          elif [ ! -f certs/rootCA.pem ]; then
            echo "No existing CA found and no CA_PRIVATE_KEY provided, generating new CA..."
            # Generate custom CA with proper subject information
            openssl genrsa -out certs/rootCA-key.pem 4096
            openssl req -new -x509 -days 3650 -key certs/rootCA-key.pem -out certs/rootCA.pem \
              -subj "/C=US/ST=Local/L=Local/O=UDS/OU=UDS/CN=UDS Local CA"

            # Set proper file permissions so everyone can read the CA
            chmod 644 certs/rootCA.pem
            chmod 600 certs/rootCA-key.pem

            echo "Created custom UDS Local CA with proper permissions"
            echo "CA private key created locally"
          else
            echo "Using existing CA from certs/rootCA.pem"
          fi

          # Generate domain certificates using OpenSSL with proper subject fields
          # Generate tenant domain certificate (*.uds.dev)
          openssl genrsa -out certs/uds-dev.key 4096
          openssl req -new -key certs/uds-dev.key -out certs/uds-dev.csr -config certs/uds-dev.conf
          openssl x509 -req -in certs/uds-dev.csr -CA certs/rootCA.pem -CAkey certs/rootCA-key.pem -CAcreateserial \
            -out certs/uds-dev.crt -days 730 -extensions v3_req -extfile certs/uds-dev.conf

          # Generate admin domain certificate (*.admin.uds.dev)
          openssl genrsa -out certs/admin-uds-dev.key 4096
          openssl req -new -key certs/admin-uds-dev.key -out certs/admin-uds-dev.csr -config certs/admin-uds-dev.conf
          openssl x509 -req -in certs/admin-uds-dev.csr -CA certs/rootCA.pem -CAkey certs/rootCA-key.pem -CAcreateserial \
            -out certs/admin-uds-dev.crt -days 730 -extensions v3_req -extfile certs/admin-uds-dev.conf

          # Clean up temporary files
          rm -f certs/uds-dev.csr certs/admin-uds-dev.csr certs/rootCA.srl

          # Clean up CA private key if it was provided via environment variable
          if [ -n "$CA_PRIVATE_KEY" ]; then
            echo "Cleaning up CA private key from local filesystem..."
            rm -f certs/rootCA-key.pem
          fi

          # Base64 encode certificates and keys (compatible with both macOS and Linux)
          ADMIN_CERT_B64=$(cat certs/admin-uds-dev.crt | base64 | tr -d '\n')
          ADMIN_KEY_B64=$(cat certs/admin-uds-dev.key | base64 | tr -d '\n')
          TENANT_CERT_B64=$(cat certs/uds-dev.crt | base64 | tr -d '\n')
          TENANT_KEY_B64=$(cat certs/uds-dev.key | base64 | tr -d '\n')
          CA_CERT_B64=$(cat certs/rootCA.pem | base64 | tr -d '\n')

          # Update Istio gateway values using yq
          ./uds zarf tools yq eval ".tls.cert = \"$ADMIN_CERT_B64\"" -i src/istio/values/config-admin.yaml
          ./uds zarf tools yq eval ".tls.key = \"$ADMIN_KEY_B64\"" -i src/istio/values/config-admin.yaml
          ./uds zarf tools yq eval ".tls.cacert = \"$CA_CERT_B64\"" -i src/istio/values/config-admin.yaml

          ./uds zarf tools yq eval ".tls.cert = \"$TENANT_CERT_B64\"" -i src/istio/values/config-tenant.yaml
          ./uds zarf tools yq eval ".tls.key = \"$TENANT_KEY_B64\"" -i src/istio/values/config-tenant.yaml
          ./uds zarf tools yq eval ".tls.cacert = \"$CA_CERT_B64\"" -i src/istio/values/config-tenant.yaml

          # Update bundle CA_CERT variables
          ./uds zarf tools yq eval ".variables.core.CA_CERT = \"$CA_CERT_B64\"" -i bundles/k3d-standard/uds-bundle.yaml
          ./uds zarf tools yq eval ".variables.core-base.CA_CERT = \"$CA_CERT_B64\"" -i bundles/k3d-slim-dev/uds-bundle.yaml
          ./uds zarf tools yq eval ".variables.core-base.CA_CERT = \"$CA_CERT_B64\"" -i bundles/base-shim/uds-bundle.yaml

          echo "Certificates generated and Istio gateway values updated successfully!"
          echo "CA certificate also templated into bundle files"
