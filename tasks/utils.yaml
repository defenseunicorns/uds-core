# Copyright 2024 Defense Unicorns
# SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial

variables:
  - name: BASE_REPO
    default: "ghcr.io/defenseunicorns/packages"
  - name: FLAVOR
    default: "upstream"
  - name: SNAPSHOT
    description: Whether this is a snapshot release
    default: "false"

tasks:
  - name: determine-repo
    actions:
      - description: "Determine repository for the given flavor/type of release"
        cmd: |
          repo="${BASE_REPO}"
          # unicorn flavor = private repository
          if [ "${FLAVOR}" = "unicorn" ]; then
            repo="${repo}/private"
          fi
          repo="${repo}/uds"
          # snapshots = snapshot repository
          if [ "${SNAPSHOT}" = "true" ]; then
            repo="${repo}/snapshots"
          fi
          echo "${repo}"
        mute: true
        setVariables:
          - name: TARGET_REPO

  - name: keycloak-admin-user
    actions:
      - description: Sets up the Keycloak admin user for dev/testing if not already created
        cmd: |
          # Check if the secret exists
          if ./zarf tools kubectl get secret keycloak-admin-password -n keycloak > /dev/null 2>&1; then
            echo "Admin user exists, skipping..."
          else
            # Start port-forward with zarf
            ./zarf tools kubectl port-forward -n keycloak svc/keycloak-http 8080:8080 &
            PF_PID=$!

            # Wait a bit to ensure port-forward is ready
            sleep 5

            # Create admin user with curl
            PASSWORD=$(openssl rand -base64 12)
            STATE_COOKIE=$(curl --silent --output /dev/null --cookie-jar - http://localhost:8080/ | grep "WELCOME_STATE_CHECKER" | awk '{print $7}')
            curl --silent --show-error http://localhost:8080/ \
              -H "Cookie: WELCOME_STATE_CHECKER=${STATE_COOKIE}" \
              -H "Content-Type: application/x-www-form-urlencoded" \
              --data-urlencode "username=admin" \
              --data-urlencode "password=${PASSWORD}" \
              --data-urlencode "passwordConfirmation=${PASSWORD}" \
              --data-urlencode "stateChecker=${STATE_COOKIE}"

            # Kill the port-forward
            kill $PF_PID

            ./zarf tools kubectl create secret generic keycloak-admin-password \
              --from-literal=username=admin \
              --from-literal=password=${PASSWORD} \
              -n keycloak
          fi
  - name: aks-coredns-setup
    actions:
      - description: Setup Custom ConfigMap for Core DNS
        cmd: |
          uds zarf tools kubectl apply -f - <<EOF
          apiVersion: v1
          data:
            uds.override: |
              rewrite stop {
                name regex (.*\.admin\.uds\.dev) admin-ingressgateway.istio-admin-gateway.svc.cluster.local answer auto
              }
              rewrite stop {
                name regex (.*\.uds\.dev) tenant-ingressgateway.istio-tenant-gateway.svc.cluster.local answer auto
              }
          kind: ConfigMap
          metadata:
            name: coredns-custom
            namespace: kube-system
          EOF
            uds zarf tools kubectl -n kube-system rollout restart deployment coredns
  - name: rke2-allow-prom-kube-dns
    actions:
      - description: Create NetworkPolicy to allow Prometheus to scrape kube-dns
        cmd: |
          uds zarf tools kubectl apply -f - <<EOF
          apiVersion: networking.k8s.io/v1
          kind: NetworkPolicy
          metadata:
            name: allow-prometheus-to-kube-dns
            namespace: kube-system
          spec:
            podSelector:
              matchLabels:
                k8s-app: kube-dns
            policyTypes:
              - Ingress
            ingress:
              - from:
                  - namespaceSelector:
                      matchLabels:
                        kubernetes.io/metadata.name: monitoring
                    podSelector:
                      matchLabels:
                        app: prometheus
                ports:
                  - protocol: TCP
                    port: 9153
          EOF
  - name: eks-coredns-setup
    actions:
      - description: Setup Custom ConfigMap for Core DNS
        cmd: |
          uds zarf tools kubectl apply -f - <<EOF
          apiVersion: v1
          data:
            Corefile: |-
              .:53 {
                  errors
                  health {
                      lameduck 5s
                  }
                  ready
                  kubernetes  cluster.local  cluster.local in-addr.arpa ip6.arpa {
                      pods insecure
                      fallthrough in-addr.arpa ip6.arpa
                      ttl 30
                  }
                  prometheus  0.0.0.0:9153
                  forward  . /etc/resolv.conf
                  cache  30
                  loop
                  reload
                  loadbalance
                  rewrite stop {
                    name regex (.*\.admin\.uds\.dev) admin-ingressgateway.istio-admin-gateway.svc.cluster.local answer auto
                    }
                  rewrite stop {
                  name regex (.*\.uds\.dev) tenant-ingressgateway.istio-tenant-gateway.svc.cluster.local answer auto
                    }
              }
          kind: ConfigMap
          metadata:
            name: coredns
            namespace: kube-system
          EOF
          uds zarf tools kubectl rollout restart deployment -n kube-system coredns
  - name: admin-gw-ip
    actions:
      - description: Fetch Admin Gateway IP Address
        cmd: |
          IP_ADDR=$(uds zarf tools kubectl get service -n istio-admin-gateway admin-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -z $IP_ADDR ]; then
            HOSTNAME=$(uds zarf tools kubectl get service -n istio-admin-gateway admin-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            IP_ADDR=$(dig +short $HOSTNAME)
          fi; echo $IP_ADDR
        mute: true
        setVariables:
          - name: ADMIN_GW_IP
  - name: tenant-gw-ip
    actions:
      - description: Fetch Tenant Gateway IP Address
        cmd: |
          IP_ADDR=$(uds zarf tools kubectl get service -n istio-tenant-gateway tenant-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
          if [ -z $IP_ADDR ]; then
            HOSTNAME=$(uds zarf tools kubectl get service -n istio-tenant-gateway tenant-ingressgateway -o=jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null)
            IP_ADDR=$(dig +short $HOSTNAME)
          fi; echo $IP_ADDR
        mute: true
        setVariables:
          - name: TENANT_GW_IP
  - name: setup-hosts
    actions:
      - task: admin-gw-ip
      - task: tenant-gw-ip
      - description: Adds Cluster LoadBalancer IP Addresses to match appropriate hosts names in /etc/hosts
        mute: true
        cmd: |
          echo "$ADMIN_GW_IP keycloak.admin.uds.dev neuvector.admin.uds.dev grafana.admin.uds.dev demo.admin.uds.dev\n$TENANT_GW_IP sso.uds.dev demo-8080.uds.dev demo-8081.uds.dev protected.uds.dev" | sudo tee --append /etc/hosts
