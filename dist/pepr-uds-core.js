"use strict";var ic=Object.defineProperty;var a=(e,t)=>ic(e,"name",{value:t,configurable:!0});var oc=require("pepr");var xn={name:"uds-core",version:"0.6.0",description:"A collection of capabilities for UDS Core",keywords:["pepr","k8s","policy-engine","pepr-module","security"],engines:{node:">=20.0.0"},pepr:{name:"UDS Core",uuid:"uds-core",onError:"reject",logLevel:"info",alwaysIgnore:{namespaces:[]},admission:{alwaysIgnore:{namespaces:["zarf"]}},watch:{alwaysIgnore:{namespaces:["zarf"]}},additionalWebhooks:[{failurePolicy:"Ignore",namespace:"istio-system"}]},scripts:{"k3d-setup":"k3d cluster delete pepr-dev && k3d cluster create pepr-dev --k3s-arg '--debug@server:0'","test:unit":"vitest run src/pepr/"},dependencies:{"@grpc/grpc-js":"^1.14.3",pepr:"^1.0.4-nightly.6"},devDependencies:{"@commitlint/cli":"20.2.0","@commitlint/config-conventional":"20.2.0","@eslint/eslintrc":"^3.3.1","@eslint/js":"^9.27.0","@types/ws":"^8.18.1","@vitest/coverage-v8":"^4.0.0",globals:"^16.2.0",husky:"9.1.7","lint-staged":"16.2.7",vitest:"^4.0.0"}};var Pn=require("pepr");function P(e){let t=Pn.Log.child({component:e}),r=process.env.UDS_LOG_LEVEL;return(!r||r==="###ZARF_VAR_UDS_LOG_LEVEL###")&&(r="debug"),t.level=r,t}a(P,"setupLogger");var Z=require("pepr");var wn=require("pepr"),Yt=new wn.Capability({name:"uds-core-operator",description:"The UDS Operator is responsible for managing the lifecycle of UDS resources"}),{Store:ym,When:_}=Yt;var G=require("pepr");var qt=require("kubernetes-fluent-client");var ee=class extends qt.GenericKind{static{a(this,"Package")}spec;status};(0,qt.RegisterKind)(ee,{group:"uds.dev",version:"v1alpha1",kind:"Package",plural:"packages"});var Jt=require("kubernetes-fluent-client");var Le=class extends Jt.GenericKind{static{a(this,"Exemption")}spec};var xe=(y=>(y.DisallowHostNamespaces="DisallowHostNamespaces",y.DisallowNodePortServices="DisallowNodePortServices",y.DisallowPrivileged="DisallowPrivileged",y.DisallowSELinuxOptions="DisallowSELinuxOptions",y.DropAllCapabilities="DropAllCapabilities",y.RequireNonRootUser="RequireNonRootUser",y.RestrictCapabilities="RestrictCapabilities",y.RestrictExternalNames="RestrictExternalNames",y.RestrictHostPathWrite="RestrictHostPathWrite",y.RestrictHostPorts="RestrictHostPorts",y.RestrictIstioAmbientOverrides="RestrictIstioAmbientOverrides",y.RestrictIstioSidecarOverrides="RestrictIstioSidecarOverrides",y.RestrictIstioTrafficOverrides="RestrictIstioTrafficOverrides",y.RestrictIstioUser="RestrictIstioUser",y.RestrictProcMount="RestrictProcMount",y.RestrictSELinuxType="RestrictSELinuxType",y.RestrictSeccomp="RestrictSeccomp",y.RestrictVolumeTypes="RestrictVolumeTypes",y))(xe||{});(0,Jt.RegisterKind)(Le,{group:"uds.dev",version:"v1alpha1",kind:"Exemption",plural:"exemptions"});var Qt=require("kubernetes-fluent-client");var ae=class extends Qt.GenericKind{static{a(this,"ClusterConfig")}spec;status};(0,Qt.RegisterKind)(ae,{group:"uds.dev",version:"v1alpha1",kind:"ClusterConfig",plural:"clusterconfig"});var Xt=require("kubernetes-fluent-client");var se=class extends Xt.GenericKind{static{a(this,"VirtualService")}spec;status};(0,Xt.RegisterKind)(se,{group:"networking.istio.io",version:"v1beta1",kind:"VirtualService"});var Zt=require("kubernetes-fluent-client");var ie=class extends Zt.GenericKind{static{a(this,"ServiceEntry")}spec;status};(0,Zt.RegisterKind)(ie,{group:"networking.istio.io",version:"v1beta1",kind:"ServiceEntry",plural:"serviceentries"});var er=require("kubernetes-fluent-client");var Re=class extends er.GenericKind{static{a(this,"PodMonitor")}spec};(0,er.RegisterKind)(Re,{group:"monitoring.coreos.com",version:"v1",kind:"PodMonitor",plural:"podmonitors"});var tr=require("kubernetes-fluent-client");var Ee=class extends tr.GenericKind{static{a(this,"ServiceMonitor")}spec;status};(0,tr.RegisterKind)(Ee,{group:"monitoring.coreos.com",version:"v1",kind:"ServiceMonitor",plural:"servicemonitors"});var rr=require("kubernetes-fluent-client");var D=class extends rr.GenericKind{static{a(this,"AuthorizationPolicy")}spec;status};(0,rr.RegisterKind)(D,{group:"security.istio.io",version:"v1beta1",kind:"AuthorizationPolicy",plural:"authorizationpolicies"});var or=require("kubernetes-fluent-client");var Be=class extends or.GenericKind{static{a(this,"RequestAuthentication")}spec;status};(0,or.RegisterKind)(Be,{group:"security.istio.io",version:"v1",kind:"RequestAuthentication"});var ir=require("kubernetes-fluent-client");var nr=class extends ir.GenericKind{static{a(this,"DestinationRule")}spec;status};(0,ir.RegisterKind)(nr,{group:"networking.istio.io",version:"v1",kind:"DestinationRule",plural:"destinationrules"});var ar=require("kubernetes-fluent-client");var ke=class extends ar.GenericKind{static{a(this,"Gateway")}spec;status};(0,ar.RegisterKind)(ke,{group:"networking.istio.io",version:"v1",kind:"Gateway",plural:"gateways"});var sr=require("kubernetes-fluent-client");var $e=class extends sr.GenericKind{static{a(this,"Sidecar")}spec;status};(0,sr.RegisterKind)($e,{group:"networking.istio.io",version:"v1",kind:"Sidecar",plural:"sidecars"});var cr=require("kubernetes-fluent-client");var ce=class extends cr.GenericKind{static{a(this,"K8sGateway")}spec;status};(0,cr.RegisterKind)(ce,{group:"gateway.networking.k8s.io",version:"v1",kind:"Gateway",plural:"gateways"});var We=(o=>(o.Tenant="tenant",o.Admin="admin",o.Passthrough="passthrough",o))(We||{});var Do=require("kubernetes-fluent-client/dist/fluent/shared-types"),he=require("pepr");var An=require("crypto");var ze=require("kubernetes-fluent-client"),Ue=require("pepr");var Ct="cluster.local/ns/monitoring/sa/kube-prometheus-stack-prometheus",it={resyncFailureMax:process.env.PEPR_RESYNC_FAILURE_MAX?parseInt(process.env.PEPR_RESYNC_FAILURE_MAX,10):5,resyncDelaySec:process.env.PEPR_RESYNC_DELAY_SECONDS?parseInt(process.env.PEPR_RESYNC_DELAY_SECONDS,10):5,lastSeenLimitSeconds:process.env.PEPR_LAST_SEEN_LIMIT_SECONDS?parseInt(process.env.PEPR_LAST_SEEN_LIMIT_SECONDS,10):300,relistIntervalSec:process.env.PEPR_RELIST_INTERVAL_SECONDS?parseInt(process.env.PEPR_RELIST_INTERVAL_SECONDS,10):600};function at(e,t,r){let o={[ze.WatchEvent.GIVE_UP]:n=>{t.error(`WatchEvent GiveUp (${r}): The watch has failed to start after several attempts: ${n.message}`),process.exit(1)},[ze.WatchEvent.DATA_ERROR]:n=>t.warn(`WatchEvent DataError (${r}): ${n.message}`),[ze.WatchEvent.RECONNECT]:n=>t.debug(`WatchEvent Reconnect (${r}): Reconnecting watch after ${n} attempt${n===1?"":"s"}`),[ze.WatchEvent.ABORT]:n=>t.warn(`WatchEvent Abort (${r}): ${n.message}`),[ze.WatchEvent.NETWORK_ERROR]:n=>t.warn(`WatchEvent NetworkError (${r}): ${n.message}`),[ze.WatchEvent.LIST_ERROR]:n=>t.warn(`WatchEvent ListError (${r}): ${n.message}`)};Object.entries(o).forEach(([n,s])=>{e.events.on(n,s)})}a(at,"registerWatchEventHandlers");function v(e){return e.toLowerCase().replace(/[^a-z0-9]+/g,"-").slice(0,250).replace(/^[^a-z]+|[^a-z]+$/g,"")}a(v,"sanitizeResourceName");function L(e){let{name:t,uid:r}=e.metadata;return[{apiVersion:e.apiVersion,kind:e.kind,uid:r,name:t}]}a(L,"getOwnerRef");async function R(e,t,r,o,n,s){let i=(0,Ue.K8s)(o).InNamespace(t).WithLabel("uds/package",r);if(s)for(let[l,p]of Object.entries(s))i=i.WithLabel(l,p);let c=await i.Get();for(let l of c.items)l.metadata?.labels?.["uds/generation"]!==e&&(n.debug({resource:l},`Deleting orphaned ${l.kind} ${l.metadata.name}`),await(0,Ue.K8s)(o).Delete(l))}a(R,"purgeOrphans");async function I(e,t,r=5,o=2e3){let n=0;for(;n<r;)try{return await e()}catch(s){if(n++,n>=r)throw s;let i="Unknown Error";s&&(i=`${JSON.stringify(s)}`,s.data?.message?i=s.data.message:s.message&&(i=s.message)),t.warn({error:i},`Attempt ${n} of ${e.name||"anonymous function"} failed, retrying in ${o}ms.`),await new Promise(c=>setTimeout(c,o))}throw new Error("Retry loop exited unexpectedly without returning.")}a(I,"retryWithDelay");function vn(e){try{return Buffer.from(e,"base64").toString("base64")===e}catch{return!1}}a(vn,"isBase64");async function Cn(e,t={},r){let o=e.metadata?.name,n=e.metadata?.namespace,s=e.kind;if(!o||!n||!s){let i=new Error("Cannot create event: resource missing name, namespace, or kind");throw r.error(i.message),i}await(0,Ue.K8s)(Ue.kind.CoreEvent).Create({type:"Normal",reason:"Update",...t,metadata:{namespace:n,generateName:o},involvedObject:{apiVersion:e.apiVersion,kind:s,name:o,namespace:n,uid:e.metadata?.uid},firstTimestamp:new Date,reportingComponent:"uds.dev/operator",reportingInstance:process.env.HOSTNAME})}a(Cn,"createEvent");async function Ye(e,t){try{return await(0,Ue.K8s)(Ue.kind.Namespace).Get(e)}catch(r){if(r?.status==404){if(t)return null;throw r}else throw r}}a(Ye,"validateNamespace");function Pe(e){return(e.spec?.sso||[]).filter(r=>r?.enableAuthserviceSelector!=null)}a(Pe,"getAuthserviceClients");async function Rn(e){try{no(e.Raw)}catch(t){return e.Deny(`Validation failed: ${t.message}`)}return e.Approve()}a(Rn,"validateCfgUpdate");function no(e){if(e.spec?.caBundle?.certs&&e.spec.caBundle.certs!=="###ZARF_VAR_CA_BUNDLE_CERTS###"&&e.spec.caBundle.certs!=="###ZARF_VAR_CA_CERT###"){if(!vn(e.spec.caBundle.certs))throw new Error("ClusterConfig: caBundle.certs must be base64 encoded; found invalid value");let r=Buffer.from(e.spec.caBundle.certs,"base64").toString("utf8").match(/-----BEGIN CERTIFICATE-----[\s\S]*?-----END CERTIFICATE-----/g);if(!r||r.length===0)throw new Error("ClusterConfig: No valid certificates found in bundle");r.forEach((o,n)=>{try{new An.X509Certificate(o)}catch(s){throw new Error(`ClusterConfig: Invalid certificate at index ${n}: ${s instanceof Error?s.message:String(s)}`)}})}}a(no,"validateCfg");var Fe=require("pepr");var io="uds/ca-bundle",hc="uds-trust-bundle",yc="ca-bundle.pem",fe=P("operator.ca-bundle");async function ao(e,t){let r=e.metadata.name,o=(e.metadata?.generation??0).toString(),n=L(e),s=e.spec?.caBundle?.configMap?.name||hc,i=e.spec?.caBundle?.configMap?.key||yc,c=e.spec?.caBundle?.configMap?.labels||{},l=e.spec?.caBundle?.configMap?.annotations||{};try{fe.debug(`Reconciling CA Bundle ConfigMap for ${r}`);let p=bc();if(!p||p.trim()===""){fe.debug(`No CA bundle content available, deleting any existing ConfigMaps for ${r}`);try{await(0,Fe.K8s)(Fe.kind.ConfigMap).InNamespace(t).WithLabel("uds/package",r).WithLabel(io,"true").Delete(),fe.debug(`Deleted existing CA bundle ConfigMaps for ${r} in namespace ${t}`)}catch{}return}let u={apiVersion:"v1",kind:"ConfigMap",metadata:{name:s,namespace:t,labels:{"uds/package":r,"uds/generation":o,[io]:"true",...c},annotations:{...l},ownerReferences:n},data:{[i]:p}};await(0,Fe.K8s)(Fe.kind.ConfigMap).Apply(u,{force:!0}),await R(o,t,r,Fe.kind.ConfigMap,fe,{[io]:"true"})}catch(p){throw new Error(`Failed to process CA Bundle ConfigMap for ${r}, cause: ${JSON.stringify(p)}`)}}a(ao,"caBundleConfigMap");function bc(){let e=[];if(g.caBundle.certs){let t=atob(g.caBundle.certs);t&&e.push(t)}if(g.caBundle.includeDoDCerts&&g.caBundle.dodCerts){let t=atob(g.caBundle.dodCerts);t&&e.push(t)}if(g.caBundle.includePublicCerts&&g.caBundle.publicCerts){let t=atob(g.caBundle.publicCerts);t&&e.push(t)}return e.filter(t=>t.trim()).join(`

`).trim()}a(bc,"buildCABundleContent");async function so(){try{fe.debug("Starting CA bundle ConfigMap updates for all UDS packages");let e=await(0,Fe.K8s)(ee).Get();if(!e.items||e.items.length===0){fe.debug("No UDS packages found, no CA bundle ConfigMaps to update");return}fe.debug(`Found ${e.items.length} UDS packages, processing CA bundle ConfigMaps`);for(let t of e.items){if(!t.metadata?.name||!t.metadata?.namespace)continue;let r=t.metadata.name,o=t.metadata.namespace;try{fe.debug(`Processing CA bundle ConfigMap for package ${r} in namespace ${o}`),await ao(t,o)}catch(n){fe.error(`Failed to process CA bundle ConfigMap for package ${r} in namespace ${o}`,n)}}fe.debug("Completed CA bundle ConfigMap updates for all UDS packages")}catch(e){throw fe.error("Failed to update CA bundle ConfigMaps for all packages",e),new Error("Failed to update CA bundle ConfigMaps for all packages",{cause:e})}}a(so,"updateAllCaBundleConfigMaps");var Io=require("pepr");var O=require("pepr");var co=P("operator.packages"),we,qe;function xc(){we=new Map,qe=new Map}a(xc,"init");function Pc(e,t=!0){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let r=e.metadata.namespace,o=e.metadata.name;we.has(r)||we.set(r,new Map);let n=we.get(r),s=n.has(o);n.set(o,e);let i=e.spec?.sso;i&&i.forEach(c=>{let l=c.clientId;qe.has(l)||qe.set(l,new Set),qe.get(l).add(r)}),t&&(s?co.debug(`Updating PackageStore for package ${o} in namespace ${r}.`):co.debug(`Added package: ${r}/${o} to package map`))}a(Pc,"add");function wc(e,t=!0){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let r=e.metadata.namespace,o=e.metadata.name,n=we.get(r);if(!n)return;n.delete(o),n.size===0&&we.delete(r);let s=e.spec?.sso;s&&s.forEach(i=>{let c=i.clientId,l=qe.get(c);l&&(l.delete(r),l.size===0&&qe.delete(c))}),t&&co.debug(`Removed package: ${r}/${o} from package map`)}a(wc,"remove");function Sc(e){return we.has(e)}a(Sc,"hasKey");function vc(e){let t=we.get(e);return!t||t.size===0?null:Array.from(t.keys())[0]}a(vc,"getPkgName");function Cc(e){return qe.get(e)??new Set}a(Cc,"findPackagesWithSsoClientId");function Ac(){let e=[];for(let t of we.values())for(let r of t.values())r.spec?.network?.serviceMesh?.mode==="ambient"&&e.push(r);return e}a(Ac,"getAmbientPackages");function Rc(e){let t=we.get(e);if(!(!t||t.size===0))return Array.from(t.values())[0]}a(Rc,"getPackageByNamespace");var ge={init:xc,add:Pc,remove:wc,hasKey:Sc,getPkgName:vc,findPackagesWithSsoClientId:Cc,getAmbientPackages:Ac,getPackageByNamespace:Rc};var fr=require("pepr");function En(e,t,r,o,n,s,i){let c=i?{principals:[`cluster.local/ns/${r}/sa/${i}`]}:{namespaces:[`${r}`]};return{metadata:{name:Ec(e,i),namespace:r,labels:{"uds/package":t,"uds/generation":o,"uds/for":"egress"},ownerReferences:n},spec:{action:"ALLOW",rules:[{from:[{source:c}]}],targetRef:{group:"networking.istio.io",kind:"ServiceEntry",name:s}}}}a(En,"generateAmbientEgressAuthorizationPolicy");function Ec(e,t){return t?v(`${e}-${t}-egress`):v(`${e}-egress`)}a(Ec,"generateAmbientEgressAuthorizationPolicyName");var Ie=require("pepr");var Vn=require("pepr");var uo=require("pepr");function kn(e,t,r,o,n){let{gateway:s="tenant",host:i}=e,c=kc(r,e),l=s==="admin"?g.adminDomain:g.domain,p="";i==="."?p=l:p=`${i}.${l}`;let u={name:"https",number:443,protocol:"HTTPS"},d={address:`${s}-ingressgateway.istio-${s}-gateway.svc.cluster.local`};return{metadata:{name:c,namespace:t,labels:{"uds/package":r,"uds/generation":o},ownerReferences:n},spec:{hosts:[p],location:"MESH_INTERNAL",resolution:"DNS",ports:[u],endpoints:[d]}}}a(kn,"generateIngressServiceEntry");function kc(e,t){let{gateway:r="tenant",host:o}=t;return v(`${e}-${r}-${o==="."?"root-domain":o}`)}a(kc,"generateSEName");function lr(e,t,r,o,n,s,i){let{portProtocol:c}=t,l=lo(r,c,e),p=c.map(d=>({name:`${d.protocol.toLowerCase()}-${d.port.toString()}`,number:d.port,protocol:d.protocol})),u={metadata:{name:l,namespace:o,labels:{"uds/package":r,"uds/generation":n},ownerReferences:s},spec:{hosts:[e],location:"MESH_EXTERNAL",resolution:"DNS",ports:p,exportTo:["."]}};return i==="ambient"&&(u.metadata.labels["istio.io/use-waypoint"]=pr,u.metadata.labels["istio.io/use-waypoint-namespace"]=re),u}a(lr,"generateLocalEgressServiceEntry");function Tn(e,t,r){let o=Tc(e),n={};for(let c of t.packages)n[`${He(c)}`]="user";let s=t.portProtocols.map(c=>({name:`${c.protocol.toLowerCase()}-${c.port.toString()}`,number:c.port,protocol:c.protocol}));return{metadata:{name:o,namespace:F,annotations:n,labels:{"uds/package":Te,"uds/generation":r.toString()}},spec:{hosts:[e],location:"MESH_EXTERNAL",resolution:"DNS",ports:s,exportTo:["."]}}}a(Tn,"generateSharedServiceEntry");function lo(e,t,r){let o=t.map(n=>`${n.port.toString()}-${n.protocol.toLowerCase()}`).join("-");return v(`${e}-egress-${r}-${o}`)}a(lo,"generateLocalEgressSEName");function Tc(e){return v(`service-entry-${e}`)}a(Tc,"generateSharedEgressSEName");var In=require("pepr");function On(e,t,r,o,n){let{gateway:s="tenant",host:i,port:c,service:l,advancedHTTP:p={}}=e,u=po(r,e),d=g.domain;e.domain?d=e.domain:(s==="admin"||s.includes("admin"))&&(d=g.adminDomain);let m="";i==="."?m=d:m=`${i}.${d}`;let h={...p},x=[{destination:{host:`${l}.${t}.svc.cluster.local`,port:{number:c}}}];!p.directResponse&&!p.redirect&&(h.route=x);let S={metadata:{name:u,namespace:t,labels:{"uds/package":r,"uds/generation":o},ownerReferences:n},spec:{hosts:[m],gateways:[`istio-${s}-gateway/${s}-gateway`],http:[h]}};return(s==="passthrough"||s.includes("passthrough"))&&(S.spec.tls=[{match:[{port:443,sniHosts:[m]}],route:x}]),S}a(On,"generateIngressVirtualService");function po(e,t){let{gateway:r="tenant",host:o,port:n,service:s,description:i,advancedHTTP:c}=t,l=c?.match?.flatMap(m=>m.name).join("-")||"",u=i||`${o==="."?"root-domain":o}-${n}-${s}-${l}`;return v(`${e}-${r}-${u}`)}a(po,"generateVSName");function Nn(e,t,r){let o=Dn(e),n={};for(let l of t.packages)n[`${He(l)}`]="user";let s=[],i=[];for(let l of t.portProtocols){let p=l.port,u=l.protocol,d=Ic(e,p,u);u=="TLS"?i.push(...d):u=="HTTP"&&s.push(...d)}return{metadata:{name:o,namespace:F,annotations:n,labels:{"uds/generation":r.toString(),"uds/package":Te}},spec:{hosts:[e],gateways:["mesh",`${At(e)}`],...i.length>0&&{tls:i},...s.length>0&&{http:s}}}}a(Nn,"generateEgressVirtualService");function Ic(e,t,r){let o={gateways:["mesh"],port:t,...r=="TLS"&&{sniHosts:[e]}},n={gateways:[`${At(e)}`],port:t,...r=="TLS"&&{sniHosts:[e]}};return[{match:[o],route:[{destination:{host:`egressgateway.${F}.svc.cluster.local`,port:{number:t}}}]},{match:[n],route:[{destination:{host:e,port:{number:t}}}]}]}a(Ic,"generateVirtualServiceRoutes");async function Mn(e){let t=await(0,In.K8s)(se).Get(),r=Dn(e);for(let o of t.items)if(!(o.metadata?.name===r&&o.metadata?.namespace===F)&&o.spec&&o.spec.hosts){for(let n of o.spec.hosts)if(n===e){let s=`Found existing Virtual Service ${o.metadata?.name}/${o.metadata?.namespace} with matching host. Istio will not behave properly with multiple Virtual Services using the same hosts.`;throw b.error(s),new Error(s)}}}a(Mn,"warnMatchingExistingVirtualServices");function Dn(e){return v(`egress-vs-${e}`)}a(Dn,"generateEgressVSName");var b=P("operator.istio");async function Ln(e,t){let r=e.metadata.name,o=(e.metadata?.generation??0).toString(),n=L(e),s=e.spec?.network?.expose??[],i=new Set,c=new Map;for(let l of s){let p=On(l,t,r,o,n);b.debug(p,`Applying VirtualService ${p.metadata?.name}`),await(0,uo.K8s)(se).Apply(p,{force:!0}),p.spec.hosts.forEach(d=>i.add(d));let u=kn(l,t,r,o,n);c.get(u.metadata.name)||(b.debug(u,`Applying ServiceEntry ${u.metadata?.name}`),await(0,uo.K8s)(ie).Apply(u,{force:!0}),c.set(u.metadata.name,!0))}return await Oc(e,t),await R(o,t,r,se,b),await R(o,t,r,ie,b),await R(o,t,r,$e,b),await R(o,t,r,D,b,{"uds/for":"egress"}),[...i]}a(Ln,"istioResources");async function Oc(e,t){let r=e.spec?.network?.serviceMesh?.mode||"sidecar",o=mo(e),n=e.metadata.name,s=(e.metadata?.generation??0).toString(),i=L(e),c=Fn(e),l=dr(e.spec?.network?.allow??[]);if(c)if(r==="ambient"){try{await Ye(re)}catch(p){let u=`Unable to get the egress waypoint namespace ${re}.`;throw p?.status==404&&(u=`The '${re}' namespace was not found. Ensure the 'istio-egress-ambient' component is deployed and try again.`),b.error(u),new Error(u)}await Hn(c,l,n,t,s,i)}else await $n(c),await Un(c,l,n,t,s,i);try{await ur(c,o,"AddOrUpdatePackage",r)}catch(p){throw b.error(`Failed to reconcile shared egress resources for package ${o}`,p),p}}a(Oc,"istioEgressResources");function He(e){return`uds.dev/user-${e}`}a(He,"getSharedAnnotationKey");function mo(e){return`${e.metadata?.name}-${e.metadata?.namespace}`}a(mo,"getPackageId");function jn(e,t,r){let o=At(e),n={};for(let c of t.packages)n[`${He(c)}`]="user";let s=[];for(let c of t.portProtocols){let l=c.port,p=c.protocol,u=Nc(e,p,l);s.push(u)}return{metadata:{name:o,namespace:F,annotations:n,labels:{"uds/generation":r.toString(),"uds/package":Te}},spec:{selector:{app:"egressgateway"},servers:s}}}a(jn,"generateEgressGateway");function Nc(e,t,r){return{hosts:[e],port:{name:`${t.toLowerCase()}-${r.toString()}`,number:r,protocol:t},tls:{mode:"PASSTHROUGH"}}}a(Nc,"generateGatewayServer");async function Kn(e){let t=await(0,Vn.K8s)(ke).Get(),r=At(e);for(let o of t.items)if(!(o.metadata?.name===r&&o.metadata?.namespace===F)&&o.spec&&o.spec.servers){for(let n of o.spec.servers)for(let s of n.hosts)if(s===e){let i=`Found existing Gateway ${o.metadata?.name}/${o.metadata?.namespace} with matching host. Istio will not behave properly with multiple Gateways using the same hosts.`;throw b.error(i),new Error(i)}}}a(Kn,"warnMatchingExistingGateways");function At(e){return v(`gateway-${e}`)}a(At,"generateGatewayName");function Gn(e,t,r,o,n){return{metadata:{name:Mc(t,e),namespace:r,labels:{"uds/package":t,"uds/generation":o},ownerReferences:n},spec:{outboundTrafficPolicy:{mode:"REGISTRY_ONLY"},...e&&{workloadSelector:{labels:e}}}}}a(Gn,"generateEgressSidecar");function Mc(e,t){let r=t?Object.entries(t).map(([o,n])=>`${o}-${n}`).join("-"):"default";return v(`${e}-egress-${r}`)}a(Mc,"generateSidecarName");var F="istio-egress-gateway",Te="shared-egress-resource";async function Bn(e,t){let r=Dc(e),o=[];for(let n in r){let s=r[n],i=_c(n,s,t);o.push(i)}await Promise.all(o)}a(Bn,"applySidecarEgressResources");async function Wn(e){try{await R(e,F,Te,ke,b),await R(e,F,Te,se,b),await R(e,F,Te,ie,b)}catch(t){let r="Failed to purge orphaned sidecar egress resources";throw b.error("Failed to purge orphaned sidecar egress resources",t),r}}a(Wn,"purgeSidecarEgressResources");function Dc(e){let t={};for(let r in e){let o=e[r];for(let n in o){let s=o[n].portProtocol;t[n]??={packages:[],portProtocols:[]},t[n].packages.includes(r)||t[n].packages.push(r);for(let i of s)t[n].portProtocols.find(l=>l.port===i.port&&l.protocol===i.protocol)||t[n].portProtocols.push(i)}}return t}a(Dc,"remapEgressResources");async function _c(e,t,r){try{await Kn(e),await Mn(e);let o=[],n=(async()=>{try{let c=jn(e,t,r);b.debug(c,`Applying Egress Gateway ${c.metadata?.name}`),await(0,Ie.K8s)(ke).Apply(c,{force:!0})}catch(c){let l=`Failed to apply Gateway for host ${e}`;throw b.error(l,c),new Error(l)}})();o.push(n);let s=(async()=>{try{let c=Nn(e,t,r);b.debug(c,`Applying Egress Virtual Service ${c.metadata?.name}`),await(0,Ie.K8s)(se).Apply(c,{force:!0})}catch(c){let l=`Failed to apply Virtual Service for host ${e}`;throw b.error(l,c),new Error(l)}})();o.push(s);let i=(async()=>{try{let c=Tn(e,t,r);b.debug(c,`Applying Service Entry ${c.metadata?.name}`),await(0,Ie.K8s)(ie).Apply(c,{force:!0})}catch(c){let l=`Failed to apply Service Entry for host ${e}`;throw b.error(l,c),new Error(l)}})();o.push(i),await Promise.all(o)}catch(o){throw b.error(`Failed to apply egress resources for host ${e} of generation ${r}`,o),o}}a(_c,"applyHostResources");async function $n(e){try{await Ye(F)}catch(o){let n=`Unable to get the egress gateway namespace ${F}.`;throw o?.status==404&&(n="Egress gateway is not enabled in the cluster. Please enable the egress gateway and retry."),b.error(n),new Error(n)}let r=(await(0,Ie.K8s)(Ie.kind.Service).InNamespace(F).Get("egressgateway")).spec?.ports??[];for(let o in e)for(let n of e[o].portProtocol)if(!r.find(i=>i.port===n.port)){let i=`Egress gateway does not expose port ${n.port} for host ${o}. Please update the egress gateway service to expose this port.`;throw b.error(i),new Error(i)}}a($n,"validateEgressGateway");async function Un(e,t,r,o,n,s){for(let l of Object.keys(e)){let p=lr(l,e[l],r,o,n,s,"sidecar");b.debug(p,`Applying Service Entry ${p.metadata?.name}`),await(0,Ie.K8s)(ie).Apply(p,{force:!0})}let i=new Set(t.map(l=>l.selector||void 0)),c=new Set;for(let l of i){if(c.has(JSON.stringify(l)))continue;c.add(JSON.stringify(l));let p=Gn(l,r,o,n,s);b.debug(p,`Applying Sidecar ${p.metadata?.name}`),await(0,Ie.K8s)($e).Apply(p,{force:!0})}}a(Un,"createSidecarWorkloadEgressResources");var ct={},fo=!1,zn=[],lt={},go=!1,Yn=[],st=null,bo=new Set,ho=0,yo=0;async function ur(e,t,r,o){return o==="ambient"?(await qn(e,t,"RemovePackage"),await Jn(e,t,r)):(await qn(e,t,r),await Jn(e,t,"RemovePackage")),await Lc(t)}a(ur,"reconcileSharedEgressResources");async function Lc(e){if(st)try{if(await st,bo.has(e))return}catch{st=null}st=$c();try{await st}catch(t){throw b.error("Egress reconciliation failed",t),t}finally{st=null}}a(Lc,"performEgressReconciliationWithMutex");async function $c(){Uc();let e=[];try{await Ye(F,!0)&&(ho++,await Bn(ct,ho),await Wn(ho.toString()))}catch(t){let r="Failed to reconcile sidecar egress resources";b.error(r,t),e.push(new Error(r))}try{if(await Ye(re,!0)){yo++;let r=new Set(Object.keys(lt));await Qn(r,yo),await Xn(yo.toString())}}catch(t){let r="Failed to reconcile ambient egress resources";b.error(r,t),e.push(new Error(r))}if(e.length>0){let t=e.map(r=>r.message).join("; ");throw new Error(`Egress reconciliation failed: ${t}`)}}a($c,"performEgressReconciliation");async function qn(e,t,r){fo&&await new Promise(o=>{zn.push(o)});try{b.debug("Locking egress package map for update"),fo=!0,r=="AddOrUpdatePackage"?e?(Fc(ct,e,t),ct[t]=e):mr(ct,t):r=="RemovePackage"&&mr(ct,t)}catch(o){throw b.error({action:r,e:o},"Failed to update in memory egress package map for event"),o}finally{b.debug("Unlocking egress package map for update"),fo=!1;let o=zn.shift();o&&o()}}a(qn,"updateInMemoryPackageMap");async function Jn(e,t,r){go&&await new Promise(o=>{Yn.push(o)});try{if(b.debug("Locking ambient package map for update"),go=!0,r=="AddOrUpdatePackage")if(e){let o=Hc(lt,e,t);lt[t]=o}else mr(lt,t);else r=="RemovePackage"&&mr(lt,t)}catch(o){throw b.error({action:r,e:o},"Failed to update in memory ambient package map for event"),o}finally{b.debug("Unlocking ambient package map for update"),go=!1;let o=Yn.shift();o&&o()}}a(Jn,"updateInMemoryAmbientPackageMap");function Uc(){return bo=new Set([...Object.keys(ct),...Object.keys(lt)]),bo}a(Uc,"updateLastReconciliationPackages");function Fc(e,t,r){let o={};for(let[n,s]of Object.entries(e))if(n!==r)for(let[i,c]of Object.entries(s))for(let l of c.portProtocol){let p=`${i}:${l.port}`;o[p]={protocol:l.protocol,packageId:n}}for(let[n,s]of Object.entries(t))for(let i of s.portProtocol){let c=`${n}:${i.port}`,l=o[c];if(l&&l.protocol!==i.protocol){let p=`Protocol conflict detected for ${n}:${i.port}. Package "${r}" wants to use ${i.protocol} but package "${l.packageId}" is already using ${l.protocol} for the same host and port combination.`;throw b.error(p),new Error(p)}}}a(Fc,"validateProtocolConflicts");function Hc(e,t,r){let o=t;for(let[n,s]of Object.entries(e))if(n!==r)for(let[i,c]of Object.entries(s)){let l=c.portProtocol.map(p=>`${p.port}-${p.protocol}`);for(let[p,u]of Object.entries(t))if(i===p){if(!u.portProtocol.map(m=>`${m.port}-${m.protocol}`).every(m=>l.includes(m))){let m=`Port/Protocol conflict detected for ${i}. Package "${n}" is using different port/protocol combination for the same host.`;throw b.error(m),new Error(m)}o[p].portProtocol=c.portProtocol}}return o}a(Hc,"validatePortProtocolConflicts");function Fn(e){let t={};for(let r of e.spec?.network?.allow??[]){let o=xo(r);if(o){t[o.host]||(t[o.host]={portProtocol:[]});for(let n of o.ports)t[o.host].portProtocol.find(i=>i.port===n&&i.protocol===o.protocol)||t[o.host].portProtocol.push({port:n,protocol:o.protocol})}}if(Object.keys(t).length>0)return t}a(Fn,"createHostResourceMap");function xo(e){let t,r=e.remoteHost,o=e.remoteProtocol??"TLS",n=[];return e.ports?n=e.ports:e.port?n=[e.port]:n=[443],r&&(t={host:r,ports:n,protocol:o}),t}a(xo,"getHostPortsProtocol");function mr(e,t){e[t]?delete e[t]:b.debug({pkgId:t},"No resources found for package")}a(mr,"removeMapResources");function dr(e){return e.filter(t=>t.remoteHost)}a(dr,"egressRequestedFromNetwork");var re="istio-egress-ambient",Po="shared-ambient-egress-resource";async function Qn(e,t){if(e.size===0)return;let r=Zn(e,t),o=r.metadata?.name??"undefined";b.debug(r,`Applying Waypoint ${o}`),await(0,fr.K8s)(ce).Apply(r,{force:!0}),await wo(re,o)}a(Qn,"applyAmbientEgressResources");async function Xn(e){try{await R(e,re,Po,ce,b)}catch(t){let r="Failed to purge orphaned ambient egress resources";throw b.error("Failed to purge orphaned ambient egress resources",t),r}}a(Xn,"purgeAmbientEgressResources");async function Hn(e,t,r,o,n,s){for(let i of Object.keys(e)){let c=lr(i,e[i],r,o,n,s,"ambient");b.debug(c,`Applying Service Entry ${c.metadata?.name}`),await(0,fr.K8s)(ie).Apply(c,{force:!0})}for(let i of t){let c=xo(i);if(!c)continue;let{host:l,ports:p,protocol:u}=c,d=p.map(h=>({port:h,protocol:u})),m=En(l,r,o,n,s,lo(r,d,l),i.serviceAccount);b.debug(m,`Applying Authorization Policy ${m.metadata?.name}`),await(0,fr.K8s)(D).Apply(m,{force:!0})}}a(Hn,"createAmbientWorkloadEgressResources");var ei="-waypoint",Rt=a(e=>e.spec?.network?.serviceMesh?.mode==="ambient"&&Vc(e),"shouldUseAmbientWaypoint"),Vc=a(e=>e.spec?.sso?.some(t=>t.enableAuthserviceSelector!==void 0)||!1,"hasAuthserviceSSO"),H=a(e=>{if(!e||e.trim()==="")throw new Error("Waypoint ID cannot be empty");let t=e;return t.endsWith(ei)||(t=`${t}${ei}`),t},"getWaypointName");function Et(e,t,r){return Rt(e)?{"istio.io/gateway-name":r}:t}a(Et,"getPodSelector");function So(e,t){let r=e.spec?.selector||{};return Object.entries(t).every(([o,n])=>r[o]===n)}a(So,"serviceMatchesSelector");function kt(e,t){return Object.entries(t).every(([r,o])=>e[r]===o)}a(kt,"matchesLabels");var pr="egress-waypoint",pt="istio.io/use-waypoint",jc="uds/managed-by",Kc={intervalMs:5e3,timeoutMs:6e4};async function ti(e,t){let{namespace:r,name:o}=e.metadata||{};if(!r||!o){let i="Package metadata is missing namespace or name";throw b.error({pkg:e},i),new Error(i)}b.info(`Starting ambient waypoint setup for package ${o} in ${r}`);let n=t.clientId,s=H(n);try{await Gc(e,s),await wo(r,s),await Yc(e,t,s)}catch(i){let c=i instanceof Error?i.message:String(i);throw b.error({errorMessage:c},`Error in ambient waypoint setup for waypoint ${s} in ${r}`),i}}a(ti,"setupAmbientWaypoint");async function Gc(e,t){let{namespace:r,name:o}=e.metadata||{};if(!r||!o)throw new Error("Package metadata is missing namespace or name");b.info(`Creating waypoint gateway for package: ${r}/${o}`);try{let n=new ce;n.metadata={name:t,namespace:r,labels:{[jc]:"uds-operator","app.kubernetes.io/component":"ambient-waypoint","istio.io/waypoint-for":"all","istio.io/gateway-name":t,"uds/generation":(e.metadata?.generation??0).toString(),"uds/package":e.metadata?.name??"unknown"},ownerReferences:L(e)},n.spec={gatewayClassName:"istio-waypoint",listeners:[{name:"mesh",port:15008,protocol:"HBONE"}]},b.info({namespace:r,name:t,gatewayClassName:n.spec.gatewayClassName,ownerReferences:JSON.stringify(n.metadata.ownerReferences)},"Applying waypoint gateway");try{return await(0,O.K8s)(ce).Apply(n),b.info({namespace:r,waypointName:t},"Successfully created waypoint gateway"),t}catch(s){throw b.error({namespace:r,waypointName:t,errorType:typeof s,errorDetails:s},"Error creating waypoint gateway"),new Error(`Failed to create waypoint gateway: ${s instanceof Error?s.message:String(s)}`)}}catch(n){throw b.error({namespace:r,waypointName:t,errorDetails:n},"Failed to create waypoint gateway"),new Error(`Failed to create waypoint gateway: ${n instanceof Error?n.message:String(n)}`)}}a(Gc,"createWaypointGateway");async function Bc(e,t){try{return(await(0,O.K8s)(O.a.Pod).InNamespace(e).WithLabel(`istio.io/gateway-name=${t}`).Get()).items?.some(o=>o.status?.phase==="Running"&&o.status?.containerStatuses?.every(n=>n.ready))??!1}catch(r){return b.warn(`Error checking waypoint pod health for ${t} in ${e}:`,r),!1}}a(Bc,"isWaypointPodHealthy");async function wo(e,t){let r=Date.now(),{intervalMs:o,timeoutMs:n}=Kc,s=0;for(;;){s++;let i=Date.now()-r;if(i>=n)throw new Error(`Timeout waiting for waypoint pod ${t} in ${e} after ${i}ms`);if(await Bc(e,t)){b.debug(`Waypoint pod ${t} in ${e} is healthy after ${s} attempts and ${i}ms`);return}await new Promise(l=>setTimeout(l,o))}}a(wo,"waitForWaypointPodHealthy");async function ri(e){let t=e.metadata?.namespace;if(!t||(e.metadata||(e.metadata={}),e.metadata.labels||(e.metadata.labels={}),e.metadata?.labels?.["app.kubernetes.io/component"]==="ambient-waypoint"&&e.metadata?.labels?.["gateway.networking.k8s.io/gateway-name"]?.includes("waypoint")))return;let r=ge.getPackageByNamespace(t);if(!r||r.metadata?.deletionTimestamp||r.spec?.network?.serviceMesh?.mode!=="ambient")return;let n=Pe(r).find(i=>So(e,i.enableAuthserviceSelector));if(!n?.clientId)return;let s=H(n.clientId);e.metadata.labels={...e.metadata.labels,[pt]:s,"istio.io/ingress-use-waypoint":"true"},b.info({namespace:t,waypointName:s,clientId:n.clientId,labels:e.metadata.labels},`Added waypoint labels to service ${e.metadata?.name}`)}a(ri,"reconcileService");async function oi(e){let t=e.metadata?.namespace;if(!t||(e.metadata||(e.metadata={}),e.metadata.labels||(e.metadata.labels={}),e.metadata?.labels?.["app.kubernetes.io/component"]==="ambient-waypoint"&&e.metadata?.labels?.["gateway.networking.k8s.io/gateway-name"]?.includes("waypoint")))return;let r=ge.getPackageByNamespace(t);if(!r||r.metadata?.deletionTimestamp||r.spec?.network?.serviceMesh?.mode!=="ambient")return;let n=Pe(r).find(c=>kt(e.metadata?.labels||{},c.enableAuthserviceSelector));if(!n?.clientId)return;let s=H(n.clientId);e.metadata.labels={...e.metadata.labels,[pt]:s};let i=e.metadata?.name||e.metadata?.generateName||"<unknown name>";b.info({namespace:t,waypointName:s,clientId:n.clientId},`Added waypoint labels to pod ${i}`)}a(oi,"reconcilePod");async function vo(e,t){b.info(`Starting cleanup of waypoint labels: namespace=${e}, waypoint=${t}`);try{await Wc(e,t),await zc(e,t)}catch(r){let o=r instanceof Error?r.message:String(r);b.error({namespace:e,waypointName:t,error:o},"Failed to clean up waypoint labels")}}a(vo,"cleanupWaypointLabels");async function Wc(e,t){let r=await(0,O.K8s)(O.a.Pod).InNamespace(e).WithLabel(pt,t).Get();await Promise.all(r.items.map(async o=>{let n=o.metadata?.name;if(n){if(o.metadata?.deletionTimestamp){b.debug({namespace:e,podName:n},"Skipping pod: marked for deletion");return}try{await(0,O.K8s)(O.kind.Pod,{name:n,namespace:e}).Patch([{op:"remove",path:"/metadata/labels/istio.io~1use-waypoint"}]),b.info({namespace:e,podName:n,waypointName:t},"Removed waypoint label from pod")}catch(s){b.error({namespace:e,podName:n,waypointName:t,error:s instanceof Error?s.message:String(s)},"Failed to remove waypoint label from pod")}}}))}a(Wc,"cleanupPodsWithWaypointLabel");async function zc(e,t){let r=await(0,O.K8s)(O.a.Service).InNamespace(e).WithLabel(pt,t).Get();await Promise.all(r.items.map(async o=>{let n=o.metadata?.name;if(n){if(o.metadata?.deletionTimestamp){b.debug({namespace:e,svcName:n},"Skipping service: marked for deletion");return}try{await(0,O.K8s)(O.kind.Service,{name:n,namespace:e}).Patch([{op:"remove",path:"/metadata/labels/istio.io~1ingress-use-waypoint"},{op:"remove",path:"/metadata/labels/istio.io~1use-waypoint"}]),b.info({namespace:e,svcName:n,waypointName:t},"Removed waypoint labels from service")}catch(s){b.error({namespace:e,svcName:n,waypointName:t,error:s instanceof Error?s.message:String(s)},"Failed to remove waypoint labels from service")}}}))}a(zc,"cleanupServicesWithWaypointLabel");async function Yc(e,t,r){let o=e.metadata?.namespace;if(!o){b.warn({pkg:e},"No namespace found in package metadata");return}b.info(`Starting reconciliation of existing resources in ${o} for ${r}`);try{let[n,s]=await Promise.all([(0,O.K8s)(O.kind.Service).InNamespace(o).Get(),(0,O.K8s)(O.kind.Pod).InNamespace(o).Get()]),i=n.items.filter(l=>So(l,t.enableAuthserviceSelector)),c=s.items.filter(l=>kt(l.metadata?.labels||{},t.enableAuthserviceSelector));b.debug(`Found resource to update with waypoint labels in ${o}`);for(let l of i)try{await(0,O.K8s)(O.kind.Service,{name:l.metadata.name,namespace:o}).Patch([{op:"add",path:"/metadata/labels/istio.io~1ingress-use-waypoint",value:"true"},{op:"add",path:`/metadata/labels/${pt.replace(/\//g,"~1")}`,value:r}])}catch(p){let u=p instanceof Error?p.message:String(p);b.error({errorMessage:u},`Service reconciliation failed for ${o}`)}for(let l of c)try{await(0,O.K8s)(O.kind.Pod,{name:l.metadata.name,namespace:o}).Patch([{op:"add",path:`/metadata/labels/${pt.replace(/\//g,"~1")}`,value:r}])}catch(p){let u=p instanceof Error?p.message:String(p);b.info({errorMessage:u},`Pod reconciliation failed for ${o}`)}}catch(n){let s=n instanceof Error?n.message:String(n);throw b.error({errorMessage:s},"Error in reconcileExistingResources()"),n}}a(Yc,"reconcileExistingResources");function Zn(e,t){let r={};for(let n of e)r[`${He(n)}`]="user";return{metadata:{name:pr,namespace:re,annotations:r,labels:{"uds/package":Po,"uds/generation":t.toString(),"istio.io/gateway-name":pr}},spec:{gatewayClassName:"istio-waypoint",listeners:[{name:"mesh",port:15008,protocol:"HBONE",allowedRoutes:{namespaces:{from:"All"},kinds:[{group:"networking.istio.io",kind:"ServiceEntry"}]}}],infrastructure:{parametersRef:{group:"",kind:"ConfigMap",name:"egress-waypoint-config"}}}}}a(Zn,"createEgressWaypointGateway");var gr=require("pepr");var qc={AddClient:"Apply",RemoveClient:"Delete"};function Ao(e,t,r,o){t&&r?(e.targetRef={group:"gateway.networking.k8s.io",kind:"Gateway",name:r},delete e.selector):(e.selector={matchLabels:o},delete e.targetRef)}a(Ao,"setPolicyTarget");function ni(e){let t=[],r=new Map;for(let n of e){if(!n.port)continue;let s=r.get(n.port)??new Set;n.path&&s.add(n.path),r.set(n.port,s)}for(let[n,s]of r.entries()){let i=Array.from(s);i.length>0?t.push({operation:{ports:[n],notPaths:i}}):t.push({operation:{ports:[n],notPaths:["/metrics"]}})}let o=Array.from(r.keys());return o.length>0&&t.push({operation:{notPorts:o}}),t}a(ni,"buildNonMetricsOperations");function Jc(e){let t=[],r=new Map;for(let o of e){if(!o.port)continue;let n=r.get(o.port)??new Set;o.path&&n.add(o.path),r.set(o.port,n)}for(let[o,n]of r.entries()){let s=Array.from(n);s.length>0?t.push({operation:{ports:[o],paths:s}}):t.push({operation:{ports:[o],paths:["/metrics"]}})}return t}a(Jc,"buildMetricsOperations");function Qc(e,t,r,o=!1,n,s=[]){let i=ni(s),c=[{key:"request.headers[authorization]",notValues:["*"]}],l=[];i.length>0?l.push({to:i,when:c}):l.push({when:c});let u={kind:"AuthorizationPolicy",metadata:{name:v(`${t}-authservice`),namespace:r},spec:{action:"CUSTOM",provider:{name:"authservice"},rules:l}};return Ao(u.spec,o,n,e),u}a(Qc,"authserviceAuthorizationPolicy");function Xc(e,t,r,o=!1,n,s=[]){let i=Jc(s),c=ni(s),l=[],p={notRequestPrincipals:[`https://sso.${g.domain}/realms/uds/*`]},u={...p,notPrincipals:[Ct]};i.length>0?(l.push({from:[{source:u}],to:i}),l.push({from:[{source:p}],to:c})):l.push({from:[{source:p}]});let m={kind:"AuthorizationPolicy",metadata:{name:v(`${t}-jwt-authz`),namespace:r},spec:{action:"DENY",rules:l}};return Ao(m.spec,o,n,e),m}a(Xc,"jwtAuthZAuthorizationPolicy");function Zc(e,t,r,o=!1,n){let s={kind:"RequestAuthentication",metadata:{name:v(`${t}-jwt-authn`),namespace:r},spec:{jwtRules:[{audiences:[t],forwardOriginalToken:!0,issuer:`https://sso.${g.domain}/realms/uds`,jwksUri:`https://sso.${g.domain}/realms/uds/protocol/openid-connect/certs`}]}};return Ao(s.spec,o,n,e),s}a(Zc,"authNRequestAuthentication");async function ii(e,t,r,o,n){let s=qc[e.action],i=r.metadata.namespace,c=(r.metadata?.generation??0).toString(),l=L(r),p=tl(r,t);o||p.push({port:"15020",path:"/stats/prometheus"});let u=a(d=>(d.metadata.ownerReferences=l,d.metadata.labels={"uds/package":r.metadata.name,"uds/generation":c},d),"updateMetadata");try{await(0,gr.K8s)(D)[s](u(Qc(t,e.name,i,o,n,p)),{force:!0}),await(0,gr.K8s)(Be)[s](u(Zc(t,e.name,i,o,n)),{force:!0}),await(0,gr.K8s)(D)[s](u(Xc(t,e.name,i,o,n,p)),{force:!0})}catch(d){let m=`Failed to update auth policy for ${e.name} in ${i}: ${d}`;throw E.error(d,m),new Error(m,{cause:d})}try{await el(c,i,r.metadata.name)}catch(d){E.error(d,`Failed to purge orphan auth policies ${e.name} in ${i}: ${d}`)}}a(ii,"updatePolicy");async function el(e,t,r){for(let o of[D,Be])await R(e,t,r,o,E)}a(el,"purgeOrphanPolicies");function tl(e,t){let r=e.spec?.monitor??[],o=[];for(let n of r){let s=n.podSelector??n.selector;(Object.keys(t).length===0||kt(s,t))&&o.push({port:String(n.targetPort),path:n.path||"/metrics"})}return o}a(tl,"computeMonitorExemptions");var ai=require("crypto"),le=require("pepr");var hr=null,It=null,Tt=new Map,Ro=null,yr=null,rl=parseInt(process.env.DEBOUNCE_DURATION||"1000",10),K={};function ol(){K={namespace:"authservice",secretName:"authservice-uds",baseDomain:`https://sso.${g.domain}`,realm:"uds"},E.info(K,"Authservice operator config initialized")}a(ol,"initializeOperatorConfig");async function si(){if(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev"){ol(),E.info("One-time authservice secret initialization"),await(0,le.K8s)(le.kind.Namespace).Apply({metadata:{name:K.namespace}});try{let e=await(0,le.K8s)(le.kind.Secret).InNamespace(K.namespace).Get(K.secretName);E.info(`Authservice Secret exists, skipping creation - ${e.metadata?.name}`)}catch{E.info("Secret does not exist, creating authservice secret");try{await Eo(nl(),!1)}catch(e){throw E.error(e,"Failed to create UDS managed authservice secret."),new Error("Failed to create UDS managed authservice secret.",{cause:e})}}}}a(si,"setupAuthserviceSecret");function nl(){let e={allow_unmatched_requests:!1,listen_address:"0.0.0.0",listen_port:"10003",log_level:"info",default_oidc_config:{skip_verify_peer_cert:!1,authorization_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/auth`,token_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/token`,jwks_fetcher:{jwks_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/certs`,periodic_fetch_interval_sec:60},client_id:"global_id",client_secret:"global_secret",id_token:{preamble:"Bearer",header:"Authorization"},trusted_certificate_authority:`${atob(g.caBundle.certs)}`,logout:{path:"/globallogout",redirect_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/token/logout`},absolute_session_timeout:"0",idle_session_timeout:"0",scopes:[]},threads:8,chains:[ko({name:"placeholder",action:"AddClient",client:{clientId:"placeholder",secret:"placeholder",redirectUris:["https://localhost/login"]}})]};return g.authserviceRedisUri&&(e.default_oidc_config.redis_session_store_config={server_uri:g.authserviceRedisUri}),e}a(nl,"buildInitialSecret");function ci(e){It=e}a(ci,"setAuthserviceConfig");async function li(){return It?(E.info("Returning in-memory authservice secret"),Promise.resolve(It)):(hr===null&&(hr=(0,le.K8s)(le.kind.Secret).InNamespace(K.namespace).Get(K.secretName).then(e=>{let t=JSON.parse(atob(e.data["config.json"]));return It=t,Ro=t,t}).finally(()=>{hr=null})),hr)}a(li,"getAuthserviceConfig");async function Eo(e,t=!0){return new Promise((r,o)=>{Tt.set(e,{resolve:r,reject:o}),yr&&clearTimeout(yr),yr=setTimeout(async()=>{try{E.info(`Applying debounced secret update for packages: ${Array.from(Tt.keys()).length} pending packages`);let{base64EncodedConfig:n,hash:s}=sl(e);Ro=await al(n),E.info("Updated authservice secret successfully for all pending packages."),t&&(E.info("Adding checksum to deployment for authservice secret"),await il(s)),Tt.forEach(i=>{i.resolve()})}catch(n){E.error(n,"Failed to write authservice secret"),It=Ro,E.info("Reverted to last successful secret state."),Tt.forEach(s=>{s.reject(new Error("Failed to write authservice secret for config",{cause:n}))})}finally{Tt.clear(),yr=null}},rl)})}a(Eo,"updateAuthServiceSecret");async function il(e){try{await(0,le.K8s)(le.kind.Deployment,{name:"authservice",namespace:K.namespace}).Patch([{op:"add",path:"/spec/template/metadata/annotations/pepr.dev~1checksum",value:e}]),E.info("Successfully applied the checksum to authservice")}catch(t){throw E.error(t,"Failed to apply the checksum to authservice"),new Error("Failed to apply the checksum to authservice",{cause:t})}}a(il,"checksumDeployment");async function al(e){try{return await(0,le.K8s)(le.kind.Secret).Apply({metadata:{namespace:K.namespace,name:K.secretName},data:{"config.json":e}},{force:!0}).then(t=>JSON.parse(atob(t.data["config.json"])))}catch(t){throw E.error(t,"Failed to apply the authservice config secret"),new Error("Failed to apply the authservice secret",{cause:t})}}a(al,"applySecret");function sl(e){let t=btoa(JSON.stringify(e)),r=(0,ai.createHash)("sha256").update(t).digest("hex");return{base64EncodedConfig:t,hash:r}}a(sl,"encodeConfig");var E=P("operator.authservice"),To=!1;async function pi(e,t){if(!e.metadata?.namespace||!e.metadata?.name)throw new Error("Package metadata is missing required fields");let r=e.spec?.network?.serviceMesh?.mode||"sidecar",o=e.status?.meshMode||"sidecar",n=r==="ambient",s=Pe(e),i=s.map(c=>({clientId:c.clientId,selector:c.enableAuthserviceSelector||{}}));for(let c of s){n&&await ti(e,c);let l=t.get(c.clientId);if(!l)throw new Error(`Failed to get client ${c.clientId}`);let p=H(c.clientId);await br({name:c.clientId,action:"AddClient",client:l},c.enableAuthserviceSelector,n,e,p)}return await Oo(e,i,o,r),await R((e.metadata?.generation??0).toString(),e.metadata.namespace,e.metadata.name,ce,E),i}a(pi,"authservice");async function Oo(e,t=[],r,o){let n=e.status?.authserviceClients||[],s=r!==o,i=n.filter(l=>!t.some(p=>p.clientId===l.clientId));await Promise.all(i.map(async l=>{let p=H(l.clientId);E.info(`Removing authservice client ${l.clientId}`),await br({name:l.clientId,action:"RemoveClient"},{},!1,e,p),e.metadata?.namespace&&await vo(e.metadata.namespace,p)}));let c=s?n:n.filter(l=>{let p=t.find(u=>u.clientId===l.clientId);return p?JSON.stringify(l.selector)!==JSON.stringify(p.selector):!1});for(let l of c){let p=t.find(d=>d.clientId===l.clientId),u=H(l.clientId);p&&(E.info({reason:s?"mesh_mode_change":"selector_changed"},`Updating authservice client ${l.clientId}`),e.metadata?.namespace&&await vo(e.metadata.namespace,u))}}a(Oo,"purgeAuthserviceClients");function cl(e){return e.action==="AddClient"||e.action==="RemoveClient"}a(cl,"isAddOrRemoveClientEvent");async function br(e,t={},r,o,n){if(await ui(e),cl(e)){if(!o)throw new Error("Package must be provided for AddClient or RemoveClient events");await ii(e,t,o,r,n)}}a(br,"reconcileAuthservice");async function ui(e){if(To){E.debug("Lock is set for config update, retrying..."),setTimeout(()=>ui(e),0);return}let t;try{E.debug("Locking config for update"),To=!0,t=await li().then(r=>ll(r,e)),ci(t)}catch(r){throw E.error({event:e,e:r},"Failed to build in memory authservice secret for event"),r}finally{E.debug("Unlocking config for update"),To=!1}E.debug("Applying authservice secret"),await Eo(t)}a(ui,"updateConfig");function ll(e,t){let r;if(t.action==="AddClient")r=e.chains.filter(n=>n.name!==t.name),r=r.concat(ko(t)),r=Io.R.sortBy(Io.R.prop("name"))(r);else if(t.action==="RemoveClient")r=e.chains.filter(o=>o.name!==t.name);else if(t.action==="UpdateGlobalConfig")t.redisUri?e.default_oidc_config.redis_session_store_config={server_uri:t.redisUri}:delete e.default_oidc_config.redis_session_store_config,t.trustedCA?e.default_oidc_config.trusted_certificate_authority=t.trustedCA:delete e.default_oidc_config.trusted_certificate_authority,r=e.chains;else throw new Error(`Unhandled Action: ${t.action}`);return{...e,chains:r}}a(ll,"buildConfig");function ko(e){let t=new URL(e.client.redirectUris[0]).hostname;return{name:e.name,match:{header:":authority",prefix:t},filters:[{oidc_override:{authorization_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/auth`,token_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/token`,callback_uri:e.client.redirectUris[0],client_id:e.client.clientId,client_secret:e.client.secret,scopes:[],logout:{path:"/logout",redirect_uri:`https://sso.${g.domain}/realms/${K.realm}/protocol/openid-connect/logout`},cookie_name_prefix:e.client.clientId}}]}}a(ko,"buildChain");var Y=require("pepr");var Ot="169.254.169.254/32",di=[{ipBlock:{cidr:Ot}}];var ut={ipBlock:{cidr:"0.0.0.0/0",except:[Ot]}},mi={namespaceSelector:{}};var Se=P("operator.generators"),Oe=new Set,xr=new Map,fi=!1;async function Sr(){if(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev"){if(g.kubeNodeCIDRs.length>0){for(let e of g.kubeNodeCIDRs)Oe.add(e);await Pr(),await wr();return}try{let e=await I(pl,Se);Oe.clear();for(let t of e.items){let r=Mo(t),o=t.metadata.name;r&&(Oe.add(r),xr.set(o,r))}await Pr(),await wr()}catch(e){Se.error("error fetching node IPs:",e)}}}a(Sr,"initAllNodesTarget");function vr(){let e=No([...Oe]);return e.length>0?e:(Se.warn("Unable to get Node CIDRs, defaulting to 0.0.0.0/0"),[ut])}a(vr,"kubeNodes");async function gi(e){let t=Mo(e),r=e.metadata.name;if(t){let o=xr.get(r);Oe.add(t),xr.set(r,t),o&&o!==t&&Oe.delete(o)}await Pr(),await wr()}a(gi,"updateKubeNodesFromCreateUpdate");async function hi(e){let t=Mo(e),r=e.metadata.name;t&&(Oe.delete(t),xr.delete(r)),await Pr(),await wr()}a(hi,"updateKubeNodesFromDelete");async function pl(){return(0,Y.K8s)(Y.kind.Node).Get()}a(pl,"fetchKubernetesNodes");async function Pr(){let e=No([...Oe]),t=await(0,Y.K8s)(Y.kind.NetworkPolicy).WithLabel("uds/generated","KubeNodes").Get();for(let r of t.items){if(!r.spec){Se.warn(`KubeNodes NetworkPolicy ${r.metadata?.namespace}/${r.metadata?.name} is missing spec.`);continue}let o=!1;if(r.spec.egress){r.spec.egress[0]=r.spec.egress[0]||{to:[]};let n=r.spec.egress[0].to;Y.R.equals(n,e)||(o=!0,r.spec.egress[0].to=e)}else if(r.spec.ingress){r.spec.ingress[0]=r.spec.ingress[0]||{from:[]};let n=r.spec.ingress[0].from;Y.R.equals(n,e)||(o=!0,r.spec.ingress[0].from=e)}if(o){r.metadata&&(r.metadata.managedFields=void 0),Se.debug(`Updating KubeNodes NetworkPolicy ${r.metadata?.namespace}/${r.metadata?.name} with new CIDRs.`);try{await(0,Y.K8s)(Y.kind.NetworkPolicy).Apply(r,{force:!0})}catch(n){let s=n.data?.message||"Unknown error while applying KubeNode network policies";throw g.kubeNodeCIDRs.length>0&&(s+=", ensure that the KUBENODE_CIDRS override configured for the operator is correct."),new Error(s)}}}}a(Pr,"updateKubeNodesNetworkPolicies");async function wr(){let t=No([...Oe]).map(o=>o.ipBlock?.cidr).filter(o=>typeof o=="string");if(!fi)try{await(0,Y.K8s)(Y.kind.CustomResourceDefinition).Get("authorizationpolicies.security.istio.io"),fi=!0}catch{Se.warn("AuthorizationPolicy CRD is not present in the cluster, skipping KubeNodes AuthorizationPolicy updates");return}let r=await(0,Y.K8s)(D).WithLabel("uds/generated","KubeNodes").Get();if(r.items.length>0){let o=r.items.map(n=>`name: ${n.metadata?.name}, namespace: ${n.metadata?.namespace}`).join(" | ");Se.trace(`Fetched ${r.items.length} AuthorizationPolicies: ${o}`)}for(let o of r.items){if(!o.spec||!o.spec.rules||o.spec.rules.length===0){Se.warn(`AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name} is missing rules.`);continue}let n=!1,s=o.spec.rules[0];if(s.from&&s.from.length>0&&s.from[0].source?.ipBlocks){let i=s.from[0].source.ipBlocks;Y.R.equals(i,t)||(s.from[0].source.ipBlocks=t,n=!0)}else s.from=[{source:{ipBlocks:t}}],n=!0;if(n){o.metadata&&(o.metadata.managedFields=void 0);try{await(0,Y.K8s)(D).Apply(o,{force:!0}),Se.debug(`Updated KubeNodes AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name}`)}catch(i){Se.error(i,`Failed to update AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name}`)}}}}a(wr,"updateKubeNodesAuthorizationPolicies");function No(e){return e.map(t=>({ipBlock:{cidr:ul(t)}}))}a(No,"buildNodePolicies");function ul(e){return e.includes("/")?e:`${e}/32`}a(ul,"format32cidr");function Mo(e){return e.status?.addresses?.find(t=>t.type==="InternalIP")?.address}a(Mo,"getNodeInternalIP");var k=P("operator.config"),g={domain:"",adminDomain:"",caBundle:{certs:"",includeDoDCerts:!1,includePublicCerts:!1,dodCerts:"",publicCerts:""},authserviceRedisUri:"",allowAllNSExemptions:!1,kubeApiCIDR:"",kubeNodeCIDRs:[],isIdentityDeployed:!1};function Cr(e,t,r){let o=e===0;return`${t===0?o?"Loading":"Updating":o?"Loaded":"Updated"} UDS Config from ${r}${o?"":" change"}`}a(Cr,"getConfigLogMessage");function yi(e){return e===1&&(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev")}a(yi,"shouldUpdateClusterResources");function dl(e){let t=e.status?.phase==="Pending",r=e.metadata?.generation===e.status?.observedGeneration;return t?(k.trace(e,"Should skip? Yes, is pending"),!0):r?(k.trace(e,"Should skip? Yes, current generation already processed"),!0):(k.trace(e,"Should skip? No, not pending or current generation"),!1)}a(dl,"shouldSkip");function ml(e){let t={};for(let r in e.data)try{let o=atob(e.data[r]);o?t[r]=o:t[r]=""}catch(o){k.error(`Failed to decode secret key: ${r}, error: ${o.message}`)}return t}a(ml,"decodeSecret");async function _o(e,t){let r="uds-operator-config secret";k.info(Cr(t,0,r));let o=yi(t),n=ml(e);Object.keys(n).includes("AUTHSERVICE_REDIS_URI")||(n.AUTHSERVICE_REDIS_URI=""),n.AUTHSERVICE_REDIS_URI==="###ZARF_VAR_AUTHSERVICE_REDIS_URI###"&&(n.AUTHSERVICE_REDIS_URI=""),g.authserviceRedisUri!==n.AUTHSERVICE_REDIS_URI&&(g.authserviceRedisUri=n.AUTHSERVICE_REDIS_URI,o&&await Pi("change to Redis URI")),k.info(Cr(t,1,r))}a(_o,"handleCfgSecret");function bi(e,t,r){return!!(g.caBundle.certs!==e.certs||g.caBundle.includeDoDCerts!==(e.includeDoDCerts===!0)||g.caBundle.includePublicCerts!==(e.includePublicCerts===!0)||e.includeDoDCerts&&g.caBundle.dodCerts!==t||e.includePublicCerts&&g.caBundle.publicCerts!==r)}a(bi,"shouldUpdateCaBundleConfigMaps");async function fl(e,t){e.certs||(e.certs=""),(e.certs==="###ZARF_VAR_CA_BUNDLE_CERTS###"||e.certs==="###ZARF_VAR_CA_CERT###")&&(e.certs="");let r,o="",n="";try{r=await(0,he.K8s)(he.kind.ConfigMap).InNamespace("pepr-system").Get("uds-ca-certs"),r.data&&(o=r.data.dodCACerts||"",n=r.data.publicCACerts||"")}catch(i){if(i?.status===404)k.warn("CA certs ConfigMap not found, using empty values for DoD and public certs");else throw k.error("Failed to fetch CA certs ConfigMap due to K8s API error",i),i}let s=bi(e,o,n);g.caBundle.certs!==e.certs&&(g.caBundle.certs=e.certs||"",t&&await Pi("change to CA Cert")),g.caBundle.includeDoDCerts=e.includeDoDCerts===!0,g.caBundle.includePublicCerts=e.includePublicCerts===!0,g.caBundle.dodCerts=o,g.caBundle.publicCerts=n,s&&t&&await so()}a(fl,"handleCABundleUpdate");async function Ar(e,t){if(!(t!==0&&dl(e)))try{await(0,he.K8s)(ae).PatchStatus({metadata:{name:e.metadata.name},status:{phase:"Pending"}});let r="uds-operator-config ClusterConfig";k.info(Cr(t,0,r));let o=yi(t),{expose:n,policy:s,networking:i,caBundle:c}=e.spec;await fl(c||{},o),i?.kubeApiCIDR!==g.kubeApiCIDR&&(g.kubeApiCIDR=i?.kubeApiCIDR||"",o&&(k.debug("Updating KubeAPI network policies based on change to kubeApiCidr"),await Rr())),hl(i?.kubeNodeCIDRs,g.kubeNodeCIDRs)||(g.kubeNodeCIDRs=i?.kubeNodeCIDRs||[],o&&(k.debug("Updating KubeNodes network policies based on change to kubeNodeCidrs"),await Sr())),(n.domain!==g.domain||n.adminDomain!==g.adminDomain)&&(n.domain&&n.domain!=="###ZARF_VAR_DOMAIN###"?g.domain=n.domain:g.domain="uds.dev",n.adminDomain&&n.adminDomain!=="###ZARF_VAR_ADMIN_DOMAIN###"?g.adminDomain=n.adminDomain:g.adminDomain=`admin.${g.domain}`),g.allowAllNSExemptions=s.allowAllNsExemptions===!0,k.info(Cr(t,1,r)),await(0,he.K8s)(ae).PatchStatus({metadata:{name:e.metadata.name},status:{phase:"Ready",observedGeneration:e.metadata.generation}})}catch(r){throw k.error("Error processing ClusterConfig",r),await(0,he.K8s)(ae).PatchStatus({metadata:{name:e.metadata.name},status:{phase:"Failed",observedGeneration:e.metadata.generation}}),r}}a(Ar,"handleCfg");async function xi(){if(process.env.PEPR_WATCH_MODE||process.env.PEPR_MODE==="dev"){let e={},t={};try{if(e=await(0,he.K8s)(ae).Get("uds-cluster-config"),!e)throw new Error("'uds-cluster-config' not found")}catch(r){throw k.error("Error while fetching cluster config",r),new Error("Error while fetching cluster config",{cause:r})}try{if(t=await(0,he.K8s)(he.kind.Secret).InNamespace("pepr-system").Get("uds-operator-config"),!t)throw new Error("'uds-operator-config' not found")}catch(r){throw k.error("Error while fetching operator config secret",r),new Error("Error while fetching operator config secret",{cause:r})}try{no(e),await Ar(e,0),await _o(t,0),k.info(gl(),"Loaded UDS Config")}catch(r){throw k.error(r),r}}}a(xi,"loadUDSConfig");function gl(){let e=g.authserviceRedisUri?"****":"",t=g.caBundle.dodCerts?"****":"",r=g.caBundle.publicCerts?"****":"",o=g.caBundle.certs?"****":"",n={...g.caBundle,dodCerts:t,publicCerts:r,certs:o};return{...g,authserviceRedisUri:e,caBundle:n}}a(gl,"redactConfig");function hl(e=[],t=[]){if(e.length!==t.length)return!1;let r=[...e].sort(),o=[...t].sort();return r.every((n,s)=>n===o[s])}a(hl,"areKubeNodeCidrsEqual");async function Pi(e){let t={name:"global-config-update",action:"UpdateGlobalConfig",trustedCA:atob(g.caBundle.certs),redisUri:g.authserviceRedisUri};k.debug(`Updating Authservice secret based on: ${e}`),await br(t)}a(Pi,"performAuthserviceUpdate");async function wi(e){try{k.debug("Processing uds-ca-certs ConfigMap update");let t=e.data?.dodCACerts||"",r=e.data?.publicCACerts||"",o={certs:g.caBundle.certs,includeDoDCerts:g.caBundle.includeDoDCerts,includePublicCerts:g.caBundle.includePublicCerts};if(!bi(o,t,r)){k.debug("No CA bundle updates needed, skipping");return}g.caBundle.dodCerts=t,g.caBundle.publicCerts=r,k.debug("Updated UDSConfig with new DoD and public CA certs"),await so(),k.debug("Successfully updated all CA bundle ConfigMaps")}catch(t){throw k.error(t,"Failed to process uds-ca-certs ConfigMap update"),t}}a(wi,"handleUDSCACertsConfigMapUpdate");async function Si(){if(process.env.PEPR_WATCH_MODE==="false"||process.env.PEPR_MODE==="dev"){let e=(0,he.K8s)(ae).Watch(async(t,r)=>{if(k.debug(`Processing cluster config update, phase ${r}`),t.metadata?.name==="uds-cluster-config")switch(r){case Do.WatchPhase.Added:case Do.WatchPhase.Modified:try{await Ar(t,1)}catch(o){k.error(o,"Unexpected error during cluster config update")}break}},it);k.debug("Starting cluster config watch..."),at(e,k,"ClusterConfig"),await e.start()}}a(Si,"startConfigWatch");var $=P("operator.generators"),Nt,vi=!1;async function Rr(){if(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev")try{let e=await I(Ri,$);if(g.kubeApiCIDR)$.info(`Static CIDR (${g.kubeApiCIDR}) is defined for KubeAPI, skipping EndpointSlice lookup.`),await Mt(e,g.kubeApiCIDR);else{let t=await I(Ei,$);await Mt(e,t)}}catch(e){$.error({err:JSON.stringify(e)},"Failed to initialize API Server CIDR for KubeAPI generated network policies")}}a(Rr,"initAPIServerCIDR");function Er(){return Nt||($.warn("Unable to get API server CIDR, defaulting to 0.0.0.0/0"),[ut])}a(Er,"kubeAPI");async function Ci(e){try{$.debug("Processing update for endpointslices, getting k8s service for updating API server CIDR");let t=await I(Ri,$);await Mt(t,e)}catch(t){$.error({err:t},"Failed to update network policies from endpoint slice watch")}}a(Ci,"updateAPIServerCIDRFromEndpointSlice");async function Ai(e){try{if(g.kubeApiCIDR)$.debug("Processing update for api service, using configured API CIDR for endpoints"),await Mt(e,g.kubeApiCIDR);else{$.debug("Processing update for api service, getting endpoint slices for updating API server CIDR");let t=await I(Ei,$);await Mt(e,t)}}catch(t){$.error({err:t},"Failed to update network policies from API service watch")}}a(Ai,"updateAPIServerCIDRFromService");async function Mt(e,t){let r=e.spec?.clusterIP,o=[];if(typeof t=="string")o.push(t);else{let{endpoints:n}=t;o=Array.isArray(n)?n.flatMap(s=>!Array.isArray(s?.addresses)||s.addresses.length===0?[]:s.addresses.map(i=>`${i}/32`)):[]}r&&o.push(`${r}/32`),o.length?(Nt=o.flatMap(n=>({ipBlock:{cidr:n}})),await yl(Nt),await bl(Nt)):$.warn("No peers found for the API server CIDR update.")}a(Mt,"updateAPIServerCIDR");async function yl(e){let t=await(0,G.K8s)(G.kind.NetworkPolicy).WithLabel("uds/generated","KubeAPI").Get();for(let r of t.items){if(!r.spec){$.warn(`KubeAPI NetworkPolicy ${r.metadata.namespace}/${r.metadata.name} is missing spec.`);continue}let o=!1;if(r.spec.egress){r.spec.egress[0]||(r.spec.egress[0]={to:[]});let n=r.spec.egress[0].to;G.R.equals(n,e)||(o=!0,r.spec.egress[0].to=e)}else if(r.spec.ingress){r.spec.ingress[0]||(r.spec.ingress[0]={from:[]});let n=r.spec.ingress[0].from;G.R.equals(n,e)||(o=!0,r.spec.ingress[0].from=e)}if(o){r.metadata&&(r.metadata.managedFields=void 0),$.debug(`Updating KubeAPI NetworkPolicy ${r.metadata.namespace}/${r.metadata.name} with new CIDRs.`);try{await(0,G.K8s)(G.kind.NetworkPolicy).Apply(r,{force:!0})}catch(n){let s=n.data?.message||"Unknown error while applying KubeAPI network policies";throw g.kubeApiCIDR&&(s+=", ensure that the KUBEAPI_CIDR override configured for the operator is correct."),new Error(s)}}}}a(yl,"updateKubeAPINetworkPolicies");async function bl(e){let t=e.map(o=>o.ipBlock?.cidr).filter(o=>typeof o=="string");if(!vi)try{await(0,G.K8s)(G.kind.CustomResourceDefinition).Get("authorizationpolicies.security.istio.io"),vi=!0}catch{$.warn("AuthorizationPolicy CRD is not present in the cluster, skipping KubeAPI AuthorizationPolicy updates");return}let r=await(0,G.K8s)(D).WithLabel("uds/generated","KubeAPI").Get();if(r.items.length>0){let o=r.items.map(n=>`name: ${n.metadata?.name}, namespace: ${n.metadata?.namespace}`).join(" | ");$.trace(`Fetched ${r.items.length} AuthorizationPolicies: ${o}`)}for(let o of r.items){if(!o.spec||!o.spec.rules||o.spec.rules.length===0){$.warn(`AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name} is missing rules.`);continue}let n=!1,s=o.spec.rules[0];if(s.from&&s.from.length>0&&s.from[0].source?.ipBlocks){let i=s.from[0].source.ipBlocks;G.R.equals(i,t)||(s.from[0].source.ipBlocks=t,n=!0)}else s.from=[{source:{ipBlocks:t}}],n=!0;if(n){o.metadata&&(o.metadata.managedFields=void 0);try{await(0,G.K8s)(D).Apply(o,{force:!0}),$.debug(`Updated KubeAPI AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name}`)}catch(i){$.error(i,`Failed to update AuthorizationPolicy ${o.metadata?.namespace}/${o.metadata?.name}`)}}}}a(bl,"updateKubeAPIAuthorizationPolicies");async function Ri(){return(0,G.K8s)(G.kind.Service).InNamespace("default").Get("kubernetes")}a(Ri,"fetchKubernetesService");async function Ei(){return(0,G.K8s)(G.kind.EndpointSlice).InNamespace("default").Get("kubernetes")}a(Ei,"fetchKubernetesEndpointSlice");var ki=require("crypto"),Ve=require("pepr");var V=require("pepr");async function _t(e,t,r,o,n){if(t.length===0){o.warn(`No pods provided for eviction in namespace ${e}`);return}o.info(`Processing ${t.length} pods for restart/eviction in namespace ${e}`);let s={},i=[];for(let c of t){let l=c.status?.phase;if(l==="Succeeded"||l==="Failed"){o.debug(`Ignoring Pod ${e}/${c.metadata?.name} (phase: ${l})`);continue}if(c.metadata?.deletionTimestamp){o.debug(`Ignoring Pod ${e}/${c.metadata?.name}, already being deleted`);continue}let u=(c.metadata?.ownerReferences||[]).find(m=>m.controller===!0);if(!u){i.push(c);continue}let d=`${u.kind}:${u.name}`;if(!s[d])try{if(u.kind==="ReplicaSet")await xl(e,u.name,r,o,n);else if(u.kind==="Deployment")await Dt(e,V.kind.Deployment,u.name,r,o,n);else if(u.kind==="StatefulSet")await Dt(e,V.kind.StatefulSet,u.name,r,o,n);else if(u.kind==="DaemonSet")await Dt(e,V.kind.DaemonSet,u.name,r,o,n);else{i.push(c);continue}s[d]=!0}catch(m){o.error({pod:c.metadata?.name,namespace:e,controller:u.kind,controllerName:u.name,error:m},`Failed to handle controller for pod: ${r}`)}}i.length>0&&await Pl(e,i,r,o)}a(_t,"reloadPods");async function xl(e,t,r,o,n){try{async function s(){return(0,V.K8s)(V.kind.ReplicaSet).InNamespace(e).Get(t)}a(s,"getReplicaSet");let c=(await I(s,o)).metadata?.ownerReferences?.find(l=>l.kind==="Deployment");c?.name?await Dt(e,V.kind.Deployment,c.name,r,o,n):await Dt(e,V.kind.ReplicaSet,t,r,o,n)}catch(s){throw o.error({replicaSet:t,namespace:e,error:s},`Failed to handle ReplicaSet owner: ${r}`),s}}a(xl,"handleReplicaSetOwner");async function Dt(e,t,r,o,n,s){let i=t?.name??String(t);if(![V.kind.Deployment,V.kind.StatefulSet,V.kind.DaemonSet,V.kind.ReplicaSet].some(d=>d===t))throw new Error(`Unsupported controller kind: ${i}`);async function p(){return(0,V.K8s)(t).InNamespace(e).Get(r)}a(p,"getController");let u=await I(p,n);try{u.spec||(u.spec={}),u.spec.template||(u.spec.template={}),u.spec.template.metadata||(u.spec.template.metadata={}),u.spec.template.metadata.annotations||(u.spec.template.metadata.annotations={}),u.spec.template.metadata.annotations["uds.dev/restartedAt"]=new Date().toISOString(),delete u.metadata?.managedFields;async function d(){return(0,V.K8s)(t,{name:r,namespace:e}).Apply(u)}a(d,"applyControllerAnnotation"),await I(d,n)}catch(d){throw n.error({controller:i,name:r,namespace:e,error:d},`Failed to apply ${i} controller update: ${o}`),d}try{async function d(){return Cn(u,{type:"Normal",reason:`${s}`,message:`Restarted due to: ${o}`},n)}a(d,"createControllerEvent"),await I(d,n)}catch(d){n.warn({controller:i,name:r,namespace:e,error:d},`Controller ${i}/${r} was restarted, but failed to create event notification`)}n.info(`Successfully restarted ${i} ${e}/${r}: ${o}`)}a(Dt,"restartController");async function Pl(e,t,r,o){if(t.length===0)return;o.info(`Directly evicting ${t.length} standalone pods in namespace ${e}`);let n={};for(let s of t){let i=s.metadata?.ownerReferences?.find(c=>c.controller)?.uid||"other";n[i]=n[i]||[],n[i].push(s)}for(let s of Object.values(n))for(let i of s){o.info(`Evicting pod ${e}/${i.metadata?.name} due to ${r}`);try{async function c(){return(0,V.K8s)(V.kind.Pod).InNamespace(e).Evict(i.metadata.name)}a(c,"evictPod"),await I(c,o),o.info(`Successfully evicted pod ${e}/${i.metadata?.name}`)}catch(c){o.warn(`Failed to evict pod ${e}/${i.metadata?.name} using Evict API, falling back to Delete: ${c.message}`);try{async function l(){return(0,V.K8s)(V.kind.Pod).Delete(i)}a(l,"deletePod"),await I(l,o),o.info(`Successfully initiated graceful deletion of pod ${e}/${i.metadata?.name}`)}catch(l){o.error(`Failed to delete pod ${e}/${i.metadata?.name}: ${l.message}`)}}}}a(Pl,"evictStandalonePods");var pe=P("operator.secrets"),Ti=new Map,Ii=new Map;function wl(e){let t=Object.keys(e).sort(),r=(0,ki.createHash)("sha256");for(let o of t)r.update(`${o}=${e[o]}`);return r.digest("hex")}a(wl,"computeResourceChecksum");async function Sl(e,t){return(await(0,Ve.K8s)(Ve.kind.Pod).InNamespace(e).Get()).items.filter(o=>o.spec?o.spec.volumes?.some(l=>l.secret&&l.secret.secretName===t)||o.spec.volumes?.some(l=>l.projected?.sources?.some(p=>p.secret?.name===t))?!0:[...o.spec.containers||[],...o.spec.initContainers||[]].some(l=>l.env?.some(p=>p.valueFrom?.secretKeyRef?.name===t)||l.envFrom?.some(p=>p.secretRef?.name===t)):!1)}a(Sl,"discoverSecretConsumers");function vl(e){try{let t={},r=e.split(",");for(let o of r){let[n,s]=o.trim().split("=");if(n&&s)t[n.trim()]=s.trim();else return null}return Object.keys(t).length>0?t:null}catch{return null}}a(vl,"parseSelectorString");async function Cl(e,t){return(await(0,Ve.K8s)(Ve.kind.Pod).InNamespace(e).Get()).items.filter(o=>o.spec?o.spec.volumes?.some(l=>l.configMap&&l.configMap.name===t)||o.spec.volumes?.some(l=>l.projected?.sources?.some(p=>p.configMap?.name===t))?!0:[...o.spec.containers||[],...o.spec.initContainers||[]].some(l=>l.env?.some(p=>p.valueFrom?.configMapKeyRef?.name===t)||l.envFrom?.some(p=>p.configMapRef?.name===t)):!1)}a(Cl,"discoverConfigMapConsumers");async function Oi(e,t,r,o){if(!e.metadata?.name||!e.metadata?.namespace)return;let{name:n,namespace:s}=e.metadata,i=`${s}/${n}`,c=e.data||{},l=wl(c),p=t.get(i);if(t.set(i,l),!p||p===l)return;pe.info({resource:n,namespace:s,type:o},`${o} data changed, processing pod reload`);let u=[],d=e.metadata?.annotations?.["uds.dev/pod-reload-selector"];if(d){let m=vl(d);if(!m){let x=`Invalid selector format in uds.dev/pod-reload-selector annotation for ${o.toLowerCase()} ${s}/${n}: ${d}. Expected format: key1=value1,key2=value2`;pe.error({resource:n,namespace:s,selector:d,type:o},x);return}pe.debug({resource:n,namespace:s,selector:m,type:o},`Using explicit pod selector from ${o.toLowerCase()} annotation for reload`);let h=(0,Ve.K8s)(Ve.kind.Pod).InNamespace(s);for(let[x,S]of Object.entries(m))h=h.WithLabel(x,S);try{async function x(){return h.Get()}a(x,"getPodsWithSelector"),u=(await I(x,pe)).items}catch(x){pe.error({resource:n,namespace:s,selector:m,error:x,type:o},`Failed to get pods using selector from ${o.toLowerCase()} annotation`);return}}else{pe.debug({resource:n,namespace:s,type:o},`Auto-discovering ${o.toLowerCase()} consumers`);try{async function m(){return r(s,n)}a(m,"getPodsUsingResource"),u=await I(m,pe)}catch(m){pe.error({resource:n,namespace:s,error:m,type:o},`Failed to discover ${o.toLowerCase()} consumers`);return}}if(u.length===0){pe.warn({resource:n,namespace:s,type:o},`No pods found to reload for ${o.toLowerCase()} change`);return}pe.info({resource:n,namespace:s,podCount:u.length,type:o},`Reloading ${u.length} pods due to ${o.toLowerCase()} change`);try{await _t(s,u,`${o} ${n} change`,pe,`${o}Changed`)}catch(m){pe.error({resource:n,namespace:s,podCount:u.length,error:m,type:o},`Failed to reload pods after ${o.toLowerCase()} change`);return}}a(Oi,"handleResourceUpdate");function Ni(e,t){if(!e.metadata?.name||!e.metadata?.namespace)return;let{name:r,namespace:o}=e.metadata,n=`${o}/${r}`;t.delete(n)}a(Ni,"handleResourceDelete");async function Mi(e){await Oi(e,Ti,Sl,"Secret")}a(Mi,"handleSecretUpdate");function Di(e){Ni(e,Ti)}a(Di,"handleSecretDelete");async function _i(e){await Oi(e,Ii,Cl,"ConfigMap")}a(_i,"handleConfigMapUpdate");function Li(e){Ni(e,Ii)}a(Li,"handleConfigMapDelete");function dt(e,t){let{selector:r,portName:o,description:n}=t,s=n||`${Object.values(r)}-${o}`;return v(`${e}-${s}`)}a(dt,"generateMonitorName");var $i={podSelector:{matchLabels:{}}};function Ui(e){return{ipBlock:{cidr:e}}}a(Ui,"remoteCidr");var Fi={namespaceSelector:{matchLabels:{"kubernetes.io/metadata.name":F}},podSelector:{matchLabels:{app:"egressgateway"}}},Hi={namespaceSelector:{matchLabels:{"kubernetes.io/metadata.name":re}},podSelector:{matchLabels:{"gateway.networking.k8s.io/gateway-name":"egress-waypoint"}}};function Al(e){return e===""||e==="*"}a(Al,"isWildcardNamespace");function Rl(e,t){let r=[];if(e.remoteGenerated)switch(e.remoteGenerated){case"KubeAPI":r=Er();break;case"KubeNodes":r=vr();break;case"CloudMetadata":r=di;break;case"IntraNamespace":r=[$i];break;case"Anywhere":r=[ut,mi];break}else if(e.remoteNamespace!==void 0||e.remoteSelector!==void 0){let o={};e.remoteNamespace!==void 0&&(Al(e.remoteNamespace)?o.namespaceSelector={}:o.namespaceSelector={matchLabels:{"kubernetes.io/metadata.name":e.remoteNamespace}}),e.remoteSelector!==void 0&&(o.podSelector={matchLabels:e.remoteSelector}),r.push(o)}else e.remoteCidr!==void 0?r=[Ui(e.remoteCidr)]:e.remoteHost&&(t==="ambient"?r=[Hi]:r=[Fi]);return r}a(Rl,"getPeers");function B(e,t,r){let n={apiVersion:"networking.k8s.io/v1",kind:"NetworkPolicy",metadata:{name:Lo(t),namespace:e,labels:{...t.labels}},spec:{policyTypes:[t.direction],podSelector:{matchLabels:t.selector}}};t.description&&(n.metadata.annotations={"uds/description":t.description}),t.remoteGenerated&&(n.metadata.labels["uds/generated"]=t.remoteGenerated);let s=Rl(t,r),i=(t.ports??[]).map(c=>({port:c}));switch(t.port&&i.push({port:t.port}),t.direction){case"Ingress":n.spec.ingress=[{from:s,ports:i}];break;case"Egress":n.spec.egress=[{to:s,ports:i}];break}return n}a(B,"generate");function Lo(e){let t=e.description||[Object.values(e.selector||["all pods"]),e.remoteGenerated||[e.remoteNamespace,Object.values(e.remoteSelector||["all pods"])]].flat(1).join("-");return`${e.direction}-${t}`}a(Lo,"generateName");function kr(e){let t=e.spec?.network?.expose??[];for(let o of t)o.match&&(o.advancedHTTP=o.advancedHTTP??{},o.advancedHTTP.match=o.match,delete o.match);let r=e.spec?.network?.allow??[];for(let o of r)o.podLabels&&(o.selector=o.podLabels,delete o.podLabels),o.remotePodLabels&&(o.remoteSelector=o.remotePodLabels,delete o.remotePodLabels);return kl(e),e}a(kr,"migrate");function $o(e){let t=e.status?.authserviceClients;if(!Array.isArray(t)||t.length===0)return;let r=t[0];if(typeof r=="object")return t;if(typeof r=="string"){let o=e.spec?.sso||[];return t.map(n=>{let s=o.find(i=>i.clientId===n);return{clientId:n,selector:s?.enableAuthserviceSelector||{}}})}}a($o,"buildMigratedAuthserviceStatus");function El(e){let t=$o(e);if(!t)return;let r=e.status??{};e.status={...r,authserviceClients:t}}a(El,"migrateAuthserviceStatus");function kl(e){El(e)}a(kl,"migrateStatus");var Tl=["kube-system","kube-public","_unknown_","pepr-system"];async function ji(e){let t=kr(e.Raw),r=t.metadata?.name??"_unknown_",o=t.metadata?.namespace??"_unknown_",n=t.metadata?.deletionTimestamp??null,s=t.spec?.network?.serviceMesh?.mode||"sidecar";if(Tl.includes(o))return e.Deny("invalid namespace");if(ge.hasKey(o)&&!n){let f=ge.getPkgName(o);if(f!==r)return e.Deny(`A package with the name "${f}" already exists in the namespace "${o}". Only one package can exist in a namespace.`)}let i=a(f=>Object.values(We).includes(f),"isStandardGateway"),c=t.spec?.network?.expose??[],l=new Set;for(let f of c){if(f.gateway&&!i(f.gateway)&&v(f.gateway)!==f.gateway)return e.Deny(`Gateway name "${f.gateway}" is not a valid Kubernetes resource name. It should only contain lowercase alphanumeric characters, '-', or '.'`);if(f.gateway&&i(f.gateway)&&f.domain)return e.Deny("domain cannot be set for the standard gateways (tenant, admin, or passthrough)");if((f.gateway==="passthrough"||f.gateway?.includes("passthrough"))&&f.advancedHTTP)return e.Deny("advancedHTTP cannot be used with a passthrough gateway");if(f.advancedHTTP?.directResponse&&(f.service||f.selector||f.port||f.targetPort))return e.Deny("directResponse cannot be combined with service, port, selector, targetPort");let y=po(r,f);if(l.has(y))return e.Deny(`The combination of characteristics of this expose entry would create a duplicate VirtualService. Verify you do not have duplicate values, or add a unique "description" field for this rule. The duplicate rule would be named "${y}".`);l.add(y)}let p=t.spec?.network?.allow??[],u=new Set;for(let f of p){if(f.remoteGenerated&&(f.remoteNamespace||f.remoteSelector||f.remoteCidr||f.remoteHost||f.remoteProtocol))return e.Deny("remoteGenerated cannot be combined with remoteNamespace, remoteSelector, remoteCidr, remoteHost, or remoteProtocol");if((f.remoteNamespace||f.remoteSelector)&&(f.remoteGenerated||f.remoteCidr||f.remoteHost||f.remoteProtocol))return e.Deny("remoteNamespace and remoteSelector cannot be combined with remoteGenerated, remoteCidr, remoteHost, or remoteProtocol");if(f.remoteCidr&&(f.remoteGenerated||f.remoteNamespace||f.remoteSelector||f.remoteHost||f.remoteProtocol))return e.Deny("remoteCidr cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, remoteHost, or remoteProtocol");if(f.remoteHost&&(f.remoteGenerated||f.remoteNamespace||f.remoteSelector||f.remoteCidr))return e.Deny("remoteHost cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, or remoteCidr");if(f.remoteProtocol&&(f.remoteGenerated||f.remoteNamespace||f.remoteSelector||f.remoteCidr||!f.remoteHost))return e.Deny("remoteProtocol cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, or remoteCidr and must have remoteHost");if((f.remoteHost||f.remoteProtocol)&&f.direction=="Ingress")return e.Deny("remoteHost and/or remoteProtocol cannot be used with Ingress");if(f.remoteHost&&f.remoteHost.includes("*"))return e.Deny("remoteHost does not support wildcard domains");if(f.serviceAccount&&!(f.remoteHost&&s==="ambient"))return e.Deny("serviceAccount is only valid for Ambient mode when using remoteHost");let y=v(`allow-${t.metadata?.name}-${Lo(f)}`);if(u.has(y))return e.Deny(`The combination of characteristics of this network allow rule would create a duplicate NetworkPolicy. Verify you do not have duplicate allow rules, or add a unique "description" field for this rule. The duplicate rule would be named "${y}".`);u.add(y)}let d=t.spec?.sso??[],m=new Set,h=new Set(["oidc.ciba.grant.enabled","backchannel.logout.session.required","backchannel.logout.revoke.offline.tokens","post.logout.redirect.uris","oauth2.device.authorization.grant.enabled","pkce.code.challenge.method","client.session.idle.timeout","client.session.max.lifespan","access.token.lifespan","saml.assertion.signature","saml.client.signature","saml_assertion_consumer_url_post","saml_assertion_consumer_url_redirect","saml_single_logout_service_url_post","saml_single_logout_service_url_redirect","saml_idp_initiated_sso_url_name","use.refresh.tokens","saml.encrypt","saml_name_id_format","saml.signing.certificate"]);for(let f of d){if(m.has(f.clientId))return e.Deny(`The client ID "${f.clientId}" is not unique within this package`);m.add(f.clientId);let y=ge.findPackagesWithSsoClientId(f.clientId);if(y.size>0&&!y.has(o))return e.Deny(`The client ID "${f.clientId}" is already in use by another package.`);if(f.secretName&&f.secretName!==v(f.secretName))return e.Deny(`The client ID "${f.clientId}" uses an invalid secret name ${f.secretName}`);if(f.standardFlowEnabled!==!1&&!f.redirectUris)return e.Deny(`The client ID "${f.clientId}" must specify redirectUris if standardFlowEnabled is turned on (it is enabled by default)`);if(f.serviceAccountsEnabled&&f.standardFlowEnabled)return e.Deny(`The client ID "${f.clientId}" serviceAccountsEnabled is disallowed with standardFlowEnabled`);if(f.publicClient&&(f.standardFlowEnabled!==!1||f.serviceAccountsEnabled||f.secret!==void 0||f.secretName!==void 0||f.secretTemplate!==void 0||f.enableAuthserviceSelector!==void 0||f.protocol==="saml"||f.attributes?.["oauth2.device.authorization.grant.enabled"]!=="true"))return e.Deny(`The client ID "${f.clientId}" sets options incompatible with publicClient`);if(f.attributes){for(let me of Object.keys(f.attributes))if(!h.has(me))return e.Deny(`The client ID "${f.clientId}" contains an unsupported attribute "${me}"`)}if(f.enableAuthserviceSelector&&f.clientId.includes(":"))return e.Deny(`The client ID "${f.clientId}" is invalid as an Authservice client - Authservice does not support client IDs with the ":" character`)}let x=t.spec?.monitor??[],S=new Set,C=new Set;for(let f of x){let y=dt(r,f);if(f.kind==="PodMonitor"){if(S.has(y))return e.Deny(`The combination of characteristics of this monitor entry would create a duplicate PodMonitor. Verify you do not have duplicate values, or add a unique "description" field for this monitor. The duplicate rule would be named "${y}".`);S.add(y)}else{if(C.has(y))return e.Deny(`The combination of characteristics of this monitor entry would create a duplicate ServiceMonitor. Verify you do not have duplicate values, or add a unique "description" field for this monitor. The duplicate rule would be named "${y}".`);C.add(y)}}return e.Approve()}a(ji,"validator");function na(e){return typeof e>"u"||e===null}a(na,"isNothing");function Il(e){return typeof e=="object"&&e!==null}a(Il,"isObject");function Ol(e){return Array.isArray(e)?e:na(e)?[]:[e]}a(Ol,"toArray");function Nl(e,t){var r,o,n,s;if(t)for(s=Object.keys(t),r=0,o=s.length;r<o;r+=1)n=s[r],e[n]=t[n];return e}a(Nl,"extend");function Ml(e,t){var r="",o;for(o=0;o<t;o+=1)r+=e;return r}a(Ml,"repeat");function Dl(e){return e===0&&Number.NEGATIVE_INFINITY===1/e}a(Dl,"isNegativeZero");var _l=na,Ll=Il,$l=Ol,Ul=Ml,Fl=Dl,Hl=Nl,j={isNothing:_l,isObject:Ll,toArray:$l,repeat:Ul,isNegativeZero:Fl,extend:Hl};function ia(e,t){var r="",o=e.reason||"(unknown reason)";return e.mark?(e.mark.name&&(r+='in "'+e.mark.name+'" '),r+="("+(e.mark.line+1)+":"+(e.mark.column+1)+")",!t&&e.mark.snippet&&(r+=`

`+e.mark.snippet),o+" "+r):o}a(ia,"formatError");function $t(e,t){Error.call(this),this.name="YAMLException",this.reason=e,this.mark=t,this.message=ia(this,!1),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error().stack||""}a($t,"YAMLException$1");$t.prototype=Object.create(Error.prototype);$t.prototype.constructor=$t;$t.prototype.toString=a(function(t){return this.name+": "+ia(this,t)},"toString");var Q=$t;function Uo(e,t,r,o,n){var s="",i="",c=Math.floor(n/2)-1;return o-t>c&&(s=" ... ",t=o-c+s.length),r-o>c&&(i=" ...",r=o+c-i.length),{str:s+e.slice(t,r).replace(/\t/g,"\u2192")+i,pos:o-t+s.length}}a(Uo,"getLine");function Fo(e,t){return j.repeat(" ",t-e.length)+e}a(Fo,"padStart");function Vl(e,t){if(t=Object.create(t||null),!e.buffer)return null;t.maxLength||(t.maxLength=79),typeof t.indent!="number"&&(t.indent=1),typeof t.linesBefore!="number"&&(t.linesBefore=3),typeof t.linesAfter!="number"&&(t.linesAfter=2);for(var r=/\r?\n|\r|\0/g,o=[0],n=[],s,i=-1;s=r.exec(e.buffer);)n.push(s.index),o.push(s.index+s[0].length),e.position<=s.index&&i<0&&(i=o.length-2);i<0&&(i=o.length-1);var c="",l,p,u=Math.min(e.line+t.linesAfter,n.length).toString().length,d=t.maxLength-(t.indent+u+3);for(l=1;l<=t.linesBefore&&!(i-l<0);l++)p=Uo(e.buffer,o[i-l],n[i-l],e.position-(o[i]-o[i-l]),d),c=j.repeat(" ",t.indent)+Fo((e.line-l+1).toString(),u)+" | "+p.str+`
`+c;for(p=Uo(e.buffer,o[i],n[i],e.position,d),c+=j.repeat(" ",t.indent)+Fo((e.line+1).toString(),u)+" | "+p.str+`
`,c+=j.repeat("-",t.indent+u+3+p.pos)+`^
`,l=1;l<=t.linesAfter&&!(i+l>=n.length);l++)p=Uo(e.buffer,o[i+l],n[i+l],e.position-(o[i]-o[i+l]),d),c+=j.repeat(" ",t.indent)+Fo((e.line+l+1).toString(),u)+" | "+p.str+`
`;return c.replace(/\n$/,"")}a(Vl,"makeSnippet");var jl=Vl,Kl=["kind","multi","resolve","construct","instanceOf","predicate","represent","representName","defaultStyle","styleAliases"],Gl=["scalar","sequence","mapping"];function Bl(e){var t={};return e!==null&&Object.keys(e).forEach(function(r){e[r].forEach(function(o){t[String(o)]=r})}),t}a(Bl,"compileStyleAliases");function Wl(e,t){if(t=t||{},Object.keys(t).forEach(function(r){if(Kl.indexOf(r)===-1)throw new Q('Unknown option "'+r+'" is met in definition of "'+e+'" YAML type.')}),this.options=t,this.tag=e,this.kind=t.kind||null,this.resolve=t.resolve||function(){return!0},this.construct=t.construct||function(r){return r},this.instanceOf=t.instanceOf||null,this.predicate=t.predicate||null,this.represent=t.represent||null,this.representName=t.representName||null,this.defaultStyle=t.defaultStyle||null,this.multi=t.multi||!1,this.styleAliases=Bl(t.styleAliases||null),Gl.indexOf(this.kind)===-1)throw new Q('Unknown kind "'+this.kind+'" is specified for "'+e+'" YAML type.')}a(Wl,"Type$1");var W=Wl;function Ki(e,t){var r=[];return e[t].forEach(function(o){var n=r.length;r.forEach(function(s,i){s.tag===o.tag&&s.kind===o.kind&&s.multi===o.multi&&(n=i)}),r[n]=o}),r}a(Ki,"compileList");function zl(){var e={scalar:{},sequence:{},mapping:{},fallback:{},multi:{scalar:[],sequence:[],mapping:[],fallback:[]}},t,r;function o(n){n.multi?(e.multi[n.kind].push(n),e.multi.fallback.push(n)):e[n.kind][n.tag]=e.fallback[n.tag]=n}for(a(o,"collectType"),t=0,r=arguments.length;t<r;t+=1)arguments[t].forEach(o);return e}a(zl,"compileMap");function Vo(e){return this.extend(e)}a(Vo,"Schema$1");Vo.prototype.extend=a(function(t){var r=[],o=[];if(t instanceof W)o.push(t);else if(Array.isArray(t))o=o.concat(t);else if(t&&(Array.isArray(t.implicit)||Array.isArray(t.explicit)))t.implicit&&(r=r.concat(t.implicit)),t.explicit&&(o=o.concat(t.explicit));else throw new Q("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");r.forEach(function(s){if(!(s instanceof W))throw new Q("Specified list of YAML types (or a single Type object) contains a non-Type object.");if(s.loadKind&&s.loadKind!=="scalar")throw new Q("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");if(s.multi)throw new Q("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.")}),o.forEach(function(s){if(!(s instanceof W))throw new Q("Specified list of YAML types (or a single Type object) contains a non-Type object.")});var n=Object.create(Vo.prototype);return n.implicit=(this.implicit||[]).concat(r),n.explicit=(this.explicit||[]).concat(o),n.compiledImplicit=Ki(n,"implicit"),n.compiledExplicit=Ki(n,"explicit"),n.compiledTypeMap=zl(n.compiledImplicit,n.compiledExplicit),n},"extend");var aa=Vo,sa=new W("tag:yaml.org,2002:str",{kind:"scalar",construct:a(function(e){return e!==null?e:""},"construct")}),ca=new W("tag:yaml.org,2002:seq",{kind:"sequence",construct:a(function(e){return e!==null?e:[]},"construct")}),la=new W("tag:yaml.org,2002:map",{kind:"mapping",construct:a(function(e){return e!==null?e:{}},"construct")}),pa=new aa({explicit:[sa,ca,la]});function Yl(e){if(e===null)return!0;var t=e.length;return t===1&&e==="~"||t===4&&(e==="null"||e==="Null"||e==="NULL")}a(Yl,"resolveYamlNull");function ql(){return null}a(ql,"constructYamlNull");function Jl(e){return e===null}a(Jl,"isNull");var ua=new W("tag:yaml.org,2002:null",{kind:"scalar",resolve:Yl,construct:ql,predicate:Jl,represent:{canonical:a(function(){return"~"},"canonical"),lowercase:a(function(){return"null"},"lowercase"),uppercase:a(function(){return"NULL"},"uppercase"),camelcase:a(function(){return"Null"},"camelcase"),empty:a(function(){return""},"empty")},defaultStyle:"lowercase"});function Ql(e){if(e===null)return!1;var t=e.length;return t===4&&(e==="true"||e==="True"||e==="TRUE")||t===5&&(e==="false"||e==="False"||e==="FALSE")}a(Ql,"resolveYamlBoolean");function Xl(e){return e==="true"||e==="True"||e==="TRUE"}a(Xl,"constructYamlBoolean");function Zl(e){return Object.prototype.toString.call(e)==="[object Boolean]"}a(Zl,"isBoolean");var da=new W("tag:yaml.org,2002:bool",{kind:"scalar",resolve:Ql,construct:Xl,predicate:Zl,represent:{lowercase:a(function(e){return e?"true":"false"},"lowercase"),uppercase:a(function(e){return e?"TRUE":"FALSE"},"uppercase"),camelcase:a(function(e){return e?"True":"False"},"camelcase")},defaultStyle:"lowercase"});function ep(e){return 48<=e&&e<=57||65<=e&&e<=70||97<=e&&e<=102}a(ep,"isHexCode");function tp(e){return 48<=e&&e<=55}a(tp,"isOctCode");function rp(e){return 48<=e&&e<=57}a(rp,"isDecCode");function op(e){if(e===null)return!1;var t=e.length,r=0,o=!1,n;if(!t)return!1;if(n=e[r],(n==="-"||n==="+")&&(n=e[++r]),n==="0"){if(r+1===t)return!0;if(n=e[++r],n==="b"){for(r++;r<t;r++)if(n=e[r],n!=="_"){if(n!=="0"&&n!=="1")return!1;o=!0}return o&&n!=="_"}if(n==="x"){for(r++;r<t;r++)if(n=e[r],n!=="_"){if(!ep(e.charCodeAt(r)))return!1;o=!0}return o&&n!=="_"}if(n==="o"){for(r++;r<t;r++)if(n=e[r],n!=="_"){if(!tp(e.charCodeAt(r)))return!1;o=!0}return o&&n!=="_"}}if(n==="_")return!1;for(;r<t;r++)if(n=e[r],n!=="_"){if(!rp(e.charCodeAt(r)))return!1;o=!0}return!(!o||n==="_")}a(op,"resolveYamlInteger");function np(e){var t=e,r=1,o;if(t.indexOf("_")!==-1&&(t=t.replace(/_/g,"")),o=t[0],(o==="-"||o==="+")&&(o==="-"&&(r=-1),t=t.slice(1),o=t[0]),t==="0")return 0;if(o==="0"){if(t[1]==="b")return r*parseInt(t.slice(2),2);if(t[1]==="x")return r*parseInt(t.slice(2),16);if(t[1]==="o")return r*parseInt(t.slice(2),8)}return r*parseInt(t,10)}a(np,"constructYamlInteger");function ip(e){return Object.prototype.toString.call(e)==="[object Number]"&&e%1===0&&!j.isNegativeZero(e)}a(ip,"isInteger");var ma=new W("tag:yaml.org,2002:int",{kind:"scalar",resolve:op,construct:np,predicate:ip,represent:{binary:a(function(e){return e>=0?"0b"+e.toString(2):"-0b"+e.toString(2).slice(1)},"binary"),octal:a(function(e){return e>=0?"0o"+e.toString(8):"-0o"+e.toString(8).slice(1)},"octal"),decimal:a(function(e){return e.toString(10)},"decimal"),hexadecimal:a(function(e){return e>=0?"0x"+e.toString(16).toUpperCase():"-0x"+e.toString(16).toUpperCase().slice(1)},"hexadecimal")},defaultStyle:"decimal",styleAliases:{binary:[2,"bin"],octal:[8,"oct"],decimal:[10,"dec"],hexadecimal:[16,"hex"]}}),ap=new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");function sp(e){return!(e===null||!ap.test(e)||e[e.length-1]==="_")}a(sp,"resolveYamlFloat");function cp(e){var t,r;return t=e.replace(/_/g,"").toLowerCase(),r=t[0]==="-"?-1:1,"+-".indexOf(t[0])>=0&&(t=t.slice(1)),t===".inf"?r===1?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:t===".nan"?NaN:r*parseFloat(t,10)}a(cp,"constructYamlFloat");var lp=/^[-+]?[0-9]+e/;function pp(e,t){var r;if(isNaN(e))switch(t){case"lowercase":return".nan";case"uppercase":return".NAN";case"camelcase":return".NaN"}else if(Number.POSITIVE_INFINITY===e)switch(t){case"lowercase":return".inf";case"uppercase":return".INF";case"camelcase":return".Inf"}else if(Number.NEGATIVE_INFINITY===e)switch(t){case"lowercase":return"-.inf";case"uppercase":return"-.INF";case"camelcase":return"-.Inf"}else if(j.isNegativeZero(e))return"-0.0";return r=e.toString(10),lp.test(r)?r.replace("e",".e"):r}a(pp,"representYamlFloat");function up(e){return Object.prototype.toString.call(e)==="[object Number]"&&(e%1!==0||j.isNegativeZero(e))}a(up,"isFloat");var fa=new W("tag:yaml.org,2002:float",{kind:"scalar",resolve:sp,construct:cp,predicate:up,represent:pp,defaultStyle:"lowercase"}),ga=pa.extend({implicit:[ua,da,ma,fa]}),ha=ga,ya=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),ba=new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");function dp(e){return e===null?!1:ya.exec(e)!==null||ba.exec(e)!==null}a(dp,"resolveYamlTimestamp");function mp(e){var t,r,o,n,s,i,c,l=0,p=null,u,d,m;if(t=ya.exec(e),t===null&&(t=ba.exec(e)),t===null)throw new Error("Date resolve error");if(r=+t[1],o=+t[2]-1,n=+t[3],!t[4])return new Date(Date.UTC(r,o,n));if(s=+t[4],i=+t[5],c=+t[6],t[7]){for(l=t[7].slice(0,3);l.length<3;)l+="0";l=+l}return t[9]&&(u=+t[10],d=+(t[11]||0),p=(u*60+d)*6e4,t[9]==="-"&&(p=-p)),m=new Date(Date.UTC(r,o,n,s,i,c,l)),p&&m.setTime(m.getTime()-p),m}a(mp,"constructYamlTimestamp");function fp(e){return e.toISOString()}a(fp,"representYamlTimestamp");var xa=new W("tag:yaml.org,2002:timestamp",{kind:"scalar",resolve:dp,construct:mp,instanceOf:Date,represent:fp});function gp(e){return e==="<<"||e===null}a(gp,"resolveYamlMerge");var Pa=new W("tag:yaml.org,2002:merge",{kind:"scalar",resolve:gp}),Wo=`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;function hp(e){if(e===null)return!1;var t,r,o=0,n=e.length,s=Wo;for(r=0;r<n;r++)if(t=s.indexOf(e.charAt(r)),!(t>64)){if(t<0)return!1;o+=6}return o%8===0}a(hp,"resolveYamlBinary");function yp(e){var t,r,o=e.replace(/[\r\n=]/g,""),n=o.length,s=Wo,i=0,c=[];for(t=0;t<n;t++)t%4===0&&t&&(c.push(i>>16&255),c.push(i>>8&255),c.push(i&255)),i=i<<6|s.indexOf(o.charAt(t));return r=n%4*6,r===0?(c.push(i>>16&255),c.push(i>>8&255),c.push(i&255)):r===18?(c.push(i>>10&255),c.push(i>>2&255)):r===12&&c.push(i>>4&255),new Uint8Array(c)}a(yp,"constructYamlBinary");function bp(e){var t="",r=0,o,n,s=e.length,i=Wo;for(o=0;o<s;o++)o%3===0&&o&&(t+=i[r>>18&63],t+=i[r>>12&63],t+=i[r>>6&63],t+=i[r&63]),r=(r<<8)+e[o];return n=s%3,n===0?(t+=i[r>>18&63],t+=i[r>>12&63],t+=i[r>>6&63],t+=i[r&63]):n===2?(t+=i[r>>10&63],t+=i[r>>4&63],t+=i[r<<2&63],t+=i[64]):n===1&&(t+=i[r>>2&63],t+=i[r<<4&63],t+=i[64],t+=i[64]),t}a(bp,"representYamlBinary");function xp(e){return Object.prototype.toString.call(e)==="[object Uint8Array]"}a(xp,"isBinary");var wa=new W("tag:yaml.org,2002:binary",{kind:"scalar",resolve:hp,construct:yp,predicate:xp,represent:bp}),Pp=Object.prototype.hasOwnProperty,wp=Object.prototype.toString;function Sp(e){if(e===null)return!0;var t=[],r,o,n,s,i,c=e;for(r=0,o=c.length;r<o;r+=1){if(n=c[r],i=!1,wp.call(n)!=="[object Object]")return!1;for(s in n)if(Pp.call(n,s))if(!i)i=!0;else return!1;if(!i)return!1;if(t.indexOf(s)===-1)t.push(s);else return!1}return!0}a(Sp,"resolveYamlOmap");function vp(e){return e!==null?e:[]}a(vp,"constructYamlOmap");var Sa=new W("tag:yaml.org,2002:omap",{kind:"sequence",resolve:Sp,construct:vp}),Cp=Object.prototype.toString;function Ap(e){if(e===null)return!0;var t,r,o,n,s,i=e;for(s=new Array(i.length),t=0,r=i.length;t<r;t+=1){if(o=i[t],Cp.call(o)!=="[object Object]"||(n=Object.keys(o),n.length!==1))return!1;s[t]=[n[0],o[n[0]]]}return!0}a(Ap,"resolveYamlPairs");function Rp(e){if(e===null)return[];var t,r,o,n,s,i=e;for(s=new Array(i.length),t=0,r=i.length;t<r;t+=1)o=i[t],n=Object.keys(o),s[t]=[n[0],o[n[0]]];return s}a(Rp,"constructYamlPairs");var va=new W("tag:yaml.org,2002:pairs",{kind:"sequence",resolve:Ap,construct:Rp}),Ep=Object.prototype.hasOwnProperty;function kp(e){if(e===null)return!0;var t,r=e;for(t in r)if(Ep.call(r,t)&&r[t]!==null)return!1;return!0}a(kp,"resolveYamlSet");function Tp(e){return e!==null?e:{}}a(Tp,"constructYamlSet");var Ca=new W("tag:yaml.org,2002:set",{kind:"mapping",resolve:kp,construct:Tp}),zo=ha.extend({implicit:[xa,Pa],explicit:[wa,Sa,va,Ca]}),Ke=Object.prototype.hasOwnProperty,Tr=1,Aa=2,Ra=3,Ir=4,Ho=1,Ip=2,Gi=3,Op=/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,Np=/[\x85\u2028\u2029]/,Mp=/[,\[\]\{\}]/,Ea=/^(?:!|!!|![a-z\-]+!)$/i,ka=/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;function Bi(e){return Object.prototype.toString.call(e)}a(Bi,"_class");function ve(e){return e===10||e===13}a(ve,"is_EOL");function Qe(e){return e===9||e===32}a(Qe,"is_WHITE_SPACE");function oe(e){return e===9||e===32||e===10||e===13}a(oe,"is_WS_OR_EOL");function ft(e){return e===44||e===91||e===93||e===123||e===125}a(ft,"is_FLOW_INDICATOR");function Dp(e){var t;return 48<=e&&e<=57?e-48:(t=e|32,97<=t&&t<=102?t-97+10:-1)}a(Dp,"fromHexCode");function _p(e){return e===120?2:e===117?4:e===85?8:0}a(_p,"escapedHexLen");function Lp(e){return 48<=e&&e<=57?e-48:-1}a(Lp,"fromDecimalCode");function Wi(e){return e===48?"\0":e===97?"\x07":e===98?"\b":e===116||e===9?"	":e===110?`
`:e===118?"\v":e===102?"\f":e===114?"\r":e===101?"\x1B":e===32?" ":e===34?'"':e===47?"/":e===92?"\\":e===78?"\x85":e===95?"\xA0":e===76?"\u2028":e===80?"\u2029":""}a(Wi,"simpleEscapeSequence");function $p(e){return e<=65535?String.fromCharCode(e):String.fromCharCode((e-65536>>10)+55296,(e-65536&1023)+56320)}a($p,"charFromCodepoint");function Ta(e,t,r){t==="__proto__"?Object.defineProperty(e,t,{configurable:!0,enumerable:!0,writable:!0,value:r}):e[t]=r}a(Ta,"setProperty");var Ia=new Array(256),Oa=new Array(256);for(Je=0;Je<256;Je++)Ia[Je]=Wi(Je)?1:0,Oa[Je]=Wi(Je);var Je;function Up(e,t){this.input=e,this.filename=t.filename||null,this.schema=t.schema||zo,this.onWarning=t.onWarning||null,this.legacy=t.legacy||!1,this.json=t.json||!1,this.listener=t.listener||null,this.implicitTypes=this.schema.compiledImplicit,this.typeMap=this.schema.compiledTypeMap,this.length=e.length,this.position=0,this.line=0,this.lineStart=0,this.lineIndent=0,this.firstTabInLine=-1,this.documents=[]}a(Up,"State$1");function Na(e,t){var r={name:e.filename,buffer:e.input.slice(0,-1),position:e.position,line:e.line,column:e.position-e.lineStart};return r.snippet=jl(r),new Q(t,r)}a(Na,"generateError");function w(e,t){throw Na(e,t)}a(w,"throwError");function Or(e,t){e.onWarning&&e.onWarning.call(null,Na(e,t))}a(Or,"throwWarning");var zi={YAML:a(function(t,r,o){var n,s,i;t.version!==null&&w(t,"duplication of %YAML directive"),o.length!==1&&w(t,"YAML directive accepts exactly one argument"),n=/^([0-9]+)\.([0-9]+)$/.exec(o[0]),n===null&&w(t,"ill-formed argument of the YAML directive"),s=parseInt(n[1],10),i=parseInt(n[2],10),s!==1&&w(t,"unacceptable YAML version of the document"),t.version=o[0],t.checkLineBreaks=i<2,i!==1&&i!==2&&Or(t,"unsupported YAML version of the document")},"handleYamlDirective"),TAG:a(function(t,r,o){var n,s;o.length!==2&&w(t,"TAG directive accepts exactly two arguments"),n=o[0],s=o[1],Ea.test(n)||w(t,"ill-formed tag handle (first argument) of the TAG directive"),Ke.call(t.tagMap,n)&&w(t,'there is a previously declared suffix for "'+n+'" tag handle'),ka.test(s)||w(t,"ill-formed tag prefix (second argument) of the TAG directive");try{s=decodeURIComponent(s)}catch{w(t,"tag prefix is malformed: "+s)}t.tagMap[n]=s},"handleTagDirective")};function je(e,t,r,o){var n,s,i,c;if(t<r){if(c=e.input.slice(t,r),o)for(n=0,s=c.length;n<s;n+=1)i=c.charCodeAt(n),i===9||32<=i&&i<=1114111||w(e,"expected valid JSON character");else Op.test(c)&&w(e,"the stream contains non-printable characters");e.result+=c}}a(je,"captureSegment");function Yi(e,t,r,o){var n,s,i,c;for(j.isObject(r)||w(e,"cannot merge mappings; the provided source object is unacceptable"),n=Object.keys(r),i=0,c=n.length;i<c;i+=1)s=n[i],Ke.call(t,s)||(Ta(t,s,r[s]),o[s]=!0)}a(Yi,"mergeMappings");function gt(e,t,r,o,n,s,i,c,l){var p,u;if(Array.isArray(n))for(n=Array.prototype.slice.call(n),p=0,u=n.length;p<u;p+=1)Array.isArray(n[p])&&w(e,"nested arrays are not supported inside keys"),typeof n=="object"&&Bi(n[p])==="[object Object]"&&(n[p]="[object Object]");if(typeof n=="object"&&Bi(n)==="[object Object]"&&(n="[object Object]"),n=String(n),t===null&&(t={}),o==="tag:yaml.org,2002:merge")if(Array.isArray(s))for(p=0,u=s.length;p<u;p+=1)Yi(e,t,s[p],r);else Yi(e,t,s,r);else!e.json&&!Ke.call(r,n)&&Ke.call(t,n)&&(e.line=i||e.line,e.lineStart=c||e.lineStart,e.position=l||e.position,w(e,"duplicated mapping key")),Ta(t,n,s),delete r[n];return t}a(gt,"storeMappingPair");function Yo(e){var t;t=e.input.charCodeAt(e.position),t===10?e.position++:t===13?(e.position++,e.input.charCodeAt(e.position)===10&&e.position++):w(e,"a line break is expected"),e.line+=1,e.lineStart=e.position,e.firstTabInLine=-1}a(Yo,"readLineBreak");function U(e,t,r){for(var o=0,n=e.input.charCodeAt(e.position);n!==0;){for(;Qe(n);)n===9&&e.firstTabInLine===-1&&(e.firstTabInLine=e.position),n=e.input.charCodeAt(++e.position);if(t&&n===35)do n=e.input.charCodeAt(++e.position);while(n!==10&&n!==13&&n!==0);if(ve(n))for(Yo(e),n=e.input.charCodeAt(e.position),o++,e.lineIndent=0;n===32;)e.lineIndent++,n=e.input.charCodeAt(++e.position);else break}return r!==-1&&o!==0&&e.lineIndent<r&&Or(e,"deficient indentation"),o}a(U,"skipSeparationSpace");function Dr(e){var t=e.position,r;return r=e.input.charCodeAt(t),!!((r===45||r===46)&&r===e.input.charCodeAt(t+1)&&r===e.input.charCodeAt(t+2)&&(t+=3,r=e.input.charCodeAt(t),r===0||oe(r)))}a(Dr,"testDocumentSeparator");function qo(e,t){t===1?e.result+=" ":t>1&&(e.result+=j.repeat(`
`,t-1))}a(qo,"writeFoldedLines");function Fp(e,t,r){var o,n,s,i,c,l,p,u,d=e.kind,m=e.result,h;if(h=e.input.charCodeAt(e.position),oe(h)||ft(h)||h===35||h===38||h===42||h===33||h===124||h===62||h===39||h===34||h===37||h===64||h===96||(h===63||h===45)&&(n=e.input.charCodeAt(e.position+1),oe(n)||r&&ft(n)))return!1;for(e.kind="scalar",e.result="",s=i=e.position,c=!1;h!==0;){if(h===58){if(n=e.input.charCodeAt(e.position+1),oe(n)||r&&ft(n))break}else if(h===35){if(o=e.input.charCodeAt(e.position-1),oe(o))break}else{if(e.position===e.lineStart&&Dr(e)||r&&ft(h))break;if(ve(h))if(l=e.line,p=e.lineStart,u=e.lineIndent,U(e,!1,-1),e.lineIndent>=t){c=!0,h=e.input.charCodeAt(e.position);continue}else{e.position=i,e.line=l,e.lineStart=p,e.lineIndent=u;break}}c&&(je(e,s,i,!1),qo(e,e.line-l),s=i=e.position,c=!1),Qe(h)||(i=e.position+1),h=e.input.charCodeAt(++e.position)}return je(e,s,i,!1),e.result?!0:(e.kind=d,e.result=m,!1)}a(Fp,"readPlainScalar");function Hp(e,t){var r,o,n;if(r=e.input.charCodeAt(e.position),r!==39)return!1;for(e.kind="scalar",e.result="",e.position++,o=n=e.position;(r=e.input.charCodeAt(e.position))!==0;)if(r===39)if(je(e,o,e.position,!0),r=e.input.charCodeAt(++e.position),r===39)o=e.position,e.position++,n=e.position;else return!0;else ve(r)?(je(e,o,n,!0),qo(e,U(e,!1,t)),o=n=e.position):e.position===e.lineStart&&Dr(e)?w(e,"unexpected end of the document within a single quoted scalar"):(e.position++,n=e.position);w(e,"unexpected end of the stream within a single quoted scalar")}a(Hp,"readSingleQuotedScalar");function Vp(e,t){var r,o,n,s,i,c;if(c=e.input.charCodeAt(e.position),c!==34)return!1;for(e.kind="scalar",e.result="",e.position++,r=o=e.position;(c=e.input.charCodeAt(e.position))!==0;){if(c===34)return je(e,r,e.position,!0),e.position++,!0;if(c===92){if(je(e,r,e.position,!0),c=e.input.charCodeAt(++e.position),ve(c))U(e,!1,t);else if(c<256&&Ia[c])e.result+=Oa[c],e.position++;else if((i=_p(c))>0){for(n=i,s=0;n>0;n--)c=e.input.charCodeAt(++e.position),(i=Dp(c))>=0?s=(s<<4)+i:w(e,"expected hexadecimal character");e.result+=$p(s),e.position++}else w(e,"unknown escape sequence");r=o=e.position}else ve(c)?(je(e,r,o,!0),qo(e,U(e,!1,t)),r=o=e.position):e.position===e.lineStart&&Dr(e)?w(e,"unexpected end of the document within a double quoted scalar"):(e.position++,o=e.position)}w(e,"unexpected end of the stream within a double quoted scalar")}a(Vp,"readDoubleQuotedScalar");function jp(e,t){var r=!0,o,n,s,i=e.tag,c,l=e.anchor,p,u,d,m,h,x=Object.create(null),S,C,f,y;if(y=e.input.charCodeAt(e.position),y===91)u=93,h=!1,c=[];else if(y===123)u=125,h=!0,c={};else return!1;for(e.anchor!==null&&(e.anchorMap[e.anchor]=c),y=e.input.charCodeAt(++e.position);y!==0;){if(U(e,!0,t),y=e.input.charCodeAt(e.position),y===u)return e.position++,e.tag=i,e.anchor=l,e.kind=h?"mapping":"sequence",e.result=c,!0;r?y===44&&w(e,"expected the node content, but found ','"):w(e,"missed comma between flow collection entries"),C=S=f=null,d=m=!1,y===63&&(p=e.input.charCodeAt(e.position+1),oe(p)&&(d=m=!0,e.position++,U(e,!0,t))),o=e.line,n=e.lineStart,s=e.position,ht(e,t,Tr,!1,!0),C=e.tag,S=e.result,U(e,!0,t),y=e.input.charCodeAt(e.position),(m||e.line===o)&&y===58&&(d=!0,y=e.input.charCodeAt(++e.position),U(e,!0,t),ht(e,t,Tr,!1,!0),f=e.result),h?gt(e,c,x,C,S,f,o,n,s):d?c.push(gt(e,null,x,C,S,f,o,n,s)):c.push(S),U(e,!0,t),y=e.input.charCodeAt(e.position),y===44?(r=!0,y=e.input.charCodeAt(++e.position)):r=!1}w(e,"unexpected end of the stream within a flow collection")}a(jp,"readFlowCollection");function Kp(e,t){var r,o,n=Ho,s=!1,i=!1,c=t,l=0,p=!1,u,d;if(d=e.input.charCodeAt(e.position),d===124)o=!1;else if(d===62)o=!0;else return!1;for(e.kind="scalar",e.result="";d!==0;)if(d=e.input.charCodeAt(++e.position),d===43||d===45)Ho===n?n=d===43?Gi:Ip:w(e,"repeat of a chomping mode identifier");else if((u=Lp(d))>=0)u===0?w(e,"bad explicit indentation width of a block scalar; it cannot be less than one"):i?w(e,"repeat of an indentation width identifier"):(c=t+u-1,i=!0);else break;if(Qe(d)){do d=e.input.charCodeAt(++e.position);while(Qe(d));if(d===35)do d=e.input.charCodeAt(++e.position);while(!ve(d)&&d!==0)}for(;d!==0;){for(Yo(e),e.lineIndent=0,d=e.input.charCodeAt(e.position);(!i||e.lineIndent<c)&&d===32;)e.lineIndent++,d=e.input.charCodeAt(++e.position);if(!i&&e.lineIndent>c&&(c=e.lineIndent),ve(d)){l++;continue}if(e.lineIndent<c){n===Gi?e.result+=j.repeat(`
`,s?1+l:l):n===Ho&&s&&(e.result+=`
`);break}for(o?Qe(d)?(p=!0,e.result+=j.repeat(`
`,s?1+l:l)):p?(p=!1,e.result+=j.repeat(`
`,l+1)):l===0?s&&(e.result+=" "):e.result+=j.repeat(`
`,l):e.result+=j.repeat(`
`,s?1+l:l),s=!0,i=!0,l=0,r=e.position;!ve(d)&&d!==0;)d=e.input.charCodeAt(++e.position);je(e,r,e.position,!1)}return!0}a(Kp,"readBlockScalar");function qi(e,t){var r,o=e.tag,n=e.anchor,s=[],i,c=!1,l;if(e.firstTabInLine!==-1)return!1;for(e.anchor!==null&&(e.anchorMap[e.anchor]=s),l=e.input.charCodeAt(e.position);l!==0&&(e.firstTabInLine!==-1&&(e.position=e.firstTabInLine,w(e,"tab characters must not be used in indentation")),!(l!==45||(i=e.input.charCodeAt(e.position+1),!oe(i))));){if(c=!0,e.position++,U(e,!0,-1)&&e.lineIndent<=t){s.push(null),l=e.input.charCodeAt(e.position);continue}if(r=e.line,ht(e,t,Ra,!1,!0),s.push(e.result),U(e,!0,-1),l=e.input.charCodeAt(e.position),(e.line===r||e.lineIndent>t)&&l!==0)w(e,"bad indentation of a sequence entry");else if(e.lineIndent<t)break}return c?(e.tag=o,e.anchor=n,e.kind="sequence",e.result=s,!0):!1}a(qi,"readBlockSequence");function Gp(e,t,r){var o,n,s,i,c,l,p=e.tag,u=e.anchor,d={},m=Object.create(null),h=null,x=null,S=null,C=!1,f=!1,y;if(e.firstTabInLine!==-1)return!1;for(e.anchor!==null&&(e.anchorMap[e.anchor]=d),y=e.input.charCodeAt(e.position);y!==0;){if(!C&&e.firstTabInLine!==-1&&(e.position=e.firstTabInLine,w(e,"tab characters must not be used in indentation")),o=e.input.charCodeAt(e.position+1),s=e.line,(y===63||y===58)&&oe(o))y===63?(C&&(gt(e,d,m,h,x,null,i,c,l),h=x=S=null),f=!0,C=!0,n=!0):C?(C=!1,n=!0):w(e,"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"),e.position+=1,y=o;else{if(i=e.line,c=e.lineStart,l=e.position,!ht(e,r,Aa,!1,!0))break;if(e.line===s){for(y=e.input.charCodeAt(e.position);Qe(y);)y=e.input.charCodeAt(++e.position);if(y===58)y=e.input.charCodeAt(++e.position),oe(y)||w(e,"a whitespace character is expected after the key-value separator within a block mapping"),C&&(gt(e,d,m,h,x,null,i,c,l),h=x=S=null),f=!0,C=!1,n=!1,h=e.tag,x=e.result;else if(f)w(e,"can not read an implicit mapping pair; a colon is missed");else return e.tag=p,e.anchor=u,!0}else if(f)w(e,"can not read a block mapping entry; a multiline key may not be an implicit key");else return e.tag=p,e.anchor=u,!0}if((e.line===s||e.lineIndent>t)&&(C&&(i=e.line,c=e.lineStart,l=e.position),ht(e,t,Ir,!0,n)&&(C?x=e.result:S=e.result),C||(gt(e,d,m,h,x,S,i,c,l),h=x=S=null),U(e,!0,-1),y=e.input.charCodeAt(e.position)),(e.line===s||e.lineIndent>t)&&y!==0)w(e,"bad indentation of a mapping entry");else if(e.lineIndent<t)break}return C&&gt(e,d,m,h,x,null,i,c,l),f&&(e.tag=p,e.anchor=u,e.kind="mapping",e.result=d),f}a(Gp,"readBlockMapping");function Bp(e){var t,r=!1,o=!1,n,s,i;if(i=e.input.charCodeAt(e.position),i!==33)return!1;if(e.tag!==null&&w(e,"duplication of a tag property"),i=e.input.charCodeAt(++e.position),i===60?(r=!0,i=e.input.charCodeAt(++e.position)):i===33?(o=!0,n="!!",i=e.input.charCodeAt(++e.position)):n="!",t=e.position,r){do i=e.input.charCodeAt(++e.position);while(i!==0&&i!==62);e.position<e.length?(s=e.input.slice(t,e.position),i=e.input.charCodeAt(++e.position)):w(e,"unexpected end of the stream within a verbatim tag")}else{for(;i!==0&&!oe(i);)i===33&&(o?w(e,"tag suffix cannot contain exclamation marks"):(n=e.input.slice(t-1,e.position+1),Ea.test(n)||w(e,"named tag handle cannot contain such characters"),o=!0,t=e.position+1)),i=e.input.charCodeAt(++e.position);s=e.input.slice(t,e.position),Mp.test(s)&&w(e,"tag suffix cannot contain flow indicator characters")}s&&!ka.test(s)&&w(e,"tag name cannot contain such characters: "+s);try{s=decodeURIComponent(s)}catch{w(e,"tag name is malformed: "+s)}return r?e.tag=s:Ke.call(e.tagMap,n)?e.tag=e.tagMap[n]+s:n==="!"?e.tag="!"+s:n==="!!"?e.tag="tag:yaml.org,2002:"+s:w(e,'undeclared tag handle "'+n+'"'),!0}a(Bp,"readTagProperty");function Wp(e){var t,r;if(r=e.input.charCodeAt(e.position),r!==38)return!1;for(e.anchor!==null&&w(e,"duplication of an anchor property"),r=e.input.charCodeAt(++e.position),t=e.position;r!==0&&!oe(r)&&!ft(r);)r=e.input.charCodeAt(++e.position);return e.position===t&&w(e,"name of an anchor node must contain at least one character"),e.anchor=e.input.slice(t,e.position),!0}a(Wp,"readAnchorProperty");function zp(e){var t,r,o;if(o=e.input.charCodeAt(e.position),o!==42)return!1;for(o=e.input.charCodeAt(++e.position),t=e.position;o!==0&&!oe(o)&&!ft(o);)o=e.input.charCodeAt(++e.position);return e.position===t&&w(e,"name of an alias node must contain at least one character"),r=e.input.slice(t,e.position),Ke.call(e.anchorMap,r)||w(e,'unidentified alias "'+r+'"'),e.result=e.anchorMap[r],U(e,!0,-1),!0}a(zp,"readAlias");function ht(e,t,r,o,n){var s,i,c,l=1,p=!1,u=!1,d,m,h,x,S,C;if(e.listener!==null&&e.listener("open",e),e.tag=null,e.anchor=null,e.kind=null,e.result=null,s=i=c=Ir===r||Ra===r,o&&U(e,!0,-1)&&(p=!0,e.lineIndent>t?l=1:e.lineIndent===t?l=0:e.lineIndent<t&&(l=-1)),l===1)for(;Bp(e)||Wp(e);)U(e,!0,-1)?(p=!0,c=s,e.lineIndent>t?l=1:e.lineIndent===t?l=0:e.lineIndent<t&&(l=-1)):c=!1;if(c&&(c=p||n),(l===1||Ir===r)&&(Tr===r||Aa===r?S=t:S=t+1,C=e.position-e.lineStart,l===1?c&&(qi(e,C)||Gp(e,C,S))||jp(e,S)?u=!0:(i&&Kp(e,S)||Hp(e,S)||Vp(e,S)?u=!0:zp(e)?(u=!0,(e.tag!==null||e.anchor!==null)&&w(e,"alias node should not have any properties")):Fp(e,S,Tr===r)&&(u=!0,e.tag===null&&(e.tag="?")),e.anchor!==null&&(e.anchorMap[e.anchor]=e.result)):l===0&&(u=c&&qi(e,C))),e.tag===null)e.anchor!==null&&(e.anchorMap[e.anchor]=e.result);else if(e.tag==="?"){for(e.result!==null&&e.kind!=="scalar"&&w(e,'unacceptable node kind for !<?> tag; it should be "scalar", not "'+e.kind+'"'),d=0,m=e.implicitTypes.length;d<m;d+=1)if(x=e.implicitTypes[d],x.resolve(e.result)){e.result=x.construct(e.result),e.tag=x.tag,e.anchor!==null&&(e.anchorMap[e.anchor]=e.result);break}}else if(e.tag!=="!"){if(Ke.call(e.typeMap[e.kind||"fallback"],e.tag))x=e.typeMap[e.kind||"fallback"][e.tag];else for(x=null,h=e.typeMap.multi[e.kind||"fallback"],d=0,m=h.length;d<m;d+=1)if(e.tag.slice(0,h[d].tag.length)===h[d].tag){x=h[d];break}x||w(e,"unknown tag !<"+e.tag+">"),e.result!==null&&x.kind!==e.kind&&w(e,"unacceptable node kind for !<"+e.tag+'> tag; it should be "'+x.kind+'", not "'+e.kind+'"'),x.resolve(e.result,e.tag)?(e.result=x.construct(e.result,e.tag),e.anchor!==null&&(e.anchorMap[e.anchor]=e.result)):w(e,"cannot resolve a node with !<"+e.tag+"> explicit tag")}return e.listener!==null&&e.listener("close",e),e.tag!==null||e.anchor!==null||u}a(ht,"composeNode");function Yp(e){var t=e.position,r,o,n,s=!1,i;for(e.version=null,e.checkLineBreaks=e.legacy,e.tagMap=Object.create(null),e.anchorMap=Object.create(null);(i=e.input.charCodeAt(e.position))!==0&&(U(e,!0,-1),i=e.input.charCodeAt(e.position),!(e.lineIndent>0||i!==37));){for(s=!0,i=e.input.charCodeAt(++e.position),r=e.position;i!==0&&!oe(i);)i=e.input.charCodeAt(++e.position);for(o=e.input.slice(r,e.position),n=[],o.length<1&&w(e,"directive name must not be less than one character in length");i!==0;){for(;Qe(i);)i=e.input.charCodeAt(++e.position);if(i===35){do i=e.input.charCodeAt(++e.position);while(i!==0&&!ve(i));break}if(ve(i))break;for(r=e.position;i!==0&&!oe(i);)i=e.input.charCodeAt(++e.position);n.push(e.input.slice(r,e.position))}i!==0&&Yo(e),Ke.call(zi,o)?zi[o](e,o,n):Or(e,'unknown document directive "'+o+'"')}if(U(e,!0,-1),e.lineIndent===0&&e.input.charCodeAt(e.position)===45&&e.input.charCodeAt(e.position+1)===45&&e.input.charCodeAt(e.position+2)===45?(e.position+=3,U(e,!0,-1)):s&&w(e,"directives end mark is expected"),ht(e,e.lineIndent-1,Ir,!1,!0),U(e,!0,-1),e.checkLineBreaks&&Np.test(e.input.slice(t,e.position))&&Or(e,"non-ASCII line breaks are interpreted as content"),e.documents.push(e.result),e.position===e.lineStart&&Dr(e)){e.input.charCodeAt(e.position)===46&&(e.position+=3,U(e,!0,-1));return}if(e.position<e.length-1)w(e,"end of the stream or a document separator is expected");else return}a(Yp,"readDocument");function Ma(e,t){e=String(e),t=t||{},e.length!==0&&(e.charCodeAt(e.length-1)!==10&&e.charCodeAt(e.length-1)!==13&&(e+=`
`),e.charCodeAt(0)===65279&&(e=e.slice(1)));var r=new Up(e,t),o=e.indexOf("\0");for(o!==-1&&(r.position=o,w(r,"null byte is not allowed in input")),r.input+="\0";r.input.charCodeAt(r.position)===32;)r.lineIndent+=1,r.position+=1;for(;r.position<r.length-1;)Yp(r);return r.documents}a(Ma,"loadDocuments");function qp(e,t,r){t!==null&&typeof t=="object"&&typeof r>"u"&&(r=t,t=null);var o=Ma(e,r);if(typeof t!="function")return o;for(var n=0,s=o.length;n<s;n+=1)t(o[n])}a(qp,"loadAll$1");function Jp(e,t){var r=Ma(e,t);if(r.length!==0){if(r.length===1)return r[0];throw new Q("expected a single document in the stream, but found more")}}a(Jp,"load$1");var Qp=qp,Xp=Jp,Da={loadAll:Qp,load:Xp},_a=Object.prototype.toString,La=Object.prototype.hasOwnProperty,Jo=65279,Zp=9,Ut=10,eu=13,tu=32,ru=33,ou=34,jo=35,nu=37,iu=38,au=39,su=42,$a=44,cu=45,Nr=58,lu=61,pu=62,uu=63,du=64,Ua=91,Fa=93,mu=96,Ha=123,fu=124,Va=125,q={};q[0]="\\0";q[7]="\\a";q[8]="\\b";q[9]="\\t";q[10]="\\n";q[11]="\\v";q[12]="\\f";q[13]="\\r";q[27]="\\e";q[34]='\\"';q[92]="\\\\";q[133]="\\N";q[160]="\\_";q[8232]="\\L";q[8233]="\\P";var gu=["y","Y","yes","Yes","YES","on","On","ON","n","N","no","No","NO","off","Off","OFF"],hu=/^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;function yu(e,t){var r,o,n,s,i,c,l;if(t===null)return{};for(r={},o=Object.keys(t),n=0,s=o.length;n<s;n+=1)i=o[n],c=String(t[i]),i.slice(0,2)==="!!"&&(i="tag:yaml.org,2002:"+i.slice(2)),l=e.compiledTypeMap.fallback[i],l&&La.call(l.styleAliases,c)&&(c=l.styleAliases[c]),r[i]=c;return r}a(yu,"compileStyleMap");function bu(e){var t,r,o;if(t=e.toString(16).toUpperCase(),e<=255)r="x",o=2;else if(e<=65535)r="u",o=4;else if(e<=4294967295)r="U",o=8;else throw new Q("code point within a string may not be greater than 0xFFFFFFFF");return"\\"+r+j.repeat("0",o-t.length)+t}a(bu,"encodeHex");var xu=1,Ft=2;function Pu(e){this.schema=e.schema||zo,this.indent=Math.max(1,e.indent||2),this.noArrayIndent=e.noArrayIndent||!1,this.skipInvalid=e.skipInvalid||!1,this.flowLevel=j.isNothing(e.flowLevel)?-1:e.flowLevel,this.styleMap=yu(this.schema,e.styles||null),this.sortKeys=e.sortKeys||!1,this.lineWidth=e.lineWidth||80,this.noRefs=e.noRefs||!1,this.noCompatMode=e.noCompatMode||!1,this.condenseFlow=e.condenseFlow||!1,this.quotingType=e.quotingType==='"'?Ft:xu,this.forceQuotes=e.forceQuotes||!1,this.replacer=typeof e.replacer=="function"?e.replacer:null,this.implicitTypes=this.schema.compiledImplicit,this.explicitTypes=this.schema.compiledExplicit,this.tag=null,this.result="",this.duplicates=[],this.usedDuplicates=null}a(Pu,"State");function Ji(e,t){for(var r=j.repeat(" ",t),o=0,n=-1,s="",i,c=e.length;o<c;)n=e.indexOf(`
`,o),n===-1?(i=e.slice(o),o=c):(i=e.slice(o,n+1),o=n+1),i.length&&i!==`
`&&(s+=r),s+=i;return s}a(Ji,"indentString");function Ko(e,t){return`
`+j.repeat(" ",e.indent*t)}a(Ko,"generateNextLine");function wu(e,t){var r,o,n;for(r=0,o=e.implicitTypes.length;r<o;r+=1)if(n=e.implicitTypes[r],n.resolve(t))return!0;return!1}a(wu,"testImplicitResolving");function Mr(e){return e===tu||e===Zp}a(Mr,"isWhitespace");function Ht(e){return 32<=e&&e<=126||161<=e&&e<=55295&&e!==8232&&e!==8233||57344<=e&&e<=65533&&e!==Jo||65536<=e&&e<=1114111}a(Ht,"isPrintable");function Qi(e){return Ht(e)&&e!==Jo&&e!==eu&&e!==Ut}a(Qi,"isNsCharOrWhitespace");function Xi(e,t,r){var o=Qi(e),n=o&&!Mr(e);return(r?o:o&&e!==$a&&e!==Ua&&e!==Fa&&e!==Ha&&e!==Va)&&e!==jo&&!(t===Nr&&!n)||Qi(t)&&!Mr(t)&&e===jo||t===Nr&&n}a(Xi,"isPlainSafe");function Su(e){return Ht(e)&&e!==Jo&&!Mr(e)&&e!==cu&&e!==uu&&e!==Nr&&e!==$a&&e!==Ua&&e!==Fa&&e!==Ha&&e!==Va&&e!==jo&&e!==iu&&e!==su&&e!==ru&&e!==fu&&e!==lu&&e!==pu&&e!==au&&e!==ou&&e!==nu&&e!==du&&e!==mu}a(Su,"isPlainSafeFirst");function vu(e){return!Mr(e)&&e!==Nr}a(vu,"isPlainSafeLast");function Lt(e,t){var r=e.charCodeAt(t),o;return r>=55296&&r<=56319&&t+1<e.length&&(o=e.charCodeAt(t+1),o>=56320&&o<=57343)?(r-55296)*1024+o-56320+65536:r}a(Lt,"codePointAt");function ja(e){var t=/^\n* /;return t.test(e)}a(ja,"needIndentIndicator");var Ka=1,Go=2,Ga=3,Ba=4,mt=5;function Cu(e,t,r,o,n,s,i,c){var l,p=0,u=null,d=!1,m=!1,h=o!==-1,x=-1,S=Su(Lt(e,0))&&vu(Lt(e,e.length-1));if(t||i)for(l=0;l<e.length;p>=65536?l+=2:l++){if(p=Lt(e,l),!Ht(p))return mt;S=S&&Xi(p,u,c),u=p}else{for(l=0;l<e.length;p>=65536?l+=2:l++){if(p=Lt(e,l),p===Ut)d=!0,h&&(m=m||l-x-1>o&&e[x+1]!==" ",x=l);else if(!Ht(p))return mt;S=S&&Xi(p,u,c),u=p}m=m||h&&l-x-1>o&&e[x+1]!==" "}return!d&&!m?S&&!i&&!n(e)?Ka:s===Ft?mt:Go:r>9&&ja(e)?mt:i?s===Ft?mt:Go:m?Ba:Ga}a(Cu,"chooseScalarStyle");function Au(e,t,r,o,n){e.dump=(function(){if(t.length===0)return e.quotingType===Ft?'""':"''";if(!e.noCompatMode&&(gu.indexOf(t)!==-1||hu.test(t)))return e.quotingType===Ft?'"'+t+'"':"'"+t+"'";var s=e.indent*Math.max(1,r),i=e.lineWidth===-1?-1:Math.max(Math.min(e.lineWidth,40),e.lineWidth-s),c=o||e.flowLevel>-1&&r>=e.flowLevel;function l(p){return wu(e,p)}switch(a(l,"testAmbiguity"),Cu(t,c,e.indent,i,l,e.quotingType,e.forceQuotes&&!o,n)){case Ka:return t;case Go:return"'"+t.replace(/'/g,"''")+"'";case Ga:return"|"+Zi(t,e.indent)+ea(Ji(t,s));case Ba:return">"+Zi(t,e.indent)+ea(Ji(Ru(t,i),s));case mt:return'"'+Eu(t)+'"';default:throw new Q("impossible error: invalid scalar style")}})()}a(Au,"writeScalar");function Zi(e,t){var r=ja(e)?String(t):"",o=e[e.length-1]===`
`,n=o&&(e[e.length-2]===`
`||e===`
`),s=n?"+":o?"":"-";return r+s+`
`}a(Zi,"blockHeader");function ea(e){return e[e.length-1]===`
`?e.slice(0,-1):e}a(ea,"dropEndingNewline");function Ru(e,t){for(var r=/(\n+)([^\n]*)/g,o=(function(){var p=e.indexOf(`
`);return p=p!==-1?p:e.length,r.lastIndex=p,ta(e.slice(0,p),t)})(),n=e[0]===`
`||e[0]===" ",s,i;i=r.exec(e);){var c=i[1],l=i[2];s=l[0]===" ",o+=c+(!n&&!s&&l!==""?`
`:"")+ta(l,t),n=s}return o}a(Ru,"foldString");function ta(e,t){if(e===""||e[0]===" ")return e;for(var r=/ [^ ]/g,o,n=0,s,i=0,c=0,l="";o=r.exec(e);)c=o.index,c-n>t&&(s=i>n?i:c,l+=`
`+e.slice(n,s),n=s+1),i=c;return l+=`
`,e.length-n>t&&i>n?l+=e.slice(n,i)+`
`+e.slice(i+1):l+=e.slice(n),l.slice(1)}a(ta,"foldLine");function Eu(e){for(var t="",r=0,o,n=0;n<e.length;r>=65536?n+=2:n++)r=Lt(e,n),o=q[r],!o&&Ht(r)?(t+=e[n],r>=65536&&(t+=e[n+1])):t+=o||bu(r);return t}a(Eu,"escapeString");function ku(e,t,r){var o="",n=e.tag,s,i,c;for(s=0,i=r.length;s<i;s+=1)c=r[s],e.replacer&&(c=e.replacer.call(r,String(s),c)),(Ne(e,t,c,!1,!1)||typeof c>"u"&&Ne(e,t,null,!1,!1))&&(o!==""&&(o+=","+(e.condenseFlow?"":" ")),o+=e.dump);e.tag=n,e.dump="["+o+"]"}a(ku,"writeFlowSequence");function ra(e,t,r,o){var n="",s=e.tag,i,c,l;for(i=0,c=r.length;i<c;i+=1)l=r[i],e.replacer&&(l=e.replacer.call(r,String(i),l)),(Ne(e,t+1,l,!0,!0,!1,!0)||typeof l>"u"&&Ne(e,t+1,null,!0,!0,!1,!0))&&((!o||n!=="")&&(n+=Ko(e,t)),e.dump&&Ut===e.dump.charCodeAt(0)?n+="-":n+="- ",n+=e.dump);e.tag=s,e.dump=n||"[]"}a(ra,"writeBlockSequence");function Tu(e,t,r){var o="",n=e.tag,s=Object.keys(r),i,c,l,p,u;for(i=0,c=s.length;i<c;i+=1)u="",o!==""&&(u+=", "),e.condenseFlow&&(u+='"'),l=s[i],p=r[l],e.replacer&&(p=e.replacer.call(r,l,p)),Ne(e,t,l,!1,!1)&&(e.dump.length>1024&&(u+="? "),u+=e.dump+(e.condenseFlow?'"':"")+":"+(e.condenseFlow?"":" "),Ne(e,t,p,!1,!1)&&(u+=e.dump,o+=u));e.tag=n,e.dump="{"+o+"}"}a(Tu,"writeFlowMapping");function Iu(e,t,r,o){var n="",s=e.tag,i=Object.keys(r),c,l,p,u,d,m;if(e.sortKeys===!0)i.sort();else if(typeof e.sortKeys=="function")i.sort(e.sortKeys);else if(e.sortKeys)throw new Q("sortKeys must be a boolean or a function");for(c=0,l=i.length;c<l;c+=1)m="",(!o||n!=="")&&(m+=Ko(e,t)),p=i[c],u=r[p],e.replacer&&(u=e.replacer.call(r,p,u)),Ne(e,t+1,p,!0,!0,!0)&&(d=e.tag!==null&&e.tag!=="?"||e.dump&&e.dump.length>1024,d&&(e.dump&&Ut===e.dump.charCodeAt(0)?m+="?":m+="? "),m+=e.dump,d&&(m+=Ko(e,t)),Ne(e,t+1,u,!0,d)&&(e.dump&&Ut===e.dump.charCodeAt(0)?m+=":":m+=": ",m+=e.dump,n+=m));e.tag=s,e.dump=n||"{}"}a(Iu,"writeBlockMapping");function oa(e,t,r){var o,n,s,i,c,l;for(n=r?e.explicitTypes:e.implicitTypes,s=0,i=n.length;s<i;s+=1)if(c=n[s],(c.instanceOf||c.predicate)&&(!c.instanceOf||typeof t=="object"&&t instanceof c.instanceOf)&&(!c.predicate||c.predicate(t))){if(r?c.multi&&c.representName?e.tag=c.representName(t):e.tag=c.tag:e.tag="?",c.represent){if(l=e.styleMap[c.tag]||c.defaultStyle,_a.call(c.represent)==="[object Function]")o=c.represent(t,l);else if(La.call(c.represent,l))o=c.represent[l](t,l);else throw new Q("!<"+c.tag+'> tag resolver accepts not "'+l+'" style');e.dump=o}return!0}return!1}a(oa,"detectType");function Ne(e,t,r,o,n,s,i){e.tag=null,e.dump=r,oa(e,r,!1)||oa(e,r,!0);var c=_a.call(e.dump),l=o,p;o&&(o=e.flowLevel<0||e.flowLevel>t);var u=c==="[object Object]"||c==="[object Array]",d,m;if(u&&(d=e.duplicates.indexOf(r),m=d!==-1),(e.tag!==null&&e.tag!=="?"||m||e.indent!==2&&t>0)&&(n=!1),m&&e.usedDuplicates[d])e.dump="*ref_"+d;else{if(u&&m&&!e.usedDuplicates[d]&&(e.usedDuplicates[d]=!0),c==="[object Object]")o&&Object.keys(e.dump).length!==0?(Iu(e,t,e.dump,n),m&&(e.dump="&ref_"+d+e.dump)):(Tu(e,t,e.dump),m&&(e.dump="&ref_"+d+" "+e.dump));else if(c==="[object Array]")o&&e.dump.length!==0?(e.noArrayIndent&&!i&&t>0?ra(e,t-1,e.dump,n):ra(e,t,e.dump,n),m&&(e.dump="&ref_"+d+e.dump)):(ku(e,t,e.dump),m&&(e.dump="&ref_"+d+" "+e.dump));else if(c==="[object String]")e.tag!=="?"&&Au(e,e.dump,t,s,l);else{if(c==="[object Undefined]")return!1;if(e.skipInvalid)return!1;throw new Q("unacceptable kind of an object to dump "+c)}e.tag!==null&&e.tag!=="?"&&(p=encodeURI(e.tag[0]==="!"?e.tag.slice(1):e.tag).replace(/!/g,"%21"),e.tag[0]==="!"?p="!"+p:p.slice(0,18)==="tag:yaml.org,2002:"?p="!!"+p.slice(18):p="!<"+p+">",e.dump=p+" "+e.dump)}return!0}a(Ne,"writeNode");function Ou(e,t){var r=[],o=[],n,s;for(Bo(e,r,o),n=0,s=o.length;n<s;n+=1)t.duplicates.push(r[o[n]]);t.usedDuplicates=new Array(s)}a(Ou,"getDuplicateReferences");function Bo(e,t,r){var o,n,s;if(e!==null&&typeof e=="object")if(n=t.indexOf(e),n!==-1)r.indexOf(n)===-1&&r.push(n);else if(t.push(e),Array.isArray(e))for(n=0,s=e.length;n<s;n+=1)Bo(e[n],t,r);else for(o=Object.keys(e),n=0,s=o.length;n<s;n+=1)Bo(e[o[n]],t,r)}a(Bo,"inspectNode");function Nu(e,t){t=t||{};var r=new Pu(t);r.noRefs||Ou(e,r);var o=e;return r.replacer&&(o=r.replacer.call({"":o},"",o)),Ne(r,0,o,!0,!0)?r.dump+`
`:""}a(Nu,"dump$1");var Mu=Nu,Du={dump:Mu};function Qo(e,t){return function(){throw new Error("Function yaml."+e+" is removed in js-yaml 4. Use yaml."+t+" instead, which is now safe by default.")}}a(Qo,"renamed");var _u=W,Lu=aa,$u=pa,Uu=ga,Fu=ha,Hu=zo,Vu=Da.load,ju=Da.loadAll,Ku=Du.dump,Gu=Q,Bu={binary:wa,float:fa,map:la,null:ua,pairs:va,set:Ca,timestamp:xa,bool:da,int:ma,merge:Pa,omap:Sa,seq:ca,str:sa},Wu=Qo("safeLoad","load"),zu=Qo("safeLoadAll","loadAll"),Yu=Qo("safeDump","dump"),Wa={Type:_u,Schema:Lu,FAILSAFE_SCHEMA:$u,JSON_SCHEMA:Uu,CORE_SCHEMA:Fu,DEFAULT_SCHEMA:Hu,load:Vu,loadAll:ju,dump:Ku,YAMLException:Gu,types:Bu,safeLoad:Wu,safeLoadAll:zu,safeDump:Yu};var yt=require("pepr");var Xo="istio-tenant-gateway",Zo="istio-admin-gateway",za="Restarting Gateway Pods to apply new Istio configuration",_r=P("operator.istio"),en;async function Ya(e){let t=e?.data?.mesh;if(t){let r=Wa.load(t);if(r.defaultConfig?.gatewayTopology?.numTrustedProxies!=en?.defaultConfig?.gatewayTopology?.numTrustedProxies||r.defaultConfig?.gatewayTopology?.forwardClientCertDetails!=en?.defaultConfig?.gatewayTopology?.forwardClientCertDetails){en=r;let o=await(0,yt.K8s)(yt.kind.Pod).InNamespace(Xo).Get(),n=await(0,yt.K8s)(yt.kind.Pod).InNamespace(Zo).Get();_r.info({TENANT_GATEWAY_NAMESPACE:Xo},"Restarting {} pods to apply new configuration"),await _t(Xo,o.items,za,_r,"ConfigMapChanged"),_r.info({ADMIN_GATEWAY_NAMESPACE:Zo},"Restarting {} pods to apply new configuration"),await _t(Zo,n.items,za,_r,"ConfigMapChanged")}}}a(Ya,"restartGatewayPods");var Ur=require("pepr");var z=[];for(let e=0;e<256;++e)z.push((e+256).toString(16).slice(1));function qa(e,t=0){return(z[e[t+0]]+z[e[t+1]]+z[e[t+2]]+z[e[t+3]]+"-"+z[e[t+4]]+z[e[t+5]]+"-"+z[e[t+6]]+z[e[t+7]]+"-"+z[e[t+8]]+z[e[t+9]]+"-"+z[e[t+10]]+z[e[t+11]]+z[e[t+12]]+z[e[t+13]]+z[e[t+14]]+z[e[t+15]]).toLowerCase()}a(qa,"unsafeStringify");var Ja=require("node:crypto");var $r=new Uint8Array(256),Lr=$r.length;function tn(){return Lr>$r.length-16&&((0,Ja.randomFillSync)($r),Lr=0),$r.slice(Lr,Lr+=16)}a(tn,"rng");var Qa=require("node:crypto"),rn={randomUUID:Qa.randomUUID};function qu(e,t,r){e=e||{};let o=e.random??e.rng?.()??tn();if(o.length<16)throw new Error("Random bytes length must be >= 16");if(o[6]=o[6]&15|64,o[8]=o[8]&63|128,t){if(r=r||0,r<0||r+16>t.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let n=0;n<16;++n)t[r+n]=o[n];return t}return qa(o)}a(qu,"_v4");function Ju(e,t,r){return rn.randomUUID&&!t&&!e?rn.randomUUID():qu(e,t,r)}a(Ju,"v4");var on=Ju;var Xa="uds-operator",bt="keycloak",Vt="keycloak-client-secrets",Qu=P("operator.config");async function Fr(e,t=!1){e.data=e.data||{},delete e.metadata?.managedFields,(!e.data[Xa]||t)&&(Qu.info("Generating new Keycloak client secret"),e.data[Xa]=Buffer.from(on()).toString("base64"),await(0,Ur.K8s)(Ur.kind.Secret).Apply(e))}a(Fr,"updateKeycloakClientsSecret");function Xu(e){return e[0]==="/"&&e[e.length-1]==="/"}a(Xu,"checkForSlashes");var Za="uds-policy-exemptions",Zu=new Map([["pod",Object.values(xe).filter(e=>e!=="DisallowNodePortServices"&&e!=="RestrictExternalNames")],["service",["RestrictExternalNames","DisallowNodePortServices"]]]);async function es(e){let t=e.Raw,r=t.spec?.exemptions??[];if(!g.allowAllNSExemptions&&t.metadata?.namespace!==Za)return e.Deny(`Invalid namespace "${t.metadata?.namespace}" for UDSExemption ${t.metadata?.name}: must be "${Za}"`);for(let o of r){let n=Zu.get(o.matcher.kind);for(let s of o.policies)if(!n.includes(s)){let i=o.matcher.kind==="pod"?"service":"pod";return e.Deny(`Invalid kind "${o.matcher.kind}" for matcher "${o.matcher.name}" with policy "${s}": "${s}" can only be exempted for kind "${i}"`)}}for(let o of r){if(Xu(o.matcher.name))return e.Deny(`Invalid matcher name "${o.matcher.name}": please remove the leading and trailing slashes`);try{new RegExp(o.matcher.name)}catch(n){return e.Deny(`Invalid regular expression pattern ${o.matcher.name}: ${n}`)}}return e.Approve()}a(es,"exemptValidator");var Kt=require("pepr");var ts=new Set,ye=P("operator.reconcilers");function rs(e){let t=e.status?.phase==="Retrying",r=e.status?.phase==="Pending",o=e.metadata?.deletionTimestamp||e.status?.phase==="Removing"||e.status?.phase==="RemovalFailed",n=e.metadata?.generation===e.status?.observedGeneration;return ts.has(e.metadata.uid)?t?(ye.debug(e,"Should skip? No, retrying"),!1):o?(ye.debug(e,"Should skip? Yes, removing"),!0):r||n?(ye.trace(e,"Should skip? Yes, pending or current generation and not first time seen"),!0):(ye.trace(e,"Should skip? No, not pending or current generation and not first time seen"),!1):(ye.trace(e,"Should skip? No, first time processed during this pod's lifetime"),!1)}a(rs,"shouldSkip");async function Me(e,t){ye.debug(`Updating ${e.metadata?.name}/${e.metadata?.namespace} status to ${t.phase}`);let r={...t},o=$o(e);o&&(r.authserviceClients=o),await(0,Kt.K8s)(ee).PatchStatus({metadata:{name:e.metadata.name,namespace:e.metadata.namespace},status:r}),ts.add(e.metadata.uid)}a(Me,"updateStatus");async function ue(e,t){ye.debug(`Writing ${e.metadata?.name}/${e.metadata?.namespace} event: ${t.message}`),await(0,Kt.K8s)(Kt.kind.CoreEvent).Create({type:"Warning",reason:"ReconciliationFailed",...t,metadata:{namespace:e.metadata.namespace,generateName:e.metadata.name},involvedObject:{apiVersion:e.apiVersion,kind:e.kind,name:e.metadata.name,namespace:e.metadata.namespace,uid:e.metadata.uid},firstTimestamp:new Date,reportingComponent:"uds.dev/operator",reportingInstance:process.env.HOSTNAME})}a(ue,"writeEvent");async function os(e,t){let r=t.metadata,o=`${r.namespace}/${r.name}`,n;if(e.status===404){ye.warn({err:e},"Package metadata seems to have been deleted");return}let s=e.data?.message||e.message,i=t.status?.retryAttempt||0;if(i<4){let c=i+1;ye.error({err:e},`Reconciliation attempt ${c} failed for ${o}, retrying...`),n={phase:"Retrying",conditions:jt(!1),retryAttempt:c}}else ye.error({err:e},`Error configuring ${o}, maxed out retries`),n={phase:"Failed",conditions:jt(!1),observedGeneration:r.generation,retryAttempt:0};await ue(t,{message:s}),Me(t,n).catch(c=>{ye.error({err:c},`Error updating status for ${o} failed`),ue(t,{message:c.message})})}a(os,"handleFailure");function jt(e=!0){return[{type:"Ready",status:e===!0?"True":"False",lastTransitionTime:new Date,message:e===!0?"The package is ready for use.":"The package is not ready for use.",reason:"ReconciliationComplete"}]}a(jt,"getReadinessConditions");var X=require("pepr");var Ge=P("operator.istio"),Hr="istio-injection",Vr="istio.io/dataplane-mode",jr="uds.dev/original-istio-state",ne=(o=>(o[o.Sidecar="sidecar"]="Sidecar",o[o.Ambient="ambient"]="Ambient",o.None="none",o))(ne||{});async function is(e){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let t=await(0,X.K8s)(X.kind.Namespace).Get(e.metadata.namespace),r={...t.metadata?.labels||{}},o={...t.metadata?.annotations||{}},n=`uds.dev/pkg-${e.metadata.name}`,s=ss(r);o[jr]||(o[jr]=s);let i="none";o[n]="true",e.spec?.network?.serviceMesh?.mode==="ambient"?i=ne.Ambient:i=ne.Sidecar;let c=ps(r,i,s);await cs(e.metadata.namespace,c.labels,o,t.metadata?.labels,t.metadata?.annotations),await ls(e.metadata.namespace,c.shouldRestartPods,i)}a(is,"enableIstio");async function as(e){if(!e.metadata?.namespace||!e.metadata.name)throw new Error("Invalid Package definition, missing namespace or name");let t=await(0,X.K8s)(X.kind.Namespace).Get(e.metadata.namespace),r={...t.metadata?.labels||{}},o={...t.metadata?.annotations||{}},n=ss(r),s=o[jr];delete o[`uds.dev/pkg-${e.metadata.name}`];let i=Object.keys(o).some(l=>l.startsWith("uds.dev/pkg-")),c;i?c={labels:r,shouldRestartPods:!1}:(c=ps(r,s,n),delete o[jr]),await cs(e.metadata.namespace,c.labels,o,t.metadata?.labels,t.metadata?.annotations,`Updating namespace ${e.metadata.namespace}, removing ${e.metadata.name} state.`),await ls(e.metadata.namespace,c.shouldRestartPods,s)}a(as,"cleanupNamespace");async function ns(e,t){let r=await(0,X.K8s)(X.kind.Pod).InNamespace(e).Get(),o={};for(let n of r.items){if(n.metadata?.deletionTimestamp){Ge.debug(`Ignoring Pod ${e}/${n.metadata?.name}, already being deleted`);continue}let s=n.spec?.containers?.some(c=>c.name==="istio-proxy")||n.spec?.initContainers?.some(c=>c.name==="istio-proxy");if(t&&s){Ge.debug(`Ignoring Pod ${e}/${n.metadata?.name}, already has sidecar`);continue}if(!t&&!s){Ge.debug(`Ignoring Pod ${e}/${n.metadata?.name}, injection disabled`);continue}let i=n.metadata?.ownerReferences?.find(c=>c.controller)?.uid||"other";o[i]=o[i]||[],Ge.debug(`Adding Pod ${e}/${n.metadata?.name} to ${i} deletion list.`),o[i].push(n)}for(let n of Object.values(o)){n[0].metadata?.ownerReferences?.find(s=>s.kind==="StatefulSet")&&n.sort((s,i)=>(i.metadata?.name||"").localeCompare(s.metadata?.name||""));for(let s of n){let i=t?"enable":"remove";Ge.info(`Deleting pod ${e}/${s.metadata?.name} to ${i} the istio sidecar`),await(0,X.K8s)(X.kind.Pod).Delete(s)}}}a(ns,"killPods");function ss(e){return e[Hr]==="enabled"?ne.Sidecar:e[Vr]==="ambient"?ne.Ambient:"none"}a(ss,"getCurrentIstioState");async function cs(e,t,r,o,n,s){let i={metadata:{name:e,labels:t,annotations:r}};return!X.R.equals(o,t)||!X.R.equals(n,r)?(Ge.debug(s||`Applying updates to namespace ${e}.`),await(0,X.K8s)(X.kind.Namespace).Apply(i,{force:!0}),!0):(Ge.debug(`No namespace updates needed for ${e}.`),!1)}a(cs,"applyNamespaceUpdates");async function ls(e,t,r){t&&(Ge.debug(`Restarting pods in ${e} due to configuration changes (switching to ${r} Istio state)`),r===ne.Sidecar?await ns(e,!0):(r===ne.Ambient||r==="none")&&await ns(e,!1))}a(ls,"restartPodsIfNeeded");function ps(e,t,r){let o=!1;return t===ne.Sidecar?(e[Hr]="enabled",delete e[Vr],r!==ne.Sidecar&&(o=!0)):t===ne.Ambient?(e[Vr]="ambient",delete e[Hr],r===ne.Sidecar&&(o=!0)):(delete e[Hr],delete e[Vr],r===ne.Sidecar&&(o=!0)),{labels:e,shouldRestartPods:o}}a(ps,"getIstioLabels");var et=require("pepr");var Ce=require("pepr");var Kr="http://keycloak-http.keycloak.svc.cluster.local:8080";process.env.PEPR_MODE==="dev"&&(Kr="http://localhost:8080");var Xe=P("operator.keycloak");async function xt(e,t){if(!e.ok){let{status:r,statusText:o,data:n}=e,s=new Error(`${r}, ${o}, ${n?JSON.stringify(n):""}`);throw t&&t(s),s}}a(xt,"throwErrorIfNeeded");function ed(e){return JSON.parse(Buffer.from(e.split(".")[1],"base64").toString())}a(ed,"parseKeycloakToken");var Gr=`${Kr}/admin/realms/uds/clients`,td=`${Kr}/realms/uds/protocol/openid-connect/token`,rd="keycloak",od="keycloak-client-secrets",us="uds-operator",Ze=null;function Br(){Ze=null}a(Br,"resetCachedToken");async function Wr(){if(Ze)try{let s=ed(Ze);if(s.exp&&s.exp>Math.floor(Date.now()/1e3)+5)return Ze}catch(s){Xe.error(s,"Failed to parse cached token"),Ze=null}let e=await(0,Ce.K8s)(Ce.kind.Secret).InNamespace(rd).Get(od);if(!e)throw new Error("Missing secret");let t=e.data?.[us];if(!t)throw new Error("Missing client secret");let r=Buffer.from(t,"base64").toString("utf-8"),o=new URLSearchParams;o.append("grant_type","client_credentials"),o.append("client_id",us),o.append("client_secret",r);let n=await(0,Ce.fetch)(td,{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:o.toString()});return await xt(n),Ze=n.data.access_token,Ze}a(Wr,"credentialsGetAccessToken");async function ds(e){return Xe.info(`credentialsCreateOrUpdate: creating/updating client ${JSON.stringify(e)}`),await Gt(e)?id(e):nd(e)}a(ds,"credentialsCreateOrUpdate");async function nd(e){Xe.info(`credentialsCreate: creating client ${JSON.stringify(e)}`);let t=await Wr(),r=await(0,Ce.fetch)(Gr,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(e)});return await xt(r,()=>{Br()}),Gt(e)}a(nd,"credentialsCreate");async function Gt(e){Xe.info(`credentialsGet: retrieving client ${JSON.stringify(e)}`);let t=await Wr(),r=`${Gr}?clientId=${encodeURIComponent(e.clientId)}`,o=await(0,Ce.fetch)(r,{method:"GET",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`}});return await xt(o,()=>{Br()}),o.data[0]}a(Gt,"credentialsGet");async function id(e){Xe.info(`credentialsUpdate: updating client ${JSON.stringify(e)}`);let t=await Wr(),r=await Gt(e);if(!r||!r.id)throw new Error(`Failed to retrieve existing client, ${e.clientId}`);let o=`${Gr}/${encodeURIComponent(r.id)}`,n=await(0,Ce.fetch)(o,{method:"PUT",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`},body:JSON.stringify(e)});return await xt(n,()=>{Br()}),Gt(e)}a(id,"credentialsUpdate");async function ms(e){Xe.info(`credentialsDelete: deleting client ${JSON.stringify(e)}`);let t=await Wr(),r=await Gt(e);if(!r||!r.id)throw new Error(`Failed to retrieve existing client, ${e.clientId}`);let o=`${Gr}/${encodeURIComponent(r.id)}`,n=await(0,Ce.fetch)(o,{method:"DELETE",headers:{"Content-Type":"application/json",Authorization:`Bearer ${t}`}});await xt(n,()=>{Br()})}a(ms,"credentialsDelete");var fs=["adminUrl","alwaysDisplayInConsole","attributes","authenticationFlowBindingOverrides","baseUrl","bearerOnly","clientAuthenticatorType","clientId","consentRequired","defaultClientScopes","defaultRoles","directAccessGrantsEnabled","enabled","frontchannelLogout","fullScopeAllowed","implicitFlowEnabled","name","nodeReRegistrationTimeout","notBefore","optionalClientScopes","protocol","protocolMappers","publicClient","redirectUris","registrationAccessToken","secret","serviceAccountsEnabled","standardFlowEnabled","surrogateAuthRequired","webOrigins","samlIdpCertificate"];var ad="http://keycloak-http.keycloak.svc.cluster.local:8080/realms/uds/protocol/saml/descriptor",sd=new RegExp('clientField\\(([a-zA-Z]+)\\)(?:\\["?([\\w]+)"?\\]|(\\.json\\(\\)))?',"gm"),cd=new RegExp(/<[^>]*:IDPSSODescriptor[^>]*>((.|[\n\r])*)<\/[^>]*:IDPSSODescriptor>/),ld=new RegExp(/<[^>]*:X509Certificate[^>]*>((.|[\n\r])*)<\/[^>]*:X509Certificate>/),Ae=P("operator.keycloak");async function gs(e){let t=e.spec?.sso||[],r=new Map,o=(e.metadata?.generation??0).toString();for(let n of t){let s=await hs(n,e);r.set(s.clientId,s)}try{await nn(e,[...r.keys()])}catch(n){Ae.error(n,`Failed to purge orphaned clients in for ${e.metadata.name}: ${n}`)}try{await R(o,e.metadata.namespace,e.metadata.name,et.kind.Secret,Ae)}catch(n){Ae.error(n,`Failed to purge orphaned SSO secrets in for ${e.metadata.name}: ${n}`)}return r}a(gs,"keycloak");async function nn(e,t=[]){let o=(e.status?.ssoClients||[]).filter(n=>!t.includes(n));for(let n of o)try{await ms({clientId:n})}catch(s){throw Ae.warn(e.metadata,`Failed to remove client ${n}, package ${e.metadata?.namespace}/${e.metadata?.name}. Error: ${s.message}`),new Error(`Failed to remove client ${n}, package ${e.metadata?.namespace}/${e.metadata?.name}. Error: ${s.message}`)}}a(nn,"purgeSSOClients");function pd(e){let t={};for(let r of fs)r in e&&(t[r]=e[r]);return t.attributes=t.attributes||{},e.groups?.anyOf?t.attributes["uds.core.groups"]=JSON.stringify(e.groups):t.attributes["uds.core.groups"]="",t}a(pd,"convertSsoToClient");async function hs({secretName:e,secretTemplate:t,...r},o,n=!1){Ae.debug(o.metadata,`Processing client request: ${r.clientId}`);let s=`sso-client-${r.clientId}`,i=pd(r);try{i=await ds(i)}catch(c){let l=`Failed to process Keycloak request for client '${i.clientId}', package ${o.metadata?.namespace}/${o.metadata?.name}. Error: ${c.message}`;if(n)throw Ae.error(`${l}, retry failed.`),new Error(l);Ae.error(`${l}, retrying...`);try{return await hs({secretName:e,secretTemplate:t,...r},o,!0)}catch(p){let u=`Retry of Keycloak request failed for client '${i.clientId}', package ${o.metadata?.namespace}/${o.metadata?.name}. Error: ${p.message}`;throw Ae.error(u),new Error(l)}}if(delete i.registrationAccessToken,i.protocol==="saml"&&(i.samlIdpCertificate=await dd()),!i.publicClient){let c=(o.metadata?.generation??0).toString(),l=v(e||s),p={"uds/package":o.metadata.name||"","uds/generation":c};r.secretLabels&&Object.assign(p,r.secretLabels);let u={};r.secretAnnotations&&Object.assign(u,r.secretAnnotations),await(0,et.K8s)(et.kind.Secret).Apply({metadata:{namespace:o.metadata.namespace,name:l,labels:p,annotations:u,ownerReferences:L(o)},data:ud(i,t)})}return i}a(hs,"syncClient");function ud(e,t){if(t)return Ae.debug(`Using secret template for client: ${e.clientId}`),fd(t,e);let r={};Ae.debug(`Using client data for secret: ${e.clientId}`);for(let[o,n]of Object.entries(e)){let s=typeof n=="object"?JSON.stringify(n):String(n);r[o]=Buffer.from(s).toString("base64")}return r}a(ud,"generateSecretData");async function dd(){let e=await(0,et.fetch)(ad);if(e.ok)return md(e.data)}a(dd,"getSamlCertificate");function md(e){return(e.match(cd)?.[1]||"").match(ld)?.[1]||""}a(md,"extractSamlCertificateFromXML");function fd(e,t){let r={};for(let[o,n]of Object.entries(e)){let s=n.replace(sd,(i,c,l,p)=>{let u=t[c];return l?String(u[l]??""):p?JSON.stringify(u):u!==void 0?String(u):""});r[o]=Buffer.from(s).toString("base64")}return r}a(fd,"templateData");var ys=require("pepr");var an=P("operator.monitoring");async function bs(e,t){let r=e.metadata.name,o=(e.metadata?.generation??0).toString(),n=L(e);an.debug(`Reconciling PodMonitors for ${r}`);let s=e.spec?.monitor??[],i=[];try{for(let c of s)if(c.kind==="PodMonitor"){let l=gd(c,t,r,o,n);an.debug(l,`Applying PodMonitor ${l.metadata?.name}`),await(0,ys.K8s)(Re).Apply(l,{force:!0}),i.push(l)}await R(o,t,r,Re,an)}catch(c){throw new Error(`Failed to process PodMonitors for ${r}, cause: ${JSON.stringify(c)}`)}return[...i.map(c=>c.metadata.name)]}a(bs,"podMonitor");function gd(e,t,r,o,n){let{selector:s,podSelector:i,portName:c}=e;return{metadata:{name:dt(r,e),namespace:t,labels:{"uds/package":r,"uds/generation":o},ownerReferences:n},spec:{podMetricsEndpoints:[{port:c,path:e.path||"/metrics",authorization:e.authorization}],selector:{matchLabels:i??s},fallbackScrapeProtocol:e.fallbackScrapeProtocol||"PrometheusText0.0.4"}}}a(gd,"generatePodMonitor");var xs=require("pepr");var sn=P("operator.monitoring");async function Ps(e,t){let r=e.metadata.name,o=(e.metadata?.generation??0).toString(),n=L(e);sn.debug(`Reconciling ServiceMonitors for ${r}`);let s=e.spec?.monitor??[],i=[];try{for(let c of s)if(c.kind!=="PodMonitor"){let l=yd(c,t,r,o,n);sn.debug(l,`Applying ServiceMonitor ${l.metadata?.name}`),await(0,xs.K8s)(Ee).Apply(l,{force:!0}),i.push(l)}await R(o,t,r,Ee,sn)}catch(c){throw new Error(`Failed to process ServiceMonitors for ${r}, cause: ${JSON.stringify(c)}`)}return[...i.map(c=>c.metadata.name)]}a(Ps,"serviceMonitor");function yd(e,t,r,o,n){let{selector:s,portName:i}=e;return{metadata:{name:dt(r,e),namespace:t,labels:{"uds/package":r,"uds/generation":o},ownerReferences:n},spec:{endpoints:[{port:i,path:e.path||"/metrics",authorization:e.authorization}],selector:{matchLabels:s},fallbackScrapeProtocol:e.fallbackScrapeProtocol||"PrometheusText0.0.4"}}}a(yd,"generateServiceMonitor");var Cs=require("pepr");var de=P("operator.network");function ws(e){let t=e.podSelector??e.selector??{},r=e.targetPort?.toString()??"unknown-port",o=t.app?.replace(/-pod$/,"")??(t["app.kubernetes.io/name"]?t["app.kubernetes.io/name"].replace(/-pod$/,"")+"-workload":void 0)??(Object.values(t).join("-")||"workload");return`monitor-${r}-${o}`}a(ws,"generateMonitorName");function Ss(e){let{description:t,selector:r,remoteGenerated:o,remoteNamespace:n,remoteSelector:s}=e;return`ingress-${t||[Object.values(r||{default:"all pods"}).join("-"),o||[n||"default",Object.values(s||{default:"all pods"}).join("-")]].flat().join("-")}`}a(Ss,"generateAllowName");function bd(e){let t=e.targetPort??e.port,r=e.selector?Object.values(e.selector).join("-"):"all",o=e.gateway||"tenant";return`ingress-${t}-${r}-istio-${o}-gateway`}a(bd,"generateExposeName");function xd(e,t){let r=[];e.port!==void 0&&r.push(e.port.toString()),e.ports&&r.push(...e.ports.map(i=>i.toString()));let o={},n=e.remoteServiceAccount?.trim(),s=e.remoteNamespace?.trim();if(n)o={principals:[`cluster.local/ns/${s||t}/sa/${e.remoteServiceAccount}`]};else if(e.remoteCidr)o={ipBlocks:[e.remoteCidr]};else if(e.remoteGenerated)switch(e.remoteGenerated){case"CloudMetadata":o={ipBlocks:[Ot]};break;case"KubeAPI":o={ipBlocks:Er().map(i=>i.ipBlock?.cidr).filter(i=>typeof i=="string")};break;case"KubeNodes":o={ipBlocks:vr().map(i=>i.ipBlock?.cidr).filter(i=>typeof i=="string")};break;case"IntraNamespace":o={namespaces:[t]};break;case"Anywhere":o={};break}else e.remoteNamespace===""||e.remoteNamespace==="*"?o={}:e.remoteNamespace&&(o={namespaces:[e.remoteNamespace]});return{source:o,ports:r}}a(xd,"processAllowRule");function vs(e){let t=[],r=e.targetPort??e.port;r!==void 0&&t.push(r.toString());let o=e.gateway??"tenant";return{source:{principals:[`cluster.local/ns/istio-${o}-gateway/sa/${o}-ingressgateway`]},ports:t}}a(vs,"processExposeRule");function Pd(e){return Object.keys(e).length===0}a(Pd,"isEmpty");function tt(e,t,r,o,n,s){let i={};Pd(o)||(i.from=[{source:o}]),n.length>0&&(i.to=[{operation:{ports:n}}]);let c=t.metadata?.name??"unknown",l=t.metadata?.namespace??"default",p=t.metadata?.generation?.toString()??"0";return{apiVersion:"security.istio.io/v1beta1",kind:"AuthorizationPolicy",metadata:{name:e,namespace:l,labels:{"uds/package":c,"uds/generation":p,"uds/for":"network",...s},ownerReferences:L(t)},spec:{action:"ALLOW",...r?{selector:{matchLabels:r}}:{},rules:[i]}}}a(tt,"buildAuthPolicy");async function As(e,t,r){let o=e.metadata?.name??"unknown",n=e.metadata?.generation?.toString()??"0";de.info(`Starting authorization policy generation for package "${o}" in namespace "${t}" (generation ${n}).`);let s=[];if(e.spec?.network?.allow)for(let i of e.spec.network.allow){if(i.direction==="Egress")continue;let c=cn(e,i.selector),{source:l,ports:p}=xd(i,t);if(c){let u=H(c.clientId),d={"istio.io/gateway-name":u},m=v(`protect-${o}-allow-${Ss(i)}-${u}`),h=i.remoteGenerated?{"uds/generated":i.remoteGenerated,"uds/waypoint":u}:{"uds/waypoint":u},x=tt(m,e,d,l,p,h);s.push(x),de.trace(`Generated waypoint allow authpol: ${x.metadata?.name}`)}else{let u=v(`protect-${o}-${Ss(i)}`),d=i.remoteGenerated?{"uds/generated":i.remoteGenerated}:void 0,m=tt(u,e,i.selector,l,p,d);s.push(m),de.trace(`Generated allow authpol: ${m.metadata?.name}`)}}if(e.spec?.network?.expose)for(let i of e.spec.network.expose){let c=cn(e,i.selector);if(c){let l=H(c.clientId),{source:p}=vs(i),u=i.port?[i.port.toString()]:[];if(u.length>0){let d=Object.entries(i.selector||{}).map(([S,C])=>`${S}-${C}`).join("-")||"all",m=v(`protect-${o}-ingress-${i.port||"http"}-${d}-${l}`),x=tt(m,e,{"istio.io/gateway-name":l},p,u);s.push(x),de.trace(`Generated waypoint authpol: ${x.metadata?.name}`)}else de.warn({selector:i.selector,package:o},"No exposed port found for waypoint policy")}else{let{source:l,ports:p}=vs(i),u=v(`protect-${o}-${bd(i)}`),d=tt(u,e,i.selector,l,p);s.push(d),de.trace(`Generated authpol: ${d.metadata?.name}`)}}if(e.spec?.monitor)for(let i of e.spec.monitor){let c=i.podSelector??i.selector,l={principals:[Ct]},p=[i.targetPort.toString()],u=cn(e,c);if(u){let d=H(u.clientId),m={"istio.io/gateway-name":d},h=v(`protect-${o}-monitor-${ws(i)}-${d}`),x=tt(h,e,m,l,p,{"uds/waypoint":d});s.push(x),de.trace(`Generated waypoint monitor authpol: ${x.metadata?.name}`)}else{let d=v(`protect-${o}-${ws(i)}`),m=tt(d,e,c,l,p);s.push(m),de.trace(`Generated monitor authpol: ${m.metadata?.name}`)}}if(e.spec?.sso&&Rt(e))for(let i of e.spec.sso){if(!i.enableAuthserviceSelector)continue;let c=H(i.clientId),l=i.enableAuthserviceSelector,p=wd(e,c,l);s.push(p)}if(r===ne.Sidecar){let i=v(`protect-${o}-ingress-15020-sidecar-metric-scraping`),c=tt(i,e,{},{principals:[Ct]},["15020"]);s.push(c),de.trace(`Generated extra ambient allow authpol for port 15020: ${c.metadata?.name}`)}for(let i of s)try{await(0,Cs.K8s)(D).Apply(i,{force:!0}),de.trace(`Applied AuthorizationPolicy ${i.metadata?.name} in namespace ${i.metadata?.namespace}`)}catch(c){throw de.error(c,`Error applying AuthorizationPolicy ${i.metadata?.name} in namespace ${i.metadata?.namespace}`),c}return await R(n,t,o,D,de,{"uds/for":"network"}),s}a(As,"generateAuthorizationPolicies");function cn(e,t){return!t||e.spec?.network?.serviceMesh?.mode!=="ambient"?void 0:Pe(e).find(o=>{let n=o.enableAuthserviceSelector;return Object.keys(n).length===0?!0:Object.entries(n).every(([s,i])=>t[s]===i)})}a(cn,"findMatchingSsoClient");function wd(e,t,r){let o=e.metadata?.name??"unknown",s={apiVersion:"security.istio.io/v1beta1",kind:"AuthorizationPolicy",metadata:{name:v(`deny-all-except-waypoint-${t}`),namespace:e.metadata?.namespace,labels:{"uds/package":o,"uds/generation":e.metadata?.generation?.toString()??"0","uds/for":"network","uds/ambient-waypoint":t},ownerReferences:L(e)},spec:{action:"DENY",rules:[{from:[{source:{notPrincipals:[`cluster.local/ns/${e.metadata?.namespace}/sa/${t}`]}}]}]}};return r&&Object.keys(r).length>0&&(s.spec.selector={matchLabels:r}),s}a(wd,"createDenyAllExceptWaypointPolicy");var Bt=require("pepr");var Rs=a(e=>{let t=B(e,{direction:"Egress",description:"DNS lookup via CoreDNS",remoteNamespace:"kube-system",remoteSelector:{"k8s-app":"kube-dns"},port:53});return t.spec.egress[0].ports[0].protocol="UDP",t},"allowEgressDNS");var ln=a((e,t,r)=>{let o={direction:"Egress",description:t?`Istiod communication for ${t}`:"Istiod communication",remoteNamespace:"istio-system",remoteSelector:{istio:"pilot"},port:15012,...r&&{selector:r}};return B(e,o)},"allowEgressIstiod");var Es=a(e=>B(e,{direction:"Ingress",description:"Sidecar monitoring",remoteNamespace:"monitoring",remoteSelector:{app:"prometheus"},port:15020}),"allowIngressSidecarMonitoring");function ks(e){return{apiVersion:"networking.k8s.io/v1",kind:"NetworkPolicy",metadata:{name:"default",namespace:e},spec:{podSelector:{},policyTypes:["Ingress","Egress"],ingress:[],egress:[]}}}a(ks,"defaultDenyAll");var Ts=a(e=>B(e,{direction:"Ingress",description:"Ambient Healthprobes",remoteCidr:"169.254.7.127/32"}),"allowAmbientHealthprobes");function pn(e,t){let r=Pe(e);if(!(!t||r.length===0))return r.find(o=>{let n=o.enableAuthserviceSelector;return Object.keys(n).length===0?!0:Object.entries(n).every(([s,i])=>s in t&&t[s]===i)})}a(pn,"findMatchingClient");var Is=P("operator.network");async function Os(e,t,r){let o=e.spec?.network?.allow??[],n=e.metadata.name,s=(e.metadata?.generation??0).toString();Is.debug(e.metadata,`Generating NetworkPolicies for generation ${s}`);let i=[ks(t),Rs(t)];r==="sidecar"&&(i.push(ln(t)),i.push(Es(t))),r==="ambient"&&i.push(Ts(t));for(let u of o){if(u.direction==="Ingress"&&u.selector){let m=pn(e,u.selector),h=m?H(m.clientId):void 0;h&&(u.selector=Et(e,u.selector,h))}let d=B(t,u,r);i.push(d)}let c=e.spec?.network?.expose??[];for(let u of c.filter(d=>!d.advancedHTTP?.directResponse)){let{gateway:d="tenant",port:m,selector:h={},targetPort:x}=u,S=x??m,C=pn(e,h),f=C?H(C.clientId):void 0,y=f?Et(e,h,f):h,me={direction:"Ingress",selector:y,remoteNamespace:`istio-${d}-gateway`,remoteSelector:{app:`${d}-ingressgateway`},port:S,description:`${S}-${Object.values(h).join("-")} Istio ${d} gateway`},nc=B(t,me,r);i.push(nc)}let l=Pe(e);for(let u of l){let d=H(u.clientId),m=Et(e,u.enableAuthserviceSelector,d),h={direction:"Egress",selector:m,remoteNamespace:"authservice",remoteSelector:{"app.kubernetes.io/name":"authservice"},port:10003,description:`${v(u.clientId)} authservice egress`},x=B(t,h,r);i.push(x);let S={direction:"Egress",selector:m,remoteNamespace:"keycloak",remoteSelector:{"app.kubernetes.io/name":"keycloak"},port:8080,description:`${v(u.clientId)} keycloak JWKS egress`},C=B(t,S,r);if(i.push(C),Rt(e)){let f=H(u.clientId),y=u.enableAuthserviceSelector,me=ln(t,u.clientId,m);me.metadata={...me.metadata,labels:{...me.metadata?.labels,"uds/sso-client":u.clientId}},i.push(me),i.push(B(t,{direction:"Egress",selector:{"istio.io/gateway-name":f},remoteSelector:y,description:`Allow traffic from ${f} to app`})),i.push(B(t,{direction:"Ingress",selector:y,remoteSelector:{"istio.io/gateway-name":f},description:`Allow traffic from ${f} to app pods`})),i.push(B(t,{direction:"Ingress",selector:{"istio.io/gateway-name":f},remoteNamespace:"monitoring",remoteSelector:{app:"prometheus"},ports:[15020],description:`Allow health checks from monitoring to ${f}`}))}}let p=e.spec?.monitor??[];for(let u of p){let{selector:d,targetPort:m,podSelector:h}=u,x=pn(e,d),S=x?H(x.clientId):void 0,C=S?Et(e,h??d,S):h??d,f={direction:"Ingress",selector:C,remoteNamespace:"monitoring",remoteSelector:{app:"prometheus"},port:m,description:`${m}-${Object.values(d)} Metrics`},y=B(t,f,r);i.push(y)}for(let[u,d]of i.entries()){if(d.metadata=d.metadata??{},d.metadata.labels=d.metadata?.labels??{},d.metadata.labels["uds/package"]=n,d.metadata.labels["uds/generation"]=s,u<1?d.metadata.name=`deny-${n}-${d.metadata.name}`:d.metadata.name=`allow-${n}-${d.metadata.name}`,d.spec?.ingress)for(let m of d.spec.ingress)m.ports&&m.ports.some(h=>h.protocol!=="UDP")&&m.ports.push({port:15008});else if(d.spec?.egress)for(let m of d.spec.egress)d.metadata?.labels?.["uds/generated"]==="KubeNodes"||d.metadata?.labels?.["uds/generated"]==="KubeAPI"||d.metadata?.labels?.["uds/generated"]==="CloudMetadata"||m.ports&&m.ports.some(h=>h.protocol!=="UDP")&&m.ports.push({port:15008});d.metadata.name=v(d.metadata.name),d.metadata.ownerReferences=L(e);try{await(0,Bt.K8s)(Bt.kind.NetworkPolicy).Apply(d,{force:!0})}catch(m){let h=m.data?.message||"Unknown error while applying network policies";throw g.kubeApiCIDR&&d.metadata.labels["uds/generated"]==="KubeAPI"&&(h+=", ensure that the KUBEAPI_CIDR override configured for the operator is correct."),g.kubeNodeCIDRs.length>0&&d.metadata.labels["uds/generated"]==="KubeNodes"&&(h+=", ensure that the KUBENODE_CIDRS override configured for the operator is correct."),new Error(h)}}return await R(s,t,n,Bt.kind.NetworkPolicy,Is),i}a(Os,"networkPolicies");var J=P("operator.reconcilers");async function Ns(e){let t=e.metadata,{namespace:r,name:o}=t;if(J.info(`Processing Package ${r}/${o}, status.phase: ${e.status?.phase}, observedGeneration: ${e.status?.observedGeneration}, retryAttempt: ${e.status?.retryAttempt}`),rs(e)){J.info(`Skipping Package ${r}/${o}, status.phase: ${e.status?.phase}, observedGeneration: ${e.status?.observedGeneration}, retryAttempt: ${e.status?.retryAttempt}`);return}if(kr(e),e.status?.retryAttempt&&e.status?.retryAttempt>0){let n=3**e.status.retryAttempt;J.info(t,`Waiting ${n} seconds before processing package ${r}/${o}, status.phase: ${e.status?.phase}, observedGeneration: ${e.status?.observedGeneration}, retryAttempt: ${e.status?.retryAttempt}`),await ue(e,{message:`Waiting ${n} seconds before retrying package`}),await new Promise(s=>setTimeout(s,n*1e3))}try{await Me(e,{phase:"Pending",conditions:jt(!1)}),await Sd(e)}catch(n){await os(n,e)}}a(Ns,"packageReconciler");async function Sd(e){let t=e.metadata,{namespace:r}=t,o=e.spec?.network?.serviceMesh?.mode||"sidecar",n=await Os(e,r,o),s=await As(e,r,o);await is(e);let i=[],c=new Map,l=[];if(g.isIdentityDeployed)c=await gs(e),l=await pi(e,c);else if(e.spec?.sso)throw J.error("Identity & Authorization is not deployed, but the package has SSO configuration"),new Error("Identity & Authorization is not deployed, but the package has SSO configuration");i=await Ln(e,r);let p=0;o==="ambient"&&e.spec?.network?.allow&&(p=dr(e.spec.network.allow).length);let u=[];u.push(...await bs(e,r)),u.push(...await Ps(e,r)),await ao(e,r),await Me(e,{phase:"Ready",conditions:jt(!0),ssoClients:[...c.keys()],authserviceClients:l,endpoints:i,monitors:u,networkPolicyCount:n.length,authorizationPolicyCount:s.length+l.length*2+p,meshMode:o,observedGeneration:t.generation,retryAttempt:0})}a(Sd,"reconcilePackageFlow");async function Ms(e){if(e.status?.phase==="Removing"||e.status?.phase==="RemovalFailed")return J.trace(`Skipping finalizer for ${e.metadata?.namespace}/${e.metadata?.name}, removal already in progress or failed.`),!1;if(e.status?.phase!=="Ready"&&e.status?.phase!=="Failed")return J.debug(`Waiting to finalize package ${e.metadata?.namespace}/${e.metadata?.name}, package has not completed initial reconciliation.`),!1;J.debug(`Processing removal of package ${e.metadata?.namespace}/${e.metadata?.name}`),await Me(e,{phase:"Removing"});try{await ue(e,{message:"Restoring original Istio injection status on namespace",reason:"RemovalInProgress",type:"Normal"}),await I(a(async function(){return as(e)},"cleanupIstioConfig"),J)}catch(t){return J.debug(`Restoration of Istio injection status during finalizer failed for ${e.metadata?.namespace}/${e.metadata?.name}: ${t.message}`),await ue(e,{message:`Restoration of Istio injection status failed: ${t.message}. Istio status must be manually restored, by updating or deleting the istio-injection label and cycling pods.`,reason:"RemovalFailed",type:"Warning"}),await Me(e,{phase:"RemovalFailed"}),!1}try{await ue(e,{message:"Removing AuthService configuration for package",reason:"RemovalInProgress",type:"Normal"}),await I(a(async function(){let r=e.spec?.network?.serviceMesh?.mode||"sidecar";return Oo(e,[],r,r)},"cleanupAuthserviceConfig"),J)}catch(t){return J.debug(`Removal of AuthService configuration during finalizer failed for ${e.metadata?.namespace}/${e.metadata?.name}: ${t.message}`),await ue(e,{message:`Removal of AuthService configuration failed: ${t.message}. AuthService configuration secret should be reviewed and cleaned up as needed.`,reason:"RemovalFailed",type:"Warning"}),await Me(e,{phase:"RemovalFailed"}),!1}try{await ue(e,{message:"Removing SSO clients for package",reason:"RemovalInProgress",type:"Normal"}),await I(a(async function(){return nn(e,[])},"cleanupSSOClients"),J)}catch(t){return J.debug(`Removal of SSO clients during finalizer failed for ${e.metadata?.namespace}/${e.metadata?.name}: ${t.message}`),await ue(e,{message:`Removal of SSO clients failed: ${t.message}. Clients must be manually removed from Keycloak.`,reason:"RemovalFailed",type:"Warning"}),await Me(e,{phase:"RemovalFailed"}),!1}try{await ue(e,{message:"Reconciling any shared egress resources",reason:"RemovalInProgress",type:"Normal"}),await I(a(async function(){await ur(void 0,mo(e),"RemovePackage",e.spec?.network?.serviceMesh?.mode||"sidecar")},"cleanupSharedEgressResources"),J)}catch(t){return J.debug(`Removal of shared egress resources during finalizer failed for ${e.metadata?.namespace}/${e.metadata?.name}: ${t.message}`),await ue(e,{message:`Removal of shared egress resources failed: ${t.message}`,reason:"RemovalFailed",type:"Warning"}),await Me(e,{phase:"RemovalFailed"}),!1}return J.debug(`Package ${e.metadata?.namespace}/${e.metadata?.name} removed successfully`),!0}a(Ms,"packageFinalizer");var Ds=P("operator");g.kubeApiCIDR||_(Z.a.EndpointSlice).IsCreatedOrUpdated().InNamespace("default").WithName("kubernetes").Reconcile(Ci);_(Z.a.Service).IsCreatedOrUpdated().InNamespace("default").WithName("kubernetes").Reconcile(Ai);_(Z.a.Service).IsCreatedOrUpdated().Mutate(e=>ri(e.Raw));_(Z.a.Pod).IsCreatedOrUpdated().Mutate(e=>oi(e.Raw));_(ee).IsCreatedOrUpdated().Validate(ji).Reconcile(Ns).Finalize(Ms);_(Le).IsCreatedOrUpdated().Validate(es);_(ee).IsCreatedOrUpdated().InNamespace("keycloak").WithName("keycloak").Watch(()=>{Ds.info("Identity and Authorization layer deployed, operator configured to handle SSO."),g.isIdentityDeployed=!0});_(ee).IsDeleted().InNamespace("keycloak").WithName("keycloak").Watch(()=>{Ds.info("Identity and Authorization layer removed, operator will NOT handle SSO."),g.isIdentityDeployed=!1});g.kubeNodeCIDRs.length===0&&_(Z.a.Node).IsCreatedOrUpdated().Reconcile(gi);g.kubeNodeCIDRs.length===0&&_(Z.a.Node).IsDeleted().Reconcile(hi);_(Z.a.Secret).IsCreatedOrUpdated().InNamespace("pepr-system").WithName("uds-operator-config").Reconcile(e=>_o(e,1));_(ae).IsCreatedOrUpdated().Validate(Rn).Reconcile(e=>Ar(e,1));_(Z.a.ConfigMap).IsCreatedOrUpdated().InNamespace("pepr-system").WithName("uds-ca-certs").Reconcile(wi);_(Z.a.Secret).IsCreatedOrUpdated().InNamespace(bt).WithName(Vt).Reconcile(e=>Fr(e,!1));_(Z.a.Secret).IsCreatedOrUpdated().WithLabel("uds.dev/pod-reload","true").Reconcile(Mi);_(Z.a.Secret).IsDeleted().WithLabel("uds.dev/pod-reload","true").Reconcile(Di);_(Z.a.ConfigMap).IsCreatedOrUpdated().WithLabel("uds.dev/pod-reload","true").Reconcile(_i);_(Z.a.ConfigMap).IsDeleted().WithLabel("uds.dev/pod-reload","true").Reconcile(Li);_(Z.a.ConfigMap).IsUpdated().InNamespace("istio-system").WithName("istio").Reconcile(Ya);var Pt=require("pepr");var un=P("operator.keycloak");async function _s(){if(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev"){await(0,Pt.K8s)(Pt.kind.Namespace).Apply({metadata:{name:bt}});try{await(0,Pt.K8s)(Pt.kind.Secret).InNamespace(bt).Get(Vt),un.info("Keycloak Clients Secret exists, skipping creation")}catch{un.info("Keycloak Clients Secret does not exist, creating it");try{await Fr({metadata:{namespace:bt,name:Vt},type:"Opaque"},!1)}catch(e){throw un.error(e,"Failed to create Keycloak Clients Secret"),e}}}}a(_s,"setupKeycloakClientSecret");var zr=require("kubernetes-fluent-client/dist/fluent/shared-types"),Ls=require("pepr");var dn=P("operator.reconcilers");async function $s(){if(ge.init(),process.env.PEPR_WATCH_MODE==="false"||process.env.PEPR_MODE==="dev"){let e=(0,Ls.K8s)(ee).Watch(async(t,r)=>{dn.debug(`Processing package ${t.metadata?.name}, watch phase: ${r}`),vd(t,r)},it);dn.debug("Starting package watch..."),at(e,dn,"UDSPackage"),await e.start()}}a($s,"startPackageWatch");function vd(e,t){switch(t){case zr.WatchPhase.Added:case zr.WatchPhase.Modified:ge.add(e);break;case zr.WatchPhase.Deleted:ge.remove(e);break}}a(vd,"processPackages");var wt=require("pepr");var Us={name:"v1alpha1",served:!0,storage:!0,schema:{openAPIV3Schema:{type:"object",properties:{spec:{type:"object",required:["exemptions"],properties:{exemptions:{type:"array",minItems:1,description:"Policy exemptions",items:{type:"object",required:["policies","matcher"],properties:{title:{type:"string",description:"title to give the exemption for reporting purposes"},description:{type:"string",description:"Reasons as to why this exemption is needed"},policies:{description:"A list of policies to override",type:"array",items:{type:"string",enum:["DisallowHostNamespaces","DisallowNodePortServices","DisallowPrivileged","DisallowSELinuxOptions","DropAllCapabilities","RequireNonRootUser","RestrictCapabilities","RestrictExternalNames","RestrictHostPathWrite","RestrictHostPorts","RestrictIstioAmbientOverrides","RestrictIstioSidecarOverrides","RestrictIstioTrafficOverrides","RestrictIstioUser","RestrictProcMount","RestrictSeccomp","RestrictSELinuxType","RestrictVolumeTypes"]}},matcher:{description:"Resource to exempt (Regex allowed for name)",type:"object",required:["namespace","name"],properties:{namespace:{type:"string"},name:{type:"string"},kind:{type:"string",enum:["pod","service"],default:"pod"}}}}}}}}}}}};var Fs=[{required:["exact"]},{required:["prefix"]},{required:["regex"]}],Yr={oneOf:[{not:{anyOf:Fs}},...Fs],properties:{exact:{type:"string"},prefix:{type:"string"},regex:{description:"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",type:"string"}},type:"object"},mn={description:"Advanced HTTP settings for the route.",properties:{corsPolicy:{description:"Cross-Origin Resource Sharing policy (CORS).",properties:{allowCredentials:{description:"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.",nullable:!0,type:"boolean"},allowHeaders:{description:"List of HTTP headers that can be used when requesting the resource.",items:{type:"string"},type:"array"},allowMethods:{description:"List of HTTP methods allowed to access the resource.",items:{type:"string"},type:"array"},allowOrigin:{items:{type:"string"},type:"array"},allowOrigins:{description:"String patterns that match allowed origins.",items:Yr,type:"array"},exposeHeaders:{description:"A list of HTTP headers that the browsers are allowed to access.",items:{type:"string"},type:"array"},maxAge:{description:"Specifies how long the results of a preflight request can be cached.",type:"string"}},type:"object"},directResponse:{description:"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.",properties:{body:{description:"Specifies the content of the response body.",oneOf:[{not:{anyOf:[{required:["string"]},{required:["bytes"]}]}},{required:["string"]},{required:["bytes"]}],properties:{bytes:{description:"response body as base64 encoded bytes.",format:"binary",type:"string"},string:{type:"string"}},type:"object"},status:{description:"Specifies the HTTP response status to be returned.",type:"integer"}},required:["status"],type:"object"},headers:{properties:{request:{properties:{add:{additionalProperties:{type:"string"},type:"object"},remove:{items:{type:"string"},type:"array"},set:{additionalProperties:{type:"string"},type:"object"}},type:"object"},response:{properties:{add:{additionalProperties:{type:"string"},type:"object"},remove:{items:{type:"string"},type:"array"},set:{additionalProperties:{type:"string"},type:"object"}},type:"object"}},type:"object"},match:{description:"Match the incoming request based on custom rules. Not permitted when using the passthrough gateway.",items:{properties:{ignoreUriCase:{description:"Flag to specify whether the URI matching should be case-insensitive.",type:"boolean"},method:Yr,name:{description:"The name assigned to a match.",type:"string"},queryParams:{additionalProperties:Yr,description:"Query parameters for matching.",type:"object"},uri:Yr},required:["name"],type:"object"},type:"array"},rewrite:{description:"Rewrite HTTP URIs and Authority headers.",properties:{authority:{description:"rewrite the Authority/Host header with this value.",type:"string"},uri:{description:"rewrite the path (or the prefix) portion of the URI with this value.",type:"string"},uriRegexRewrite:{description:"rewrite the path portion of the URI with the specified regex.",properties:{match:{description:"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).",type:"string"},rewrite:{description:"The string that should replace into matching portions of original URI.",type:"string"}},type:"object"}},type:"object"},redirect:{description:"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.",oneOf:[{not:{anyOf:[{required:["port"]},{required:["derivePort"]}]}},{required:["port"]},{required:["derivePort"]}],properties:{authority:{description:"On a redirect, overwrite the Authority/Host portion of the URL with this value.",type:"string"},port:{description:"On a redirect, overwrite the port portion of the URL with this value.",maximum:4294967295,minimum:0,type:"integer"},derivePort:{description:`On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.

Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT`,enum:["FROM_PROTOCOL_DEFAULT","FROM_REQUEST_PORT"],type:"string"},redirectCode:{description:"On a redirect, Specifies the HTTP status code to use in the redirect response.",maximum:4294967295,minimum:0,type:"integer"},scheme:{description:"On a redirect, overwrite the scheme portion of the URL with this value.",type:"string"},uri:{description:"On a redirect, overwrite the Path portion of the URL with this value.",type:"string"}},type:"object"},retries:{description:"Retry policy for HTTP requests.",properties:{attempts:{description:"Number of retries to be allowed for a given request.",format:"int32",type:"integer"},perTryTimeout:{description:"Timeout per attempt for a given request, including the initial call and any retries.",type:"string"},retryOn:{description:"Specifies the conditions under which retry takes place.",type:"string"},retryRemoteLocalities:{description:"Flag to specify whether the retries should retry to other localities.",nullable:!0,type:"boolean"}},type:"object"},weight:{description:"Weight specifies the relative proportion of traffic to be forwarded to the destination.",format:"int32",type:"integer"},timeout:{description:"Timeout for HTTP requests, default is disabled.",type:"string"}},type:"object"};var Cd={description:"Authorization settings.",type:"object",properties:{credentials:{description:"Selects a key of a Secret in the namespace that contains the credentials for authentication.",type:"object",properties:{key:{description:"The key of the secret to select from. Must be a valid secret key.",type:"string"},name:{description:"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",type:"string"},optional:{description:"Specify whether the Secret or its key must be defined",type:"boolean"}},required:["key"]},type:{description:'Defines the authentication type. The value is case-insensitive. "Basic" is not a supported value. Default: "Bearer"',type:"string"}},required:["credentials"]},Ad={description:"Allow specific traffic (namespace will have a default-deny policy)",type:"array",items:{type:"object",required:["direction"],properties:{labels:{description:"The labels to apply to the policy",type:"object",additionalProperties:{type:"string"}},description:{type:"string",description:"A description of the policy, this will become part of the policy name"},direction:{description:"The direction of the traffic",enum:["Ingress","Egress"],type:"string"},selector:{description:"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace",type:"object",additionalProperties:{type:"string"}},remoteNamespace:{description:"The remote namespace to allow traffic to/from. Use * or empty string to allow all namespaces",type:"string"},remoteSelector:{description:"The remote pod selector labels to allow traffic to/from",type:"object",additionalProperties:{type:"string"}},remoteGenerated:{description:"Custom generated remote selector for the policy",type:"string",enum:["KubeAPI","KubeNodes","IntraNamespace","CloudMetadata","Anywhere"]},remoteCidr:{description:"Custom generated policy CIDR",type:"string"},remoteHost:{description:"Remote host to allow traffic out to",type:"string"},remoteProtocol:{description:"Protocol used for external connection",type:"string",enum:["TLS","HTTP"]},port:{description:"The port to allow (protocol is always TCP)",minimum:1,maximum:65535,type:"number"},ports:{description:"A list of ports to allow (protocol is always TCP)",type:"array",items:{minimum:1,maximum:65535,type:"number"}},remoteServiceAccount:{description:"The remote service account to restrict incoming traffic from within the remote namespace.           Only valid for Ingress rules.",type:"string"},serviceAccount:{description:"The service account to restrict outgoing traffic from within the package namespace.           Only valid for Egress rules.",type:"string"},podLabels:{description:"Deprecated: use selector",type:"object",additionalProperties:{type:"string"}},remotePodLabels:{description:"Deprecated: use remoteSelector",type:"object",additionalProperties:{type:"string"}}}}},Rd={type:"array",description:"Expose a service on an Istio Gateway",items:{type:"object",required:["host"],anyOf:[{required:["service","podLabels","port"]},{required:["service","selector","port"]},{required:["advancedHTTP"]}],properties:{description:{type:"string",description:"A description of this expose entry, this will become part of the VirtualService name"},host:{description:"The hostname to expose the service on",type:"string"},gateway:{description:"The name of the gateway to expose the service on (default: tenant)",type:"string",default:"tenant"},domain:{description:"The domain to expose the service on, only valid for additional gateways (not tenant, admin, or passthrough)",type:"string"},service:{description:"The name of the service to expose",type:"string"},port:{description:"The port number to expose",minimum:1,maximum:65535,type:"number"},selector:{description:"Selector for Pods targeted by the selected Services (so the NetworkPolicy can be generated correctly).",type:"object",additionalProperties:{type:"string"}},targetPort:{description:"The service targetPort. This defaults to port and is only required if the service port is different from the target port (so the NetworkPolicy can be generated correctly).",minimum:1,maximum:65535,type:"number"},advancedHTTP:mn,match:{description:"Deprecated: use advancedHTTP.match",...mn.properties?.match},podLabels:{description:"Deprecated: use selector",type:"object",additionalProperties:{type:"string"}}}}},Ed={description:"Service Mesh configuration for the package",type:"object",properties:{mode:{type:"string",enum:["sidecar","ambient"],default:"sidecar",description:"Set the service mesh mode for this package (namespace), defaults to sidecar"}}},kd={description:"Create Service or Pod Monitor configurations",type:"array",items:{type:"object",required:["portName","selector","targetPort"],properties:{description:{type:"string",description:"A description of this monitor entry, this will become part of the ServiceMonitor name"},portName:{description:"The port name for the serviceMonitor",type:"string"},targetPort:{description:"The service targetPort. This is required so the NetworkPolicy can be generated correctly.",minimum:1,maximum:65535,type:"number"},selector:{description:"Selector for Services that expose metrics to scrape",type:"object",additionalProperties:{type:"string"}},podSelector:{description:"Selector for Pods targeted by the selected Services (so the NetworkPolicy can be generated correctly). Defaults to `selector` when not specified.",type:"object",additionalProperties:{type:"string"}},path:{description:"HTTP path from which to scrape for metrics, defaults to `/metrics`",type:"string"},kind:{description:"The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the default.",enum:["PodMonitor","ServiceMonitor"],type:"string"},fallbackScrapeProtocol:{description:"The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise invalid Content-Type",enum:["OpenMetricsText0.0.1","OpenMetricsText1.0.0","PrometheusProto","PrometheusText0.0.4","PrometheusText1.0.0"],type:"string"},authorization:Cd}}},Td={description:"Create SSO client configurations",type:"array",items:{type:"object",required:["clientId","name"],properties:{enableAuthserviceSelector:{description:"Labels to match pods to automatically protect with authservice. Leave empty to disable authservice protection",type:"object",additionalProperties:{type:"string"}},secretName:{description:"The name of the secret to store the client secret",type:"string"},secretLabels:{description:"Additional labels to apply to the generated secret, can be used for pod reloading",type:"object",additionalProperties:{type:"string"}},secretAnnotations:{description:"Additional annotations to apply to the generated secret, can be used for pod reloading with a selector",type:"object",additionalProperties:{type:"string"}},secretTemplate:{description:"A template for the generated secret",type:"object",additionalProperties:{type:"string"}},clientId:{description:"The client identifier registered with the identity provider.",type:"string"},secret:{description:"The client secret. Typically left blank and auto-generated.",type:"string"},name:{description:"Specifies display name of the client",type:"string"},description:{description:"A description for the client, can be a URL to an image to replace the login logo",type:"string"},baseUrl:{description:"Default URL to use when the auth server needs to redirect or link back to the client.",type:"string"},adminUrl:{description:"This URL will be used for every binding to both the SP's Assertion Consumer and Single Logout Services.",type:"string"},protocol:{description:"Specifies the protocol of the client, either 'openid-connect' or 'saml'",type:"string",enum:["openid-connect","saml"]},attributes:{description:"Specifies attributes for the client.",type:"object",additionalProperties:{type:"string"}},protocolMappers:{description:"Protocol Mappers to configure on the client",type:"array",default:[],items:{type:"object",required:["name","protocol","protocolMapper"],properties:{name:{description:"Name of the mapper",type:"string"},protocol:{description:"Protocol of the mapper",type:"string",enum:["openid-connect","saml"]},protocolMapper:{description:"Protocol Mapper type of the mapper",type:"string"},consentRequired:{description:"Whether user consent is required for this mapper",type:"boolean",default:!1},config:{description:"Configuration options for the mapper.",type:"object",additionalProperties:{type:"string"}}}}},rootUrl:{description:"Root URL appended to relative URLs",type:"string"},redirectUris:{description:"Valid URI pattern a browser can redirect to after a successful login. Simple wildcards are allowed such as 'https://unicorns.uds.dev/*'",type:"array",items:{type:"string"},minItems:1},webOrigins:{description:"Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.",type:"array",items:{type:"string"}},enabled:{description:"Whether the SSO client is enabled",type:"boolean",default:!0},alwaysDisplayInConsole:{description:"Always list this client in the Account UI, even if the user does not have an active session.",type:"boolean",default:!1},standardFlowEnabled:{description:"Enables the standard OpenID Connect redirect based authentication with authorization code.",type:"boolean",default:!0},serviceAccountsEnabled:{description:"Enables the client credentials grant based authentication via OpenID Connect protocol.",type:"boolean",default:!1},publicClient:{description:"Defines whether the client requires a client secret for authentication",type:"boolean",default:!1},clientAuthenticatorType:{description:"The client authenticator type",type:"string",enum:["client-secret","client-jwt"]},defaultClientScopes:{description:"Default client scopes",type:"array",items:{type:"string"}},groups:{description:"The client SSO group type",type:"object",properties:{anyOf:{description:"List of groups allowed to access the client",type:"array",items:{type:"string"}}}}}}},Id={description:"CA bundle configuration for the package",type:"object",properties:{configMap:{description:"ConfigMap configuration for CA bundle",type:"object",properties:{name:{description:"The name of the ConfigMap to create (default: uds-trust-bundle)",type:"string",default:"uds-trust-bundle"},key:{description:"The key name inside the ConfigMap (default: ca-bundle.pem)",type:"string",default:"ca-bundle.pem"},labels:{description:"Additional labels to apply to the generated ConfigMap (default: {})",type:"object",additionalProperties:{type:"string"},default:{}},annotations:{description:"Additional annotations to apply to the generated ConfigMap (default: {})",type:"object",additionalProperties:{type:"string"},default:{}}}}}},Hs={name:"v1alpha1",served:!0,storage:!0,additionalPrinterColumns:[{name:"Status",type:"string",description:"The status of the package",jsonPath:".status.phase"},{name:"SSO Clients",type:"string",description:"SSO Clients created by the package",jsonPath:".status.ssoClients"},{name:"Endpoints",type:"string",description:"Service endpoints exposed by the package",jsonPath:".status.endpoints"},{name:"Monitors",type:"string",description:"Service monitors for the package",jsonPath:".status.monitors"},{name:"Network Policies",type:"integer",description:"The number of network policies created by the package",jsonPath:".status.networkPolicyCount"},{name:"Authorization Policies",type:"integer",description:"The number of authorization policies created by the package",jsonPath:".status.authorizationPolicyCount"},{name:"Age",type:"date",description:"The age of the package",jsonPath:".metadata.creationTimestamp"}],subresources:{status:{}},schema:{openAPIV3Schema:{type:"object",properties:{status:{type:"object",properties:{observedGeneration:{type:"integer"},conditions:{description:"Status conditions following Kubernetes-style conventions",type:"array",items:{type:"object",required:["type","status","lastTransitionTime","reason","message"],properties:{type:{description:"Type of condition in CamelCase or in foo.example.com/CamelCase format",type:"string"},status:{description:"Status of the condition, one of True, False, Unknown",type:"string",enum:["True","False","Unknown"]},observedGeneration:{description:"Represents the .metadata.generation that the condition was set based upon",type:"integer"},lastTransitionTime:{description:"The last time the condition transitioned from one status to another",type:"string",format:"date-time"},reason:{description:"A programmatic identifier indicating the reason for the condition's last transition",type:"string"},message:{description:"A human-readable message indicating details about the transition",type:"string"}}}},phase:{enum:["Pending","Ready","Failed","Retrying","Removing","RemovalFailed"],type:"string"},ssoClients:{type:"array",items:{type:"string"}},authserviceClients:{type:"array",items:{type:"object",required:["clientId"],properties:{clientId:{type:"string"},selector:{type:"object",additionalProperties:{type:"string"}}}}},meshMode:{type:"string",enum:["ambient","sidecar"],description:"The current service mesh mode for this package"},endpoints:{type:"array",items:{type:"string"}},monitors:{type:"array",items:{type:"string"}},networkPolicyCount:{type:"integer"},authorizationPolicyCount:{type:"integer"},retryAttempt:{type:"integer",nullable:!0}}},spec:{type:"object",properties:{network:{type:"object",description:"Network configuration for the package",properties:{expose:Rd,allow:Ad,serviceMesh:Ed}},monitor:kd,sso:Td,caBundle:Id}}}}}};var qr=P("operator.crd");async function Vs(){(process.env.PEPR_WATCH_MODE==="true"||process.env.PEPR_MODE==="dev")&&await(0,wt.K8s)(wt.kind.CustomResourceDefinition).Apply({apiVersion:"apiextensions.k8s.io/v1",kind:"CustomResourceDefinition",metadata:{name:"packages.uds.dev"},spec:{group:"uds.dev",versions:[Hs],scope:"Namespaced",names:{plural:"packages",singular:"package",kind:"Package",shortNames:["pkg"]}}},{force:!0}).then(()=>{qr.info("Package CRD registered")}).catch(e=>{qr.error({err:e},"Failed to register Package CRD"),process.exit(1)}),(process.env.PEPR_WATCH_MODE==="false"||process.env.PEPR_MODE==="dev")&&await(0,wt.K8s)(wt.kind.CustomResourceDefinition).Apply({apiVersion:"apiextensions.k8s.io/v1",kind:"CustomResourceDefinition",metadata:{name:"exemptions.uds.dev"},spec:{group:"uds.dev",versions:[Us],scope:"Namespaced",names:{plural:"exemptions",singular:"exemption",kind:"Exemption",shortNames:["exempt"]}}},{force:!0}).then(()=>{qr.info("Exemption CRD registered")}).catch(e=>{qr.error({err:e},"Failed to register Exemption CRD"),process.exit(1)})}a(Vs,"registerCRDs");var js=require("pepr"),Ks=new js.Capability({name:"patches",description:"UDS Core Capability for patching miscellaneous things."});var Xs=require("pepr");var fn=P("operator.exemptions"),Jr,Qr;function Od(){Jr=new Map,Qr=new Map;for(let e of Object.values(xe))Jr.set(e,[])}a(Od,"init");function gn(e){return Jr.get(e)||[]}a(gn,"getByPolicy");function Nd(e,t){Jr.set(e,t)}a(Nd,"setByPolicy");function Md(e,t,r=""){let o={...e,owner:r};gn(t).push(o)}a(Md,"addMatcher");function Dd(e,t=!0){Gs(e);let r=e.metadata?.uid||"";Qr.set(r,e);for(let o of e.spec?.exemptions??[]){let n=o.policies??[];for(let s of n)Md(o.matcher,s,r),t&&fn.debug(`Added exemption to ${s}: ${JSON.stringify(o.matcher)}`)}}a(Dd,"add");function Gs(e){let t=e.metadata?.uid||"",r=Qr.get(t);if(r){for(let o of r.spec?.exemptions??[]){let n=o.policies??[];for(let s of n){let c=gn(s).filter(l=>l.owner!==t);Nd(s,c)}}Qr.delete(t),fn.debug(`Removed all policy exemptions for ${t}`)}else fn.debug(`No existing exemption for owner ${t}`)}a(Gs,"remove");var rt={init:Od,add:Dd,remove:Gs,getByPolicy:gn};var Xr=require("kubernetes-fluent-client/dist/fluent/shared-types");function Bs(e,t){switch(t){case Xr.WatchPhase.Added:case Xr.WatchPhase.Modified:rt.add(e);break;case Xr.WatchPhase.Deleted:rt.remove(e);break}}a(Bs,"processExemptions");var ot=require("pepr");var Zr=require("pepr");var{containers:_d}=Zr.sdk,eo=new Zr.Capability({name:"uds-core-policies",description:"Collection of core validation policies for Pods, ConfigMaps, and other Kubernetes resources."}),{When:N}=eo,Ws=P("policies"),Ld=process.env.ZARF_REGISTRY_ADDRESS||"127.0.0.1:31999",$d={upstream:{registry:"docker.io",repository:"istio/proxyv2"},registry1:{registry:"registry1.dso.mil",repository:"ironbank/tetrate/istio/proxyv2"},unicorn:{registry:"quay.io",repository:"rfcurated/istio/proxyv2"}};function Ud(e){if(!e)return null;try{let t=e.trim();if(t==="")return null;let r=t.replace(/[@:][^/]+$/,""),o=r.split("/"),n=o[0],s=n.includes(".")||n.includes(":")||n==="localhost",i,c;if(s){if(i=n,c=o.slice(1).join("/"),!c)return null}else i="docker.io",c=r;return{registry:i,repository:c}}catch(t){return Ws.error(`Error parsing image reference '${e}':`,t),null}}a(Ud,"parseImageRef");function zs(e){try{let t=Ud(e);if(!t)return!1;let{registry:r,repository:o}=t;for(let n of Object.values($d))if(n.repository===o)return r===n.registry||r===Ld;return!1}catch(t){return Ws.error(`Error validating image ${e}:`,t),!1}}a(zs,"validateIstioImage");function hn(e){return e.Raw.spec?.volumes||[]}a(hn,"volumes");function De(e,t=!1){return _d(e).filter(r=>r.securityContext).filter(r=>!t||!Fd(e,r)).map(r=>({name:r.name,ctx:r.securityContext}))}a(De,"securityContextContainers");function _e(e,t,r){let o=r.map(s=>JSON.stringify(s)).join(" | "),n=t.filter(s=>s).join(" | ");return`${e}. Authorized: [${n}] Found: ${o}`}a(_e,"securityContextMessage");function Fd(e,t){return!e.HasAnnotation("sidecar.istio.io/status")||!e.Raw.spec?.initContainers?.some(n=>to(n))||!t.image?!1:t.name==="istio-init"&&t.args?.[0]==="istio-iptables"&&t.command===void 0&&zs(t.image)}a(Fd,"isIstioInitContainer");function to(e){return!e.image||!(e?.name==="istio-proxy"&&e.ports?.some(r=>r.name==="http-envoy-prom")&&e.args?.[0]==="proxy"&&e.command===void 0)?!1:zs(e.image)}a(to,"isIstioProxyContainer");function Hd(e){return e.split(/(?=[A-Z])/).join("-").toLowerCase()}a(Hd,"transform");function ro(e,t){let r="uds-core.pepr.dev/mutated",n=(e.Raw.metadata?.annotations??{})[r],s=JSON.parse(n||"[]"),i=Hd(t);s.includes(i)||s.push(i),e.SetAnnotation(r,JSON.stringify(s))}a(ro,"annotateMutation");var Ys=P("policies.exemptions");function T(e,t){let r=rt.getByPolicy(t),o=e.Raw.metadata?.name||e.Raw.metadata?.generateName,n=e.Raw.metadata?.namespace;if(r.length!==0){Ys.debug(`Checking ${o} against ${t} exemptions: ${JSON.stringify(r)}`);for(let s of r)if(s.namespace===n&&o?.match(s.name))return Ys.info(`${o} is exempt from ${t}`),!0}return!1}a(T,"isExempt");var Wt="uds-core.pepr.dev/uds-core-policies";function M(e){return t=>{if(T(t,e)){t.SetAnnotation(`${Wt}.${e}`,"exempted");return}}}a(M,"markExemption");var{containers:qs}=ot.sdk;N(ot.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictIstioSidecarOverrides")).Validate(e=>{if(T(e,"RestrictIstioSidecarOverrides"))return e.Approve();let t=Vd(e.Raw);return t.length>0?e.Deny(`The following istio annotations can modify secure sidecar configuration and are not allowed: ${t.join(", ")}`):e.Approve()});function Vd(e){let t=["sidecar.istio.io/bootstrapOverride","sidecar.istio.io/discoveryAddress","sidecar.istio.io/proxyImage","proxy.istio.io/config","sidecar.istio.io/userVolume","sidecar.istio.io/userVolumeMount"],r=e.metadata?.annotations||{};return Object.keys(r).filter(o=>t.includes(o)).sort((o,n)=>o.localeCompare(n))}a(Vd,"checkIstioSidecarOverrides");N(ot.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictIstioTrafficOverrides")).Validate(e=>{if(T(e,"RestrictIstioTrafficOverrides"))return e.Approve();let t=qs(e),r=jd(t,e.Raw);return r.length>0?e.Deny(`The following istio annotations or labels can modify secure traffic interception are not allowed: ${r.join(", ")}`):e.Approve()});function jd(e,t){let r=t.metadata?.namespace||"default",o=t.metadata?.annotations||{},n=t.metadata?.labels||{},s=["sidecar.istio.io/inject","traffic.sidecar.istio.io/excludeInboundPorts","traffic.sidecar.istio.io/excludeInterfaces","traffic.sidecar.istio.io/excludeOutboundIPRanges","traffic.sidecar.istio.io/excludeOutboundPorts","traffic.sidecar.istio.io/includeInboundPorts","traffic.sidecar.istio.io/includeOutboundIPRanges","traffic.sidecar.istio.io/includeOutboundPorts","sidecar.istio.io/interceptionMode","traffic.sidecar.istio.io/kubevirtInterfaces","istio.io/redirect-virtual-interfaces"],i=["sidecar.istio.io/inject"],c=Object.entries(o).filter(([u])=>u==="sidecar.istio.io/inject"&&r==="istio-system"||u==="sidecar.istio.io/inject"&&o[u].trim()==="true"?!1:s.includes(u)).map(([u])=>`annotation ${u}`),l=!1;for(let u of e)if(to(u)&&u.args?.some(d=>d==="waypoint")){l=!0;break}let p=Object.entries(n).filter(([u,d])=>u==="sidecar.istio.io/inject"&&r==="istio-system"||u==="sidecar.istio.io/inject"&&d.trim()==="true"||u==="sidecar.istio.io/inject"&&l?!1:i.includes(u)).map(([u])=>`label ${u}`);return[...c,...p].sort((u,d)=>u.localeCompare(d))}a(jd,"checkIstioTrafficInterceptionOverrides");N(ot.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictIstioAmbientOverrides")).Validate(e=>{if(T(e,"RestrictIstioAmbientOverrides"))return e.Approve();let t=Kd(e.Raw);return t.length>0?e.Deny(`The following istio ambient annotations that can modify secure mesh behavior are not allowed: ${t.join(", ")}`):e.Approve()});function Kd(e){let t=e.metadata?.annotations||{},r=["ambient.istio.io/bypass-inbound-capture"];return Object.keys(t).filter(o=>r.includes(o)).sort((o,n)=>o.localeCompare(n))}a(Kd,"checkIstioAmbientOverrides");N(ot.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictIstioUser")).Validate(e=>{if(T(e,"RestrictIstioUser"))return e.Approve();if(Gd(e.Raw))return e.Deny("Pods cannot use UID/GID 1337 (Istio proxy) unless they are trusted Istio components");let t=qs(e),r=Bd(t);return r?e.Deny(`Container '${r}' cannot use UID/GID 1337 (Istio proxy) as it is not a trusted Istio component`):e.Approve()});function Gd(e){let t=e.spec?.securityContext||{};return!!(t.runAsUser===1337||t.runAsGroup===1337||t.fsGroup===1337||t.supplementalGroups?.includes(1337))}a(Gd,"isPodUsingIstioUserID");function Bd(e){for(let t of e)if(!to(t)){let o=t.securityContext||{};if(o.runAsUser===1337||o.runAsGroup===1337)return t.name}}a(Bd,"findContainerUsingIstioUserID");var nt=require("pepr");var{containers:Wd}=nt.sdk;N(nt.a.Pod).IsCreatedOrUpdated().Mutate(M("DisallowHostNamespaces")).Validate(e=>{if(T(e,"DisallowHostNamespaces"))return e.Approve();let t=e.Raw.spec;return zd(t)?e.Approve():e.Deny("Sharing the host namespaces is disallowed. The fields spec.hostNetwork, spec.hostIPC, and spec.hostPID must not be set to true.")});function zd(e){return!(e.hostNetwork||e.hostIPC||e.hostPID)}a(zd,"checkNoHostNamespaces");N(nt.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictHostPorts")).Validate(e=>{if(T(e,"RestrictHostPorts"))return e.Approve();let t=Wd(e);return Yd(t)?e.Approve():e.Deny("Host ports are not allowed.")});function Yd(e){return!e.flatMap(r=>r.ports||[]).find(r=>r.hostPort)}a(Yd,"checkNoHostPorts");N(nt.a.Service).IsCreatedOrUpdated().Mutate(M("RestrictExternalNames")).Validate(e=>T(e,"RestrictExternalNames")||qd(e.Raw.spec)?e.Approve():e.Deny("ExternalName services are not allowed."));function qd(e){return e?.type!=="ExternalName"}a(qd,"checkNotExternalNameService");N(nt.a.Service).IsCreatedOrUpdated().Mutate(M("DisallowNodePortServices")).Validate(e=>T(e,"DisallowNodePortServices")||Jd(e.Raw.spec)?e.Approve():e.Deny("NodePort services are not allowed."));function Jd(e){return e?.type!=="NodePort"}a(Jd,"checkNotNodePortService");var be=require("pepr");var{containers:Qs}=be.sdk;N(be.a.Pod).IsCreatedOrUpdated().Mutate(e=>{M("DisallowPrivileged")(e),!e.HasAnnotation(`${Wt}.DisallowPrivileged`)&&Qd(Qs(e))&&ro(e,"DisallowPrivileged")}).Validate(e=>{if(T(e,"DisallowPrivileged"))return e.Approve();let t=Xd(De(e));return t.length?e.Deny(_e("Privilege escalation is disallowed",["allowPrivilegeEscalation = false","privileged = false"],t)):e.Approve()});function Qd(e){let t=!1;for(let r of e)r.securityContext=r.securityContext||{},[r.securityContext.allowPrivilegeEscalation===void 0,!r.securityContext.privileged,!r.securityContext.capabilities?.add?.includes("CAP_SYS_ADMIN")].every(Boolean)&&(r.securityContext.allowPrivilegeEscalation=!1,t=!0);return t}a(Qd,"setPrivilegeEscalation");function Xd(e){return e.filter(t=>(t.ctx.allowPrivilegeEscalation??!0)||t.ctx.privileged)}a(Xd,"validatePrivilegeEscalation");N(be.a.Pod).IsCreatedOrUpdated().Mutate(e=>{M("RequireNonRootUser")(e),!e.HasAnnotation(`${Wt}.RequireNonRootUser`)&&(Zd(e.Raw.spec,e.Raw.metadata),ro(e,"RequireNonRootUser"))}).Validate(e=>{if(T(e,"RequireNonRootUser"))return e.Approve();let t=e.Raw.spec?.securityContext||{};if(Js(t))return e.Deny("Pod level securityContext does not meet the non-root user requirement.");let r=De(e,!0).filter(o=>Js(o.ctx));return r.length?e.Deny(_e("Unauthorized container securityContext. Containers must not run as root or have root-level supplemental groups",["runAsNonRoot = true","runAsUser > 0","supplementalGroups must not include 0"],r)):e.Approve()});function Zd(e,t){e.securityContext=e.securityContext||{};let r=t.labels?.["uds/user"];r&&(e.securityContext.runAsUser=parseInt(r));let o=t.labels?.["uds/group"];o&&(e.securityContext.runAsGroup=parseInt(o));let n=t.labels?.["uds/fsgroup"];n&&(e.securityContext.fsGroup=parseInt(n)),e.securityContext.runAsNonRoot===void 0&&(e.securityContext.runAsNonRoot=!0),e.securityContext.runAsUser===void 0&&(e.securityContext.runAsUser=1e3),e.securityContext.runAsGroup===void 0&&(e.securityContext.runAsGroup=1e3)}a(Zd,"setNonRootUserSettings");function Js(e){let t=e.runAsNonRoot===!1,r=e.runAsUser===0,o=!!e.supplementalGroups?.includes(0);return t||r||o}a(Js,"isRootSecurityContext");N(be.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictProcMount")).Validate(e=>{if(T(e,"RestrictProcMount"))return e.Approve();let t=[void 0,"Default"],{violations:r}=em(De(e),t);return r.length?e.Deny(_e("Unauthorized procMount type",t,r)):e.Approve()});function em(e,t){return{violations:e.filter(o=>o.ctx.procMount&&!t.includes(o.ctx.procMount)),isPodViolation:!1}}a(em,"validateProcMount");N(be.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictSeccomp")).Validate(e=>{if(T(e,"RestrictSeccomp"))return e.Approve();let t=[void 0,"RuntimeDefault","Localhost"],{violations:r,isPodViolation:o}=tm(e.Raw.spec?.securityContext,De(e),t);if(r.length){let n=o?"Unauthorized pod seccomp profile type":"Unauthorized container seccomp profile type";return e.Deny(_e(n,t,r))}return e.Approve()});function tm(e,t,r){let o=e?.seccompProfile?.type;return r.includes(o)?{violations:t.filter(s=>!r.includes(s.ctx.seccompProfile?.type)),isPodViolation:!1}:{violations:[{name:"pod",ctx:e||{}}],isPodViolation:!0}}a(tm,"validateSeccompProfile");N(be.a.Pod).IsCreatedOrUpdated().Mutate(M("DisallowSELinuxOptions")).Validate(e=>{if(T(e,"DisallowSELinuxOptions"))return e.Approve();let t=["user: undefined","role: undefined"],{violations:r,isPodViolation:o}=rm(e.Raw.spec?.securityContext,De(e));if(r.length){let n=o?"Unauthorized pod SELinux Options":"Unauthorized container SELinux Options";return e.Deny(_e(n,t,r))}return e.Approve()});function rm(e,t){let r=e?.seLinuxOptions;return r?.user||r?.role?{violations:[{name:"pod",ctx:e||{}}],isPodViolation:!0}:{violations:t.filter(n=>n.ctx.seLinuxOptions?.user||n.ctx.seLinuxOptions?.role),isPodViolation:!1}}a(rm,"validateSELinuxOptions");N(be.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictSELinuxType")).Validate(e=>{if(T(e,"RestrictSELinuxType"))return e.Approve();let t=[void 0,"container_t","container_init_t","container_kvm_t"],{violations:r,isPodViolation:o}=om(e.Raw.spec?.securityContext,De(e),t);if(r.length){let n=o?"Unauthorized pod SELinux type":"Unauthorized container SELinux type";return e.Deny(_e(n,t,r))}return e.Approve()});function om(e,t,r){let o=e?.seLinuxOptions?.type;return r.includes(o)?{violations:t.filter(s=>!r.includes(s.ctx.seLinuxOptions?.type)),isPodViolation:!1}:{violations:[{name:"pod",ctx:e||{}}],isPodViolation:!0}}a(om,"validateSELinuxTypes");N(be.a.Pod).IsCreatedOrUpdated().Mutate(e=>{M("DropAllCapabilities")(e),!e.HasAnnotation(`${Wt}.DropAllCapabilities`)&&(nm(Qs(e)),ro(e,"DropAllCapabilities"))}).Validate(e=>{if(T(e,"DropAllCapabilities"))return e.Approve();let t="ALL",r=im(De(e),t);return r.length?e.Deny(_e("Unauthorized container DROP capabilities in securityContext.capabilities.drop",[t],r)):e.Approve()});function nm(e){for(let t of e)t.securityContext=t.securityContext||{},t.securityContext.capabilities=t.securityContext.capabilities||{},t.securityContext.capabilities.drop=["ALL"]}a(nm,"setAllContainersDropAllCapabilities");function im(e,t){return e.filter(r=>!r.ctx.capabilities?.drop?.includes(t))}a(im,"findContainersWithoutDropAllCapability");N(be.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictCapabilities")).Validate(e=>{if(T(e,"RestrictCapabilities"))return e.Approve();let t=["NET_BIND_SERVICE"],r=De(e,!0),o=am(r,t);return o.length>0?e.Deny(_e("Unauthorized container capabilities in securityContext.capabilities.add",t,o)):e.Approve()});function am(e,t){return e.filter(r=>!!r.ctx?.capabilities?.add?.length).filter(r=>!r.ctx.capabilities.add.every(o=>t.includes(o))).map(r=>({name:r.name||"unnamed",ctx:{capabilities:{add:r.ctx.capabilities.add}}}))}a(am,"validateContainerCapabilities");var zt=require("pepr");var{containers:sm}=zt.sdk;N(zt.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictVolumeTypes")).Validate(e=>{if(T(e,"RestrictVolumeTypes"))return e.Approve();let[t,r]=cm(hn(e));return!t&&r?e.Deny(`Volume ${r.name} has a disallowed volume type of '${r.type}'.`):e.Approve()});function cm(e){let t=["configMap","csi","downwardAPI","emptyDir","ephemeral","persistentVolumeClaim","projected","secret"];for(let r of e){let o=Object.keys(r).find(n=>n!=="name")||"unknown";if(!t.includes(o))return[!1,{name:r.name,type:o}]}return[!0,null]}a(cm,"validateVolumeTypes");N(zt.a.Pod).IsCreatedOrUpdated().Mutate(M("RestrictHostPathWrite")).Validate(e=>{if(T(e,"RestrictHostPathWrite"))return e.Approve();let[t,r]=lm(hn(e),sm(e));return!t&&r?e.Deny(`hostPath volume '${r.name}' must be mounted as readOnly.`):e.Approve()});function lm(e,t){for(let r of e)if(r.hostPath&&t.flatMap(n=>n.volumeMounts||[]).filter(n=>n.name===r.name).some(n=>!n.readOnly))return[!1,{name:r.name}];return[!0,null]}a(lm,"validateHostPathVolumes");var yn=P("policies");async function Zs(){if(rt.init(),process.env.PEPR_WATCH_MODE==="false"||process.env.PEPR_MODE==="dev"){let e=(0,Xs.K8s)(Le).Watch(async(t,r)=>{yn.debug(`Processing exemption ${t.metadata?.name}, watch phase: ${r}`),Bs(t,r)},it);yn.debug("Starting exemption watch..."),at(e,yn,"UDSExemption"),await e.start()}}a(Zs,"startExemptionWatch");var ec=require("pepr");var tc=P("prometheus"),bn=new ec.Capability({name:"prometheus",description:"UDS Core Capability for the Prometheus stack."}),{When:rc}=bn;async function pm(e){e.Raw.spec.fallbackScrapeProtocol||(e.Raw.spec.fallbackScrapeProtocol="PrometheusText0.0.4",tc.info(`Set fallbackScrapeProtocol for ServiceMonitor ${e.Raw.metadata?.name}`))}a(pm,"mutateServiceMonitor");rc(Ee).IsCreatedOrUpdated().Mutate(async e=>await pm(e));async function um(e){e.Raw.spec.fallbackScrapeProtocol||(e.Raw.spec.fallbackScrapeProtocol="PrometheusText0.0.4",tc.info(`Set fallbackScrapeProtocol for PodMonitor ${e.Raw.metadata?.name}`))}a(um,"mutatePodMonitor");rc(Re).IsCreatedOrUpdated().Mutate(async e=>await um(e));var dm=P("startup");(async()=>{await xi(),await Vs(),await Si(),await Zs(),await $s(),await Rr(),await Sr(),await si(),await _s(),new oc.PeprModule(xn,[Yt,eo,bn,Ks])})().catch(e=>{dm.error(e,"Critical error during startup. Exiting..."),process.exit(1)});
//# sourceMappingURL=pepr-uds-core.js.map
