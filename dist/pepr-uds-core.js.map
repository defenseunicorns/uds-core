{
  "version": 3,
  "sources": ["../pepr.ts", "../package.json", "../src/pepr/logger.ts", "../src/pepr/operator/index.ts", "../src/pepr/operator/common.ts", "../src/pepr/operator/controllers/network/generators/kubeAPI.ts", "../src/pepr/operator/crd/generated/package-v1alpha1.ts", "../src/pepr/operator/crd/generated/exemption-v1alpha1.ts", "../src/pepr/operator/crd/generated/clusterconfig-v1alpha1.ts", "../src/pepr/operator/crd/generated/istio/virtualservice-v1beta1.ts", "../src/pepr/operator/crd/generated/istio/serviceentry-v1beta1.ts", "../src/pepr/operator/crd/generated/prometheus/podmonitor-v1.ts", "../src/pepr/operator/crd/generated/prometheus/servicemonitor-v1.ts", "../src/pepr/operator/crd/generated/istio/authorizationpolicy-v1beta1.ts", "../src/pepr/operator/crd/generated/istio/requestauthentication-v1.ts", "../src/pepr/operator/crd/generated/istio/destinationrule-v1.ts", "../src/pepr/operator/crd/generated/istio/gateway-v1.ts", "../src/pepr/operator/crd/generated/istio/sidecar-v1.ts", "../src/pepr/operator/crd/generated/k8s/gateway-v1.ts", "../src/pepr/operator/crd/index.ts", "../src/pepr/operator/controllers/config/config.ts", "../src/pepr/operator/crd/validators/clusterconfig-validator.ts", "../src/pepr/operator/controllers/utils.ts", "../src/pepr/operator/controllers/ca-bundles/ca-bundle.ts", "../src/pepr/operator/controllers/keycloak/authservice/authservice.ts", "../src/pepr/operator/controllers/istio/ambient-waypoint.ts", "../src/pepr/operator/controllers/packages/package-store.ts", "../src/pepr/operator/controllers/istio/egress-ambient.ts", "../src/pepr/operator/controllers/istio/auth-policy.ts", "../src/pepr/operator/controllers/istio/egress-sidecar.ts", "../src/pepr/operator/controllers/istio/gateway.ts", "../src/pepr/operator/controllers/istio/istio-resources.ts", "../src/pepr/operator/controllers/istio/service-entry.ts", "../src/pepr/operator/controllers/istio/virtual-service.ts", "../src/pepr/operator/controllers/istio/sidecar.ts", "../src/pepr/operator/controllers/istio/egress.ts", "../src/pepr/operator/controllers/istio/waypoint-utils.ts", "../src/pepr/operator/controllers/keycloak/authservice/authorization-policy.ts", "../src/pepr/operator/controllers/keycloak/authservice/config.ts", "../src/pepr/operator/controllers/network/generators/kubeNodes.ts", "../src/pepr/operator/controllers/network/generators/cloudMetadata.ts", "../src/pepr/operator/controllers/network/generators/anywhere.ts", "../src/pepr/operator/controllers/reload/pod-reload.ts", "../src/pepr/operator/controllers/reload/reload-utils.ts", "../src/pepr/operator/controllers/monitoring/common.ts", "../src/pepr/operator/controllers/network/generators/intraNamespace.ts", "../src/pepr/operator/controllers/network/generators/remoteCidr.ts", "../src/pepr/operator/controllers/network/generators/egress.ts", "../src/pepr/operator/controllers/network/generate.ts", "../src/pepr/operator/crd/migrate.ts", "../src/pepr/operator/crd/validators/package-validator.ts", "../node_modules/js-yaml/dist/js-yaml.mjs", "../src/pepr/operator/controllers/istio/istio-configmap-sync.ts", "../src/pepr/operator/controllers/keycloak/client-secret-sync.ts", "../node_modules/uuid/dist-node/stringify.js", "../node_modules/uuid/dist-node/rng.js", "../node_modules/uuid/dist-node/native.js", "../node_modules/uuid/dist-node/v4.js", "../src/pepr/operator/crd/validators/exempt-validator.ts", "../src/pepr/operator/reconcilers/index.ts", "../src/pepr/operator/controllers/istio/namespace.ts", "../src/pepr/operator/controllers/keycloak/client-sync.ts", "../src/pepr/operator/controllers/keycloak/clients/client-credentials.ts", "../src/pepr/operator/controllers/keycloak/clients/common.ts", "../src/pepr/operator/controllers/keycloak/types.ts", "../src/pepr/operator/controllers/monitoring/pod-monitor.ts", "../src/pepr/operator/controllers/monitoring/service-monitor.ts", "../src/pepr/operator/controllers/network/authorizationPolicies.ts", "../src/pepr/operator/controllers/network/policies.ts", "../src/pepr/operator/controllers/network/defaults/allow-egress-dns.ts", "../src/pepr/operator/controllers/network/defaults/allow-egress-istiod.ts", "../src/pepr/operator/controllers/network/defaults/allow-ingress-sidecar-monitoring.ts", "../src/pepr/operator/controllers/network/defaults/default-deny-all.ts", "../src/pepr/operator/controllers/network/generators/ambientHealthprobes.ts", "../src/pepr/operator/reconcilers/package-reconciler.ts", "../src/pepr/operator/controllers/keycloak/config.ts", "../src/pepr/operator/controllers/packages/packages.ts", "../src/pepr/operator/crd/register.ts", "../src/pepr/operator/crd/sources/exemption/v1alpha1.ts", "../src/pepr/operator/crd/sources/istio/virtualservice-v1beta1.ts", "../src/pepr/operator/crd/sources/package/v1alpha1.ts", "../src/pepr/patches/index.ts", "../src/pepr/policies/index.ts", "../src/pepr/operator/controllers/exemptions/exemption-store.ts", "../src/pepr/operator/controllers/exemptions/exemptions.ts", "../src/pepr/policies/istio.ts", "../src/pepr/policies/common.ts", "../src/pepr/policies/exemptions/index.ts", "../src/pepr/policies/networking.ts", "../src/pepr/policies/security.ts", "../src/pepr/policies/storage.ts", "../src/pepr/prometheus/index.ts"],
  "sourcesContent": ["/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { PeprModule } from \"pepr\";\n\nimport cfg from \"./package.json\";\n\nimport { Component, setupLogger } from \"./src/pepr/logger\";\nimport { operator } from \"./src/pepr/operator\";\nimport { loadUDSConfig, startConfigWatch } from \"./src/pepr/operator/controllers/config/config\";\nimport { setupAuthserviceSecret } from \"./src/pepr/operator/controllers/keycloak/authservice/config\";\nimport { setupKeycloakClientSecret } from \"./src/pepr/operator/controllers/keycloak/config\";\nimport { initAPIServerCIDR } from \"./src/pepr/operator/controllers/network/generators/kubeAPI\";\nimport { initAllNodesTarget } from \"./src/pepr/operator/controllers/network/generators/kubeNodes\";\nimport { startPackageWatch } from \"./src/pepr/operator/controllers/packages/packages\";\nimport { registerCRDs } from \"./src/pepr/operator/crd/register\";\nimport { patches } from \"./src/pepr/patches\";\nimport { policies, startExemptionWatch } from \"./src/pepr/policies\";\nimport { prometheus } from \"./src/pepr/prometheus\";\n\nconst log = setupLogger(Component.STARTUP);\n\n(async () => {\n  // Load the UDS Config and register CRDs\n  await loadUDSConfig();\n  await registerCRDs();\n  // KFC watch for cluster config, exemptions, and packages\n  await startConfigWatch();\n  await startExemptionWatch();\n  await startPackageWatch();\n  // Initialize API Server and Nodes IPs in-memory\n  await initAPIServerCIDR();\n  await initAllNodesTarget();\n  // Setup Authservice and Keycloak Secrets used by the operator\n  await setupAuthserviceSecret();\n  await setupKeycloakClientSecret();\n  // Start the PeprModule\n  new PeprModule(cfg, [\n    // UDS Core Operator\n    operator,\n\n    // UDS Core Policies\n    policies,\n\n    // Prometheus monitoring stack\n    prometheus,\n\n    // Patches for specific components\n    patches,\n  ]);\n})().catch(err => {\n  log.error(err, \"Critical error during startup. Exiting...\");\n  process.exit(1);\n});\n", "{\n  \"name\": \"uds-core\",\n  \"version\": \"0.6.0\",\n  \"description\": \"A collection of capabilities for UDS Core\",\n  \"keywords\": [\n    \"pepr\",\n    \"k8s\",\n    \"policy-engine\",\n    \"pepr-module\",\n    \"security\"\n  ],\n  \"engines\": {\n    \"node\": \">=20.0.0\"\n  },\n  \"pepr\": {\n    \"name\": \"UDS Core\",\n    \"uuid\": \"uds-core\",\n    \"onError\": \"reject\",\n    \"logLevel\": \"info\",\n    \"alwaysIgnore\": {\n      \"namespaces\": []\n    },\n    \"admission\": {\n      \"alwaysIgnore\": {\n        \"namespaces\": [\n          \"zarf\"\n        ]\n      }\n    },\n    \"watch\": {\n      \"alwaysIgnore\": {\n        \"namespaces\": [\n          \"zarf\"\n        ]\n      }\n    },\n    \"additionalWebhooks\": [\n      {\n        \"failurePolicy\": \"Ignore\",\n        \"namespace\": \"istio-system\"\n      }\n    ]\n  },\n  \"scripts\": {\n    \"k3d-setup\": \"k3d cluster delete pepr-dev && k3d cluster create pepr-dev --k3s-arg '--debug@server:0'\",\n    \"test:unit\": \"vitest run src/pepr/\"\n  },\n  \"dependencies\": {\n    \"@grpc/grpc-js\": \"^1.14.3\",\n    \"pepr\": \"^1.0.4-nightly.6\"\n  },\n  \"devDependencies\": {\n    \"@commitlint/cli\": \"20.2.0\",\n    \"@commitlint/config-conventional\": \"20.2.0\",\n    \"@eslint/eslintrc\": \"^3.3.1\",\n    \"@eslint/js\": \"^9.27.0\",\n    \"@types/ws\": \"^8.18.1\",\n    \"@vitest/coverage-v8\": \"^4.0.0\",\n    \"globals\": \"^16.2.0\",\n    \"husky\": \"9.1.7\",\n    \"lint-staged\": \"16.2.7\",\n    \"vitest\": \"^4.0.0\"\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Log } from \"pepr\";\n\nexport enum Component {\n  STARTUP = \"startup\",\n  CONFIG = \"config\",\n  ISTIO = \"istio\",\n  OPERATOR = \"operator\",\n  OPERATOR_CONFIG = \"operator.config\",\n  OPERATOR_EXEMPTIONS = \"operator.exemptions\",\n  OPERATOR_ISTIO = \"operator.istio\",\n  OPERATOR_KEYCLOAK = \"operator.keycloak\",\n  OPERATOR_AUTHSERVICE = \"operator.authservice\",\n  OPERATOR_MONITORING = \"operator.monitoring\",\n  OPERATOR_NETWORK = \"operator.network\",\n  OPERATOR_PACKAGES = \"operator.packages\",\n  OPERATOR_SECRETS = \"operator.secrets\",\n  OPERATOR_GENERATORS = \"operator.generators\",\n  OPERATOR_CRD = \"operator.crd\",\n  OPERATOR_RECONCILERS = \"operator.reconcilers\",\n  OPERATOR_CA_BUNDLE = \"operator.ca-bundle\",\n  POLICIES = \"policies\",\n  POLICIES_EXEMPTIONS = \"policies.exemptions\",\n  PROMETHEUS = \"prometheus\",\n  PATCHES = \"patches\",\n}\n\nexport function setupLogger(component: Component) {\n  const setupLogger = Log.child({ component });\n\n  // Handle commands that do not template the env vars\n  let logLevel = process.env.UDS_LOG_LEVEL;\n  if (!logLevel || logLevel === \"###ZARF_VAR_UDS_LOG_LEVEL###\") {\n    logLevel = \"debug\";\n  }\n\n  setupLogger.level = logLevel;\n\n  return setupLogger;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// Common imports\nimport { a } from \"pepr\";\nimport { When } from \"./common\";\n\n// Controller imports\nimport {\n  updateAPIServerCIDRFromEndpointSlice,\n  updateAPIServerCIDRFromService,\n} from \"./controllers/network/generators/kubeAPI\";\n\n// Resource Pod Reload controllers\nimport {\n  handleConfigMapDelete,\n  handleConfigMapUpdate,\n  handleSecretDelete,\n  handleSecretUpdate,\n} from \"./controllers/reload/pod-reload\";\n\n// Controller imports\nimport {\n  updateKubeNodesFromCreateUpdate,\n  updateKubeNodesFromDelete,\n} from \"./controllers/network/generators/kubeNodes\";\n\n// CRD imports\nimport { ClusterConfig, UDSExemption, UDSPackage } from \"./crd\";\nimport { validator } from \"./crd/validators/package-validator\";\n\n// Reconciler imports\nimport { Component, setupLogger } from \"../logger\";\nimport {\n  ConfigAction,\n  handleCfg,\n  handleCfgSecret,\n  handleUDSCACertsConfigMapUpdate,\n  UDSConfig,\n} from \"./controllers/config/config\";\nimport { reconcilePod, reconcileService } from \"./controllers/istio/ambient-waypoint\";\nimport { restartGatewayPods } from \"./controllers/istio/istio-configmap-sync\";\nimport {\n  KEYCLOAK_CLIENTS_SECRET_NAME,\n  KEYCLOAK_CLIENTS_SECRET_NAMESPACE,\n  updateKeycloakClientsSecret,\n} from \"./controllers/keycloak/client-secret-sync\";\nimport { validateCfgUpdate } from \"./crd/validators/clusterconfig-validator\";\nimport { exemptValidator } from \"./crd/validators/exempt-validator\";\nimport { packageFinalizer, packageReconciler } from \"./reconcilers/package-reconciler\";\n\n// Export the operator capability for registration in the root pepr.ts\nexport { operator } from \"./common\";\n\nconst log = setupLogger(Component.OPERATOR);\n\n// Watch for changes to the API server EndpointSlice and update the API server CIDR\n// Skip if a CIDR is defined in the UDS Config\nif (!UDSConfig.kubeApiCIDR) {\n  When(a.EndpointSlice)\n    .IsCreatedOrUpdated()\n    .InNamespace(\"default\")\n    .WithName(\"kubernetes\")\n    .Reconcile(updateAPIServerCIDRFromEndpointSlice);\n}\n\n// Watch for changes to the API server Service and update the API server CIDR\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"default\")\n  .WithName(\"kubernetes\")\n  .Reconcile(updateAPIServerCIDRFromService);\n\n// Watch for Service mutations to apply ambient waypoint labels\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .Mutate(req => reconcileService(req.Raw));\n\n// Watch for Pod mutations to apply ambient waypoint labels\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(req => reconcilePod(req.Raw));\n\n// Watch for changes to the UDSPackage CRD for processing\nWhen(UDSPackage)\n  .IsCreatedOrUpdated()\n  // Advanced CR validation\n  .Validate(validator)\n  // Enqueue the package for processing\n  .Reconcile(packageReconciler)\n  // Handle finalizer (deletions) for the package\n  .Finalize(packageFinalizer);\n\n// Watch for Exemptions and validate\nWhen(UDSExemption).IsCreatedOrUpdated().Validate(exemptValidator);\n\n// Watch for Functional Layers and update config\nWhen(UDSPackage)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"keycloak\")\n  .WithName(\"keycloak\")\n  .Watch(() => {\n    // todo: wait for keycloak and authservice to be running?\n    log.info(\"Identity and Authorization layer deployed, operator configured to handle SSO.\");\n    UDSConfig.isIdentityDeployed = true;\n  });\nWhen(UDSPackage)\n  .IsDeleted()\n  .InNamespace(\"keycloak\")\n  .WithName(\"keycloak\")\n  .Watch(() => {\n    log.info(\"Identity and Authorization layer removed, operator will NOT handle SSO.\");\n    UDSConfig.isIdentityDeployed = false;\n  });\n\n// Watch for changes to the Nodes and update the Node CIDR list\nif (UDSConfig.kubeNodeCIDRs.length === 0) {\n  When(a.Node).IsCreatedOrUpdated().Reconcile(updateKubeNodesFromCreateUpdate);\n}\n\n// Watch for Node deletions and update the Node CIDR list\nif (UDSConfig.kubeNodeCIDRs.length === 0) {\n  When(a.Node).IsDeleted().Reconcile(updateKubeNodesFromDelete);\n}\n\n// Watch the UDS Operator Config Secret and handle changes\nWhen(a.Secret)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"pepr-system\")\n  .WithName(\"uds-operator-config\")\n  .Reconcile(secret => handleCfgSecret(secret, ConfigAction.UPDATE));\n\n// Watch UDS ClusterConfig and handle changes\nWhen(ClusterConfig)\n  .IsCreatedOrUpdated()\n  .Validate(validateCfgUpdate)\n  .Reconcile(cfg => handleCfg(cfg, ConfigAction.UPDATE));\n\n// Watch the uds-ca-certs Configmap and update CA bundle configmaps\nWhen(a.ConfigMap)\n  .IsCreatedOrUpdated()\n  .InNamespace(\"pepr-system\")\n  .WithName(\"uds-ca-certs\")\n  .Reconcile(handleUDSCACertsConfigMapUpdate);\n\n// Watch the Kubernetes Clients Secret\nWhen(a.Secret)\n  .IsCreatedOrUpdated()\n  .InNamespace(KEYCLOAK_CLIENTS_SECRET_NAMESPACE)\n  .WithName(KEYCLOAK_CLIENTS_SECRET_NAME)\n  .Reconcile(s => updateKeycloakClientsSecret(s, false));\n\n// Watch for secrets with the uds.dev/pod-reload label for pod reload\nWhen(a.Secret)\n  .IsCreatedOrUpdated()\n  .WithLabel(\"uds.dev/pod-reload\", \"true\")\n  .Reconcile(handleSecretUpdate);\n\n// Watch for deleted secrets to clean up the checksum cache\nWhen(a.Secret).IsDeleted().WithLabel(\"uds.dev/pod-reload\", \"true\").Reconcile(handleSecretDelete);\n\n// Watch for ConfigMaps with the uds.dev/pod-reload label for pod reload\nWhen(a.ConfigMap)\n  .IsCreatedOrUpdated()\n  .WithLabel(\"uds.dev/pod-reload\", \"true\")\n  .Reconcile(handleConfigMapUpdate);\n\n// Watch for deleted ConfigMaps to clean up the checksum cache\nWhen(a.ConfigMap)\n  .IsDeleted()\n  .WithLabel(\"uds.dev/pod-reload\", \"true\")\n  .Reconcile(handleConfigMapDelete);\n\n// Istio Gateway Pods are not restarted automatically when the Istio ConfigMap is updated.\nWhen(a.ConfigMap)\n  .IsUpdated()\n  .InNamespace(\"istio-system\")\n  .WithName(\"istio\")\n  .Reconcile(restartGatewayPods);\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Capability } from \"pepr\";\n\nexport const operator = new Capability({\n  name: \"uds-core-operator\",\n  description: \"The UDS Operator is responsible for managing the lifecycle of UDS resources\",\n});\n\nexport const { Store, When } = operator;\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\nimport { K8s, kind, R } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../../logger\";\nimport { RemoteGenerated } from \"../../../crd\";\nimport { AuthorizationPolicy } from \"../../../crd/generated/istio/authorizationpolicy-v1beta1\";\nimport { UDSConfig } from \"../../config/config\";\nimport { retryWithDelay } from \"../../utils\";\nimport { anywhere } from \"./anywhere\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_GENERATORS);\n\n// This is an in-memory cache of the API server CIDR\nlet apiServerPeers: V1NetworkPolicyPeer[];\n\n// Track whether AuthorizationPolicies are available yet (Pepr installs before Istio)\nlet authorizationPolicyExists = false;\n\n/**\n * Initialize the API server CIDR.\n *\n * This function checks if a static CIDR is defined in the configuration.\n * If a static CIDR exists, it skips the EndpointSlice lookup and uses the static value.\n * Otherwise, it fetches the EndpointSlice and updates the CIDR dynamically.\n */\nexport async function initAPIServerCIDR() {\n  if (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n    try {\n      const svc = await retryWithDelay(fetchKubernetesService, log);\n\n      // If static CIDR is defined, pass it directly\n      if (UDSConfig.kubeApiCIDR) {\n        log.info(\n          `Static CIDR (${UDSConfig.kubeApiCIDR}) is defined for KubeAPI, skipping EndpointSlice lookup.`,\n        );\n        await updateAPIServerCIDR(svc, UDSConfig.kubeApiCIDR); // Pass static CIDR\n      } else {\n        const slice = await retryWithDelay(fetchKubernetesEndpointSlice, log);\n        await updateAPIServerCIDR(svc, slice);\n      }\n    } catch (error) {\n      log.error(\n        {\n          err: JSON.stringify(error),\n        },\n        \"Failed to initialize API Server CIDR for KubeAPI generated network policies\",\n      );\n    }\n  }\n}\n\n/**\n * Get the API server CIDR.\n *\n * @returns {V1NetworkPolicyPeer[]} The cached API server CIDR if available; otherwise, defaults to `0.0.0.0/0`.\n */\nexport function kubeAPI(): V1NetworkPolicyPeer[] {\n  // If the API server peers are already cached, return them\n  if (apiServerPeers) {\n    return apiServerPeers;\n  }\n\n  // Otherwise, log a warning and default to 0.0.0.0/0 until the EndpointSlice is updated\n  log.warn(\"Unable to get API server CIDR, defaulting to 0.0.0.0/0\");\n  return [anywhere];\n}\n\n/**\n * When the Kubernetes EndpointSlice is created or updated, update the API server CIDR.\n *\n * @param {kind.EndpointSlice} slice - The EndpointSlice object for the API server.\n */\nexport async function updateAPIServerCIDRFromEndpointSlice(slice: kind.EndpointSlice) {\n  try {\n    log.debug(\n      \"Processing update for endpointslices, getting k8s service for updating API server CIDR\",\n    );\n    const svc = await retryWithDelay(fetchKubernetesService, log);\n    await updateAPIServerCIDR(svc, slice);\n  } catch (err) {\n    const msg = \"Failed to update network policies from endpoint slice watch\";\n    log.error({ err }, msg);\n  }\n}\n\n/**\n * When the Kubernetes Service is created or updated, update the API server CIDR.\n *\n * If a static CIDR is defined, it skips fetching the EndpointSlice and uses the static value.\n *\n * @param {kind.Service} svc - The Service object for the API server.\n */\nexport async function updateAPIServerCIDRFromService(svc: kind.Service) {\n  try {\n    if (UDSConfig.kubeApiCIDR) {\n      log.debug(\"Processing update for api service, using configured API CIDR for endpoints\");\n      await updateAPIServerCIDR(svc, UDSConfig.kubeApiCIDR);\n    } else {\n      log.debug(\n        \"Processing update for api service, getting endpoint slices for updating API server CIDR\",\n      );\n      const slice = await retryWithDelay(fetchKubernetesEndpointSlice, log);\n      await updateAPIServerCIDR(svc, slice);\n    }\n  } catch (err) {\n    const msg = \"Failed to update network policies from API service watch\";\n    log.error({ err }, msg);\n  }\n}\n\n/**\n * Update the API server CIDR and apply it to the NetworkPolicies.\n *\n * @param {kind.Service} svc - The Service object representing the Kubernetes API server.\n * @param {kind.EndpointSlice | string} slice - Either the EndpointSlice for dynamic CIDR generation or a static CIDR string.\n */\nexport async function updateAPIServerCIDR(svc: kind.Service, slice: kind.EndpointSlice | string) {\n  const k8sApiIP = svc.spec?.clusterIP;\n\n  let peers: string[] = [];\n\n  // Handle static CIDR or dynamic EndpointSlice\n  if (typeof slice === \"string\") {\n    peers.push(slice);\n  } else {\n    const { endpoints } = slice;\n    peers = Array.isArray(endpoints)\n      ? endpoints.flatMap(e => {\n          if (!Array.isArray(e?.addresses) || e.addresses.length === 0) {\n            return []; // No addresses, skip this endpoint\n          }\n          return e.addresses.map(addr => `${addr}/32`); // Add /32 to each address\n        })\n      : [];\n  }\n\n  // Add the clusterIP from the service\n  if (k8sApiIP) {\n    peers.push(`${k8sApiIP}/32`);\n  }\n\n  // Convert peers into NetworkPolicyPeer objects\n  if (peers.length) {\n    apiServerPeers = peers.flatMap(cidr => ({\n      ipBlock: {\n        cidr: cidr,\n      },\n    }));\n\n    // Update NetworkPolicies\n    await updateKubeAPINetworkPolicies(apiServerPeers);\n\n    // Update AuthorizationPolicies\n    await updateKubeAPIAuthorizationPolicies(apiServerPeers);\n  } else {\n    log.warn(\"No peers found for the API server CIDR update.\");\n  }\n}\n\n/**\n * Update NetworkPolicies with new API server peers.\n *\n * @param {V1NetworkPolicyPeer[]} newPeers - The updated list of peers to apply to the NetworkPolicies.\n */\nexport async function updateKubeAPINetworkPolicies(newPeers: V1NetworkPolicyPeer[]) {\n  const netPols = await K8s(kind.NetworkPolicy)\n    .WithLabel(\"uds/generated\", RemoteGenerated.KubeAPI)\n    .Get();\n\n  for (const netPol of netPols.items) {\n    // Safety check for network policy spec existence\n    if (!netPol.spec) {\n      log.warn(\n        `KubeAPI NetworkPolicy ${netPol.metadata!.namespace}/${\n          netPol.metadata!.name\n        } is missing spec.`,\n      );\n      continue;\n    }\n\n    let updateRequired = false;\n    // Handle egress policies\n    if (netPol.spec.egress) {\n      if (!netPol.spec.egress[0]) {\n        netPol.spec.egress[0] = { to: [] };\n      }\n      const oldPeers = netPol.spec.egress[0].to;\n      if (!R.equals(oldPeers, newPeers)) {\n        updateRequired = true;\n        netPol.spec.egress[0].to = newPeers;\n      }\n      // Handle ingress policies\n    } else if (netPol.spec.ingress) {\n      if (!netPol.spec.ingress[0]) {\n        netPol.spec.ingress[0] = { from: [] };\n      }\n      const oldPeers = netPol.spec.ingress[0].from;\n      if (!R.equals(oldPeers, newPeers)) {\n        updateRequired = true;\n        netPol.spec.ingress[0].from = newPeers;\n      }\n    }\n\n    // If the policy required a change, apply the new policy\n    if (updateRequired) {\n      if (netPol.metadata) {\n        // Remove managed fields to prevent errors on server side apply\n        netPol.metadata.managedFields = undefined;\n      }\n\n      log.debug(\n        `Updating KubeAPI NetworkPolicy ${netPol.metadata!.namespace}/${\n          netPol.metadata!.name\n        } with new CIDRs.`,\n      );\n      try {\n        await K8s(kind.NetworkPolicy).Apply(netPol, { force: true });\n      } catch (err) {\n        let message = err.data?.message || \"Unknown error while applying KubeAPI network policies\";\n        if (UDSConfig.kubeApiCIDR) {\n          message +=\n            \", ensure that the KUBEAPI_CIDR override configured for the operator is correct.\";\n        }\n        throw new Error(message);\n      }\n    }\n  }\n}\n\n/**\n * Updates the AuthorizationPolicies for KubeAPI.\n *\n * This function takes an array of V1NetworkPolicyPeer objects (newPeers) representing\n * the latest API server CIDRs, extracts the CIDR strings, and then queries for all\n * AuthorizationPolicies labeled with \"uds/generated\" equal to RemoteGenerated.KubeAPI.\n * For each policy, it compares the existing IP blocks in the \"from\" field with the new IP blocks.\n * If they differ, the policy is updated (after clearing managedFields to prevent server-side apply issues)\n * and re-applied.\n *\n * @param {V1NetworkPolicyPeer[]} newPeers - An array of peer objects containing the updated API server CIDRs.\n * @returns {Promise<void>} A promise that resolves once the update process is complete.\n */\nexport async function updateKubeAPIAuthorizationPolicies(\n  newPeers: V1NetworkPolicyPeer[],\n): Promise<void> {\n  // Convert the cached peers to an array of CIDR strings.\n  const newIpBlocks = newPeers\n    .map(peer => peer.ipBlock?.cidr)\n    .filter((cidr): cidr is string => typeof cidr === \"string\");\n\n  // Check if AuthorizationPolicy is available in the cluster\n  if (!authorizationPolicyExists) {\n    try {\n      await K8s(kind.CustomResourceDefinition).Get(\"authorizationpolicies.security.istio.io\");\n      authorizationPolicyExists = true;\n    } catch {\n      log.warn(\n        \"AuthorizationPolicy CRD is not present in the cluster, skipping KubeAPI AuthorizationPolicy updates\",\n      );\n      return;\n    }\n  }\n\n  // Query for AuthorizationPolicies with the generated label for KubeAPI.\n  const authPols = await K8s(AuthorizationPolicy)\n    .WithLabel(\"uds/generated\", RemoteGenerated.KubeAPI)\n    .Get();\n\n  if (authPols.items.length > 0) {\n    const summary = authPols.items\n      .map(pol => `name: ${pol.metadata?.name}, namespace: ${pol.metadata?.namespace}`)\n      .join(\" | \");\n    log.trace(`Fetched ${authPols.items.length} AuthorizationPolicies: ${summary}`);\n  }\n\n  for (const pol of authPols.items) {\n    // Safety check: ensure the policy has rules.\n    if (!pol.spec || !pol.spec.rules || pol.spec.rules.length === 0) {\n      log.warn(\n        `AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name} is missing rules.`,\n      );\n      continue;\n    }\n\n    let updateRequired = false;\n    const rule = pol.spec.rules[0];\n    // Check if a \"from\" entry exists and contains ipBlocks.\n    if (rule.from && rule.from.length > 0 && rule.from[0].source?.ipBlocks) {\n      const oldIpBlocks = rule.from[0].source.ipBlocks;\n      if (!R.equals(oldIpBlocks, newIpBlocks)) {\n        rule.from[0].source.ipBlocks = newIpBlocks;\n        updateRequired = true;\n      }\n    } else {\n      // If not present, create it.\n      rule.from = [{ source: { ipBlocks: newIpBlocks } }];\n      updateRequired = true;\n    }\n\n    if (updateRequired) {\n      // Clean managedFields to avoid server-side apply issues.\n      if (pol.metadata) {\n        pol.metadata.managedFields = undefined;\n      }\n      try {\n        await K8s(AuthorizationPolicy).Apply(pol, { force: true });\n        log.debug(\n          `Updated KubeAPI AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name}`,\n        );\n      } catch (err) {\n        log.error(\n          err,\n          `Failed to update AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name}`,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Fetches the Kubernetes Service object for the API server.\n *\n * @returns {Promise<kind.Service>} - The Service object.\n */\nasync function fetchKubernetesService(): Promise<kind.Service> {\n  return K8s(kind.Service).InNamespace(\"default\").Get(\"kubernetes\");\n}\n\n/**\n * Fetches the Kubernetes EndpointSlice object for the API server.\n *\n * @returns {Promise<kind.EndpointSlice>} - The EndpointSlice object.\n */\nasync function fetchKubernetesEndpointSlice(): Promise<kind.EndpointSlice> {\n  return K8s(kind.EndpointSlice).InNamespace(\"default\").Get(\"kubernetes\");\n}\n", "/**\n * Copyright 2026 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class Package extends GenericKind {\n  spec?: Spec;\n  status?: StatusObject;\n}\n\nexport interface Spec {\n  /**\n   * CA bundle configuration for the package\n   */\n  caBundle?: CABundle;\n  /**\n   * Create Service or Pod Monitor configurations\n   */\n  monitor?: Monitor[];\n  /**\n   * Network configuration for the package\n   */\n  network?: Network;\n  /**\n   * Create SSO client configurations\n   */\n  sso?: Sso[];\n}\n\n/**\n * CA bundle configuration for the package\n */\nexport interface CABundle {\n  /**\n   * ConfigMap configuration for CA bundle\n   */\n  configMap?: ConfigMap;\n}\n\n/**\n * ConfigMap configuration for CA bundle\n */\nexport interface ConfigMap {\n  /**\n   * Additional annotations to apply to the generated ConfigMap (default: {})\n   */\n  annotations?: { [key: string]: string };\n  /**\n   * The key name inside the ConfigMap (default: ca-bundle.pem)\n   */\n  key?: string;\n  /**\n   * Additional labels to apply to the generated ConfigMap (default: {})\n   */\n  labels?: { [key: string]: string };\n  /**\n   * The name of the ConfigMap to create (default: uds-trust-bundle)\n   */\n  name?: string;\n}\n\nexport interface Monitor {\n  /**\n   * Authorization settings.\n   */\n  authorization?: Authorization;\n  /**\n   * A description of this monitor entry, this will become part of the ServiceMonitor name\n   */\n  description?: string;\n  /**\n   * The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise\n   * invalid Content-Type\n   */\n  fallbackScrapeProtocol?: FallbackScrapeProtocol;\n  /**\n   * The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the\n   * default.\n   */\n  kind?: Kind;\n  /**\n   * HTTP path from which to scrape for metrics, defaults to `/metrics`\n   */\n  path?: string;\n  /**\n   * Selector for Pods targeted by the selected Services (so the NetworkPolicy can be\n   * generated correctly). Defaults to `selector` when not specified.\n   */\n  podSelector?: { [key: string]: string };\n  /**\n   * The port name for the serviceMonitor\n   */\n  portName: string;\n  /**\n   * Selector for Services that expose metrics to scrape\n   */\n  selector: { [key: string]: string };\n  /**\n   * The service targetPort. This is required so the NetworkPolicy can be generated correctly.\n   */\n  targetPort: number;\n}\n\n/**\n * Authorization settings.\n */\nexport interface Authorization {\n  /**\n   * Selects a key of a Secret in the namespace that contains the credentials for\n   * authentication.\n   */\n  credentials: Credentials;\n  /**\n   * Defines the authentication type. The value is case-insensitive. \"Basic\" is not a\n   * supported value. Default: \"Bearer\"\n   */\n  type?: string;\n}\n\n/**\n * Selects a key of a Secret in the namespace that contains the credentials for\n * authentication.\n */\nexport interface Credentials {\n  /**\n   * The key of the secret to select from. Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent. More info:\n   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise\n * invalid Content-Type\n */\nexport enum FallbackScrapeProtocol {\n  OpenMetricsText001 = \"OpenMetricsText0.0.1\",\n  OpenMetricsText100 = \"OpenMetricsText1.0.0\",\n  PrometheusProto = \"PrometheusProto\",\n  PrometheusText004 = \"PrometheusText0.0.4\",\n  PrometheusText100 = \"PrometheusText1.0.0\",\n}\n\n/**\n * The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the\n * default.\n */\nexport enum Kind {\n  PodMonitor = \"PodMonitor\",\n  ServiceMonitor = \"ServiceMonitor\",\n}\n\n/**\n * Network configuration for the package\n */\nexport interface Network {\n  /**\n   * Allow specific traffic (namespace will have a default-deny policy)\n   */\n  allow?: Allow[];\n  /**\n   * Expose a service on an Istio Gateway\n   */\n  expose?: Expose[];\n  /**\n   * Service Mesh configuration for the package\n   */\n  serviceMesh?: ServiceMesh;\n}\n\nexport interface Allow {\n  /**\n   * A description of the policy, this will become part of the policy name\n   */\n  description?: string;\n  /**\n   * The direction of the traffic\n   */\n  direction: Direction;\n  /**\n   * The labels to apply to the policy\n   */\n  labels?: { [key: string]: string };\n  /**\n   * Deprecated: use selector\n   */\n  podLabels?: { [key: string]: string };\n  /**\n   * The port to allow (protocol is always TCP)\n   */\n  port?: number;\n  /**\n   * A list of ports to allow (protocol is always TCP)\n   */\n  ports?: number[];\n  /**\n   * Custom generated policy CIDR\n   */\n  remoteCidr?: string;\n  /**\n   * Custom generated remote selector for the policy\n   */\n  remoteGenerated?: RemoteGenerated;\n  /**\n   * Remote host to allow traffic out to\n   */\n  remoteHost?: string;\n  /**\n   * The remote namespace to allow traffic to/from. Use * or empty string to allow all\n   * namespaces\n   */\n  remoteNamespace?: string;\n  /**\n   * Deprecated: use remoteSelector\n   */\n  remotePodLabels?: { [key: string]: string };\n  /**\n   * Protocol used for external connection\n   */\n  remoteProtocol?: RemoteProtocol;\n  /**\n   * The remote pod selector labels to allow traffic to/from\n   */\n  remoteSelector?: { [key: string]: string };\n  /**\n   * The remote service account to restrict incoming traffic from within the remote\n   * namespace.           Only valid for Ingress rules.\n   */\n  remoteServiceAccount?: string;\n  /**\n   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all\n   * pods in the namespace\n   */\n  selector?: { [key: string]: string };\n  /**\n   * The service account to restrict outgoing traffic from within the package\n   * namespace.           Only valid for Egress rules.\n   */\n  serviceAccount?: string;\n}\n\n/**\n * The direction of the traffic\n */\nexport enum Direction {\n  Egress = \"Egress\",\n  Ingress = \"Ingress\",\n}\n\n/**\n * Custom generated remote selector for the policy\n */\nexport enum RemoteGenerated {\n  Anywhere = \"Anywhere\",\n  CloudMetadata = \"CloudMetadata\",\n  IntraNamespace = \"IntraNamespace\",\n  KubeAPI = \"KubeAPI\",\n  KubeNodes = \"KubeNodes\",\n}\n\n/**\n * Protocol used for external connection\n */\nexport enum RemoteProtocol {\n  HTTP = \"HTTP\",\n  TLS = \"TLS\",\n}\n\nexport interface Expose {\n  /**\n   * Advanced HTTP settings for the route.\n   */\n  advancedHTTP?: AdvancedHTTP;\n  /**\n   * A description of this expose entry, this will become part of the VirtualService name\n   */\n  description?: string;\n  /**\n   * The domain to expose the service on, only valid for additional gateways (not tenant,\n   * admin, or passthrough)\n   */\n  domain?: string;\n  /**\n   * The name of the gateway to expose the service on (default: tenant)\n   */\n  gateway?: string;\n  /**\n   * The hostname to expose the service on\n   */\n  host: string;\n  /**\n   * Match the incoming request based on custom rules. Not permitted when using the\n   * passthrough gateway.\n   */\n  match?: ExposeMatch[];\n  /**\n   * Deprecated: use selector\n   */\n  podLabels?: { [key: string]: string };\n  /**\n   * The port number to expose\n   */\n  port?: number;\n  /**\n   * Selector for Pods targeted by the selected Services (so the NetworkPolicy can be\n   * generated correctly).\n   */\n  selector?: { [key: string]: string };\n  /**\n   * The name of the service to expose\n   */\n  service?: string;\n  /**\n   * The service targetPort. This defaults to port and is only required if the service port is\n   * different from the target port (so the NetworkPolicy can be generated correctly).\n   */\n  targetPort?: number;\n}\n\n/**\n * Advanced HTTP settings for the route.\n */\nexport interface AdvancedHTTP {\n  /**\n   * Cross-Origin Resource Sharing policy (CORS).\n   */\n  corsPolicy?: CorsPolicy;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  directResponse?: DirectResponse;\n  headers?: Headers;\n  /**\n   * Match the incoming request based on custom rules. Not permitted when using the\n   * passthrough gateway.\n   */\n  match?: AdvancedHTTPMatch[];\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  redirect?: Redirect;\n  /**\n   * Retry policy for HTTP requests.\n   */\n  retries?: Retries;\n  /**\n   * Rewrite HTTP URIs and Authority headers.\n   */\n  rewrite?: Rewrite;\n  /**\n   * Timeout for HTTP requests, default is disabled.\n   */\n  timeout?: string;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Cross-Origin Resource Sharing policy (CORS).\n */\nexport interface CorsPolicy {\n  /**\n   * Indicates whether the caller is allowed to send the actual request (not the preflight)\n   * using credentials.\n   */\n  allowCredentials?: boolean;\n  /**\n   * List of HTTP headers that can be used when requesting the resource.\n   */\n  allowHeaders?: string[];\n  /**\n   * List of HTTP methods allowed to access the resource.\n   */\n  allowMethods?: string[];\n  allowOrigin?: string[];\n  /**\n   * String patterns that match allowed origins.\n   */\n  allowOrigins?: AllowOrigin[];\n  /**\n   * A list of HTTP headers that the browsers are allowed to access.\n   */\n  exposeHeaders?: string[];\n  /**\n   * Specifies how long the results of a preflight request can be cached.\n   */\n  maxAge?: string;\n}\n\nexport interface AllowOrigin {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface DirectResponse {\n  /**\n   * Specifies the content of the response body.\n   */\n  body?: Body;\n  /**\n   * Specifies the HTTP response status to be returned.\n   */\n  status: number;\n}\n\n/**\n * Specifies the content of the response body.\n */\nexport interface Body {\n  /**\n   * response body as base64 encoded bytes.\n   */\n  bytes?: string;\n  string?: string;\n}\n\nexport interface Headers {\n  request?: Request;\n  response?: Response;\n}\n\nexport interface Request {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface Response {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface AdvancedHTTPMatch {\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  method?: PurpleMethod;\n  /**\n   * The name assigned to a match.\n   */\n  name: string;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: PurpleQueryParam };\n  uri?: PurpleURI;\n}\n\nexport interface PurpleMethod {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface PurpleQueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface PurpleURI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface Redirect {\n  /**\n   * On a redirect, overwrite the Authority/Host portion of the URL with this value.\n   */\n  authority?: string;\n  /**\n   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n   * for HTTP and 443 for HTTPS.\n   *\n   * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT\n   */\n  derivePort?: DerivePort;\n  /**\n   * On a redirect, overwrite the port portion of the URL with this value.\n   */\n  port?: number;\n  /**\n   * On a redirect, Specifies the HTTP status code to use in the redirect response.\n   */\n  redirectCode?: number;\n  /**\n   * On a redirect, overwrite the scheme portion of the URL with this value.\n   */\n  scheme?: string;\n  /**\n   * On a redirect, overwrite the Path portion of the URL with this value.\n   */\n  uri?: string;\n}\n\n/**\n * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n * for HTTP and 443 for HTTPS.\n *\n * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT\n */\nexport enum DerivePort {\n  FromProtocolDefault = \"FROM_PROTOCOL_DEFAULT\",\n  FromRequestPort = \"FROM_REQUEST_PORT\",\n}\n\n/**\n * Retry policy for HTTP requests.\n */\nexport interface Retries {\n  /**\n   * Number of retries to be allowed for a given request.\n   */\n  attempts?: number;\n  /**\n   * Timeout per attempt for a given request, including the initial call and any retries.\n   */\n  perTryTimeout?: string;\n  /**\n   * Specifies the conditions under which retry takes place.\n   */\n  retryOn?: string;\n  /**\n   * Flag to specify whether the retries should retry to other localities.\n   */\n  retryRemoteLocalities?: boolean;\n}\n\n/**\n * Rewrite HTTP URIs and Authority headers.\n */\nexport interface Rewrite {\n  /**\n   * rewrite the Authority/Host header with this value.\n   */\n  authority?: string;\n  /**\n   * rewrite the path (or the prefix) portion of the URI with this value.\n   */\n  uri?: string;\n  /**\n   * rewrite the path portion of the URI with the specified regex.\n   */\n  uriRegexRewrite?: URIRegexRewrite;\n}\n\n/**\n * rewrite the path portion of the URI with the specified regex.\n */\nexport interface URIRegexRewrite {\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  match?: string;\n  /**\n   * The string that should replace into matching portions of original URI.\n   */\n  rewrite?: string;\n}\n\nexport interface ExposeMatch {\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  method?: FluffyMethod;\n  /**\n   * The name assigned to a match.\n   */\n  name: string;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: FluffyQueryParam };\n  uri?: FluffyURI;\n}\n\nexport interface FluffyMethod {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface FluffyQueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface FluffyURI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Service Mesh configuration for the package\n */\nexport interface ServiceMesh {\n  /**\n   * Set the service mesh mode for this package (namespace), defaults to sidecar\n   */\n  mode?: Mode;\n}\n\n/**\n * Set the service mesh mode for this package (namespace), defaults to sidecar\n *\n * The current service mesh mode for this package\n */\nexport enum Mode {\n  Ambient = \"ambient\",\n  Sidecar = \"sidecar\",\n}\n\nexport interface Sso {\n  /**\n   * This URL will be used for every binding to both the SP's Assertion Consumer and Single\n   * Logout Services.\n   */\n  adminUrl?: string;\n  /**\n   * Always list this client in the Account UI, even if the user does not have an active\n   * session.\n   */\n  alwaysDisplayInConsole?: boolean;\n  /**\n   * Specifies attributes for the client.\n   */\n  attributes?: { [key: string]: string };\n  /**\n   * Default URL to use when the auth server needs to redirect or link back to the client.\n   */\n  baseUrl?: string;\n  /**\n   * The client authenticator type\n   */\n  clientAuthenticatorType?: ClientAuthenticatorType;\n  /**\n   * The client identifier registered with the identity provider.\n   */\n  clientId: string;\n  /**\n   * Default client scopes\n   */\n  defaultClientScopes?: string[];\n  /**\n   * A description for the client, can be a URL to an image to replace the login logo\n   */\n  description?: string;\n  /**\n   * Labels to match pods to automatically protect with authservice. Leave empty to disable\n   * authservice protection\n   */\n  enableAuthserviceSelector?: { [key: string]: string };\n  /**\n   * Whether the SSO client is enabled\n   */\n  enabled?: boolean;\n  /**\n   * The client SSO group type\n   */\n  groups?: Groups;\n  /**\n   * Specifies display name of the client\n   */\n  name: string;\n  /**\n   * Specifies the protocol of the client, either 'openid-connect' or 'saml'\n   */\n  protocol?: Protocol;\n  /**\n   * Protocol Mappers to configure on the client\n   */\n  protocolMappers?: ProtocolMapper[];\n  /**\n   * Defines whether the client requires a client secret for authentication\n   */\n  publicClient?: boolean;\n  /**\n   * Valid URI pattern a browser can redirect to after a successful login. Simple wildcards\n   * are allowed such as 'https://unicorns.uds.dev/*'\n   */\n  redirectUris?: string[];\n  /**\n   * Root URL appended to relative URLs\n   */\n  rootUrl?: string;\n  /**\n   * The client secret. Typically left blank and auto-generated.\n   */\n  secret?: string;\n  /**\n   * Additional annotations to apply to the generated secret, can be used for pod reloading\n   * with a selector\n   */\n  secretAnnotations?: { [key: string]: string };\n  /**\n   * Additional labels to apply to the generated secret, can be used for pod reloading\n   */\n  secretLabels?: { [key: string]: string };\n  /**\n   * The name of the secret to store the client secret\n   */\n  secretName?: string;\n  /**\n   * A template for the generated secret\n   */\n  secretTemplate?: { [key: string]: string };\n  /**\n   * Enables the client credentials grant based authentication via OpenID Connect protocol.\n   */\n  serviceAccountsEnabled?: boolean;\n  /**\n   * Enables the standard OpenID Connect redirect based authentication with authorization code.\n   */\n  standardFlowEnabled?: boolean;\n  /**\n   * Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does\n   * not include the '*' wildcard though. To permit all origins, explicitly add '*'.\n   */\n  webOrigins?: string[];\n}\n\n/**\n * The client authenticator type\n */\nexport enum ClientAuthenticatorType {\n  ClientJwt = \"client-jwt\",\n  ClientSecret = \"client-secret\",\n}\n\n/**\n * The client SSO group type\n */\nexport interface Groups {\n  /**\n   * List of groups allowed to access the client\n   */\n  anyOf?: string[];\n}\n\n/**\n * Specifies the protocol of the client, either 'openid-connect' or 'saml'\n *\n * Protocol of the mapper\n */\nexport enum Protocol {\n  OpenidConnect = \"openid-connect\",\n  Saml = \"saml\",\n}\n\nexport interface ProtocolMapper {\n  /**\n   * Configuration options for the mapper.\n   */\n  config?: { [key: string]: string };\n  /**\n   * Whether user consent is required for this mapper\n   */\n  consentRequired?: boolean;\n  /**\n   * Name of the mapper\n   */\n  name: string;\n  /**\n   * Protocol of the mapper\n   */\n  protocol: Protocol;\n  /**\n   * Protocol Mapper type of the mapper\n   */\n  protocolMapper: string;\n}\n\nexport interface StatusObject {\n  authorizationPolicyCount?: number;\n  authserviceClients?: AuthserviceClient[];\n  /**\n   * Status conditions following Kubernetes-style conventions\n   */\n  conditions?: Condition[];\n  endpoints?: string[];\n  /**\n   * The current service mesh mode for this package\n   */\n  meshMode?: Mode;\n  monitors?: string[];\n  networkPolicyCount?: number;\n  observedGeneration?: number;\n  phase?: Phase;\n  retryAttempt?: number;\n  ssoClients?: string[];\n}\n\nexport interface AuthserviceClient {\n  clientId: string;\n  selector?: { [key: string]: string };\n}\n\nexport interface Condition {\n  /**\n   * The last time the condition transitioned from one status to another\n   */\n  lastTransitionTime: Date;\n  /**\n   * A human-readable message indicating details about the transition\n   */\n  message: string;\n  /**\n   * Represents the .metadata.generation that the condition was set based upon\n   */\n  observedGeneration?: number;\n  /**\n   * A programmatic identifier indicating the reason for the condition's last transition\n   */\n  reason: string;\n  /**\n   * Status of the condition, one of True, False, Unknown\n   */\n  status: StatusEnum;\n  /**\n   * Type of condition in CamelCase or in foo.example.com/CamelCase format\n   */\n  type: string;\n}\n\n/**\n * Status of the condition, one of True, False, Unknown\n */\nexport enum StatusEnum {\n  False = \"False\",\n  True = \"True\",\n  Unknown = \"Unknown\",\n}\n\nexport enum Phase {\n  Failed = \"Failed\",\n  Pending = \"Pending\",\n  Ready = \"Ready\",\n  RemovalFailed = \"RemovalFailed\",\n  Removing = \"Removing\",\n  Retrying = \"Retrying\",\n}\n\nRegisterKind(Package, {\n  group: \"uds.dev\",\n  version: \"v1alpha1\",\n  kind: \"Package\",\n  plural: \"packages\",\n});\n", "/**\n * Copyright 2026 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class Exemption extends GenericKind {\n  spec?: Spec;\n}\n\nexport interface Spec {\n  /**\n   * Policy exemptions\n   */\n  exemptions: ExemptionElement[];\n}\n\nexport interface ExemptionElement {\n  /**\n   * Reasons as to why this exemption is needed\n   */\n  description?: string;\n  /**\n   * Resource to exempt (Regex allowed for name)\n   */\n  matcher: Matcher;\n  /**\n   * A list of policies to override\n   */\n  policies: Policy[];\n  /**\n   * title to give the exemption for reporting purposes\n   */\n  title?: string;\n}\n\n/**\n * Resource to exempt (Regex allowed for name)\n */\nexport interface Matcher {\n  kind?: Kind;\n  name: string;\n  namespace: string;\n}\n\nexport enum Kind {\n  Pod = \"pod\",\n  Service = \"service\",\n}\n\nexport enum Policy {\n  DisallowHostNamespaces = \"DisallowHostNamespaces\",\n  DisallowNodePortServices = \"DisallowNodePortServices\",\n  DisallowPrivileged = \"DisallowPrivileged\",\n  DisallowSELinuxOptions = \"DisallowSELinuxOptions\",\n  DropAllCapabilities = \"DropAllCapabilities\",\n  RequireNonRootUser = \"RequireNonRootUser\",\n  RestrictCapabilities = \"RestrictCapabilities\",\n  RestrictExternalNames = \"RestrictExternalNames\",\n  RestrictHostPathWrite = \"RestrictHostPathWrite\",\n  RestrictHostPorts = \"RestrictHostPorts\",\n  RestrictIstioAmbientOverrides = \"RestrictIstioAmbientOverrides\",\n  RestrictIstioSidecarOverrides = \"RestrictIstioSidecarOverrides\",\n  RestrictIstioTrafficOverrides = \"RestrictIstioTrafficOverrides\",\n  RestrictIstioUser = \"RestrictIstioUser\",\n  RestrictProcMount = \"RestrictProcMount\",\n  RestrictSELinuxType = \"RestrictSELinuxType\",\n  RestrictSeccomp = \"RestrictSeccomp\",\n  RestrictVolumeTypes = \"RestrictVolumeTypes\",\n}\n\nRegisterKind(Exemption, {\n  group: \"uds.dev\",\n  version: \"v1alpha1\",\n  kind: \"Exemption\",\n  plural: \"exemptions\",\n});\n", "/**\n * Copyright 2026 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nimport type { V1ObjectMeta } from \"@kubernetes/client-node\";\nexport class ClusterConfig extends GenericKind {\n  declare metadata?: Metadata;\n  spec?: Spec;\n  status?: Status;\n}\n\nexport interface Metadata extends V1ObjectMeta {\n  name?: Name;\n}\n\nexport enum Name {\n  UdsClusterConfig = \"uds-cluster-config\",\n}\n\nexport interface Spec {\n  attributes?: Attributes;\n  caBundle?: CABundle;\n  expose: Expose;\n  networking?: Networking;\n  policy: Policy;\n}\n\nexport interface Attributes {\n  /**\n   * Friendly name to associate with your UDS cluster\n   */\n  clusterName?: string;\n  /**\n   * Tags to apply to your UDS cluster\n   */\n  tags?: string[];\n}\n\nexport interface CABundle {\n  /**\n   * Contents of user provided CA bundle certificates\n   */\n  certs?: string;\n  /**\n   * Include DoD CA certificates in the bundle\n   */\n  includeDoDCerts?: boolean;\n  /**\n   * Include public CA certificates in the bundle\n   */\n  includePublicCerts?: boolean;\n}\n\nexport interface Expose {\n  /**\n   * Domain all cluster services on the admin gateway will be exposed on\n   */\n  adminDomain?: string;\n  /**\n   * The trusted CA that signed your domain certificates if using Private PKI\n   */\n  caCert?: string;\n  /**\n   * Domain all cluster services will be exposed on\n   */\n  domain: string;\n}\n\nexport interface Networking {\n  /**\n   * CIDR range for your Kubernetes control plane nodes. This is a manual override that can be\n   * used instead of relying on Pepr to automatically watch and update the values\n   */\n  kubeApiCIDR?: string;\n  /**\n   * CIDR(s) for all Kubernetes nodes (not just control plane). Similar reason to above,annual\n   * override instead of relying on watch\n   */\n  kubeNodeCIDRs?: string[];\n}\n\nexport interface Policy {\n  /**\n   * Allow UDS Exemption custom resources to live in any namespace (default false)\n   */\n  allowAllNsExemptions: boolean;\n}\n\nexport interface Status {\n  observedGeneration?: number;\n  phase?: Phase;\n}\n\nexport enum Phase {\n  Failed = \"Failed\",\n  Pending = \"Pending\",\n  Ready = \"Ready\",\n}\n\nRegisterKind(ClusterConfig, {\n  group: \"uds.dev\",\n  version: \"v1alpha1\",\n  kind: \"ClusterConfig\",\n  plural: \"clusterconfig\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class VirtualService extends GenericKind {\n  /**\n   * Configuration affecting label/content routing, sni routing, etc. See more details at:\n   * https://istio.io/docs/reference/config/networking/virtual-service.html\n   */\n  spec?: Spec;\n  status?: { [key: string]: unknown };\n}\n\n/**\n * Configuration affecting label/content routing, sni routing, etc. See more details at:\n * https://istio.io/docs/reference/config/networking/virtual-service.html\n */\nexport interface Spec {\n  /**\n   * A list of namespaces to which this virtual service is exported.\n   */\n  exportTo?: string[];\n  /**\n   * The names of gateways and sidecars that should apply these routes.\n   */\n  gateways?: string[];\n  /**\n   * The destination hosts to which traffic is being sent.\n   */\n  hosts?: string[];\n  /**\n   * An ordered list of route rules for HTTP traffic.\n   */\n  http?: HTTP[];\n  /**\n   * An ordered list of route rules for opaque TCP traffic.\n   */\n  tcp?: TCP[];\n  /**\n   * An ordered list of route rule for non-terminated TLS & HTTPS traffic.\n   */\n  tls?: Tl[];\n}\n\nexport interface HTTP {\n  /**\n   * Cross-Origin Resource Sharing policy (CORS).\n   */\n  corsPolicy?: CorsPolicy;\n  /**\n   * Delegate is used to specify the particular VirtualService which can be used to define\n   * delegate HTTPRoute.\n   */\n  delegate?: Delegate;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  directResponse?: DirectResponse;\n  /**\n   * Fault injection policy to apply on HTTP traffic at the client side.\n   */\n  fault?: Fault;\n  headers?: HTTPHeaders;\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: HTTPMatch[];\n  /**\n   * Mirror HTTP traffic to a another destination in addition to forwarding the requests to\n   * the intended destination.\n   */\n  mirror?: PurpleMirror;\n  mirror_percent?: number;\n  mirrorPercent?: number;\n  /**\n   * Percentage of the traffic to be mirrored by the `mirror` field.\n   */\n  mirrorPercentage?: MirrorPercentageObject;\n  /**\n   * Specifies the destinations to mirror HTTP traffic in addition to the original destination.\n   */\n  mirrors?: MirrorElement[];\n  /**\n   * The name assigned to the route for debugging purposes.\n   */\n  name?: string;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  redirect?: Redirect;\n  /**\n   * Retry policy for HTTP requests.\n   */\n  retries?: Retries;\n  /**\n   * Rewrite HTTP URIs and Authority headers.\n   */\n  rewrite?: Rewrite;\n  /**\n   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n   */\n  route?: HTTPRoute[];\n  /**\n   * Timeout for HTTP requests, default is disabled.\n   */\n  timeout?: string;\n}\n\n/**\n * Cross-Origin Resource Sharing policy (CORS).\n */\nexport interface CorsPolicy {\n  /**\n   * Indicates whether the caller is allowed to send the actual request (not the preflight)\n   * using credentials.\n   */\n  allowCredentials?: boolean;\n  /**\n   * List of HTTP headers that can be used when requesting the resource.\n   */\n  allowHeaders?: string[];\n  /**\n   * List of HTTP methods allowed to access the resource.\n   */\n  allowMethods?: string[];\n  allowOrigin?: string[];\n  /**\n   * String patterns that match allowed origins.\n   */\n  allowOrigins?: AllowOrigin[];\n  /**\n   * A list of HTTP headers that the browsers are allowed to access.\n   */\n  exposeHeaders?: string[];\n  /**\n   * Specifies how long the results of a preflight request can be cached.\n   */\n  maxAge?: string;\n}\n\nexport interface AllowOrigin {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Delegate is used to specify the particular VirtualService which can be used to define\n * delegate HTTPRoute.\n */\nexport interface Delegate {\n  /**\n   * Name specifies the name of the delegate VirtualService.\n   */\n  name?: string;\n  /**\n   * Namespace specifies the namespace where the delegate VirtualService resides.\n   */\n  namespace?: string;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface DirectResponse {\n  /**\n   * Specifies the content of the response body.\n   */\n  body?: Body;\n  /**\n   * Specifies the HTTP response status to be returned.\n   */\n  status?: number;\n}\n\n/**\n * Specifies the content of the response body.\n */\nexport interface Body {\n  /**\n   * response body as base64 encoded bytes.\n   */\n  bytes?: string;\n  string?: string;\n}\n\n/**\n * Fault injection policy to apply on HTTP traffic at the client side.\n */\nexport interface Fault {\n  /**\n   * Abort Http request attempts and return error codes back to downstream service, giving the\n   * impression that the upstream service is faulty.\n   */\n  abort?: Abort;\n  /**\n   * Delay requests before forwarding, emulating various failures such as network issues,\n   * overloaded upstream service, etc.\n   */\n  delay?: Delay;\n}\n\n/**\n * Abort Http request attempts and return error codes back to downstream service, giving the\n * impression that the upstream service is faulty.\n */\nexport interface Abort {\n  /**\n   * GRPC status code to use to abort the request.\n   */\n  grpcStatus?: string;\n  http2Error?: string;\n  /**\n   * HTTP status code to use to abort the Http request.\n   */\n  httpStatus?: number;\n  /**\n   * Percentage of requests to be aborted with the error code provided.\n   */\n  percentage?: AbortPercentage;\n}\n\n/**\n * Percentage of requests to be aborted with the error code provided.\n */\nexport interface AbortPercentage {\n  value?: number;\n}\n\n/**\n * Delay requests before forwarding, emulating various failures such as network issues,\n * overloaded upstream service, etc.\n */\nexport interface Delay {\n  exponentialDelay?: string;\n  /**\n   * Add a fixed delay before forwarding the request.\n   */\n  fixedDelay?: string;\n  /**\n   * Percentage of requests on which the delay will be injected (0-100).\n   */\n  percent?: number;\n  /**\n   * Percentage of requests on which the delay will be injected.\n   */\n  percentage?: DelayPercentage;\n}\n\n/**\n * Percentage of requests on which the delay will be injected.\n */\nexport interface DelayPercentage {\n  value?: number;\n}\n\nexport interface HTTPHeaders {\n  request?: PurpleRequest;\n  response?: PurpleResponse;\n}\n\nexport interface PurpleRequest {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface PurpleResponse {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface HTTPMatch {\n  /**\n   * HTTP Authority values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  authority?: Authority;\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * The header keys must be lowercase and use hyphen as the separator, e.g.\n   */\n  headers?: { [key: string]: Header };\n  /**\n   * Flag to specify whether the URI matching should be case-insensitive.\n   */\n  ignoreUriCase?: boolean;\n  /**\n   * HTTP Method values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  method?: Method;\n  /**\n   * The name assigned to a match.\n   */\n  name?: string;\n  /**\n   * Specifies the ports on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * Query parameters for matching.\n   */\n  queryParams?: { [key: string]: QueryParam };\n  /**\n   * URI Scheme values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  scheme?: Scheme;\n  /**\n   * One or more labels that constrain the applicability of a rule to source (client)\n   * workloads with the given labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n  /**\n   * The human readable prefix to use when emitting statistics for this route.\n   */\n  statPrefix?: string;\n  /**\n   * URI to match values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n   * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n   * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  uri?: URI;\n  /**\n   * withoutHeader has the same syntax with the header, but has opposite meaning.\n   */\n  withoutHeaders?: { [key: string]: WithoutHeader };\n}\n\n/**\n * HTTP Authority values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Authority {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface Header {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * HTTP Method values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Method {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface QueryParam {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * URI Scheme values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface Scheme {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * URI to match values are case-sensitive and formatted as follows: - `exact: \"value\"` for\n * exact string match - `prefix: \"value\"` for prefix-based match - `regex: \"value\"` for RE2\n * style regex-based match (https://github.com/google/re2/wiki/Syntax).\n */\nexport interface URI {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\nexport interface WithoutHeader {\n  exact?: string;\n  prefix?: string;\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  regex?: string;\n}\n\n/**\n * Mirror HTTP traffic to a another destination in addition to forwarding the requests to\n * the intended destination.\n */\nexport interface PurpleMirror {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: MirrorPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface MirrorPort {\n  number?: number;\n}\n\n/**\n * Percentage of the traffic to be mirrored by the `mirror` field.\n */\nexport interface MirrorPercentageObject {\n  value?: number;\n}\n\nexport interface MirrorElement {\n  /**\n   * Destination specifies the target of the mirror operation.\n   */\n  destination?: MirrorDestination;\n  /**\n   * Percentage of the traffic to be mirrored by the `destination` field.\n   */\n  percentage?: MirrorPercentage;\n}\n\n/**\n * Destination specifies the target of the mirror operation.\n */\nexport interface MirrorDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: PurplePort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface PurplePort {\n  number?: number;\n}\n\n/**\n * Percentage of the traffic to be mirrored by the `destination` field.\n */\nexport interface MirrorPercentage {\n  value?: number;\n}\n\n/**\n * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\n */\nexport interface Redirect {\n  /**\n   * On a redirect, overwrite the Authority/Host portion of the URL with this value.\n   */\n  authority?: string;\n  /**\n   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n   * for HTTP and 443 for HTTPS.\n   */\n  derivePort?: DerivePort;\n  /**\n   * On a redirect, overwrite the port portion of the URL with this value.\n   */\n  port?: number;\n  /**\n   * On a redirect, Specifies the HTTP status code to use in the redirect response.\n   */\n  redirectCode?: number;\n  /**\n   * On a redirect, overwrite the scheme portion of the URL with this value.\n   */\n  scheme?: string;\n  /**\n   * On a redirect, overwrite the Path portion of the URL with this value.\n   */\n  uri?: string;\n}\n\n/**\n * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80\n * for HTTP and 443 for HTTPS.\n */\nexport enum DerivePort {\n  FromProtocolDefault = \"FROM_PROTOCOL_DEFAULT\",\n  FromRequestPort = \"FROM_REQUEST_PORT\",\n}\n\n/**\n * Retry policy for HTTP requests.\n */\nexport interface Retries {\n  /**\n   * Number of retries to be allowed for a given request.\n   */\n  attempts?: number;\n  /**\n   * Timeout per attempt for a given request, including the initial call and any retries.\n   */\n  perTryTimeout?: string;\n  /**\n   * Specifies the conditions under which retry takes place.\n   */\n  retryOn?: string;\n  /**\n   * Flag to specify whether the retries should retry to other localities.\n   */\n  retryRemoteLocalities?: boolean;\n}\n\n/**\n * Rewrite HTTP URIs and Authority headers.\n */\nexport interface Rewrite {\n  /**\n   * rewrite the Authority/Host header with this value.\n   */\n  authority?: string;\n  /**\n   * rewrite the path (or the prefix) portion of the URI with this value.\n   */\n  uri?: string;\n  /**\n   * rewrite the path portion of the URI with the specified regex.\n   */\n  uriRegexRewrite?: URIRegexRewrite;\n}\n\n/**\n * rewrite the path portion of the URI with the specified regex.\n */\nexport interface URIRegexRewrite {\n  /**\n   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\n   */\n  match?: string;\n  /**\n   * The string that should replace into matching portions of original URI.\n   */\n  rewrite?: string;\n}\n\nexport interface HTTPRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: PurpleDestination;\n  headers?: RouteHeaders;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface PurpleDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: FluffyPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface FluffyPort {\n  number?: number;\n}\n\nexport interface RouteHeaders {\n  request?: FluffyRequest;\n  response?: FluffyResponse;\n}\n\nexport interface FluffyRequest {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface FluffyResponse {\n  add?: { [key: string]: string };\n  remove?: string[];\n  set?: { [key: string]: string };\n}\n\nexport interface TCP {\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: TCPMatch[];\n  /**\n   * The destination to which the connection should be forwarded to.\n   */\n  route?: TCPRoute[];\n}\n\nexport interface TCPMatch {\n  /**\n   * IPv4 or IPv6 ip addresses of destination with optional subnet.\n   */\n  destinationSubnets?: string[];\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * One or more labels that constrain the applicability of a rule to workloads with the given\n   * labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n  sourceSubnet?: string;\n}\n\nexport interface TCPRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: FluffyDestination;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface FluffyDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: TentacledPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface TentacledPort {\n  number?: number;\n}\n\nexport interface Tl {\n  /**\n   * Match conditions to be satisfied for the rule to be activated.\n   */\n  match?: TlMatch[];\n  /**\n   * The destination to which the connection should be forwarded to.\n   */\n  route?: TlRoute[];\n}\n\nexport interface TlMatch {\n  /**\n   * IPv4 or IPv6 ip addresses of destination with optional subnet.\n   */\n  destinationSubnets?: string[];\n  /**\n   * Names of gateways where the rule should be applied.\n   */\n  gateways?: string[];\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: number;\n  /**\n   * SNI (server name indicator) to match on.\n   */\n  sniHosts?: string[];\n  /**\n   * One or more labels that constrain the applicability of a rule to workloads with the given\n   * labels.\n   */\n  sourceLabels?: { [key: string]: string };\n  /**\n   * Source namespace constraining the applicability of a rule to workloads in that namespace.\n   */\n  sourceNamespace?: string;\n}\n\nexport interface TlRoute {\n  /**\n   * Destination uniquely identifies the instances of a service to which the\n   * request/connection should be forwarded to.\n   */\n  destination?: TentacledDestination;\n  /**\n   * Weight specifies the relative proportion of traffic to be forwarded to the destination.\n   */\n  weight?: number;\n}\n\n/**\n * Destination uniquely identifies the instances of a service to which the\n * request/connection should be forwarded to.\n */\nexport interface TentacledDestination {\n  /**\n   * The name of a service from the service registry.\n   */\n  host?: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: StickyPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface StickyPort {\n  number?: number;\n}\n\nRegisterKind(VirtualService, {\n  group: \"networking.istio.io\",\n  version: \"v1beta1\",\n  kind: \"VirtualService\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class ServiceEntry extends GenericKind {\n  /**\n   * Configuration affecting service registry. See more details at:\n   * https://istio.io/docs/reference/config/networking/service-entry.html\n   */\n  spec?: Spec;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  status?: { [key: string]: any };\n}\n\n/**\n * Configuration affecting service registry. See more details at:\n * https://istio.io/docs/reference/config/networking/service-entry.html\n */\nexport interface Spec {\n  /**\n   * The virtual IP addresses associated with the service.\n   */\n  addresses?: string[];\n  /**\n   * One or more endpoints associated with the service.\n   */\n  endpoints?: Endpoint[];\n  /**\n   * A list of namespaces to which this service is exported.\n   */\n  exportTo?: string[];\n  /**\n   * The hosts associated with the ServiceEntry.\n   */\n  hosts: string[];\n  /**\n   * Specify whether the service should be considered external to the mesh or part of the mesh.\n   */\n  location?: Location;\n  /**\n   * The ports associated with the external service.\n   */\n  ports?: Port[];\n  /**\n   * Service resolution mode for the hosts.\n   */\n  resolution?: Resolution;\n  /**\n   * If specified, the proxy will verify that the server certificate's subject alternate name\n   * matches one of the specified values.\n   */\n  subjectAltNames?: string[];\n  /**\n   * Applicable only for MESH_INTERNAL services.\n   */\n  workloadSelector?: WorkloadSelector;\n}\n\nexport interface Endpoint {\n  /**\n   * Address associated with the network endpoint without the port.\n   */\n  address?: string;\n  /**\n   * One or more labels associated with the endpoint.\n   */\n  labels?: { [key: string]: string };\n  /**\n   * The locality associated with the endpoint.\n   */\n  locality?: string;\n  /**\n   * Network enables Istio to group endpoints resident in the same L3 domain/network.\n   */\n  network?: string;\n  /**\n   * Set of ports associated with the endpoint.\n   */\n  ports?: { [key: string]: number };\n  /**\n   * The service account associated with the workload if a sidecar is present in the workload.\n   */\n  serviceAccount?: string;\n  /**\n   * The load balancing weight associated with the endpoint.\n   */\n  weight?: number;\n}\n\n/**\n * Specify whether the service should be considered external to the mesh or part of the mesh.\n */\nexport enum Location {\n  MeshExternal = \"MESH_EXTERNAL\",\n  MeshInternal = \"MESH_INTERNAL\",\n}\n\nexport interface Port {\n  /**\n   * Label assigned to the port.\n   */\n  name: string;\n  /**\n   * A valid non-negative integer port number.\n   */\n  number: number;\n  /**\n   * The protocol exposed on the port.\n   */\n  protocol?: string;\n  /**\n   * The port number on the endpoint where the traffic will be received.\n   */\n  targetPort?: number;\n}\n\n/**\n * Service resolution mode for the hosts.\n */\nexport enum Resolution {\n  DNS = \"DNS\",\n  DNSRoundRobin = \"DNS_ROUND_ROBIN\",\n  None = \"NONE\",\n  Static = \"STATIC\",\n}\n\n/**\n * Applicable only for MESH_INTERNAL services.\n */\nexport interface WorkloadSelector {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which the configuration\n   * should be applied.\n   */\n  labels?: { [key: string]: string };\n}\n\nRegisterKind(ServiceEntry, {\n  group: \"networking.istio.io\",\n  version: \"v1beta1\",\n  kind: \"ServiceEntry\",\n  plural: \"serviceentries\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n/**\n * The `PodMonitor` custom resource definition (CRD) defines how `Prometheus` and\n * `PrometheusAgent` can scrape metrics from a group of pods.\n * Among other things, it allows to specify:\n * * The pods to scrape via label selectors.\n * * The container ports to scrape.\n * * Authentication credentials to use.\n * * Target and metric relabeling.\n *\n * `Prometheus` and `PrometheusAgent` objects select `PodMonitor` objects using label and\n * namespace selectors.\n */\nexport class PodMonitor extends GenericKind {\n  /**\n   * APIVersion defines the versioned schema of this representation of an object.\n   * Servers should convert recognized schemas to the latest internal value, and\n   * may reject unrecognized values.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n   */\n  declare apiVersion?: string;\n  /**\n   * Kind is a string value representing the REST resource this object represents.\n   * Servers may infer this from the endpoint the client submits requests to.\n   * Cannot be updated.\n   * In CamelCase.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n   */\n  declare kind?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  declare metadata?: { [key: string]: any };\n  /**\n   * Specification of desired Pod selection for target discovery by Prometheus.\n   */\n  spec?: Spec;\n}\n\n/**\n * Specification of desired Pod selection for target discovery by Prometheus.\n */\nexport interface Spec {\n  /**\n   * `attachMetadata` defines additional metadata which is added to the\n   * discovered targets.\n   *\n   * It requires Prometheus >= v2.35.0.\n   */\n  attachMetadata?: AttachMetadata;\n  /**\n   * When defined, bodySizeLimit specifies a job level limit on the size\n   * of uncompressed response body that will be accepted by Prometheus.\n   *\n   * It requires Prometheus >= v2.28.0.\n   */\n  bodySizeLimit?: string;\n  /**\n   * Whether to convert all scraped classic histograms into a native histogram with custom\n   * buckets.\n   * It requires Prometheus >= v3.0.0.\n   */\n  convertClassicHistogramsToNHCB?: boolean;\n  /**\n   * The protocol to use if a scrape returns blank, unparseable, or otherwise invalid\n   * Content-Type.\n   *\n   * It requires Prometheus >= v3.0.0.\n   */\n  fallbackScrapeProtocol?: FallbackScrapeProtocol;\n  /**\n   * The label to use to retrieve the job name from.\n   * `jobLabel` selects the label from the associated Kubernetes `Pod`\n   * object which will be used as the `job` label for all metrics.\n   *\n   * For example if `jobLabel` is set to `foo` and the Kubernetes `Pod`\n   * object is labeled with `foo: bar`, then Prometheus adds the `job=\"bar\"`\n   * label to all ingested metrics.\n   *\n   * If the value of this field is empty, the `job` label of the metrics\n   * defaults to the namespace and name of the PodMonitor object (e.g. `<namespace>/<name>`).\n   */\n  jobLabel?: string;\n  /**\n   * Per-scrape limit on the number of targets dropped by relabeling\n   * that will be kept in memory. 0 means no limit.\n   *\n   * It requires Prometheus >= v2.47.0.\n   */\n  keepDroppedTargets?: number;\n  /**\n   * Per-scrape limit on number of labels that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelLimit?: number;\n  /**\n   * Per-scrape limit on length of labels name that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelNameLengthLimit?: number;\n  /**\n   * Per-scrape limit on length of labels value that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelValueLengthLimit?: number;\n  /**\n   * `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.\n   * By default, the pods are discovered in the same namespace as the `PodMonitor` object but\n   * it is possible to select pods across different/all namespaces.\n   */\n  namespaceSelector?: NamespaceSelector;\n  /**\n   * If there are more than this many buckets in a native histogram,\n   * buckets will be merged to stay within the limit.\n   * It requires Prometheus >= v2.45.0.\n   */\n  nativeHistogramBucketLimit?: number;\n  /**\n   * If the growth factor of one bucket to the next is smaller than this,\n   * buckets will be merged to increase the factor sufficiently.\n   * It requires Prometheus >= v2.50.0.\n   */\n  nativeHistogramMinBucketFactor?: number | string;\n  /**\n   * Defines how to scrape metrics from the selected pods.\n   */\n  podMetricsEndpoints?: PodMetricsEndpoint[];\n  /**\n   * `podTargetLabels` defines the labels which are transferred from the\n   * associated Kubernetes `Pod` object onto the ingested metrics.\n   */\n  podTargetLabels?: string[];\n  /**\n   * `sampleLimit` defines a per-scrape limit on the number of scraped samples\n   * that will be accepted.\n   */\n  sampleLimit?: number;\n  /**\n   * The scrape class to apply.\n   */\n  scrapeClass?: string;\n  /**\n   * Whether to scrape a classic histogram that is also exposed as a native histogram.\n   * It requires Prometheus >= v2.45.0.\n   *\n   * Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms`\n   * field in the Prometheus configuration.\n   */\n  scrapeClassicHistograms?: boolean;\n  /**\n   * `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients\n   * the\n   * protocols supported by Prometheus in order of preference (from most to least preferred).\n   *\n   * If unset, Prometheus uses its default value.\n   *\n   * It requires Prometheus >= v2.49.0.\n   */\n  scrapeProtocols?: FallbackScrapeProtocol[];\n  /**\n   * Label selector to select the Kubernetes `Pod` objects to scrape metrics from.\n   */\n  selector: Selector;\n  /**\n   * Mechanism used to select the endpoints to scrape.\n   * By default, the selection process relies on relabel configurations to filter the\n   * discovered targets.\n   * Alternatively, you can opt in for role selectors, which may offer better efficiency in\n   * large clusters.\n   * Which strategy is best for your use case needs to be carefully evaluated.\n   *\n   * It requires Prometheus >= v2.17.0.\n   */\n  selectorMechanism?: SelectorMechanism;\n  /**\n   * `targetLimit` defines a limit on the number of scraped targets that will\n   * be accepted.\n   */\n  targetLimit?: number;\n}\n\n/**\n * `attachMetadata` defines additional metadata which is added to the\n * discovered targets.\n *\n * It requires Prometheus >= v2.35.0.\n */\nexport interface AttachMetadata {\n  /**\n   * When set to true, Prometheus attaches node metadata to the discovered\n   * targets.\n   *\n   * The Prometheus service account must have the `list` and `watch`\n   * permissions on the `Nodes` objects.\n   */\n  node?: boolean;\n}\n\n/**\n * The protocol to use if a scrape returns blank, unparseable, or otherwise invalid\n * Content-Type.\n *\n * It requires Prometheus >= v3.0.0.\n *\n * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.\n * Supported values are:\n * * `OpenMetricsText0.0.1`\n * * `OpenMetricsText1.0.0`\n * * `PrometheusProto`\n * * `PrometheusText0.0.4`\n * * `PrometheusText1.0.0`\n */\nexport enum FallbackScrapeProtocol {\n  OpenMetricsText001 = \"OpenMetricsText0.0.1\",\n  OpenMetricsText100 = \"OpenMetricsText1.0.0\",\n  PrometheusProto = \"PrometheusProto\",\n  PrometheusText004 = \"PrometheusText0.0.4\",\n  PrometheusText100 = \"PrometheusText1.0.0\",\n}\n\n/**\n * `namespaceSelector` defines in which namespace(s) Prometheus should discover the pods.\n * By default, the pods are discovered in the same namespace as the `PodMonitor` object but\n * it is possible to select pods across different/all namespaces.\n */\nexport interface NamespaceSelector {\n  /**\n   * Boolean describing whether all namespaces are selected in contrast to a\n   * list restricting them.\n   */\n  any?: boolean;\n  /**\n   * List of namespace names to select from.\n   */\n  matchNames?: string[];\n}\n\n/**\n * PodMetricsEndpoint defines an endpoint serving Prometheus metrics to be scraped by\n * Prometheus.\n */\nexport interface PodMetricsEndpoint {\n  /**\n   * `authorization` configures the Authorization header credentials to use when\n   * scraping the target.\n   *\n   * Cannot be set at the same time as `basicAuth`, or `oauth2`.\n   */\n  authorization?: Authorization;\n  /**\n   * `basicAuth` configures the Basic Authentication credentials to use when\n   * scraping the target.\n   *\n   * Cannot be set at the same time as `authorization`, or `oauth2`.\n   */\n  basicAuth?: BasicAuth;\n  /**\n   * `bearerTokenSecret` specifies a key of a Secret containing the bearer\n   * token for scraping targets. The secret needs to be in the same namespace\n   * as the PodMonitor object and readable by the Prometheus Operator.\n   *\n   * Deprecated: use `authorization` instead.\n   */\n  bearerTokenSecret?: BearerTokenSecret;\n  /**\n   * `enableHttp2` can be used to disable HTTP2 when scraping the target.\n   */\n  enableHttp2?: boolean;\n  /**\n   * When true, the pods which are not running (e.g. either in Failed or\n   * Succeeded state) are dropped during the target discovery.\n   *\n   * If unset, the filtering is enabled.\n   *\n   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase\n   */\n  filterRunning?: boolean;\n  /**\n   * `followRedirects` defines whether the scrape requests should follow HTTP\n   * 3xx redirects.\n   */\n  followRedirects?: boolean;\n  /**\n   * When true, `honorLabels` preserves the metric's labels when they collide\n   * with the target's labels.\n   */\n  honorLabels?: boolean;\n  /**\n   * `honorTimestamps` controls whether Prometheus preserves the timestamps\n   * when exposed by the target.\n   */\n  honorTimestamps?: boolean;\n  /**\n   * Interval at which Prometheus scrapes the metrics from the target.\n   *\n   * If empty, Prometheus uses the global scrape interval.\n   */\n  interval?: string;\n  /**\n   * `metricRelabelings` configures the relabeling rules to apply to the\n   * samples before ingestion.\n   */\n  metricRelabelings?: MetricRelabeling[];\n  /**\n   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names\n   * that should be excluded from proxying. IP and domain names can\n   * contain port numbers.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  noProxy?: string;\n  /**\n   * `oauth2` configures the OAuth2 settings to use when scraping the target.\n   *\n   * It requires Prometheus >= 2.27.0.\n   *\n   * Cannot be set at the same time as `authorization`, or `basicAuth`.\n   */\n  oauth2?: Oauth2;\n  /**\n   * `params` define optional HTTP URL parameters.\n   */\n  params?: { [key: string]: string[] };\n  /**\n   * HTTP path from which to scrape for metrics.\n   *\n   * If empty, Prometheus uses the default value (e.g. `/metrics`).\n   */\n  path?: string;\n  /**\n   * The `Pod` port name which exposes the endpoint.\n   *\n   * It takes precedence over the `portNumber` and `targetPort` fields.\n   */\n  port?: string;\n  /**\n   * The `Pod` port number which exposes the endpoint.\n   */\n  portNumber?: number;\n  /**\n   * ProxyConnectHeader optionally specifies headers to send to\n   * proxies during CONNECT requests.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyConnectHeader?: { [key: string]: PodMetricsEndpointProxyConnectHeader[] };\n  /**\n   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY,\n   * HTTPS_PROXY, and NO_PROXY).\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyFromEnvironment?: boolean;\n  /**\n   * `proxyURL` defines the HTTP proxy server to use.\n   */\n  proxyUrl?: string;\n  /**\n   * `relabelings` configures the relabeling rules to apply the target's\n   * metadata labels.\n   *\n   * The Operator automatically adds relabelings for a few standard Kubernetes fields.\n   *\n   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.\n   *\n   * More info:\n   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n   */\n  relabelings?: Relabeling[];\n  /**\n   * HTTP scheme to use for scraping.\n   *\n   * `http` and `https` are the expected values unless you rewrite the\n   * `__scheme__` label via relabeling.\n   *\n   * If empty, Prometheus uses the default value `http`.\n   */\n  scheme?: Scheme;\n  /**\n   * Timeout after which Prometheus considers the scrape to be failed.\n   *\n   * If empty, Prometheus uses the global scrape timeout unless it is less\n   * than the target's scrape interval value in which the latter is used.\n   * The value cannot be greater than the scrape interval otherwise the operator will reject\n   * the resource.\n   */\n  scrapeTimeout?: string;\n  /**\n   * Name or number of the target port of the `Pod` object behind the Service, the\n   * port must be specified with container port property.\n   *\n   * Deprecated: use 'port' or 'portNumber' instead.\n   */\n  targetPort?: number | string;\n  /**\n   * TLS configuration to use when scraping the target.\n   */\n  tlsConfig?: PodMetricsEndpointTLSConfig;\n  /**\n   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of\n   * the metrics that have an explicit timestamp present in scraped data.\n   * Has no effect if `honorTimestamps` is false.\n   *\n   * It requires Prometheus >= v2.48.0.\n   */\n  trackTimestampsStaleness?: boolean;\n}\n\n/**\n * `authorization` configures the Authorization header credentials to use when\n * scraping the target.\n *\n * Cannot be set at the same time as `basicAuth`, or `oauth2`.\n */\nexport interface Authorization {\n  /**\n   * Selects a key of a Secret in the namespace that contains the credentials for\n   * authentication.\n   */\n  credentials?: Credentials;\n  /**\n   * Defines the authentication type. The value is case-insensitive.\n   *\n   * \"Basic\" is not a supported value.\n   *\n   * Default: \"Bearer\"\n   */\n  type?: string;\n}\n\n/**\n * Selects a key of a Secret in the namespace that contains the credentials for\n * authentication.\n */\nexport interface Credentials {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `basicAuth` configures the Basic Authentication credentials to use when\n * scraping the target.\n *\n * Cannot be set at the same time as `authorization`, or `oauth2`.\n */\nexport interface BasicAuth {\n  /**\n   * `password` specifies a key of a Secret containing the password for\n   * authentication.\n   */\n  password?: Password;\n  /**\n   * `username` specifies a key of a Secret containing the username for\n   * authentication.\n   */\n  username?: Username;\n}\n\n/**\n * `password` specifies a key of a Secret containing the password for\n * authentication.\n */\nexport interface Password {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `username` specifies a key of a Secret containing the username for\n * authentication.\n */\nexport interface Username {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `bearerTokenSecret` specifies a key of a Secret containing the bearer\n * token for scraping targets. The secret needs to be in the same namespace\n * as the PodMonitor object and readable by the Prometheus Operator.\n *\n * Deprecated: use `authorization` instead.\n */\nexport interface BearerTokenSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,\n * scraped samples and remote write samples.\n *\n * More info:\n * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n */\nexport interface MetricRelabeling {\n  /**\n   * Action to perform based on the regex matching.\n   *\n   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n   *\n   * Default: \"Replace\"\n   */\n  action?: Action;\n  /**\n   * Modulus to take of the hash of the source label values.\n   *\n   * Only applicable when the action is `HashMod`.\n   */\n  modulus?: number;\n  /**\n   * Regular expression against which the extracted value is matched.\n   */\n  regex?: string;\n  /**\n   * Replacement value against which a Replace action is performed if the\n   * regular expression matches.\n   *\n   * Regex capture groups are available.\n   */\n  replacement?: string;\n  /**\n   * Separator is the string between concatenated SourceLabels.\n   */\n  separator?: string;\n  /**\n   * The source labels select values from existing labels. Their content is\n   * concatenated using the configured Separator and matched against the\n   * configured regular expression.\n   */\n  sourceLabels?: string[];\n  /**\n   * Label to which the resulting string is written in a replacement.\n   *\n   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,\n   * `KeepEqual` and `DropEqual` actions.\n   *\n   * Regex capture groups are available.\n   */\n  targetLabel?: string;\n}\n\n/**\n * Action to perform based on the regex matching.\n *\n * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n *\n * Default: \"Replace\"\n */\nexport enum Action {\n  ActionDrop = \"Drop\",\n  ActionKeep = \"Keep\",\n  ActionLowercase = \"Lowercase\",\n  ActionReplace = \"Replace\",\n  ActionUppercase = \"Uppercase\",\n  Drop = \"drop\",\n  DropEqual = \"DropEqual\",\n  Dropequal = \"dropequal\",\n  HashMod = \"HashMod\",\n  Hashmod = \"hashmod\",\n  Keep = \"keep\",\n  KeepEqual = \"KeepEqual\",\n  Keepequal = \"keepequal\",\n  LabelDrop = \"LabelDrop\",\n  LabelKeep = \"LabelKeep\",\n  LabelMap = \"LabelMap\",\n  Labeldrop = \"labeldrop\",\n  Labelkeep = \"labelkeep\",\n  Labelmap = \"labelmap\",\n  Lowercase = \"lowercase\",\n  Replace = \"replace\",\n  Uppercase = \"uppercase\",\n}\n\n/**\n * `oauth2` configures the OAuth2 settings to use when scraping the target.\n *\n * It requires Prometheus >= 2.27.0.\n *\n * Cannot be set at the same time as `authorization`, or `basicAuth`.\n */\nexport interface Oauth2 {\n  /**\n   * `clientId` specifies a key of a Secret or ConfigMap containing the\n   * OAuth2 client's ID.\n   */\n  clientId: ClientID;\n  /**\n   * `clientSecret` specifies a key of a Secret containing the OAuth2\n   * client's secret.\n   */\n  clientSecret: ClientSecret;\n  /**\n   * `endpointParams` configures the HTTP parameters to append to the token\n   * URL.\n   */\n  endpointParams?: { [key: string]: string };\n  /**\n   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names\n   * that should be excluded from proxying. IP and domain names can\n   * contain port numbers.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  noProxy?: string;\n  /**\n   * ProxyConnectHeader optionally specifies headers to send to\n   * proxies during CONNECT requests.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyConnectHeader?: { [key: string]: Oauth2ProxyConnectHeader[] };\n  /**\n   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY,\n   * HTTPS_PROXY, and NO_PROXY).\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyFromEnvironment?: boolean;\n  /**\n   * `proxyURL` defines the HTTP proxy server to use.\n   */\n  proxyUrl?: string;\n  /**\n   * `scopes` defines the OAuth2 scopes used for the token request.\n   */\n  scopes?: string[];\n  /**\n   * TLS configuration to use when connecting to the OAuth2 server.\n   * It requires Prometheus >= v2.43.0.\n   */\n  tlsConfig?: Oauth2TLSConfig;\n  /**\n   * `tokenURL` configures the URL to fetch the token from.\n   */\n  tokenUrl: string;\n}\n\n/**\n * `clientId` specifies a key of a Secret or ConfigMap containing the\n * OAuth2 client's ID.\n */\nexport interface ClientID {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: ClientIDConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: ClientIDSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface ClientIDConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface ClientIDSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `clientSecret` specifies a key of a Secret containing the OAuth2\n * client's secret.\n */\nexport interface ClientSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * SecretKeySelector selects a key of a Secret.\n */\nexport interface Oauth2ProxyConnectHeader {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * TLS configuration to use when connecting to the OAuth2 server.\n * It requires Prometheus >= v2.43.0.\n */\nexport interface Oauth2TLSConfig {\n  /**\n   * Certificate authority used when verifying server certificates.\n   */\n  ca?: PurpleCA;\n  /**\n   * Client certificate to present when doing client-authentication.\n   */\n  cert?: PurpleCERT;\n  /**\n   * Disable target certificate validation.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Secret containing the client key file for the targets.\n   */\n  keySecret?: PurpleKeySecret;\n  /**\n   * Maximum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n   */\n  maxVersion?: Version;\n  /**\n   * Minimum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n   */\n  minVersion?: Version;\n  /**\n   * Used to verify the hostname for the targets.\n   */\n  serverName?: string;\n}\n\n/**\n * Certificate authority used when verifying server certificates.\n */\nexport interface PurpleCA {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: PurpleConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: PurpleSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface PurpleConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface PurpleSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Client certificate to present when doing client-authentication.\n */\nexport interface PurpleCERT {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: FluffyConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: FluffySecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface FluffyConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface FluffySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing the client key file for the targets.\n */\nexport interface PurpleKeySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Maximum acceptable TLS version.\n *\n * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n *\n * Minimum acceptable TLS version.\n *\n * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n */\nexport enum Version {\n  Tls10 = \"TLS10\",\n  Tls11 = \"TLS11\",\n  Tls12 = \"TLS12\",\n  Tls13 = \"TLS13\",\n}\n\n/**\n * SecretKeySelector selects a key of a Secret.\n */\nexport interface PodMetricsEndpointProxyConnectHeader {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,\n * scraped samples and remote write samples.\n *\n * More info:\n * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n */\nexport interface Relabeling {\n  /**\n   * Action to perform based on the regex matching.\n   *\n   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n   *\n   * Default: \"Replace\"\n   */\n  action?: Action;\n  /**\n   * Modulus to take of the hash of the source label values.\n   *\n   * Only applicable when the action is `HashMod`.\n   */\n  modulus?: number;\n  /**\n   * Regular expression against which the extracted value is matched.\n   */\n  regex?: string;\n  /**\n   * Replacement value against which a Replace action is performed if the\n   * regular expression matches.\n   *\n   * Regex capture groups are available.\n   */\n  replacement?: string;\n  /**\n   * Separator is the string between concatenated SourceLabels.\n   */\n  separator?: string;\n  /**\n   * The source labels select values from existing labels. Their content is\n   * concatenated using the configured Separator and matched against the\n   * configured regular expression.\n   */\n  sourceLabels?: string[];\n  /**\n   * Label to which the resulting string is written in a replacement.\n   *\n   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,\n   * `KeepEqual` and `DropEqual` actions.\n   *\n   * Regex capture groups are available.\n   */\n  targetLabel?: string;\n}\n\n/**\n * HTTP scheme to use for scraping.\n *\n * `http` and `https` are the expected values unless you rewrite the\n * `__scheme__` label via relabeling.\n *\n * If empty, Prometheus uses the default value `http`.\n */\nexport enum Scheme {\n  HTTP = \"http\",\n  HTTPS = \"https\",\n}\n\n/**\n * TLS configuration to use when scraping the target.\n */\nexport interface PodMetricsEndpointTLSConfig {\n  /**\n   * Certificate authority used when verifying server certificates.\n   */\n  ca?: FluffyCA;\n  /**\n   * Client certificate to present when doing client-authentication.\n   */\n  cert?: FluffyCERT;\n  /**\n   * Disable target certificate validation.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Secret containing the client key file for the targets.\n   */\n  keySecret?: FluffyKeySecret;\n  /**\n   * Maximum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n   */\n  maxVersion?: Version;\n  /**\n   * Minimum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n   */\n  minVersion?: Version;\n  /**\n   * Used to verify the hostname for the targets.\n   */\n  serverName?: string;\n}\n\n/**\n * Certificate authority used when verifying server certificates.\n */\nexport interface FluffyCA {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: TentacledConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: TentacledSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface TentacledConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface TentacledSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Client certificate to present when doing client-authentication.\n */\nexport interface FluffyCERT {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: StickyConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: StickySecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface StickyConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface StickySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing the client key file for the targets.\n */\nexport interface FluffyKeySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Label selector to select the Kubernetes `Pod` objects to scrape metrics from.\n */\nexport interface Selector {\n  /**\n   * matchExpressions is a list of label selector requirements. The requirements are ANDed.\n   */\n  matchExpressions?: MatchExpression[];\n  /**\n   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n   * map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n   * operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\n/**\n * A label selector requirement is a selector that contains values, a key, and an operator\n * that\n * relates the key and values.\n */\nexport interface MatchExpression {\n  /**\n   * key is the label key that the selector applies to.\n   */\n  key: string;\n  /**\n   * operator represents a key's relationship to a set of values.\n   * Valid operators are In, NotIn, Exists and DoesNotExist.\n   */\n  operator: string;\n  /**\n   * values is an array of string values. If the operator is In or NotIn,\n   * the values array must be non-empty. If the operator is Exists or DoesNotExist,\n   * the values array must be empty. This array is replaced during a strategic\n   * merge patch.\n   */\n  values?: string[];\n}\n\n/**\n * Mechanism used to select the endpoints to scrape.\n * By default, the selection process relies on relabel configurations to filter the\n * discovered targets.\n * Alternatively, you can opt in for role selectors, which may offer better efficiency in\n * large clusters.\n * Which strategy is best for your use case needs to be carefully evaluated.\n *\n * It requires Prometheus >= v2.17.0.\n */\nexport enum SelectorMechanism {\n  RelabelConfig = \"RelabelConfig\",\n  RoleSelector = \"RoleSelector\",\n}\n\nRegisterKind(PodMonitor, {\n  group: \"monitoring.coreos.com\",\n  version: \"v1\",\n  kind: \"PodMonitor\",\n  plural: \"podmonitors\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n/**\n * The `ServiceMonitor` custom resource definition (CRD) defines how `Prometheus` and\n * `PrometheusAgent` can scrape metrics from a group of services.\n * Among other things, it allows to specify:\n * * The services to scrape via label selectors.\n * * The container ports to scrape.\n * * Authentication credentials to use.\n * * Target and metric relabeling.\n *\n * `Prometheus` and `PrometheusAgent` objects select `ServiceMonitor` objects using label\n * and namespace selectors.\n */\nexport class ServiceMonitor extends GenericKind {\n  /**\n   * APIVersion defines the versioned schema of this representation of an object.\n   * Servers should convert recognized schemas to the latest internal value, and\n   * may reject unrecognized values.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n   */\n  declare apiVersion?: string;\n  /**\n   * Kind is a string value representing the REST resource this object represents.\n   * Servers may infer this from the endpoint the client submits requests to.\n   * Cannot be updated.\n   * In CamelCase.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n   */\n  declare kind?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  declare metadata?: { [key: string]: any };\n  /**\n   * Specification of desired Service selection for target discovery by\n   * Prometheus.\n   */\n  spec?: Spec;\n  /**\n   * This Status subresource is under active development and is updated only when the\n   * \"StatusForConfigurationResources\" feature gate is enabled.\n   *\n   * Most recent observed status of the ServiceMonitor. Read-only.\n   * More info:\n   *\n   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n   */\n  status?: Status;\n}\n\n/**\n * Specification of desired Service selection for target discovery by\n * Prometheus.\n */\nexport interface Spec {\n  /**\n   * `attachMetadata` defines additional metadata which is added to the\n   * discovered targets.\n   *\n   * It requires Prometheus >= v2.37.0.\n   */\n  attachMetadata?: AttachMetadata;\n  /**\n   * When defined, bodySizeLimit specifies a job level limit on the size\n   * of uncompressed response body that will be accepted by Prometheus.\n   *\n   * It requires Prometheus >= v2.28.0.\n   */\n  bodySizeLimit?: string;\n  /**\n   * Whether to convert all scraped classic histograms into a native histogram with custom\n   * buckets.\n   * It requires Prometheus >= v3.0.0.\n   */\n  convertClassicHistogramsToNHCB?: boolean;\n  /**\n   * List of endpoints part of this ServiceMonitor.\n   * Defines how to scrape metrics from Kubernetes\n   * [Endpoints](https://kubernetes.io/docs/concepts/services-networking/service/#endpoints)\n   * objects.\n   * In most cases, an Endpoints object is backed by a Kubernetes\n   * [Service](https://kubernetes.io/docs/concepts/services-networking/service/) object with\n   * the same name and labels.\n   */\n  endpoints: Endpoint[];\n  /**\n   * The protocol to use if a scrape returns blank, unparseable, or otherwise invalid\n   * Content-Type.\n   *\n   * It requires Prometheus >= v3.0.0.\n   */\n  fallbackScrapeProtocol?: FallbackScrapeProtocol;\n  /**\n   * `jobLabel` selects the label from the associated Kubernetes `Service`\n   * object which will be used as the `job` label for all metrics.\n   *\n   * For example if `jobLabel` is set to `foo` and the Kubernetes `Service`\n   * object is labeled with `foo: bar`, then Prometheus adds the `job=\"bar\"`\n   * label to all ingested metrics.\n   *\n   * If the value of this field is empty or if the label doesn't exist for\n   * the given Service, the `job` label of the metrics defaults to the name\n   * of the associated Kubernetes `Service`.\n   */\n  jobLabel?: string;\n  /**\n   * Per-scrape limit on the number of targets dropped by relabeling\n   * that will be kept in memory. 0 means no limit.\n   *\n   * It requires Prometheus >= v2.47.0.\n   */\n  keepDroppedTargets?: number;\n  /**\n   * Per-scrape limit on number of labels that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelLimit?: number;\n  /**\n   * Per-scrape limit on length of labels name that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelNameLengthLimit?: number;\n  /**\n   * Per-scrape limit on length of labels value that will be accepted for a sample.\n   *\n   * It requires Prometheus >= v2.27.0.\n   */\n  labelValueLengthLimit?: number;\n  /**\n   * `namespaceSelector` defines in which namespace(s) Prometheus should discover the\n   * services.\n   * By default, the services are discovered in the same namespace as the `ServiceMonitor`\n   * object but it is possible to select pods across different/all namespaces.\n   */\n  namespaceSelector?: NamespaceSelector;\n  /**\n   * If there are more than this many buckets in a native histogram,\n   * buckets will be merged to stay within the limit.\n   * It requires Prometheus >= v2.45.0.\n   */\n  nativeHistogramBucketLimit?: number;\n  /**\n   * If the growth factor of one bucket to the next is smaller than this,\n   * buckets will be merged to increase the factor sufficiently.\n   * It requires Prometheus >= v2.50.0.\n   */\n  nativeHistogramMinBucketFactor?: number | string;\n  /**\n   * `podTargetLabels` defines the labels which are transferred from the\n   * associated Kubernetes `Pod` object onto the ingested metrics.\n   */\n  podTargetLabels?: string[];\n  /**\n   * `sampleLimit` defines a per-scrape limit on the number of scraped samples\n   * that will be accepted.\n   */\n  sampleLimit?: number;\n  /**\n   * The scrape class to apply.\n   */\n  scrapeClass?: string;\n  /**\n   * Whether to scrape a classic histogram that is also exposed as a native histogram.\n   * It requires Prometheus >= v2.45.0.\n   *\n   * Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms`\n   * field in the Prometheus configuration.\n   */\n  scrapeClassicHistograms?: boolean;\n  /**\n   * `scrapeProtocols` defines the protocols to negotiate during a scrape. It tells clients\n   * the\n   * protocols supported by Prometheus in order of preference (from most to least preferred).\n   *\n   * If unset, Prometheus uses its default value.\n   *\n   * It requires Prometheus >= v2.49.0.\n   */\n  scrapeProtocols?: FallbackScrapeProtocol[];\n  /**\n   * Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.\n   */\n  selector: Selector;\n  /**\n   * Mechanism used to select the endpoints to scrape.\n   * By default, the selection process relies on relabel configurations to filter the\n   * discovered targets.\n   * Alternatively, you can opt in for role selectors, which may offer better efficiency in\n   * large clusters.\n   * Which strategy is best for your use case needs to be carefully evaluated.\n   *\n   * It requires Prometheus >= v2.17.0.\n   */\n  selectorMechanism?: SelectorMechanism;\n  /**\n   * `targetLabels` defines the labels which are transferred from the\n   * associated Kubernetes `Service` object onto the ingested metrics.\n   */\n  targetLabels?: string[];\n  /**\n   * `targetLimit` defines a limit on the number of scraped targets that will\n   * be accepted.\n   */\n  targetLimit?: number;\n}\n\n/**\n * `attachMetadata` defines additional metadata which is added to the\n * discovered targets.\n *\n * It requires Prometheus >= v2.37.0.\n */\nexport interface AttachMetadata {\n  /**\n   * When set to true, Prometheus attaches node metadata to the discovered\n   * targets.\n   *\n   * The Prometheus service account must have the `list` and `watch`\n   * permissions on the `Nodes` objects.\n   */\n  node?: boolean;\n}\n\n/**\n * Endpoint defines an endpoint serving Prometheus metrics to be scraped by\n * Prometheus.\n */\nexport interface Endpoint {\n  /**\n   * `authorization` configures the Authorization header credentials to use when\n   * scraping the target.\n   *\n   * Cannot be set at the same time as `basicAuth`, or `oauth2`.\n   */\n  authorization?: Authorization;\n  /**\n   * `basicAuth` configures the Basic Authentication credentials to use when\n   * scraping the target.\n   *\n   * Cannot be set at the same time as `authorization`, or `oauth2`.\n   */\n  basicAuth?: BasicAuth;\n  /**\n   * File to read bearer token for scraping the target.\n   *\n   * Deprecated: use `authorization` instead.\n   */\n  bearerTokenFile?: string;\n  /**\n   * `bearerTokenSecret` specifies a key of a Secret containing the bearer\n   * token for scraping targets. The secret needs to be in the same namespace\n   * as the ServiceMonitor object and readable by the Prometheus Operator.\n   *\n   * Deprecated: use `authorization` instead.\n   */\n  bearerTokenSecret?: BearerTokenSecret;\n  /**\n   * `enableHttp2` can be used to disable HTTP2 when scraping the target.\n   */\n  enableHttp2?: boolean;\n  /**\n   * When true, the pods which are not running (e.g. either in Failed or\n   * Succeeded state) are dropped during the target discovery.\n   *\n   * If unset, the filtering is enabled.\n   *\n   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase\n   */\n  filterRunning?: boolean;\n  /**\n   * `followRedirects` defines whether the scrape requests should follow HTTP\n   * 3xx redirects.\n   */\n  followRedirects?: boolean;\n  /**\n   * When true, `honorLabels` preserves the metric's labels when they collide\n   * with the target's labels.\n   */\n  honorLabels?: boolean;\n  /**\n   * `honorTimestamps` controls whether Prometheus preserves the timestamps\n   * when exposed by the target.\n   */\n  honorTimestamps?: boolean;\n  /**\n   * Interval at which Prometheus scrapes the metrics from the target.\n   *\n   * If empty, Prometheus uses the global scrape interval.\n   */\n  interval?: string;\n  /**\n   * `metricRelabelings` configures the relabeling rules to apply to the\n   * samples before ingestion.\n   */\n  metricRelabelings?: MetricRelabeling[];\n  /**\n   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names\n   * that should be excluded from proxying. IP and domain names can\n   * contain port numbers.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  noProxy?: string;\n  /**\n   * `oauth2` configures the OAuth2 settings to use when scraping the target.\n   *\n   * It requires Prometheus >= 2.27.0.\n   *\n   * Cannot be set at the same time as `authorization`, or `basicAuth`.\n   */\n  oauth2?: Oauth2;\n  /**\n   * params define optional HTTP URL parameters.\n   */\n  params?: { [key: string]: string[] };\n  /**\n   * HTTP path from which to scrape for metrics.\n   *\n   * If empty, Prometheus uses the default value (e.g. `/metrics`).\n   */\n  path?: string;\n  /**\n   * Name of the Service port which this endpoint refers to.\n   *\n   * It takes precedence over `targetPort`.\n   */\n  port?: string;\n  /**\n   * ProxyConnectHeader optionally specifies headers to send to\n   * proxies during CONNECT requests.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyConnectHeader?: { [key: string]: EndpointProxyConnectHeader[] };\n  /**\n   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY,\n   * HTTPS_PROXY, and NO_PROXY).\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyFromEnvironment?: boolean;\n  /**\n   * `proxyURL` defines the HTTP proxy server to use.\n   */\n  proxyUrl?: string;\n  /**\n   * `relabelings` configures the relabeling rules to apply the target's\n   * metadata labels.\n   *\n   * The Operator automatically adds relabelings for a few standard Kubernetes fields.\n   *\n   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.\n   *\n   * More info:\n   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n   */\n  relabelings?: Relabeling[];\n  /**\n   * HTTP scheme to use for scraping.\n   *\n   * `http` and `https` are the expected values unless you rewrite the\n   * `__scheme__` label via relabeling.\n   *\n   * If empty, Prometheus uses the default value `http`.\n   */\n  scheme?: Scheme;\n  /**\n   * Timeout after which Prometheus considers the scrape to be failed.\n   *\n   * If empty, Prometheus uses the global scrape timeout unless it is less\n   * than the target's scrape interval value in which the latter is used.\n   * The value cannot be greater than the scrape interval otherwise the operator will reject\n   * the resource.\n   */\n  scrapeTimeout?: string;\n  /**\n   * Name or number of the target port of the `Pod` object behind the\n   * Service. The port must be specified with the container's port property.\n   */\n  targetPort?: number | string;\n  /**\n   * TLS configuration to use when scraping the target.\n   */\n  tlsConfig?: EndpointTLSConfig;\n  /**\n   * `trackTimestampsStaleness` defines whether Prometheus tracks staleness of\n   * the metrics that have an explicit timestamp present in scraped data.\n   * Has no effect if `honorTimestamps` is false.\n   *\n   * It requires Prometheus >= v2.48.0.\n   */\n  trackTimestampsStaleness?: boolean;\n}\n\n/**\n * `authorization` configures the Authorization header credentials to use when\n * scraping the target.\n *\n * Cannot be set at the same time as `basicAuth`, or `oauth2`.\n */\nexport interface Authorization {\n  /**\n   * Selects a key of a Secret in the namespace that contains the credentials for\n   * authentication.\n   */\n  credentials?: Credentials;\n  /**\n   * Defines the authentication type. The value is case-insensitive.\n   *\n   * \"Basic\" is not a supported value.\n   *\n   * Default: \"Bearer\"\n   */\n  type?: string;\n}\n\n/**\n * Selects a key of a Secret in the namespace that contains the credentials for\n * authentication.\n */\nexport interface Credentials {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `basicAuth` configures the Basic Authentication credentials to use when\n * scraping the target.\n *\n * Cannot be set at the same time as `authorization`, or `oauth2`.\n */\nexport interface BasicAuth {\n  /**\n   * `password` specifies a key of a Secret containing the password for\n   * authentication.\n   */\n  password?: Password;\n  /**\n   * `username` specifies a key of a Secret containing the username for\n   * authentication.\n   */\n  username?: Username;\n}\n\n/**\n * `password` specifies a key of a Secret containing the password for\n * authentication.\n */\nexport interface Password {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `username` specifies a key of a Secret containing the username for\n * authentication.\n */\nexport interface Username {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `bearerTokenSecret` specifies a key of a Secret containing the bearer\n * token for scraping targets. The secret needs to be in the same namespace\n * as the ServiceMonitor object and readable by the Prometheus Operator.\n *\n * Deprecated: use `authorization` instead.\n */\nexport interface BearerTokenSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,\n * scraped samples and remote write samples.\n *\n * More info:\n * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n */\nexport interface MetricRelabeling {\n  /**\n   * Action to perform based on the regex matching.\n   *\n   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n   *\n   * Default: \"Replace\"\n   */\n  action?: Action;\n  /**\n   * Modulus to take of the hash of the source label values.\n   *\n   * Only applicable when the action is `HashMod`.\n   */\n  modulus?: number;\n  /**\n   * Regular expression against which the extracted value is matched.\n   */\n  regex?: string;\n  /**\n   * Replacement value against which a Replace action is performed if the\n   * regular expression matches.\n   *\n   * Regex capture groups are available.\n   */\n  replacement?: string;\n  /**\n   * Separator is the string between concatenated SourceLabels.\n   */\n  separator?: string;\n  /**\n   * The source labels select values from existing labels. Their content is\n   * concatenated using the configured Separator and matched against the\n   * configured regular expression.\n   */\n  sourceLabels?: string[];\n  /**\n   * Label to which the resulting string is written in a replacement.\n   *\n   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,\n   * `KeepEqual` and `DropEqual` actions.\n   *\n   * Regex capture groups are available.\n   */\n  targetLabel?: string;\n}\n\n/**\n * Action to perform based on the regex matching.\n *\n * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n *\n * Default: \"Replace\"\n */\nexport enum Action {\n  ActionDrop = \"Drop\",\n  ActionKeep = \"Keep\",\n  ActionLowercase = \"Lowercase\",\n  ActionReplace = \"Replace\",\n  ActionUppercase = \"Uppercase\",\n  Drop = \"drop\",\n  DropEqual = \"DropEqual\",\n  Dropequal = \"dropequal\",\n  HashMod = \"HashMod\",\n  Hashmod = \"hashmod\",\n  Keep = \"keep\",\n  KeepEqual = \"KeepEqual\",\n  Keepequal = \"keepequal\",\n  LabelDrop = \"LabelDrop\",\n  LabelKeep = \"LabelKeep\",\n  LabelMap = \"LabelMap\",\n  Labeldrop = \"labeldrop\",\n  Labelkeep = \"labelkeep\",\n  Labelmap = \"labelmap\",\n  Lowercase = \"lowercase\",\n  Replace = \"replace\",\n  Uppercase = \"uppercase\",\n}\n\n/**\n * `oauth2` configures the OAuth2 settings to use when scraping the target.\n *\n * It requires Prometheus >= 2.27.0.\n *\n * Cannot be set at the same time as `authorization`, or `basicAuth`.\n */\nexport interface Oauth2 {\n  /**\n   * `clientId` specifies a key of a Secret or ConfigMap containing the\n   * OAuth2 client's ID.\n   */\n  clientId: ClientID;\n  /**\n   * `clientSecret` specifies a key of a Secret containing the OAuth2\n   * client's secret.\n   */\n  clientSecret: ClientSecret;\n  /**\n   * `endpointParams` configures the HTTP parameters to append to the token\n   * URL.\n   */\n  endpointParams?: { [key: string]: string };\n  /**\n   * `noProxy` is a comma-separated string that can contain IPs, CIDR notation, domain names\n   * that should be excluded from proxying. IP and domain names can\n   * contain port numbers.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  noProxy?: string;\n  /**\n   * ProxyConnectHeader optionally specifies headers to send to\n   * proxies during CONNECT requests.\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyConnectHeader?: { [key: string]: Oauth2ProxyConnectHeader[] };\n  /**\n   * Whether to use the proxy configuration defined by environment variables (HTTP_PROXY,\n   * HTTPS_PROXY, and NO_PROXY).\n   *\n   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.\n   */\n  proxyFromEnvironment?: boolean;\n  /**\n   * `proxyURL` defines the HTTP proxy server to use.\n   */\n  proxyUrl?: string;\n  /**\n   * `scopes` defines the OAuth2 scopes used for the token request.\n   */\n  scopes?: string[];\n  /**\n   * TLS configuration to use when connecting to the OAuth2 server.\n   * It requires Prometheus >= v2.43.0.\n   */\n  tlsConfig?: Oauth2TLSConfig;\n  /**\n   * `tokenURL` configures the URL to fetch the token from.\n   */\n  tokenUrl: string;\n}\n\n/**\n * `clientId` specifies a key of a Secret or ConfigMap containing the\n * OAuth2 client's ID.\n */\nexport interface ClientID {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: ClientIDConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: ClientIDSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface ClientIDConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface ClientIDSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * `clientSecret` specifies a key of a Secret containing the OAuth2\n * client's secret.\n */\nexport interface ClientSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * SecretKeySelector selects a key of a Secret.\n */\nexport interface Oauth2ProxyConnectHeader {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * TLS configuration to use when connecting to the OAuth2 server.\n * It requires Prometheus >= v2.43.0.\n */\nexport interface Oauth2TLSConfig {\n  /**\n   * Certificate authority used when verifying server certificates.\n   */\n  ca?: PurpleCA;\n  /**\n   * Client certificate to present when doing client-authentication.\n   */\n  cert?: PurpleCERT;\n  /**\n   * Disable target certificate validation.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Secret containing the client key file for the targets.\n   */\n  keySecret?: PurpleKeySecret;\n  /**\n   * Maximum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n   */\n  maxVersion?: Version;\n  /**\n   * Minimum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n   */\n  minVersion?: Version;\n  /**\n   * Used to verify the hostname for the targets.\n   */\n  serverName?: string;\n}\n\n/**\n * Certificate authority used when verifying server certificates.\n */\nexport interface PurpleCA {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: PurpleConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: PurpleSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface PurpleConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface PurpleSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Client certificate to present when doing client-authentication.\n */\nexport interface PurpleCERT {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: FluffyConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: FluffySecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface FluffyConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface FluffySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing the client key file for the targets.\n */\nexport interface PurpleKeySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Maximum acceptable TLS version.\n *\n * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n *\n * Minimum acceptable TLS version.\n *\n * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n */\nexport enum Version {\n  Tls10 = \"TLS10\",\n  Tls11 = \"TLS11\",\n  Tls12 = \"TLS12\",\n  Tls13 = \"TLS13\",\n}\n\n/**\n * SecretKeySelector selects a key of a Secret.\n */\nexport interface EndpointProxyConnectHeader {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,\n * scraped samples and remote write samples.\n *\n * More info:\n * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config\n */\nexport interface Relabeling {\n  /**\n   * Action to perform based on the regex matching.\n   *\n   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.\n   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.\n   *\n   * Default: \"Replace\"\n   */\n  action?: Action;\n  /**\n   * Modulus to take of the hash of the source label values.\n   *\n   * Only applicable when the action is `HashMod`.\n   */\n  modulus?: number;\n  /**\n   * Regular expression against which the extracted value is matched.\n   */\n  regex?: string;\n  /**\n   * Replacement value against which a Replace action is performed if the\n   * regular expression matches.\n   *\n   * Regex capture groups are available.\n   */\n  replacement?: string;\n  /**\n   * Separator is the string between concatenated SourceLabels.\n   */\n  separator?: string;\n  /**\n   * The source labels select values from existing labels. Their content is\n   * concatenated using the configured Separator and matched against the\n   * configured regular expression.\n   */\n  sourceLabels?: string[];\n  /**\n   * Label to which the resulting string is written in a replacement.\n   *\n   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,\n   * `KeepEqual` and `DropEqual` actions.\n   *\n   * Regex capture groups are available.\n   */\n  targetLabel?: string;\n}\n\n/**\n * HTTP scheme to use for scraping.\n *\n * `http` and `https` are the expected values unless you rewrite the\n * `__scheme__` label via relabeling.\n *\n * If empty, Prometheus uses the default value `http`.\n */\nexport enum Scheme {\n  HTTP = \"http\",\n  HTTPS = \"https\",\n}\n\n/**\n * TLS configuration to use when scraping the target.\n */\nexport interface EndpointTLSConfig {\n  /**\n   * Certificate authority used when verifying server certificates.\n   */\n  ca?: FluffyCA;\n  /**\n   * Path to the CA cert in the Prometheus container to use for the targets.\n   */\n  caFile?: string;\n  /**\n   * Client certificate to present when doing client-authentication.\n   */\n  cert?: FluffyCERT;\n  /**\n   * Path to the client cert file in the Prometheus container for the targets.\n   */\n  certFile?: string;\n  /**\n   * Disable target certificate validation.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Path to the client key file in the Prometheus container for the targets.\n   */\n  keyFile?: string;\n  /**\n   * Secret containing the client key file for the targets.\n   */\n  keySecret?: FluffyKeySecret;\n  /**\n   * Maximum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.\n   */\n  maxVersion?: Version;\n  /**\n   * Minimum acceptable TLS version.\n   *\n   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.\n   */\n  minVersion?: Version;\n  /**\n   * Used to verify the hostname for the targets.\n   */\n  serverName?: string;\n}\n\n/**\n * Certificate authority used when verifying server certificates.\n */\nexport interface FluffyCA {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: TentacledConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: TentacledSecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface TentacledConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface TentacledSecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Client certificate to present when doing client-authentication.\n */\nexport interface FluffyCERT {\n  /**\n   * ConfigMap containing data to use for the targets.\n   */\n  configMap?: StickyConfigMap;\n  /**\n   * Secret containing data to use for the targets.\n   */\n  secret?: StickySecret;\n}\n\n/**\n * ConfigMap containing data to use for the targets.\n */\nexport interface StickyConfigMap {\n  /**\n   * The key to select.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the ConfigMap or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing data to use for the targets.\n */\nexport interface StickySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * Secret containing the client key file for the targets.\n */\nexport interface FluffyKeySecret {\n  /**\n   * The key of the secret to select from.  Must be a valid secret key.\n   */\n  key: string;\n  /**\n   * Name of the referent.\n   * This field is effectively required, but due to backwards compatibility is\n   * allowed to be empty. Instances of this type with an empty value here are\n   * almost certainly wrong.\n   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\n   */\n  name?: string;\n  /**\n   * Specify whether the Secret or its key must be defined\n   */\n  optional?: boolean;\n}\n\n/**\n * The protocol to use if a scrape returns blank, unparseable, or otherwise invalid\n * Content-Type.\n *\n * It requires Prometheus >= v3.0.0.\n *\n * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.\n * Supported values are:\n * * `OpenMetricsText0.0.1`\n * * `OpenMetricsText1.0.0`\n * * `PrometheusProto`\n * * `PrometheusText0.0.4`\n * * `PrometheusText1.0.0`\n */\nexport enum FallbackScrapeProtocol {\n  OpenMetricsText001 = \"OpenMetricsText0.0.1\",\n  OpenMetricsText100 = \"OpenMetricsText1.0.0\",\n  PrometheusProto = \"PrometheusProto\",\n  PrometheusText004 = \"PrometheusText0.0.4\",\n  PrometheusText100 = \"PrometheusText1.0.0\",\n}\n\n/**\n * `namespaceSelector` defines in which namespace(s) Prometheus should discover the\n * services.\n * By default, the services are discovered in the same namespace as the `ServiceMonitor`\n * object but it is possible to select pods across different/all namespaces.\n */\nexport interface NamespaceSelector {\n  /**\n   * Boolean describing whether all namespaces are selected in contrast to a\n   * list restricting them.\n   */\n  any?: boolean;\n  /**\n   * List of namespace names to select from.\n   */\n  matchNames?: string[];\n}\n\n/**\n * Label selector to select the Kubernetes `Endpoints` objects to scrape metrics from.\n */\nexport interface Selector {\n  /**\n   * matchExpressions is a list of label selector requirements. The requirements are ANDed.\n   */\n  matchExpressions?: MatchExpression[];\n  /**\n   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n   * map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n   * operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\n/**\n * A label selector requirement is a selector that contains values, a key, and an operator\n * that\n * relates the key and values.\n */\nexport interface MatchExpression {\n  /**\n   * key is the label key that the selector applies to.\n   */\n  key: string;\n  /**\n   * operator represents a key's relationship to a set of values.\n   * Valid operators are In, NotIn, Exists and DoesNotExist.\n   */\n  operator: string;\n  /**\n   * values is an array of string values. If the operator is In or NotIn,\n   * the values array must be non-empty. If the operator is Exists or DoesNotExist,\n   * the values array must be empty. This array is replaced during a strategic\n   * merge patch.\n   */\n  values?: string[];\n}\n\n/**\n * Mechanism used to select the endpoints to scrape.\n * By default, the selection process relies on relabel configurations to filter the\n * discovered targets.\n * Alternatively, you can opt in for role selectors, which may offer better efficiency in\n * large clusters.\n * Which strategy is best for your use case needs to be carefully evaluated.\n *\n * It requires Prometheus >= v2.17.0.\n */\nexport enum SelectorMechanism {\n  RelabelConfig = \"RelabelConfig\",\n  RoleSelector = \"RoleSelector\",\n}\n\n/**\n * This Status subresource is under active development and is updated only when the\n * \"StatusForConfigurationResources\" feature gate is enabled.\n *\n * Most recent observed status of the ServiceMonitor. Read-only.\n * More info:\n *\n * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n */\nexport interface Status {\n  /**\n   * The list of workload resources (Prometheus or PrometheusAgent) which select the\n   * configuration resource.\n   */\n  bindings?: Binding[];\n}\n\n/**\n * WorkloadBinding is a link between a configuration resource and a workload resource.\n */\nexport interface Binding {\n  /**\n   * The current state of the configuration resource when bound to the referenced Prometheus\n   * object.\n   */\n  conditions?: Condition[];\n  /**\n   * The group of the referenced resource.\n   */\n  group: Group;\n  /**\n   * The name of the referenced object.\n   */\n  name: string;\n  /**\n   * The namespace of the referenced object.\n   */\n  namespace: string;\n  /**\n   * The type of resource being referenced (e.g. Prometheus or PrometheusAgent).\n   */\n  resource: Resource;\n}\n\n/**\n * ConfigResourceCondition describes the status of configuration resources linked to\n * Prometheus, PrometheusAgent, Alertmanager, or ThanosRuler.\n */\nexport interface Condition {\n  /**\n   * LastTransitionTime is the time of the last update to the current status property.\n   */\n  lastTransitionTime: Date;\n  /**\n   * Human-readable message indicating details for the condition's last transition.\n   */\n  message?: string;\n  /**\n   * ObservedGeneration represents the .metadata.generation that the\n   * condition was set based upon. For instance, if `.metadata.generation` is\n   * currently 12, but the `.status.conditions[].observedGeneration` is 9, the\n   * condition is out of date with respect to the current state of the object.\n   */\n  observedGeneration?: number;\n  /**\n   * Reason for the condition's last transition.\n   */\n  reason?: string;\n  /**\n   * Status of the condition.\n   */\n  status: string;\n  /**\n   * Type of the condition being reported.\n   * Currently, only \"Accepted\" is supported.\n   */\n  type: Type;\n}\n\n/**\n * Type of the condition being reported.\n * Currently, only \"Accepted\" is supported.\n */\nexport enum Type {\n  Accepted = \"Accepted\",\n}\n\n/**\n * The group of the referenced resource.\n */\nexport enum Group {\n  MonitoringCoreosCOM = \"monitoring.coreos.com\",\n}\n\n/**\n * The type of resource being referenced (e.g. Prometheus or PrometheusAgent).\n */\nexport enum Resource {\n  Prometheusagents = \"prometheusagents\",\n  Prometheuses = \"prometheuses\",\n}\n\nRegisterKind(ServiceMonitor, {\n  group: \"monitoring.coreos.com\",\n  version: \"v1\",\n  kind: \"ServiceMonitor\",\n  plural: \"servicemonitors\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class AuthorizationPolicy extends GenericKind {\n  /**\n   * Configuration for access control on workloads. See more details at:\n   * https://istio.io/docs/reference/config/security/authorization-policy.html\n   */\n  spec?: Spec;\n  status?: { [key: string]: unknown };\n}\n\n/**\n * Configuration for access control on workloads. See more details at:\n * https://istio.io/docs/reference/config/security/authorization-policy.html\n */\nexport interface Spec {\n  /**\n   * Optional.\n   *\n   * Valid Options: ALLOW, DENY, AUDIT, CUSTOM\n   */\n  action?: Action;\n  /**\n   * Specifies detailed configuration of the CUSTOM action.\n   */\n  provider?: Provider;\n  /**\n   * Optional.\n   */\n  rules?: Rule[];\n  /**\n   * Optional.\n   */\n  selector?: Selector;\n  /**\n   * Optional.\n   */\n  targetRef?: TargetRef;\n}\n\n/**\n * Optional.\n *\n * Valid Options: ALLOW, DENY, AUDIT, CUSTOM\n */\nexport enum Action {\n  Allow = \"ALLOW\",\n  Audit = \"AUDIT\",\n  Custom = \"CUSTOM\",\n  Deny = \"DENY\",\n}\n\n/**\n * Specifies detailed configuration of the CUSTOM action.\n */\nexport interface Provider {\n  /**\n   * Specifies the name of the extension provider.\n   */\n  name?: string;\n}\n\nexport interface Rule {\n  /**\n   * Optional.\n   */\n  from?: From[];\n  /**\n   * Optional.\n   */\n  to?: To[];\n  /**\n   * Optional.\n   */\n  when?: When[];\n}\n\nexport interface From {\n  /**\n   * Source specifies the source of a request.\n   */\n  source?: Source;\n}\n\n/**\n * Source specifies the source of a request.\n */\nexport interface Source {\n  /**\n   * Optional.\n   */\n  ipBlocks?: string[];\n  /**\n   * Optional.\n   */\n  namespaces?: string[];\n  /**\n   * Optional.\n   */\n  notIpBlocks?: string[];\n  /**\n   * Optional.\n   */\n  notNamespaces?: string[];\n  /**\n   * Optional.\n   */\n  notPrincipals?: string[];\n  /**\n   * Optional.\n   */\n  notRemoteIpBlocks?: string[];\n  /**\n   * Optional.\n   */\n  notRequestPrincipals?: string[];\n  /**\n   * Optional.\n   */\n  notServiceAccounts?: string[];\n  /**\n   * Optional.\n   */\n  principals?: string[];\n  /**\n   * Optional.\n   */\n  remoteIpBlocks?: string[];\n  /**\n   * Optional.\n   */\n  requestPrincipals?: string[];\n  /**\n   * Optional.\n   */\n  serviceAccounts?: string[];\n}\n\nexport interface To {\n  /**\n   * Operation specifies the operation of a request.\n   */\n  operation?: Operation;\n}\n\n/**\n * Operation specifies the operation of a request.\n */\nexport interface Operation {\n  /**\n   * Optional.\n   */\n  hosts?: string[];\n  /**\n   * Optional.\n   */\n  methods?: string[];\n  /**\n   * Optional.\n   */\n  notHosts?: string[];\n  /**\n   * Optional.\n   */\n  notMethods?: string[];\n  /**\n   * Optional.\n   */\n  notPaths?: string[];\n  /**\n   * Optional.\n   */\n  notPorts?: string[];\n  /**\n   * Optional.\n   */\n  paths?: string[];\n  /**\n   * Optional.\n   */\n  ports?: string[];\n}\n\nexport interface When {\n  /**\n   * The name of an Istio attribute.\n   */\n  key: string;\n  /**\n   * Optional.\n   */\n  notValues?: string[];\n  /**\n   * Optional.\n   */\n  values?: string[];\n}\n\n/**\n * Optional.\n */\nexport interface Selector {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which a policy should be\n   * applied.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\n/**\n * Optional.\n */\nexport interface TargetRef {\n  /**\n   * group is the group of the target resource.\n   */\n  group?: string;\n  /**\n   * kind is kind of the target resource.\n   */\n  kind?: string;\n  /**\n   * name is the name of the target resource.\n   */\n  name?: string;\n  /**\n   * namespace is the namespace of the referent.\n   */\n  namespace?: string;\n}\n\nRegisterKind(AuthorizationPolicy, {\n  group: \"security.istio.io\",\n  version: \"v1beta1\",\n  kind: \"AuthorizationPolicy\",\n  plural: \"authorizationpolicies\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n\nexport class RequestAuthentication extends GenericKind {\n  /**\n   * Request authentication configuration for workloads. See more details at:\n   * https://istio.io/docs/reference/config/security/request_authentication.html\n   */\n  spec?: Spec;\n  status?: { [key: string]: unknown };\n}\n\n/**\n * Request authentication configuration for workloads. See more details at:\n * https://istio.io/docs/reference/config/security/request_authentication.html\n */\nexport interface Spec {\n  /**\n   * Define the list of JWTs that can be validated at the selected workloads' proxy.\n   */\n  jwtRules?: JwtRule[];\n  /**\n   * Optional.\n   */\n  selector?: Selector;\n  /**\n   * Optional.\n   */\n  targetRef?: TargetRef;\n}\n\nexport interface JwtRule {\n  /**\n   * The list of JWT [audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) that are\n   * allowed to access.\n   */\n  audiences?: string[];\n  /**\n   * If set to true, the original token will be kept for the upstream request.\n   */\n  forwardOriginalToken?: boolean;\n  /**\n   * List of header locations from which JWT is expected.\n   */\n  fromHeaders?: FromHeader[];\n  /**\n   * List of query parameters from which JWT is expected.\n   */\n  fromParams?: string[];\n  /**\n   * Identifies the issuer that issued the JWT.\n   */\n  issuer: string;\n  /**\n   * JSON Web Key Set of public keys to validate signature of the JWT.\n   */\n  jwks?: string;\n  /**\n   * URL of the provider's public key set to validate signature of the JWT.\n   */\n  jwks_uri?: string;\n  /**\n   * URL of the provider's public key set to validate signature of the JWT.\n   */\n  jwksUri?: string;\n  /**\n   * This field specifies a list of operations to copy the claim to HTTP headers on a\n   * successfully verified token.\n   */\n  outputClaimToHeaders?: OutputClaimToHeader[];\n  /**\n   * This field specifies the header name to output a successfully verified JWT payload to the\n   * backend.\n   */\n  outputPayloadToHeader?: string;\n}\n\nexport interface FromHeader {\n  /**\n   * The HTTP header name.\n   */\n  name: string;\n  /**\n   * The prefix that should be stripped before decoding the token.\n   */\n  prefix?: string;\n}\n\nexport interface OutputClaimToHeader {\n  /**\n   * The name of the claim to be copied from.\n   */\n  claim?: string;\n  /**\n   * The name of the header to be created.\n   */\n  header?: string;\n}\n\n/**\n * Optional.\n */\nexport interface Selector {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which a policy should be\n   * applied.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\n/**\n * Optional.\n */\nexport interface TargetRef {\n  /**\n   * group is the group of the target resource.\n   */\n  group?: string;\n  /**\n   * kind is kind of the target resource.\n   */\n  kind?: string;\n  /**\n   * name is the name of the target resource.\n   */\n  name?: string;\n  /**\n   * namespace is the namespace of the referent.\n   */\n  namespace?: string;\n}\n\nRegisterKind(RequestAuthentication, {\n  group: \"security.istio.io\",\n  version: \"v1\",\n  kind: \"RequestAuthentication\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class DestinationRule extends GenericKind {\n  /**\n   * Configuration affecting load balancing, outlier detection, etc. See more details at:\n   * https://istio.io/docs/reference/config/networking/destination-rule.html\n   */\n  spec?: Spec;\n  status?: Status;\n}\n\n/**\n * Configuration affecting load balancing, outlier detection, etc. See more details at:\n * https://istio.io/docs/reference/config/networking/destination-rule.html\n */\nexport interface Spec {\n  /**\n   * A list of namespaces to which this destination rule is exported.\n   */\n  exportTo?: string[];\n  /**\n   * The name of a service from the service registry.\n   */\n  host: string;\n  /**\n   * One or more named sets that represent individual versions of a service.\n   */\n  subsets?: Subset[];\n  /**\n   * Traffic policies to apply (load balancing policy, connection pool sizes, outlier\n   * detection).\n   */\n  trafficPolicy?: SpecTrafficPolicy;\n  /**\n   * Criteria used to select the specific set of pods/VMs on which this `DestinationRule`\n   * configuration should be applied.\n   */\n  workloadSelector?: WorkloadSelector;\n}\n\nexport interface Subset {\n  /**\n   * Labels apply a filter over the endpoints of a service in the service registry.\n   */\n  labels?: { [key: string]: string };\n  /**\n   * Name of the subset.\n   */\n  name: string;\n  /**\n   * Traffic policies that apply to this subset.\n   */\n  trafficPolicy?: SubsetTrafficPolicy;\n}\n\n/**\n * Traffic policies that apply to this subset.\n */\nexport interface SubsetTrafficPolicy {\n  connectionPool?: PurpleConnectionPool;\n  /**\n   * Settings controlling the load balancer algorithms.\n   */\n  loadBalancer?: PurpleLoadBalancer;\n  outlierDetection?: PurpleOutlierDetection;\n  /**\n   * Traffic policies specific to individual ports.\n   */\n  portLevelSettings?: PurplePortLevelSetting[];\n  /**\n   * The upstream PROXY protocol settings.\n   */\n  proxyProtocol?: PurpleProxyProtocol;\n  /**\n   * TLS related settings for connections to the upstream service.\n   */\n  tls?: FluffyTLS;\n  /**\n   * Configuration of tunneling TCP over other transport or application layers for the host\n   * configured in the DestinationRule.\n   */\n  tunnel?: PurpleTunnel;\n}\n\nexport interface PurpleConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: PurpleHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: PurpleTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface PurpleHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Specify if http1.1 connection should be upgraded to http2 for the associated\n * destination.\n *\n * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n */\nexport enum H2UpgradePolicy {\n  Default = \"DEFAULT\",\n  DoNotUpgrade = \"DO_NOT_UPGRADE\",\n  Upgrade = \"UPGRADE\",\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface PurpleTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: PurpleTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface PurpleTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\n/**\n * Settings controlling the load balancer algorithms.\n */\nexport interface PurpleLoadBalancer {\n  consistentHash?: PurpleConsistentHash;\n  localityLbSetting?: PurpleLocalityLBSetting;\n  /**\n   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST\n   */\n  simple?: Simple;\n  /**\n   * Represents the warmup configuration of Service.\n   */\n  warmup?: PurpleWarmup;\n  /**\n   * Deprecated: use `warmup` instead.\n   */\n  warmupDurationSecs?: string;\n}\n\nexport interface PurpleConsistentHash {\n  /**\n   * Hash based on HTTP cookie.\n   */\n  httpCookie?: PurpleHTTPCookie;\n  /**\n   * Hash based on a specific HTTP header.\n   */\n  httpHeaderName?: string;\n  /**\n   * Hash based on a specific HTTP query parameter.\n   */\n  httpQueryParameterName?: string;\n  /**\n   * The Maglev load balancer implements consistent hashing to backend hosts.\n   */\n  maglev?: PurpleMaglev;\n  /**\n   * Deprecated.\n   */\n  minimumRingSize?: number;\n  /**\n   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n   */\n  ringHash?: PurpleRingHash;\n  /**\n   * Hash based on the source IP address.\n   */\n  useSourceIp?: boolean;\n}\n\n/**\n * Hash based on HTTP cookie.\n */\nexport interface PurpleHTTPCookie {\n  /**\n   * Name of the cookie.\n   */\n  name: string;\n  /**\n   * Path to set for the cookie.\n   */\n  path?: string;\n  /**\n   * Lifetime of the cookie.\n   */\n  ttl?: string;\n}\n\n/**\n * The Maglev load balancer implements consistent hashing to backend hosts.\n */\nexport interface PurpleMaglev {\n  /**\n   * The table size for Maglev hashing.\n   */\n  tableSize?: number;\n}\n\n/**\n * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n */\nexport interface PurpleRingHash {\n  /**\n   * The minimum number of virtual nodes to use for the hash ring.\n   */\n  minimumRingSize?: number;\n}\n\nexport interface PurpleLocalityLBSetting {\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  distribute?: PurpleDistribute[];\n  /**\n   * Enable locality load balancing.\n   */\n  enabled?: boolean;\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  failover?: PurpleFailover[];\n  /**\n   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based\n   * load balancing.\n   */\n  failoverPriority?: string[];\n}\n\nexport interface PurpleDistribute {\n  /**\n   * Originating locality, '/' separated, e.g.\n   */\n  from?: string;\n  /**\n   * Map of upstream localities to traffic distribution weights.\n   */\n  to?: { [key: string]: number };\n}\n\nexport interface PurpleFailover {\n  /**\n   * Originating region.\n   */\n  from?: string;\n  /**\n   * Destination region the traffic will fail over to when endpoints in the 'from' region\n   * becomes unhealthy.\n   */\n  to?: string;\n}\n\n/**\n * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST\n */\nexport enum Simple {\n  LeastConn = \"LEAST_CONN\",\n  LeastRequest = \"LEAST_REQUEST\",\n  Passthrough = \"PASSTHROUGH\",\n  Random = \"RANDOM\",\n  RoundRobin = \"ROUND_ROBIN\",\n  Unspecified = \"UNSPECIFIED\",\n}\n\n/**\n * Represents the warmup configuration of Service.\n */\nexport interface PurpleWarmup {\n  /**\n   * This parameter controls the speed of traffic increase over the warmup duration.\n   */\n  aggression?: number;\n  duration: string;\n  minimumPercent?: number;\n}\n\nexport interface PurpleOutlierDetection {\n  /**\n   * Minimum ejection duration.\n   */\n  baseEjectionTime?: string;\n  /**\n   * Number of 5xx errors before a host is ejected from the connection pool.\n   */\n  consecutive5xxErrors?: number;\n  consecutiveErrors?: number;\n  /**\n   * Number of gateway errors before a host is ejected from the connection pool.\n   */\n  consecutiveGatewayErrors?: number;\n  /**\n   * The number of consecutive locally originated failures before ejection occurs.\n   */\n  consecutiveLocalOriginFailures?: number;\n  /**\n   * Time interval between ejection sweep analysis.\n   */\n  interval?: string;\n  /**\n   * Maximum % of hosts in the load balancing pool for the upstream service that can be\n   * ejected.\n   */\n  maxEjectionPercent?: number;\n  /**\n   * Outlier detection will be enabled as long as the associated load balancing pool has at\n   * least `minHealthPercent` hosts in healthy mode.\n   */\n  minHealthPercent?: number;\n  /**\n   * Determines whether to distinguish local origin failures from external errors.\n   */\n  splitExternalLocalOriginErrors?: boolean;\n}\n\nexport interface PurplePortLevelSetting {\n  connectionPool?: FluffyConnectionPool;\n  /**\n   * Settings controlling the load balancer algorithms.\n   */\n  loadBalancer?: FluffyLoadBalancer;\n  outlierDetection?: FluffyOutlierDetection;\n  /**\n   * Specifies the number of a port on the destination service on which this policy is being\n   * applied.\n   */\n  port?: PurplePort;\n  /**\n   * TLS related settings for connections to the upstream service.\n   */\n  tls?: PurpleTLS;\n}\n\nexport interface FluffyConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: FluffyHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: FluffyTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface FluffyHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface FluffyTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: FluffyTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface FluffyTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\n/**\n * Settings controlling the load balancer algorithms.\n */\nexport interface FluffyLoadBalancer {\n  consistentHash?: FluffyConsistentHash;\n  localityLbSetting?: FluffyLocalityLBSetting;\n  /**\n   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST\n   */\n  simple?: Simple;\n  /**\n   * Represents the warmup configuration of Service.\n   */\n  warmup?: FluffyWarmup;\n  /**\n   * Deprecated: use `warmup` instead.\n   */\n  warmupDurationSecs?: string;\n}\n\nexport interface FluffyConsistentHash {\n  /**\n   * Hash based on HTTP cookie.\n   */\n  httpCookie?: FluffyHTTPCookie;\n  /**\n   * Hash based on a specific HTTP header.\n   */\n  httpHeaderName?: string;\n  /**\n   * Hash based on a specific HTTP query parameter.\n   */\n  httpQueryParameterName?: string;\n  /**\n   * The Maglev load balancer implements consistent hashing to backend hosts.\n   */\n  maglev?: FluffyMaglev;\n  /**\n   * Deprecated.\n   */\n  minimumRingSize?: number;\n  /**\n   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n   */\n  ringHash?: FluffyRingHash;\n  /**\n   * Hash based on the source IP address.\n   */\n  useSourceIp?: boolean;\n}\n\n/**\n * Hash based on HTTP cookie.\n */\nexport interface FluffyHTTPCookie {\n  /**\n   * Name of the cookie.\n   */\n  name: string;\n  /**\n   * Path to set for the cookie.\n   */\n  path?: string;\n  /**\n   * Lifetime of the cookie.\n   */\n  ttl?: string;\n}\n\n/**\n * The Maglev load balancer implements consistent hashing to backend hosts.\n */\nexport interface FluffyMaglev {\n  /**\n   * The table size for Maglev hashing.\n   */\n  tableSize?: number;\n}\n\n/**\n * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n */\nexport interface FluffyRingHash {\n  /**\n   * The minimum number of virtual nodes to use for the hash ring.\n   */\n  minimumRingSize?: number;\n}\n\nexport interface FluffyLocalityLBSetting {\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  distribute?: FluffyDistribute[];\n  /**\n   * Enable locality load balancing.\n   */\n  enabled?: boolean;\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  failover?: FluffyFailover[];\n  /**\n   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based\n   * load balancing.\n   */\n  failoverPriority?: string[];\n}\n\nexport interface FluffyDistribute {\n  /**\n   * Originating locality, '/' separated, e.g.\n   */\n  from?: string;\n  /**\n   * Map of upstream localities to traffic distribution weights.\n   */\n  to?: { [key: string]: number };\n}\n\nexport interface FluffyFailover {\n  /**\n   * Originating region.\n   */\n  from?: string;\n  /**\n   * Destination region the traffic will fail over to when endpoints in the 'from' region\n   * becomes unhealthy.\n   */\n  to?: string;\n}\n\n/**\n * Represents the warmup configuration of Service.\n */\nexport interface FluffyWarmup {\n  /**\n   * This parameter controls the speed of traffic increase over the warmup duration.\n   */\n  aggression?: number;\n  duration: string;\n  minimumPercent?: number;\n}\n\nexport interface FluffyOutlierDetection {\n  /**\n   * Minimum ejection duration.\n   */\n  baseEjectionTime?: string;\n  /**\n   * Number of 5xx errors before a host is ejected from the connection pool.\n   */\n  consecutive5xxErrors?: number;\n  consecutiveErrors?: number;\n  /**\n   * Number of gateway errors before a host is ejected from the connection pool.\n   */\n  consecutiveGatewayErrors?: number;\n  /**\n   * The number of consecutive locally originated failures before ejection occurs.\n   */\n  consecutiveLocalOriginFailures?: number;\n  /**\n   * Time interval between ejection sweep analysis.\n   */\n  interval?: string;\n  /**\n   * Maximum % of hosts in the load balancing pool for the upstream service that can be\n   * ejected.\n   */\n  maxEjectionPercent?: number;\n  /**\n   * Outlier detection will be enabled as long as the associated load balancing pool has at\n   * least `minHealthPercent` hosts in healthy mode.\n   */\n  minHealthPercent?: number;\n  /**\n   * Determines whether to distinguish local origin failures from external errors.\n   */\n  splitExternalLocalOriginErrors?: boolean;\n}\n\n/**\n * Specifies the number of a port on the destination service on which this policy is being\n * applied.\n */\nexport interface PurplePort {\n  number?: number;\n}\n\n/**\n * TLS related settings for connections to the upstream service.\n */\nexport interface PurpleTLS {\n  /**\n   * OPTIONAL: The path to the file containing certificate authority certificates to use in\n   * verifying a presented server certificate.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented server certificate.\n   */\n  caCrl?: string;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  clientCertificate?: string;\n  /**\n   * The name of the secret that holds the TLS certs for the client including the CA\n   * certificates.\n   */\n  credentialName?: string;\n  /**\n   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature\n   * and SAN for the server certificate corresponding to the host.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL\n   */\n  mode?: Mode;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * SNI string to present to the server during TLS handshake.\n   */\n  sni?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate.\n   */\n  subjectAltNames?: string[];\n}\n\n/**\n * Indicates whether connections to this port should be secured using TLS.\n *\n * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL\n */\nexport enum Mode {\n  Disable = \"DISABLE\",\n  IstioMutual = \"ISTIO_MUTUAL\",\n  Mutual = \"MUTUAL\",\n  Simple = \"SIMPLE\",\n}\n\n/**\n * The upstream PROXY protocol settings.\n */\nexport interface PurpleProxyProtocol {\n  /**\n   * The PROXY protocol version to use.\n   *\n   * Valid Options: V1, V2\n   */\n  version?: Version;\n}\n\n/**\n * The PROXY protocol version to use.\n *\n * Valid Options: V1, V2\n */\nexport enum Version {\n  V1 = \"V1\",\n  V2 = \"V2\",\n}\n\n/**\n * TLS related settings for connections to the upstream service.\n */\nexport interface FluffyTLS {\n  /**\n   * OPTIONAL: The path to the file containing certificate authority certificates to use in\n   * verifying a presented server certificate.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented server certificate.\n   */\n  caCrl?: string;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  clientCertificate?: string;\n  /**\n   * The name of the secret that holds the TLS certs for the client including the CA\n   * certificates.\n   */\n  credentialName?: string;\n  /**\n   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature\n   * and SAN for the server certificate corresponding to the host.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL\n   */\n  mode?: Mode;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * SNI string to present to the server during TLS handshake.\n   */\n  sni?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate.\n   */\n  subjectAltNames?: string[];\n}\n\n/**\n * Configuration of tunneling TCP over other transport or application layers for the host\n * configured in the DestinationRule.\n */\nexport interface PurpleTunnel {\n  /**\n   * Specifies which protocol to use for tunneling the downstream connection.\n   */\n  protocol?: string;\n  /**\n   * Specifies a host to which the downstream connection is tunneled.\n   */\n  targetHost: string;\n  /**\n   * Specifies a port to which the downstream connection is tunneled.\n   */\n  targetPort: number;\n}\n\n/**\n * Traffic policies to apply (load balancing policy, connection pool sizes, outlier\n * detection).\n */\nexport interface SpecTrafficPolicy {\n  connectionPool?: TentacledConnectionPool;\n  /**\n   * Settings controlling the load balancer algorithms.\n   */\n  loadBalancer?: TentacledLoadBalancer;\n  outlierDetection?: TentacledOutlierDetection;\n  /**\n   * Traffic policies specific to individual ports.\n   */\n  portLevelSettings?: FluffyPortLevelSetting[];\n  /**\n   * The upstream PROXY protocol settings.\n   */\n  proxyProtocol?: FluffyProxyProtocol;\n  /**\n   * TLS related settings for connections to the upstream service.\n   */\n  tls?: StickyTLS;\n  /**\n   * Configuration of tunneling TCP over other transport or application layers for the host\n   * configured in the DestinationRule.\n   */\n  tunnel?: FluffyTunnel;\n}\n\nexport interface TentacledConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: TentacledHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: TentacledTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface TentacledHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface TentacledTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: TentacledTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface TentacledTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\n/**\n * Settings controlling the load balancer algorithms.\n */\nexport interface TentacledLoadBalancer {\n  consistentHash?: TentacledConsistentHash;\n  localityLbSetting?: TentacledLocalityLBSetting;\n  /**\n   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST\n   */\n  simple?: Simple;\n  /**\n   * Represents the warmup configuration of Service.\n   */\n  warmup?: TentacledWarmup;\n  /**\n   * Deprecated: use `warmup` instead.\n   */\n  warmupDurationSecs?: string;\n}\n\nexport interface TentacledConsistentHash {\n  /**\n   * Hash based on HTTP cookie.\n   */\n  httpCookie?: TentacledHTTPCookie;\n  /**\n   * Hash based on a specific HTTP header.\n   */\n  httpHeaderName?: string;\n  /**\n   * Hash based on a specific HTTP query parameter.\n   */\n  httpQueryParameterName?: string;\n  /**\n   * The Maglev load balancer implements consistent hashing to backend hosts.\n   */\n  maglev?: TentacledMaglev;\n  /**\n   * Deprecated.\n   */\n  minimumRingSize?: number;\n  /**\n   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n   */\n  ringHash?: TentacledRingHash;\n  /**\n   * Hash based on the source IP address.\n   */\n  useSourceIp?: boolean;\n}\n\n/**\n * Hash based on HTTP cookie.\n */\nexport interface TentacledHTTPCookie {\n  /**\n   * Name of the cookie.\n   */\n  name: string;\n  /**\n   * Path to set for the cookie.\n   */\n  path?: string;\n  /**\n   * Lifetime of the cookie.\n   */\n  ttl?: string;\n}\n\n/**\n * The Maglev load balancer implements consistent hashing to backend hosts.\n */\nexport interface TentacledMaglev {\n  /**\n   * The table size for Maglev hashing.\n   */\n  tableSize?: number;\n}\n\n/**\n * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n */\nexport interface TentacledRingHash {\n  /**\n   * The minimum number of virtual nodes to use for the hash ring.\n   */\n  minimumRingSize?: number;\n}\n\nexport interface TentacledLocalityLBSetting {\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  distribute?: TentacledDistribute[];\n  /**\n   * Enable locality load balancing.\n   */\n  enabled?: boolean;\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  failover?: TentacledFailover[];\n  /**\n   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based\n   * load balancing.\n   */\n  failoverPriority?: string[];\n}\n\nexport interface TentacledDistribute {\n  /**\n   * Originating locality, '/' separated, e.g.\n   */\n  from?: string;\n  /**\n   * Map of upstream localities to traffic distribution weights.\n   */\n  to?: { [key: string]: number };\n}\n\nexport interface TentacledFailover {\n  /**\n   * Originating region.\n   */\n  from?: string;\n  /**\n   * Destination region the traffic will fail over to when endpoints in the 'from' region\n   * becomes unhealthy.\n   */\n  to?: string;\n}\n\n/**\n * Represents the warmup configuration of Service.\n */\nexport interface TentacledWarmup {\n  /**\n   * This parameter controls the speed of traffic increase over the warmup duration.\n   */\n  aggression?: number;\n  duration: string;\n  minimumPercent?: number;\n}\n\nexport interface TentacledOutlierDetection {\n  /**\n   * Minimum ejection duration.\n   */\n  baseEjectionTime?: string;\n  /**\n   * Number of 5xx errors before a host is ejected from the connection pool.\n   */\n  consecutive5xxErrors?: number;\n  consecutiveErrors?: number;\n  /**\n   * Number of gateway errors before a host is ejected from the connection pool.\n   */\n  consecutiveGatewayErrors?: number;\n  /**\n   * The number of consecutive locally originated failures before ejection occurs.\n   */\n  consecutiveLocalOriginFailures?: number;\n  /**\n   * Time interval between ejection sweep analysis.\n   */\n  interval?: string;\n  /**\n   * Maximum % of hosts in the load balancing pool for the upstream service that can be\n   * ejected.\n   */\n  maxEjectionPercent?: number;\n  /**\n   * Outlier detection will be enabled as long as the associated load balancing pool has at\n   * least `minHealthPercent` hosts in healthy mode.\n   */\n  minHealthPercent?: number;\n  /**\n   * Determines whether to distinguish local origin failures from external errors.\n   */\n  splitExternalLocalOriginErrors?: boolean;\n}\n\nexport interface FluffyPortLevelSetting {\n  connectionPool?: StickyConnectionPool;\n  /**\n   * Settings controlling the load balancer algorithms.\n   */\n  loadBalancer?: StickyLoadBalancer;\n  outlierDetection?: StickyOutlierDetection;\n  /**\n   * Specifies the number of a port on the destination service on which this policy is being\n   * applied.\n   */\n  port?: FluffyPort;\n  /**\n   * TLS related settings for connections to the upstream service.\n   */\n  tls?: TentacledTLS;\n}\n\nexport interface StickyConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: StickyHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: StickyTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface StickyHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface StickyTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: StickyTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface StickyTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\n/**\n * Settings controlling the load balancer algorithms.\n */\nexport interface StickyLoadBalancer {\n  consistentHash?: StickyConsistentHash;\n  localityLbSetting?: StickyLocalityLBSetting;\n  /**\n   * Valid Options: LEAST_CONN, RANDOM, PASSTHROUGH, ROUND_ROBIN, LEAST_REQUEST\n   */\n  simple?: Simple;\n  /**\n   * Represents the warmup configuration of Service.\n   */\n  warmup?: StickyWarmup;\n  /**\n   * Deprecated: use `warmup` instead.\n   */\n  warmupDurationSecs?: string;\n}\n\nexport interface StickyConsistentHash {\n  /**\n   * Hash based on HTTP cookie.\n   */\n  httpCookie?: StickyHTTPCookie;\n  /**\n   * Hash based on a specific HTTP header.\n   */\n  httpHeaderName?: string;\n  /**\n   * Hash based on a specific HTTP query parameter.\n   */\n  httpQueryParameterName?: string;\n  /**\n   * The Maglev load balancer implements consistent hashing to backend hosts.\n   */\n  maglev?: StickyMaglev;\n  /**\n   * Deprecated.\n   */\n  minimumRingSize?: number;\n  /**\n   * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n   */\n  ringHash?: StickyRingHash;\n  /**\n   * Hash based on the source IP address.\n   */\n  useSourceIp?: boolean;\n}\n\n/**\n * Hash based on HTTP cookie.\n */\nexport interface StickyHTTPCookie {\n  /**\n   * Name of the cookie.\n   */\n  name: string;\n  /**\n   * Path to set for the cookie.\n   */\n  path?: string;\n  /**\n   * Lifetime of the cookie.\n   */\n  ttl?: string;\n}\n\n/**\n * The Maglev load balancer implements consistent hashing to backend hosts.\n */\nexport interface StickyMaglev {\n  /**\n   * The table size for Maglev hashing.\n   */\n  tableSize?: number;\n}\n\n/**\n * The ring/modulo hash load balancer implements consistent hashing to backend hosts.\n */\nexport interface StickyRingHash {\n  /**\n   * The minimum number of virtual nodes to use for the hash ring.\n   */\n  minimumRingSize?: number;\n}\n\nexport interface StickyLocalityLBSetting {\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  distribute?: StickyDistribute[];\n  /**\n   * Enable locality load balancing.\n   */\n  enabled?: boolean;\n  /**\n   * Optional: only one of distribute, failover or failoverPriority can be set.\n   */\n  failover?: StickyFailover[];\n  /**\n   * failoverPriority is an ordered list of labels used to sort endpoints to do priority based\n   * load balancing.\n   */\n  failoverPriority?: string[];\n}\n\nexport interface StickyDistribute {\n  /**\n   * Originating locality, '/' separated, e.g.\n   */\n  from?: string;\n  /**\n   * Map of upstream localities to traffic distribution weights.\n   */\n  to?: { [key: string]: number };\n}\n\nexport interface StickyFailover {\n  /**\n   * Originating region.\n   */\n  from?: string;\n  /**\n   * Destination region the traffic will fail over to when endpoints in the 'from' region\n   * becomes unhealthy.\n   */\n  to?: string;\n}\n\n/**\n * Represents the warmup configuration of Service.\n */\nexport interface StickyWarmup {\n  /**\n   * This parameter controls the speed of traffic increase over the warmup duration.\n   */\n  aggression?: number;\n  duration: string;\n  minimumPercent?: number;\n}\n\nexport interface StickyOutlierDetection {\n  /**\n   * Minimum ejection duration.\n   */\n  baseEjectionTime?: string;\n  /**\n   * Number of 5xx errors before a host is ejected from the connection pool.\n   */\n  consecutive5xxErrors?: number;\n  consecutiveErrors?: number;\n  /**\n   * Number of gateway errors before a host is ejected from the connection pool.\n   */\n  consecutiveGatewayErrors?: number;\n  /**\n   * The number of consecutive locally originated failures before ejection occurs.\n   */\n  consecutiveLocalOriginFailures?: number;\n  /**\n   * Time interval between ejection sweep analysis.\n   */\n  interval?: string;\n  /**\n   * Maximum % of hosts in the load balancing pool for the upstream service that can be\n   * ejected.\n   */\n  maxEjectionPercent?: number;\n  /**\n   * Outlier detection will be enabled as long as the associated load balancing pool has at\n   * least `minHealthPercent` hosts in healthy mode.\n   */\n  minHealthPercent?: number;\n  /**\n   * Determines whether to distinguish local origin failures from external errors.\n   */\n  splitExternalLocalOriginErrors?: boolean;\n}\n\n/**\n * Specifies the number of a port on the destination service on which this policy is being\n * applied.\n */\nexport interface FluffyPort {\n  number?: number;\n}\n\n/**\n * TLS related settings for connections to the upstream service.\n */\nexport interface TentacledTLS {\n  /**\n   * OPTIONAL: The path to the file containing certificate authority certificates to use in\n   * verifying a presented server certificate.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented server certificate.\n   */\n  caCrl?: string;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  clientCertificate?: string;\n  /**\n   * The name of the secret that holds the TLS certs for the client including the CA\n   * certificates.\n   */\n  credentialName?: string;\n  /**\n   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature\n   * and SAN for the server certificate corresponding to the host.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL\n   */\n  mode?: Mode;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * SNI string to present to the server during TLS handshake.\n   */\n  sni?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate.\n   */\n  subjectAltNames?: string[];\n}\n\n/**\n * The upstream PROXY protocol settings.\n */\nexport interface FluffyProxyProtocol {\n  /**\n   * The PROXY protocol version to use.\n   *\n   * Valid Options: V1, V2\n   */\n  version?: Version;\n}\n\n/**\n * TLS related settings for connections to the upstream service.\n */\nexport interface StickyTLS {\n  /**\n   * OPTIONAL: The path to the file containing certificate authority certificates to use in\n   * verifying a presented server certificate.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented server certificate.\n   */\n  caCrl?: string;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  clientCertificate?: string;\n  /**\n   * The name of the secret that holds the TLS certs for the client including the CA\n   * certificates.\n   */\n  credentialName?: string;\n  /**\n   * `insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature\n   * and SAN for the server certificate corresponding to the host.\n   */\n  insecureSkipVerify?: boolean;\n  /**\n   * Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL\n   */\n  mode?: Mode;\n  /**\n   * REQUIRED if mode is `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * SNI string to present to the server during TLS handshake.\n   */\n  sni?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate.\n   */\n  subjectAltNames?: string[];\n}\n\n/**\n * Configuration of tunneling TCP over other transport or application layers for the host\n * configured in the DestinationRule.\n */\nexport interface FluffyTunnel {\n  /**\n   * Specifies which protocol to use for tunneling the downstream connection.\n   */\n  protocol?: string;\n  /**\n   * Specifies a host to which the downstream connection is tunneled.\n   */\n  targetHost: string;\n  /**\n   * Specifies a port to which the downstream connection is tunneled.\n   */\n  targetPort: number;\n}\n\n/**\n * Criteria used to select the specific set of pods/VMs on which this `DestinationRule`\n * configuration should be applied.\n */\nexport interface WorkloadSelector {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which a policy should be\n   * applied.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\nexport interface Status {\n  /**\n   * Current service state of the resource.\n   */\n  conditions?: Condition[];\n  /**\n   * Resource Generation to which the Reconciled Condition refers.\n   */\n  observedGeneration?: number | string;\n  /**\n   * Includes any errors or warnings detected by Istio's analyzers.\n   */\n  validationMessages?: ValidationMessage[];\n}\n\nexport interface Condition {\n  /**\n   * Last time we probed the condition.\n   */\n  lastProbeTime?: Date;\n  /**\n   * Last time the condition transitioned from one status to another.\n   */\n  lastTransitionTime?: Date;\n  /**\n   * Human-readable message indicating details about last transition.\n   */\n  message?: string;\n  /**\n   * Unique, one-word, CamelCase reason for the condition's last transition.\n   */\n  reason?: string;\n  /**\n   * Status is the status of the condition.\n   */\n  status?: string;\n  /**\n   * Type is the type of the condition.\n   */\n  type?: string;\n}\n\nexport interface ValidationMessage {\n  /**\n   * A url pointing to the Istio documentation for this specific error type.\n   */\n  documentationUrl?: string;\n  /**\n   * Represents how severe a message is.\n   *\n   * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n   */\n  level?: Level;\n  type?: Type;\n}\n\n/**\n * Represents how severe a message is.\n *\n * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n */\nexport enum Level {\n  Error = \"ERROR\",\n  Info = \"INFO\",\n  Unknown = \"UNKNOWN\",\n  Warning = \"WARNING\",\n}\n\nexport interface Type {\n  /**\n   * A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message\n   * type.\n   */\n  code?: string;\n  /**\n   * A human-readable name for the message type.\n   */\n  name?: string;\n}\n\nRegisterKind(DestinationRule, {\n  group: \"networking.istio.io\",\n  version: \"v1\",\n  kind: \"DestinationRule\",\n  plural: \"destinationrules\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class Gateway extends GenericKind {\n  /**\n   * Configuration affecting edge load balancer. See more details at:\n   * https://istio.io/docs/reference/config/networking/gateway.html\n   */\n  spec?: Spec;\n  status?: Status;\n}\n\n/**\n * Configuration affecting edge load balancer. See more details at:\n * https://istio.io/docs/reference/config/networking/gateway.html\n */\nexport interface Spec {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which this gateway\n   * configuration should be applied.\n   */\n  selector?: { [key: string]: string };\n  /**\n   * A list of server specifications.\n   */\n  servers?: Server[];\n}\n\nexport interface Server {\n  /**\n   * The ip or the Unix domain socket to which the listener should be bound to.\n   */\n  bind?: string;\n  defaultEndpoint?: string;\n  /**\n   * One or more hosts exposed by this gateway.\n   */\n  hosts: string[];\n  /**\n   * An optional name of the server, when set must be unique across all servers.\n   */\n  name?: string;\n  /**\n   * The Port on which the proxy should listen for incoming connections.\n   */\n  port: Port;\n  /**\n   * Set of TLS related options that govern the server's behavior.\n   */\n  tls?: TLS;\n}\n\n/**\n * The Port on which the proxy should listen for incoming connections.\n */\nexport interface Port {\n  /**\n   * Label assigned to the port.\n   */\n  name: string;\n  /**\n   * A valid non-negative integer port number.\n   */\n  number: number;\n  /**\n   * The protocol exposed on the port.\n   */\n  protocol: string;\n  targetPort?: number;\n}\n\n/**\n * Set of TLS related options that govern the server's behavior.\n */\nexport interface TLS {\n  /**\n   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented client side certificate.\n   */\n  caCrl?: string;\n  /**\n   * Optional: If specified, only support the specified cipher list.\n   */\n  cipherSuites?: string[];\n  /**\n   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs\n   * including the CA certificates.\n   */\n  credentialName?: string;\n  /**\n   * If set to true, the load balancer will send a 301 redirect for all http connections,\n   * asking the clients to use HTTPS.\n   */\n  httpsRedirect?: boolean;\n  /**\n   * Optional: Maximum TLS protocol version.\n   *\n   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n   */\n  maxProtocolVersion?: ProtocolVersion;\n  /**\n   * Optional: Minimum TLS protocol version.\n   *\n   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n   */\n  minProtocolVersion?: ProtocolVersion;\n  /**\n   * Optional: Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL,\n   * OPTIONAL_MUTUAL\n   */\n  mode?: Mode;\n  /**\n   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.\n   */\n  serverCertificate?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate presented by\n   * the client.\n   */\n  subjectAltNames?: string[];\n  /**\n   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.\n   */\n  verifyCertificateHash?: string[];\n  /**\n   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client\n   * certificates.\n   */\n  verifyCertificateSpki?: string[];\n}\n\n/**\n * Optional: Maximum TLS protocol version.\n *\n * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n *\n * Optional: Minimum TLS protocol version.\n *\n * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n */\nexport enum ProtocolVersion {\n  TLSAuto = \"TLS_AUTO\",\n  Tlsv10 = \"TLSV1_0\",\n  Tlsv11 = \"TLSV1_1\",\n  Tlsv12 = \"TLSV1_2\",\n  Tlsv13 = \"TLSV1_3\",\n}\n\n/**\n * Optional: Indicates whether connections to this port should be secured using TLS.\n *\n * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL,\n * OPTIONAL_MUTUAL\n */\nexport enum Mode {\n  AutoPassthrough = \"AUTO_PASSTHROUGH\",\n  IstioMutual = \"ISTIO_MUTUAL\",\n  Mutual = \"MUTUAL\",\n  OptionalMutual = \"OPTIONAL_MUTUAL\",\n  Passthrough = \"PASSTHROUGH\",\n  Simple = \"SIMPLE\",\n}\n\nexport interface Status {\n  /**\n   * Current service state of the resource.\n   */\n  conditions?: Condition[];\n  /**\n   * Resource Generation to which the Reconciled Condition refers.\n   */\n  observedGeneration?: number | string;\n  /**\n   * Includes any errors or warnings detected by Istio's analyzers.\n   */\n  validationMessages?: ValidationMessage[];\n}\n\nexport interface Condition {\n  /**\n   * Last time we probed the condition.\n   */\n  lastProbeTime?: Date;\n  /**\n   * Last time the condition transitioned from one status to another.\n   */\n  lastTransitionTime?: Date;\n  /**\n   * Human-readable message indicating details about last transition.\n   */\n  message?: string;\n  /**\n   * Unique, one-word, CamelCase reason for the condition's last transition.\n   */\n  reason?: string;\n  /**\n   * Status is the status of the condition.\n   */\n  status?: string;\n  /**\n   * Type is the type of the condition.\n   */\n  type?: string;\n}\n\nexport interface ValidationMessage {\n  /**\n   * A url pointing to the Istio documentation for this specific error type.\n   */\n  documentationUrl?: string;\n  /**\n   * Represents how severe a message is.\n   *\n   * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n   */\n  level?: Level;\n  type?: Type;\n}\n\n/**\n * Represents how severe a message is.\n *\n * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n */\nexport enum Level {\n  Error = \"ERROR\",\n  Info = \"INFO\",\n  Unknown = \"UNKNOWN\",\n  Warning = \"WARNING\",\n}\n\nexport interface Type {\n  /**\n   * A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message\n   * type.\n   */\n  code?: string;\n  /**\n   * A human-readable name for the message type.\n   */\n  name?: string;\n}\n\nRegisterKind(Gateway, {\n  group: \"networking.istio.io\",\n  version: \"v1\",\n  kind: \"Gateway\",\n  plural: \"gateways\",\n});\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\nexport class Sidecar extends GenericKind {\n  /**\n   * Configuration affecting network reachability of a sidecar. See more details at:\n   * https://istio.io/docs/reference/config/networking/sidecar.html\n   */\n  spec?: Spec;\n  status?: Status;\n}\n\n/**\n * Configuration affecting network reachability of a sidecar. See more details at:\n * https://istio.io/docs/reference/config/networking/sidecar.html\n */\nexport interface Spec {\n  /**\n   * Egress specifies the configuration of the sidecar for processing outbound traffic from\n   * the attached workload instance to other services in the mesh.\n   */\n  egress?: Egress[];\n  /**\n   * Settings controlling the volume of connections Envoy will accept from the network.\n   */\n  inboundConnectionPool?: InboundConnectionPool;\n  /**\n   * Ingress specifies the configuration of the sidecar for processing inbound traffic to the\n   * attached workload instance.\n   */\n  ingress?: Ingress[];\n  /**\n   * Set the default behavior of the sidecar for handling outbound traffic from the\n   * application.\n   */\n  outboundTrafficPolicy?: OutboundTrafficPolicy;\n  /**\n   * Criteria used to select the specific set of pods/VMs on which this `Sidecar`\n   * configuration should be applied.\n   */\n  workloadSelector?: WorkloadSelector;\n}\n\nexport interface Egress {\n  /**\n   * The IP(IPv4 or IPv6) or the Unix domain socket to which the listener should be bound to.\n   */\n  bind?: string;\n  /**\n   * When the bind address is an IP, the captureMode option dictates how traffic to the\n   * listener is expected to be captured (or not).\n   *\n   * Valid Options: DEFAULT, IPTABLES, NONE\n   */\n  captureMode?: CaptureMode;\n  /**\n   * One or more service hosts exposed by the listener in `namespace/dnsName` format.\n   */\n  hosts: string[];\n  /**\n   * The port associated with the listener.\n   */\n  port?: EgressPort;\n}\n\n/**\n * When the bind address is an IP, the captureMode option dictates how traffic to the\n * listener is expected to be captured (or not).\n *\n * Valid Options: DEFAULT, IPTABLES, NONE\n *\n * The captureMode option dictates how traffic to the listener is expected to be captured\n * (or not).\n *\n * Valid Options: DEFAULT, IPTABLES, NONE\n */\nexport enum CaptureMode {\n  Default = \"DEFAULT\",\n  Iptables = \"IPTABLES\",\n  None = \"NONE\",\n}\n\n/**\n * The port associated with the listener.\n */\nexport interface EgressPort {\n  /**\n   * Label assigned to the port.\n   */\n  name?: string;\n  /**\n   * A valid non-negative integer port number.\n   */\n  number?: number;\n  /**\n   * The protocol exposed on the port.\n   */\n  protocol?: string;\n  targetPort?: number;\n}\n\n/**\n * Settings controlling the volume of connections Envoy will accept from the network.\n */\nexport interface InboundConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: InboundConnectionPoolHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: InboundConnectionPoolTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface InboundConnectionPoolHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Specify if http1.1 connection should be upgraded to http2 for the associated\n * destination.\n *\n * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n */\nexport enum H2UpgradePolicy {\n  Default = \"DEFAULT\",\n  DoNotUpgrade = \"DO_NOT_UPGRADE\",\n  Upgrade = \"UPGRADE\",\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface InboundConnectionPoolTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: PurpleTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface PurpleTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\nexport interface Ingress {\n  /**\n   * The IP(IPv4 or IPv6) to which the listener should be bound.\n   */\n  bind?: string;\n  /**\n   * The captureMode option dictates how traffic to the listener is expected to be captured\n   * (or not).\n   *\n   * Valid Options: DEFAULT, IPTABLES, NONE\n   */\n  captureMode?: CaptureMode;\n  /**\n   * Settings controlling the volume of connections Envoy will accept from the network.\n   */\n  connectionPool?: ConnectionPool;\n  /**\n   * The IP endpoint or Unix domain socket to which traffic should be forwarded to.\n   */\n  defaultEndpoint?: string;\n  /**\n   * The port associated with the listener.\n   */\n  port: IngressPort;\n  /**\n   * Set of TLS related options that will enable TLS termination on the sidecar for requests\n   * originating from outside the mesh.\n   */\n  tls?: TLS;\n}\n\n/**\n * Settings controlling the volume of connections Envoy will accept from the network.\n */\nexport interface ConnectionPool {\n  /**\n   * HTTP connection pool settings.\n   */\n  http?: ConnectionPoolHTTP;\n  /**\n   * Settings common to both HTTP and TCP upstream connections.\n   */\n  tcp?: ConnectionPoolTCP;\n}\n\n/**\n * HTTP connection pool settings.\n */\nexport interface ConnectionPoolHTTP {\n  /**\n   * Specify if http1.1 connection should be upgraded to http2 for the associated\n   * destination.\n   *\n   * Valid Options: DEFAULT, DO_NOT_UPGRADE, UPGRADE\n   */\n  h2UpgradePolicy?: H2UpgradePolicy;\n  /**\n   * Maximum number of requests that will be queued while waiting for a ready connection pool\n   * connection.\n   */\n  http1MaxPendingRequests?: number;\n  /**\n   * Maximum number of active requests to a destination.\n   */\n  http2MaxRequests?: number;\n  /**\n   * The idle timeout for upstream connection pool connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\n   */\n  maxConcurrentStreams?: number;\n  /**\n   * Maximum number of requests per connection to a backend.\n   */\n  maxRequestsPerConnection?: number;\n  /**\n   * Maximum number of retries that can be outstanding to all hosts in a cluster at a given\n   * time.\n   */\n  maxRetries?: number;\n  /**\n   * If set to true, client protocol will be preserved while initiating connection to backend.\n   */\n  useClientProtocol?: boolean;\n}\n\n/**\n * Settings common to both HTTP and TCP upstream connections.\n */\nexport interface ConnectionPoolTCP {\n  /**\n   * TCP connection timeout.\n   */\n  connectTimeout?: string;\n  /**\n   * The idle timeout for TCP connections.\n   */\n  idleTimeout?: string;\n  /**\n   * The maximum duration of a connection.\n   */\n  maxConnectionDuration?: string;\n  /**\n   * Maximum number of HTTP1 /TCP connections to a destination host.\n   */\n  maxConnections?: number;\n  /**\n   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n   */\n  tcpKeepalive?: FluffyTCPKeepalive;\n}\n\n/**\n * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\n */\nexport interface FluffyTCPKeepalive {\n  /**\n   * The time duration between keep-alive probes.\n   */\n  interval?: string;\n  /**\n   * Maximum number of keepalive probes to send without response before deciding the\n   * connection is dead.\n   */\n  probes?: number;\n  /**\n   * The time duration a connection needs to be idle before keep-alive probes start being sent.\n   */\n  time?: string;\n}\n\n/**\n * The port associated with the listener.\n */\nexport interface IngressPort {\n  /**\n   * Label assigned to the port.\n   */\n  name?: string;\n  /**\n   * A valid non-negative integer port number.\n   */\n  number?: number;\n  /**\n   * The protocol exposed on the port.\n   */\n  protocol?: string;\n  targetPort?: number;\n}\n\n/**\n * Set of TLS related options that will enable TLS termination on the sidecar for requests\n * originating from outside the mesh.\n */\nexport interface TLS {\n  /**\n   * REQUIRED if mode is `MUTUAL` or `OPTIONAL_MUTUAL`.\n   */\n  caCertificates?: string;\n  /**\n   * OPTIONAL: The path to the file containing the certificate revocation list (CRL) to use in\n   * verifying a presented client side certificate.\n   */\n  caCrl?: string;\n  /**\n   * Optional: If specified, only support the specified cipher list.\n   */\n  cipherSuites?: string[];\n  /**\n   * For gateways running on Kubernetes, the name of the secret that holds the TLS certs\n   * including the CA certificates.\n   */\n  credentialName?: string;\n  /**\n   * If set to true, the load balancer will send a 301 redirect for all http connections,\n   * asking the clients to use HTTPS.\n   */\n  httpsRedirect?: boolean;\n  /**\n   * Optional: Maximum TLS protocol version.\n   *\n   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n   */\n  maxProtocolVersion?: ProtocolVersion;\n  /**\n   * Optional: Minimum TLS protocol version.\n   *\n   * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n   */\n  minProtocolVersion?: ProtocolVersion;\n  /**\n   * Optional: Indicates whether connections to this port should be secured using TLS.\n   *\n   * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL,\n   * OPTIONAL_MUTUAL\n   */\n  mode?: TLSMode;\n  /**\n   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.\n   */\n  privateKey?: string;\n  /**\n   * REQUIRED if mode is `SIMPLE` or `MUTUAL`.\n   */\n  serverCertificate?: string;\n  /**\n   * A list of alternate names to verify the subject identity in the certificate presented by\n   * the client.\n   */\n  subjectAltNames?: string[];\n  /**\n   * An optional list of hex-encoded SHA-256 hashes of the authorized client certificates.\n   */\n  verifyCertificateHash?: string[];\n  /**\n   * An optional list of base64-encoded SHA-256 hashes of the SPKIs of authorized client\n   * certificates.\n   */\n  verifyCertificateSpki?: string[];\n}\n\n/**\n * Optional: Maximum TLS protocol version.\n *\n * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n *\n * Optional: Minimum TLS protocol version.\n *\n * Valid Options: TLS_AUTO, TLSV1_0, TLSV1_1, TLSV1_2, TLSV1_3\n */\nexport enum ProtocolVersion {\n  TLSAuto = \"TLS_AUTO\",\n  Tlsv10 = \"TLSV1_0\",\n  Tlsv11 = \"TLSV1_1\",\n  Tlsv12 = \"TLSV1_2\",\n  Tlsv13 = \"TLSV1_3\",\n}\n\n/**\n * Optional: Indicates whether connections to this port should be secured using TLS.\n *\n * Valid Options: PASSTHROUGH, SIMPLE, MUTUAL, AUTO_PASSTHROUGH, ISTIO_MUTUAL,\n * OPTIONAL_MUTUAL\n */\nexport enum TLSMode {\n  AutoPassthrough = \"AUTO_PASSTHROUGH\",\n  IstioMutual = \"ISTIO_MUTUAL\",\n  Mutual = \"MUTUAL\",\n  OptionalMutual = \"OPTIONAL_MUTUAL\",\n  Passthrough = \"PASSTHROUGH\",\n  Simple = \"SIMPLE\",\n}\n\n/**\n * Set the default behavior of the sidecar for handling outbound traffic from the\n * application.\n */\nexport interface OutboundTrafficPolicy {\n  egressProxy?: EgressProxy;\n  /**\n   * Valid Options: REGISTRY_ONLY, ALLOW_ANY\n   */\n  mode?: OutboundTrafficPolicyMode;\n}\n\nexport interface EgressProxy {\n  /**\n   * The name of a service from the service registry.\n   */\n  host: string;\n  /**\n   * Specifies the port on the host that is being addressed.\n   */\n  port?: EgressProxyPort;\n  /**\n   * The name of a subset within the service.\n   */\n  subset?: string;\n}\n\n/**\n * Specifies the port on the host that is being addressed.\n */\nexport interface EgressProxyPort {\n  number?: number;\n}\n\n/**\n * Valid Options: REGISTRY_ONLY, ALLOW_ANY\n */\nexport enum OutboundTrafficPolicyMode {\n  AllowAny = \"ALLOW_ANY\",\n  RegistryOnly = \"REGISTRY_ONLY\",\n}\n\n/**\n * Criteria used to select the specific set of pods/VMs on which this `Sidecar`\n * configuration should be applied.\n */\nexport interface WorkloadSelector {\n  /**\n   * One or more labels that indicate a specific set of pods/VMs on which the configuration\n   * should be applied.\n   */\n  labels?: { [key: string]: string };\n}\n\nexport interface Status {\n  /**\n   * Current service state of the resource.\n   */\n  conditions?: Condition[];\n  /**\n   * Resource Generation to which the Reconciled Condition refers.\n   */\n  observedGeneration?: number | string;\n  /**\n   * Includes any errors or warnings detected by Istio's analyzers.\n   */\n  validationMessages?: ValidationMessage[];\n}\n\nexport interface Condition {\n  /**\n   * Last time we probed the condition.\n   */\n  lastProbeTime?: Date;\n  /**\n   * Last time the condition transitioned from one status to another.\n   */\n  lastTransitionTime?: Date;\n  /**\n   * Human-readable message indicating details about last transition.\n   */\n  message?: string;\n  /**\n   * Unique, one-word, CamelCase reason for the condition's last transition.\n   */\n  reason?: string;\n  /**\n   * Status is the status of the condition.\n   */\n  status?: string;\n  /**\n   * Type is the type of the condition.\n   */\n  type?: string;\n}\n\nexport interface ValidationMessage {\n  /**\n   * A url pointing to the Istio documentation for this specific error type.\n   */\n  documentationUrl?: string;\n  /**\n   * Represents how severe a message is.\n   *\n   * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n   */\n  level?: Level;\n  type?: Type;\n}\n\n/**\n * Represents how severe a message is.\n *\n * Valid Options: UNKNOWN, ERROR, WARNING, INFO\n */\nexport enum Level {\n  Error = \"ERROR\",\n  Info = \"INFO\",\n  Unknown = \"UNKNOWN\",\n  Warning = \"WARNING\",\n}\n\nexport interface Type {\n  /**\n   * A 7 character code matching `^IST[0-9]{4}$` intended to uniquely identify the message\n   * type.\n   */\n  code?: string;\n  /**\n   * A human-readable name for the message type.\n   */\n  name?: string;\n}\n\nRegisterKind(Sidecar, {\n  group: \"networking.istio.io\",\n  version: \"v1\",\n  kind: \"Sidecar\",\n  plural: \"sidecars\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// This file is auto-generated by kubernetes-fluent-client, do not edit manually\n\nimport { GenericKind, RegisterKind } from \"kubernetes-fluent-client\";\n/**\n * Gateway represents an instance of a service-traffic handling infrastructure\n * by binding Listeners to a set of IP addresses.\n */\nexport class K8sGateway extends GenericKind {\n  /**\n   * APIVersion defines the versioned schema of this representation of an object.\n   * Servers should convert recognized schemas to the latest internal value, and\n   * may reject unrecognized values.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n   */\n  declare apiVersion?: string;\n  /**\n   * Kind is a string value representing the REST resource this object represents.\n   * Servers may infer this from the endpoint the client submits requests to.\n   * Cannot be updated.\n   * In CamelCase.\n   * More info:\n   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n   */\n  declare kind?: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  declare metadata?: { [key: string]: any };\n  /**\n   * Spec defines the desired state of Gateway.\n   */\n  spec?: Spec;\n  /**\n   * Status defines the current state of Gateway.\n   */\n  status?: StatusObject;\n}\n\n/**\n * Spec defines the desired state of Gateway.\n */\nexport interface Spec {\n  /**\n   * Addresses requested for this Gateway. This is optional and behavior can\n   * depend on the implementation. If a value is set in the spec and the\n   * requested address is invalid or unavailable, the implementation MUST\n   * indicate this in the associated entry in GatewayStatus.Addresses.\n   *\n   * The Addresses field represents a request for the address(es) on the\n   * \"outside of the Gateway\", that traffic bound for this Gateway will use.\n   * This could be the IP address or hostname of an external load balancer or\n   * other networking infrastructure, or some other address that traffic will\n   * be sent to.\n   *\n   * If no Addresses are specified, the implementation MAY schedule the\n   * Gateway in an implementation-specific manner, assigning an appropriate\n   * set of Addresses.\n   *\n   * The implementation MUST bind all Listeners to every GatewayAddress that\n   * it assigns to the Gateway and add a corresponding entry in\n   * GatewayStatus.Addresses.\n   *\n   * Support: Extended\n   */\n  addresses?: SpecAddress[];\n  /**\n   * GatewayClassName used for this Gateway. This is the name of a\n   * GatewayClass resource.\n   */\n  gatewayClassName: string;\n  /**\n   * Infrastructure defines infrastructure level attributes about this Gateway instance.\n   *\n   * Support: Extended\n   */\n  infrastructure?: Infrastructure;\n  /**\n   * Listeners associated with this Gateway. Listeners define\n   * logical endpoints that are bound on this Gateway's addresses.\n   * At least one Listener MUST be specified.\n   *\n   * ## Distinct Listeners\n   *\n   * Each Listener in a set of Listeners (for example, in a single Gateway)\n   * MUST be _distinct_, in that a traffic flow MUST be able to be assigned to\n   * exactly one listener. (This section uses \"set of Listeners\" rather than\n   * \"Listeners in a single Gateway\" because implementations MAY merge configuration\n   * from multiple Gateways onto a single data plane, and these rules _also_\n   * apply in that case).\n   *\n   * Practically, this means that each listener in a set MUST have a unique\n   * combination of Port, Protocol, and, if supported by the protocol, Hostname.\n   *\n   * Some combinations of port, protocol, and TLS settings are considered\n   * Core support and MUST be supported by implementations based on the objects\n   * they support:\n   *\n   * HTTPRoute\n   *\n   * 1. HTTPRoute, Port: 80, Protocol: HTTP\n   * 2. HTTPRoute, Port: 443, Protocol: HTTPS, TLS Mode: Terminate, TLS keypair provided\n   *\n   * TLSRoute\n   *\n   * 1. TLSRoute, Port: 443, Protocol: TLS, TLS Mode: Passthrough\n   *\n   * \"Distinct\" Listeners have the following property:\n   *\n   * **The implementation can match inbound requests to a single distinct\n   * Listener**.\n   *\n   * When multiple Listeners share values for fields (for\n   * example, two Listeners with the same Port value), the implementation\n   * can match requests to only one of the Listeners using other\n   * Listener fields.\n   *\n   * When multiple listeners have the same value for the Protocol field, then\n   * each of the Listeners with matching Protocol values MUST have different\n   * values for other fields.\n   *\n   * The set of fields that MUST be different for a Listener differs per protocol.\n   * The following rules define the rules for what fields MUST be considered for\n   * Listeners to be distinct with each protocol currently defined in the\n   * Gateway API spec.\n   *\n   * The set of listeners that all share a protocol value MUST have _different_\n   * values for _at least one_ of these fields to be distinct:\n   *\n   * * **HTTP, HTTPS, TLS**: Port, Hostname\n   * * **TCP, UDP**: Port\n   *\n   * One **very** important rule to call out involves what happens when an\n   * implementation:\n   *\n   * * Supports TCP protocol Listeners, as well as HTTP, HTTPS, or TLS protocol\n   * Listeners, and\n   * * sees HTTP, HTTPS, or TLS protocols with the same `port` as one with TCP\n   * Protocol.\n   *\n   * In this case all the Listeners that share a port with the\n   * TCP Listener are not distinct and so MUST NOT be accepted.\n   *\n   * If an implementation does not support TCP Protocol Listeners, then the\n   * previous rule does not apply, and the TCP Listeners SHOULD NOT be\n   * accepted.\n   *\n   * Note that the `tls` field is not used for determining if a listener is distinct, because\n   * Listeners that _only_ differ on TLS config will still conflict in all cases.\n   *\n   * ### Listeners that are distinct only by Hostname\n   *\n   * When the Listeners are distinct based only on Hostname, inbound request\n   * hostnames MUST match from the most specific to least specific Hostname\n   * values to choose the correct Listener and its associated set of Routes.\n   *\n   * Exact matches MUST be processed before wildcard matches, and wildcard\n   * matches MUST be processed before fallback (empty Hostname value)\n   * matches. For example, `\"foo.example.com\"` takes precedence over\n   * `\"*.example.com\"`, and `\"*.example.com\"` takes precedence over `\"\"`.\n   *\n   * Additionally, if there are multiple wildcard entries, more specific\n   * wildcard entries must be processed before less specific wildcard entries.\n   * For example, `\"*.foo.example.com\"` takes precedence over `\"*.example.com\"`.\n   *\n   * The precise definition here is that the higher the number of dots in the\n   * hostname to the right of the wildcard character, the higher the precedence.\n   *\n   * The wildcard character will match any number of characters _and dots_ to\n   * the left, however, so `\"*.example.com\"` will match both\n   * `\"foo.bar.example.com\"` _and_ `\"bar.example.com\"`.\n   *\n   * ## Handling indistinct Listeners\n   *\n   * If a set of Listeners contains Listeners that are not distinct, then those\n   * Listeners are _Conflicted_, and the implementation MUST set the \"Conflicted\"\n   * condition in the Listener Status to \"True\".\n   *\n   * The words \"indistinct\" and \"conflicted\" are considered equivalent for the\n   * purpose of this documentation.\n   *\n   * Implementations MAY choose to accept a Gateway with some Conflicted\n   * Listeners only if they only accept the partial Listener set that contains\n   * no Conflicted Listeners.\n   *\n   * Specifically, an implementation MAY accept a partial Listener set subject to\n   * the following rules:\n   *\n   * * The implementation MUST NOT pick one conflicting Listener as the winner.\n   * ALL indistinct Listeners must not be accepted for processing.\n   * * At least one distinct Listener MUST be present, or else the Gateway effectively\n   * contains _no_ Listeners, and must be rejected from processing as a whole.\n   *\n   * The implementation MUST set a \"ListenersNotValid\" condition on the\n   * Gateway Status when the Gateway contains Conflicted Listeners whether or\n   * not they accept the Gateway. That Condition SHOULD clearly\n   * indicate in the Message which Listeners are conflicted, and which are\n   * Accepted. Additionally, the Listener status for those listeners SHOULD\n   * indicate which Listeners are conflicted and not Accepted.\n   *\n   * ## General Listener behavior\n   *\n   * Note that, for all distinct Listeners, requests SHOULD match at most one Listener.\n   * For example, if Listeners are defined for \"foo.example.com\" and \"*.example.com\", a\n   * request to \"foo.example.com\" SHOULD only be routed using routes attached\n   * to the \"foo.example.com\" Listener (and not the \"*.example.com\" Listener).\n   *\n   * This concept is known as \"Listener Isolation\", and it is an Extended feature\n   * of Gateway API. Implementations that do not support Listener Isolation MUST\n   * clearly document this, and MUST NOT claim support for the\n   * `GatewayHTTPListenerIsolation` feature.\n   *\n   * Implementations that _do_ support Listener Isolation SHOULD claim support\n   * for the Extended `GatewayHTTPListenerIsolation` feature and pass the associated\n   * conformance tests.\n   *\n   * ## Compatible Listeners\n   *\n   * A Gateway's Listeners are considered _compatible_ if:\n   *\n   * 1. They are distinct.\n   * 2. The implementation can serve them in compliance with the Addresses\n   * requirement that all Listeners are available on all assigned\n   * addresses.\n   *\n   * Compatible combinations in Extended support are expected to vary across\n   * implementations. A combination that is compatible for one implementation\n   * may not be compatible for another.\n   *\n   * For example, an implementation that cannot serve both TCP and UDP listeners\n   * on the same address, or cannot mix HTTPS and generic TLS listens on the same port\n   * would not consider those cases compatible, even though they are distinct.\n   *\n   * Implementations MAY merge separate Gateways onto a single set of\n   * Addresses if all Listeners across all Gateways are compatible.\n   *\n   * In a future release the MinItems=1 requirement MAY be dropped.\n   *\n   * Support: Core\n   */\n  listeners: SpecListener[];\n}\n\n/**\n * GatewaySpecAddress describes an address that can be bound to a Gateway.\n */\nexport interface SpecAddress {\n  /**\n   * Type of the address.\n   */\n  type?: string;\n  /**\n   * When a value is unspecified, an implementation SHOULD automatically\n   * assign an address matching the requested type if possible.\n   *\n   * If an implementation does not support an empty value, they MUST set the\n   * \"Programmed\" condition in status to False with a reason of \"AddressNotAssigned\".\n   *\n   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\n   */\n  value?: string;\n}\n\n/**\n * Infrastructure defines infrastructure level attributes about this Gateway instance.\n *\n * Support: Extended\n */\nexport interface Infrastructure {\n  /**\n   * Annotations that SHOULD be applied to any resources created in response to this Gateway.\n   *\n   * For implementations creating other Kubernetes objects, this should be the\n   * `metadata.annotations` field on resources.\n   * For other implementations, this refers to any relevant (implementation specific)\n   * \"annotations\" concepts.\n   *\n   * An implementation may chose to add additional implementation-specific annotations as they\n   * see fit.\n   *\n   * Support: Extended\n   */\n  annotations?: { [key: string]: string };\n  /**\n   * Labels that SHOULD be applied to any resources created in response to this Gateway.\n   *\n   * For implementations creating other Kubernetes objects, this should be the\n   * `metadata.labels` field on resources.\n   * For other implementations, this refers to any relevant (implementation specific) \"labels\"\n   * concepts.\n   *\n   * An implementation may chose to add additional implementation-specific labels as they see\n   * fit.\n   *\n   * If an implementation maps these labels to Pods, or any other resource that would need to\n   * be recreated when labels\n   * change, it SHOULD clearly warn about this behavior in documentation.\n   *\n   * Support: Extended\n   */\n  labels?: { [key: string]: string };\n  /**\n   * ParametersRef is a reference to a resource that contains the configuration\n   * parameters corresponding to the Gateway. This is optional if the\n   * controller does not require any additional configuration.\n   *\n   * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway\n   * basis\n   *\n   * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,\n   * the merging behavior is implementation specific.\n   * It is generally recommended that GatewayClass provides defaults that can be overridden by\n   * a Gateway.\n   *\n   * If the referent cannot be found, refers to an unsupported kind, or when\n   * the data within that resource is malformed, the Gateway SHOULD be\n   * rejected with the \"Accepted\" status condition set to \"False\" and an\n   * \"InvalidParameters\" reason.\n   *\n   * Support: Implementation-specific\n   */\n  parametersRef?: ParametersRef;\n}\n\n/**\n * ParametersRef is a reference to a resource that contains the configuration\n * parameters corresponding to the Gateway. This is optional if the\n * controller does not require any additional configuration.\n *\n * This follows the same semantics as GatewayClass's `parametersRef`, but on a per-Gateway\n * basis\n *\n * The Gateway's GatewayClass may provide its own `parametersRef`. When both are specified,\n * the merging behavior is implementation specific.\n * It is generally recommended that GatewayClass provides defaults that can be overridden by\n * a Gateway.\n *\n * If the referent cannot be found, refers to an unsupported kind, or when\n * the data within that resource is malformed, the Gateway SHOULD be\n * rejected with the \"Accepted\" status condition set to \"False\" and an\n * \"InvalidParameters\" reason.\n *\n * Support: Implementation-specific\n */\nexport interface ParametersRef {\n  /**\n   * Group is the group of the referent.\n   */\n  group: string;\n  /**\n   * Kind is kind of the referent.\n   */\n  kind: string;\n  /**\n   * Name is the name of the referent.\n   */\n  name: string;\n}\n\n/**\n * Listener embodies the concept of a logical endpoint where a Gateway accepts\n * network connections.\n */\nexport interface SpecListener {\n  /**\n   * AllowedRoutes defines the types of routes that MAY be attached to a\n   * Listener and the trusted namespaces where those Route resources MAY be\n   * present.\n   *\n   * Although a client request may match multiple route rules, only one rule\n   * may ultimately receive the request. Matching precedence MUST be\n   * determined in order of the following criteria:\n   *\n   * * The most specific match as defined by the Route type.\n   * * The oldest Route based on creation timestamp. For example, a Route with\n   * a creation timestamp of \"2020-09-08 01:02:03\" is given precedence over\n   * a Route with a creation timestamp of \"2020-09-08 01:02:04\".\n   * * If everything else is equivalent, the Route appearing first in\n   * alphabetical order (namespace/name) should be given precedence. For\n   * example, foo/bar is given precedence over foo/baz.\n   *\n   * All valid rules within a Route attached to this Listener should be\n   * implemented. Invalid Route rules can be ignored (sometimes that will mean\n   * the full Route). If a Route rule transitions from valid to invalid,\n   * support for that Route rule should be dropped to ensure consistency. For\n   * example, even if a filter specified by a Route rule is invalid, the rest\n   * of the rules within that Route should still be supported.\n   *\n   * Support: Core\n   */\n  allowedRoutes?: AllowedRoutes;\n  /**\n   * Hostname specifies the virtual hostname to match for protocol types that\n   * define this concept. When unspecified, all hostnames are matched. This\n   * field is ignored for protocols that don't require hostname based\n   * matching.\n   *\n   * Implementations MUST apply Hostname matching appropriately for each of\n   * the following protocols:\n   *\n   * * TLS: The Listener Hostname MUST match the SNI.\n   * * HTTP: The Listener Hostname MUST match the Host header of the request.\n   * * HTTPS: The Listener Hostname SHOULD match both the SNI and Host header.\n   * Note that this does not require the SNI and Host header to be the same.\n   * The semantics of this are described in more detail below.\n   *\n   * To ensure security, Section 11.1 of RFC-6066 emphasizes that server\n   * implementations that rely on SNI hostname matching MUST also verify\n   * hostnames within the application protocol.\n   *\n   * Section 9.1.2 of RFC-7540 provides a mechanism for servers to reject the\n   * reuse of a connection by responding with the HTTP 421 Misdirected Request\n   * status code. This indicates that the origin server has rejected the\n   * request because it appears to have been misdirected.\n   *\n   * To detect misdirected requests, Gateways SHOULD match the authority of\n   * the requests with all the SNI hostname(s) configured across all the\n   * Gateway Listeners on the same port and protocol:\n   *\n   * * If another Listener has an exact match or more specific wildcard entry,\n   * the Gateway SHOULD return a 421.\n   * * If the current Listener (selected by SNI matching during ClientHello)\n   * does not match the Host:\n   * * If another Listener does match the Host the Gateway SHOULD return a\n   * 421.\n   * * If no other Listener matches the Host, the Gateway MUST return a\n   * 404.\n   *\n   * For HTTPRoute and TLSRoute resources, there is an interaction with the\n   * `spec.hostnames` array. When both listener and route specify hostnames,\n   * there MUST be an intersection between the values for a Route to be\n   * accepted. For more information, refer to the Route specific Hostnames\n   * documentation.\n   *\n   * Hostnames that are prefixed with a wildcard label (`*.`) are interpreted\n   * as a suffix match. That means that a match for `*.example.com` would match\n   * both `test.example.com`, and `foo.test.example.com`, but not `example.com`.\n   *\n   * Support: Core\n   */\n  hostname?: string;\n  /**\n   * Name is the name of the Listener. This name MUST be unique within a\n   * Gateway.\n   *\n   * Support: Core\n   */\n  name: string;\n  /**\n   * Port is the network port. Multiple listeners may use the\n   * same port, subject to the Listener compatibility rules.\n   *\n   * Support: Core\n   */\n  port: number;\n  /**\n   * Protocol specifies the network protocol this listener expects to receive.\n   *\n   * Support: Core\n   */\n  protocol: string;\n  /**\n   * TLS is the TLS configuration for the Listener. This field is required if\n   * the Protocol field is \"HTTPS\" or \"TLS\". It is invalid to set this field\n   * if the Protocol field is \"HTTP\", \"TCP\", or \"UDP\".\n   *\n   * The association of SNIs to Certificate defined in GatewayTLSConfig is\n   * defined based on the Hostname field for this listener.\n   *\n   * The GatewayClass MUST use the longest matching SNI out of all\n   * available certificates for any TLS handshake.\n   *\n   * Support: Core\n   */\n  tls?: TLS;\n}\n\n/**\n * AllowedRoutes defines the types of routes that MAY be attached to a\n * Listener and the trusted namespaces where those Route resources MAY be\n * present.\n *\n * Although a client request may match multiple route rules, only one rule\n * may ultimately receive the request. Matching precedence MUST be\n * determined in order of the following criteria:\n *\n * * The most specific match as defined by the Route type.\n * * The oldest Route based on creation timestamp. For example, a Route with\n * a creation timestamp of \"2020-09-08 01:02:03\" is given precedence over\n * a Route with a creation timestamp of \"2020-09-08 01:02:04\".\n * * If everything else is equivalent, the Route appearing first in\n * alphabetical order (namespace/name) should be given precedence. For\n * example, foo/bar is given precedence over foo/baz.\n *\n * All valid rules within a Route attached to this Listener should be\n * implemented. Invalid Route rules can be ignored (sometimes that will mean\n * the full Route). If a Route rule transitions from valid to invalid,\n * support for that Route rule should be dropped to ensure consistency. For\n * example, even if a filter specified by a Route rule is invalid, the rest\n * of the rules within that Route should still be supported.\n *\n * Support: Core\n */\nexport interface AllowedRoutes {\n  /**\n   * Kinds specifies the groups and kinds of Routes that are allowed to bind\n   * to this Gateway Listener. When unspecified or empty, the kinds of Routes\n   * selected are determined using the Listener protocol.\n   *\n   * A RouteGroupKind MUST correspond to kinds of Routes that are compatible\n   * with the application protocol specified in the Listener's Protocol field.\n   * If an implementation does not support or recognize this resource type, it\n   * MUST set the \"ResolvedRefs\" condition to False for this Listener with the\n   * \"InvalidRouteKinds\" reason.\n   *\n   * Support: Core\n   */\n  kinds?: Kind[];\n  /**\n   * Namespaces indicates namespaces from which Routes may be attached to this\n   * Listener. This is restricted to the namespace of this Gateway by default.\n   *\n   * Support: Core\n   */\n  namespaces?: Namespaces;\n}\n\n/**\n * RouteGroupKind indicates the group and kind of a Route resource.\n */\nexport interface Kind {\n  /**\n   * Group is the group of the Route.\n   */\n  group?: string;\n  /**\n   * Kind is the kind of the Route.\n   */\n  kind: string;\n}\n\n/**\n * Namespaces indicates namespaces from which Routes may be attached to this\n * Listener. This is restricted to the namespace of this Gateway by default.\n *\n * Support: Core\n */\nexport interface Namespaces {\n  /**\n   * From indicates where Routes will be selected for this Gateway. Possible\n   * values are:\n   *\n   * * All: Routes in all namespaces may be used by this Gateway.\n   * * Selector: Routes in namespaces selected by the selector may be used by\n   * this Gateway.\n   * * Same: Only Routes in the same namespace may be used by this Gateway.\n   *\n   * Support: Core\n   */\n  from?: From;\n  /**\n   * Selector must be specified when From is set to \"Selector\". In that case,\n   * only Routes in Namespaces matching this Selector will be selected by this\n   * Gateway. This field is ignored for other values of \"From\".\n   *\n   * Support: Core\n   */\n  selector?: Selector;\n}\n\n/**\n * From indicates where Routes will be selected for this Gateway. Possible\n * values are:\n *\n * * All: Routes in all namespaces may be used by this Gateway.\n * * Selector: Routes in namespaces selected by the selector may be used by\n * this Gateway.\n * * Same: Only Routes in the same namespace may be used by this Gateway.\n *\n * Support: Core\n */\nexport enum From {\n  All = \"All\",\n  Same = \"Same\",\n  Selector = \"Selector\",\n}\n\n/**\n * Selector must be specified when From is set to \"Selector\". In that case,\n * only Routes in Namespaces matching this Selector will be selected by this\n * Gateway. This field is ignored for other values of \"From\".\n *\n * Support: Core\n */\nexport interface Selector {\n  /**\n   * matchExpressions is a list of label selector requirements. The requirements are ANDed.\n   */\n  matchExpressions?: MatchExpression[];\n  /**\n   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n   * map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n   * operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n   */\n  matchLabels?: { [key: string]: string };\n}\n\n/**\n * A label selector requirement is a selector that contains values, a key, and an operator\n * that\n * relates the key and values.\n */\nexport interface MatchExpression {\n  /**\n   * key is the label key that the selector applies to.\n   */\n  key: string;\n  /**\n   * operator represents a key's relationship to a set of values.\n   * Valid operators are In, NotIn, Exists and DoesNotExist.\n   */\n  operator: string;\n  /**\n   * values is an array of string values. If the operator is In or NotIn,\n   * the values array must be non-empty. If the operator is Exists or DoesNotExist,\n   * the values array must be empty. This array is replaced during a strategic\n   * merge patch.\n   */\n  values?: string[];\n}\n\n/**\n * TLS is the TLS configuration for the Listener. This field is required if\n * the Protocol field is \"HTTPS\" or \"TLS\". It is invalid to set this field\n * if the Protocol field is \"HTTP\", \"TCP\", or \"UDP\".\n *\n * The association of SNIs to Certificate defined in GatewayTLSConfig is\n * defined based on the Hostname field for this listener.\n *\n * The GatewayClass MUST use the longest matching SNI out of all\n * available certificates for any TLS handshake.\n *\n * Support: Core\n */\nexport interface TLS {\n  /**\n   * CertificateRefs contains a series of references to Kubernetes objects that\n   * contains TLS certificates and private keys. These certificates are used to\n   * establish a TLS handshake for requests that match the hostname of the\n   * associated listener.\n   *\n   * A single CertificateRef to a Kubernetes Secret has \"Core\" support.\n   * Implementations MAY choose to support attaching multiple certificates to\n   * a Listener, but this behavior is implementation-specific.\n   *\n   * References to a resource in different namespace are invalid UNLESS there\n   * is a ReferenceGrant in the target namespace that allows the certificate\n   * to be attached. If a ReferenceGrant does not allow this reference, the\n   * \"ResolvedRefs\" condition MUST be set to False for this listener with the\n   * \"RefNotPermitted\" reason.\n   *\n   * This field is required to have at least one element when the mode is set\n   * to \"Terminate\" (default) and is optional otherwise.\n   *\n   * CertificateRefs can reference to standard Kubernetes resources, i.e.\n   * Secret, or implementation-specific custom resources.\n   *\n   * Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls\n   *\n   * Support: Implementation-specific (More than one reference or other resource types)\n   */\n  certificateRefs?: CertificateRef[];\n  /**\n   * Mode defines the TLS behavior for the TLS session initiated by the client.\n   * There are two possible modes:\n   *\n   * - Terminate: The TLS session between the downstream client and the\n   * Gateway is terminated at the Gateway. This mode requires certificates\n   * to be specified in some way, such as populating the certificateRefs\n   * field.\n   * - Passthrough: The TLS session is NOT terminated by the Gateway. This\n   * implies that the Gateway can't decipher the TLS stream except for\n   * the ClientHello message of the TLS protocol. The certificateRefs field\n   * is ignored in this mode.\n   *\n   * Support: Core\n   */\n  mode?: Mode;\n  /**\n   * Options are a list of key/value pairs to enable extended TLS\n   * configuration for each implementation. For example, configuring the\n   * minimum TLS version or supported cipher suites.\n   *\n   * A set of common keys MAY be defined by the API in the future. To avoid\n   * any ambiguity, implementation-specific definitions MUST use\n   * domain-prefixed names, such as `example.com/my-custom-option`.\n   * Un-prefixed names are reserved for key names defined by Gateway API.\n   *\n   * Support: Implementation-specific\n   */\n  options?: { [key: string]: string };\n}\n\n/**\n * SecretObjectReference identifies an API object including its namespace,\n * defaulting to Secret.\n *\n * The API object must be valid in the cluster; the Group and Kind must\n * be registered in the cluster for this reference to be valid.\n *\n * References to objects with invalid Group and Kind are not valid, and must\n * be rejected by the implementation, with appropriate Conditions set\n * on the containing object.\n */\nexport interface CertificateRef {\n  /**\n   * Group is the group of the referent. For example, \"gateway.networking.k8s.io\".\n   * When unspecified or empty string, core API group is inferred.\n   */\n  group?: string;\n  /**\n   * Kind is kind of the referent. For example \"Secret\".\n   */\n  kind?: string;\n  /**\n   * Name is the name of the referent.\n   */\n  name: string;\n  /**\n   * Namespace is the namespace of the referenced object. When unspecified, the local\n   * namespace is inferred.\n   *\n   * Note that when a namespace different than the local namespace is specified,\n   * a ReferenceGrant object is required in the referent namespace to allow that\n   * namespace's owner to accept the reference. See the ReferenceGrant\n   * documentation for details.\n   *\n   * Support: Core\n   */\n  namespace?: string;\n}\n\n/**\n * Mode defines the TLS behavior for the TLS session initiated by the client.\n * There are two possible modes:\n *\n * - Terminate: The TLS session between the downstream client and the\n * Gateway is terminated at the Gateway. This mode requires certificates\n * to be specified in some way, such as populating the certificateRefs\n * field.\n * - Passthrough: The TLS session is NOT terminated by the Gateway. This\n * implies that the Gateway can't decipher the TLS stream except for\n * the ClientHello message of the TLS protocol. The certificateRefs field\n * is ignored in this mode.\n *\n * Support: Core\n */\nexport enum Mode {\n  Passthrough = \"Passthrough\",\n  Terminate = \"Terminate\",\n}\n\n/**\n * Status defines the current state of Gateway.\n */\nexport interface StatusObject {\n  /**\n   * Addresses lists the network addresses that have been bound to the\n   * Gateway.\n   *\n   * This list may differ from the addresses provided in the spec under some\n   * conditions:\n   *\n   * * no addresses are specified, all addresses are dynamically assigned\n   * * a combination of specified and dynamic addresses are assigned\n   * * a specified address was unusable (e.g. already in use)\n   */\n  addresses?: StatusAddress[];\n  /**\n   * Conditions describe the current conditions of the Gateway.\n   *\n   * Implementations should prefer to express Gateway conditions\n   * using the `GatewayConditionType` and `GatewayConditionReason`\n   * constants so that operators and tools can converge on a common\n   * vocabulary to describe Gateway state.\n   *\n   * Known condition types are:\n   *\n   * * \"Accepted\"\n   * * \"Programmed\"\n   * * \"Ready\"\n   */\n  conditions?: StatusCondition[];\n  /**\n   * Listeners provide status for each unique listener port defined in the Spec.\n   */\n  listeners?: StatusListener[];\n}\n\n/**\n * GatewayStatusAddress describes a network address that is bound to a Gateway.\n */\nexport interface StatusAddress {\n  /**\n   * Type of the address.\n   */\n  type?: string;\n  /**\n   * Value of the address. The validity of the values will depend\n   * on the type and support by the controller.\n   *\n   * Examples: `1.2.3.4`, `128::1`, `my-ip-address`.\n   */\n  value: string;\n}\n\n/**\n * Condition contains details for one aspect of the current state of this API Resource.\n */\nexport interface StatusCondition {\n  /**\n   * lastTransitionTime is the last time the condition transitioned from one status to\n   * another.\n   * This should be when the underlying condition changed.  If that is not known, then using\n   * the time when the API field changed is acceptable.\n   */\n  lastTransitionTime: Date;\n  /**\n   * message is a human readable message indicating details about the transition.\n   * This may be an empty string.\n   */\n  message: string;\n  /**\n   * observedGeneration represents the .metadata.generation that the condition was set based\n   * upon.\n   * For instance, if .metadata.generation is currently 12, but the\n   * .status.conditions[x].observedGeneration is 9, the condition is out of date\n   * with respect to the current state of the instance.\n   */\n  observedGeneration?: number;\n  /**\n   * reason contains a programmatic identifier indicating the reason for the condition's last\n   * transition.\n   * Producers of specific condition types may define expected values and meanings for this\n   * field,\n   * and whether the values are considered a guaranteed API.\n   * The value should be a CamelCase string.\n   * This field may not be empty.\n   */\n  reason: string;\n  /**\n   * status of the condition, one of True, False, Unknown.\n   */\n  status: StatusEnum;\n  /**\n   * type of condition in CamelCase or in foo.example.com/CamelCase.\n   */\n  type: string;\n}\n\n/**\n * status of the condition, one of True, False, Unknown.\n */\nexport enum StatusEnum {\n  False = \"False\",\n  True = \"True\",\n  Unknown = \"Unknown\",\n}\n\n/**\n * ListenerStatus is the status associated with a Listener.\n */\nexport interface StatusListener {\n  /**\n   * AttachedRoutes represents the total number of Routes that have been\n   * successfully attached to this Listener.\n   *\n   * Successful attachment of a Route to a Listener is based solely on the\n   * combination of the AllowedRoutes field on the corresponding Listener\n   * and the Route's ParentRefs field. A Route is successfully attached to\n   * a Listener when it is selected by the Listener's AllowedRoutes field\n   * AND the Route has a valid ParentRef selecting the whole Gateway\n   * resource or a specific Listener as a parent resource (more detail on\n   * attachment semantics can be found in the documentation on the various\n   * Route kinds ParentRefs fields). Listener or Route status does not impact\n   * successful attachment, i.e. the AttachedRoutes field count MUST be set\n   * for Listeners with condition Accepted: false and MUST count successfully\n   * attached Routes that may themselves have Accepted: false conditions.\n   *\n   * Uses for this field include troubleshooting Route attachment and\n   * measuring blast radius/impact of changes to a Listener.\n   */\n  attachedRoutes: number;\n  /**\n   * Conditions describe the current condition of this listener.\n   */\n  conditions: ListenerCondition[];\n  /**\n   * Name is the name of the Listener that this status corresponds to.\n   */\n  name: string;\n  /**\n   * SupportedKinds is the list indicating the Kinds supported by this\n   * listener. This MUST represent the kinds an implementation supports for\n   * that Listener configuration.\n   *\n   * If kinds are specified in Spec that are not supported, they MUST NOT\n   * appear in this list and an implementation MUST set the \"ResolvedRefs\"\n   * condition to \"False\" with the \"InvalidRouteKinds\" reason. If both valid\n   * and invalid Route kinds are specified, the implementation MUST\n   * reference the valid Route kinds that have been specified.\n   */\n  supportedKinds: SupportedKind[];\n}\n\n/**\n * Condition contains details for one aspect of the current state of this API Resource.\n */\nexport interface ListenerCondition {\n  /**\n   * lastTransitionTime is the last time the condition transitioned from one status to\n   * another.\n   * This should be when the underlying condition changed.  If that is not known, then using\n   * the time when the API field changed is acceptable.\n   */\n  lastTransitionTime: Date;\n  /**\n   * message is a human readable message indicating details about the transition.\n   * This may be an empty string.\n   */\n  message: string;\n  /**\n   * observedGeneration represents the .metadata.generation that the condition was set based\n   * upon.\n   * For instance, if .metadata.generation is currently 12, but the\n   * .status.conditions[x].observedGeneration is 9, the condition is out of date\n   * with respect to the current state of the instance.\n   */\n  observedGeneration?: number;\n  /**\n   * reason contains a programmatic identifier indicating the reason for the condition's last\n   * transition.\n   * Producers of specific condition types may define expected values and meanings for this\n   * field,\n   * and whether the values are considered a guaranteed API.\n   * The value should be a CamelCase string.\n   * This field may not be empty.\n   */\n  reason: string;\n  /**\n   * status of the condition, one of True, False, Unknown.\n   */\n  status: StatusEnum;\n  /**\n   * type of condition in CamelCase or in foo.example.com/CamelCase.\n   */\n  type: string;\n}\n\n/**\n * RouteGroupKind indicates the group and kind of a Route resource.\n */\nexport interface SupportedKind {\n  /**\n   * Group is the group of the Route.\n   */\n  group?: string;\n  /**\n   * Kind is the kind of the Route.\n   */\n  kind: string;\n}\n\nRegisterKind(K8sGateway, {\n  group: \"gateway.networking.k8s.io\",\n  version: \"v1\",\n  kind: \"Gateway\",\n  plural: \"gateways\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nexport {\n  Allow,\n  Direction,\n  Expose,\n  Monitor,\n  Phase,\n  StatusObject as PkgStatus,\n  Protocol,\n  RemoteGenerated,\n  RemoteProtocol,\n  Sso,\n  Package as UDSPackage,\n} from \"./generated/package-v1alpha1\";\n\n// Type for the standard gateways\nexport enum Gateway {\n  Tenant = \"tenant\",\n  Admin = \"admin\",\n  Passthrough = \"passthrough\",\n}\n\nexport {\n  ExemptionElement,\n  Matcher,\n  Kind as MatcherKind,\n  Policy,\n  Exemption as UDSExemption,\n} from \"./generated/exemption-v1alpha1\";\n\nexport {\n  Attributes,\n  ClusterConfig,\n  Expose as ConfigExpose,\n  Policy as ConfigPolicy,\n  CABundle as ConfigCABundle,\n  Phase as ConfigPhase,\n  Name as ClusterConfigName,\n  Networking,\n} from \"./generated/clusterconfig-v1alpha1\";\n\nexport {\n  HTTP as IstioHTTP,\n  HTTPRoute as IstioHTTPRoute,\n  Tl as IstioTLS,\n  VirtualService as IstioVirtualService,\n} from \"./generated/istio/virtualservice-v1beta1\";\n\nexport {\n  Endpoint as IstioEndpoint,\n  Location as IstioLocation,\n  Port as IstioPort,\n  Resolution as IstioResolution,\n  ServiceEntry as IstioServiceEntry,\n} from \"./generated/istio/serviceentry-v1beta1\";\n\nexport {\n  PodMetricsEndpoint as PodMonitorEndpoint,\n  Scheme as PodMonitorScheme,\n  PodMonitor as PrometheusPodMonitor,\n} from \"./generated/prometheus/podmonitor-v1\";\n\nexport {\n  ServiceMonitor as PrometheusServiceMonitor,\n  Endpoint as ServiceMonitorEndpoint,\n  Scheme as ServiceMonitorScheme,\n} from \"./generated/prometheus/servicemonitor-v1\";\n\nexport {\n  Action as IstioAction,\n  AuthorizationPolicy as IstioAuthorizationPolicy,\n} from \"./generated/istio/authorizationpolicy-v1beta1\";\nexport { RequestAuthentication as IstioRequestAuthentication } from \"./generated/istio/requestauthentication-v1\";\n\nexport { DestinationRule as IstioDestinationRule } from \"./generated/istio/destinationrule-v1\";\n\nexport {\n  Gateway as IstioGateway,\n  Server as IstioServer,\n  Mode as IstioTLSMode,\n} from \"./generated/istio/gateway-v1\";\n\nexport {\n  OutboundTrafficPolicyMode as IstioOutboundTrafficPolicyMode,\n  Sidecar as IstioSidecar,\n} from \"./generated/istio/sidecar-v1\";\n\nexport { K8sGateway as K8sGateway, From as K8sGatewayFromType } from \"./generated/k8s/gateway-v1\";\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { WatchPhase } from \"kubernetes-fluent-client/dist/fluent/shared-types\";\nimport { K8s, kind } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { ClusterConfig, ConfigCABundle, ConfigPhase as Phase } from \"../../crd\";\nimport { validateCfg } from \"../../crd/validators/clusterconfig-validator\";\nimport { updateAllCaBundleConfigMaps } from \"../ca-bundles/ca-bundle\";\nimport { reconcileAuthservice } from \"../keycloak/authservice/authservice\";\nimport { Action, AuthServiceEvent } from \"../keycloak/authservice/types\";\nimport { initAPIServerCIDR } from \"../network/generators/kubeAPI\";\nimport { initAllNodesTarget } from \"../network/generators/kubeNodes\";\nimport { registerWatchEventHandlers, watchCfg } from \"../utils\";\nimport { Config } from \"./types\";\n\nexport const configLog = setupLogger(Component.OPERATOR_CONFIG);\n\n// Set default UDSConfig for build time compiling\nexport const UDSConfig: Config = {\n  domain: \"\",\n  adminDomain: \"\",\n  caBundle: {\n    certs: \"\",\n    includeDoDCerts: false,\n    includePublicCerts: false,\n    dodCerts: \"\",\n    publicCerts: \"\",\n  },\n  authserviceRedisUri: \"\",\n  allowAllNSExemptions: false,\n  kubeApiCIDR: \"\",\n  kubeNodeCIDRs: [],\n  isIdentityDeployed: false,\n};\n\n// Enums for tracking the config action and step of the action\nexport enum ConfigAction {\n  LOAD,\n  UPDATE,\n}\nexport enum ConfigStep {\n  START,\n  FINISH,\n}\n\n/**\n * Generates standardized log messages for config operations\n *\n * @param action The config action being performed (LOAD or UPDATE)\n * @param step The step of the action (START or FINISH)\n * @param resourceName The name of the resource being processed\n * @returns A formatted log message string\n */\nexport function getConfigLogMessage(\n  action: ConfigAction,\n  step: ConfigStep,\n  resourceName: string,\n): string {\n  const isLoad = action === ConfigAction.LOAD;\n  const verb =\n    step === ConfigStep.START ? (isLoad ? \"Loading\" : \"Updating\") : isLoad ? \"Loaded\" : \"Updated\";\n  const change = isLoad ? \"\" : \" change\";\n\n  return `${verb} UDS Config from ${resourceName}${change}`;\n}\n\n/**\n * Determines if cluster resources should be updated based on the action and environment\n *\n * Cluster resources are only updated for UPDATE actions in watcher mode or dev mode.\n * LOAD actions never trigger cluster resource updates to avoid side effects during startup.\n *\n * @param action The config action being performed\n * @returns true if cluster resources should be updated, false otherwise\n */\nexport function shouldUpdateClusterResources(action: ConfigAction): boolean {\n  return (\n    action === ConfigAction.UPDATE &&\n    (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\")\n  );\n}\n\n/**\n * Checks if the ClusterConfig should be skipped during UPDATE operations\n *\n * A ClusterConfig is skipped if:\n * - It is currently in Pending state (guards against infinite loop when pepr patches status to Pending)\n * - The current generation has already been processed (observedGeneration matches generation)\n *\n * @param cr The ClusterConfig custom resource to check\n * @returns true if the config should be skipped, false if it should be processed\n */\nexport function shouldSkip(cr: ClusterConfig) {\n  const isPending = cr.status?.phase === Phase.Pending;\n  const isCurrentGeneration = cr.metadata?.generation === cr.status?.observedGeneration;\n\n  // The CR is pending and should be skipped\n  if (isPending) {\n    configLog.trace(cr, `Should skip? Yes, is pending`);\n    return true;\n  }\n\n  if (isCurrentGeneration) {\n    configLog.trace(cr, `Should skip? Yes, current generation already processed`);\n    return true;\n  }\n\n  configLog.trace(cr, `Should skip? No, not pending or current generation`);\n\n  return false;\n}\n\n/**\n * Decodes base64 secret data into plain text values\n *\n * @param secret The Kubernetes secret to decode\n * @returns Object with decoded string values, empty strings for invalid base64\n */\nexport function decodeSecret(secret: kind.Secret) {\n  // Base64 decode the secret data\n  const decodedData: { [key: string]: string } = {};\n  for (const key in secret.data) {\n    try {\n      const decodedValue = atob(secret.data[key]);\n      if (decodedValue) {\n        decodedData[key] = decodedValue;\n      } else {\n        decodedData[key] = \"\";\n      }\n    } catch (e) {\n      configLog.error(`Failed to decode secret key: ${key}, error: ${e.message}`);\n    }\n  }\n\n  return decodedData;\n}\n\n/**\n * Processes operator config secret changes and updates the global UDS configuration\n *\n * @param cfg The operator config secret to process\n * @param action The type of action being performed (LOAD or UPDATE)\n */\nexport async function handleCfgSecret(cfg: kind.Secret, action: ConfigAction) {\n  const resourceName = \"uds-operator-config secret\";\n  configLog.info(getConfigLogMessage(action, ConfigStep.START, resourceName));\n\n  // Only update cluster resources in the watcher pod if not on the first load\n  const updateClusterResources = shouldUpdateClusterResources(action);\n\n  const decodedCfgData = decodeSecret(cfg);\n\n  // no data key then set to empty string\n  if (!Object.keys(decodedCfgData).includes(\"AUTHSERVICE_REDIS_URI\")) {\n    decodedCfgData.AUTHSERVICE_REDIS_URI = \"\";\n  }\n\n  // Handle placeholder values (dev mode)\n  if (decodedCfgData.AUTHSERVICE_REDIS_URI === \"###ZARF_VAR_AUTHSERVICE_REDIS_URI###\") {\n    decodedCfgData.AUTHSERVICE_REDIS_URI = \"\";\n  }\n\n  // Handle changes to the Authservice configuration\n  if (UDSConfig.authserviceRedisUri !== decodedCfgData.AUTHSERVICE_REDIS_URI) {\n    UDSConfig.authserviceRedisUri = decodedCfgData.AUTHSERVICE_REDIS_URI;\n\n    if (updateClusterResources) {\n      await performAuthserviceUpdate(\"change to Redis URI\");\n    }\n  }\n\n  configLog.info(getConfigLogMessage(action, ConfigStep.FINISH, resourceName));\n}\n\n/**\n * Determines if CA bundle ConfigMaps need to be updated based on configuration changes\n *\n * @param caBundle The new CA bundle configuration from ClusterConfig\n * @param dodCerts The DoD certificate string from the ConfigMap\n * @param publicCerts The public certificate string from the ConfigMap\n * @returns true if CA bundle ConfigMaps need updating, false otherwise\n */\nfunction shouldUpdateCaBundleConfigMaps(\n  caBundle: ConfigCABundle,\n  dodCerts: string,\n  publicCerts: string,\n): boolean {\n  // Check if user-provided certs changed\n  if (UDSConfig.caBundle.certs !== caBundle.certs) {\n    return true;\n  }\n\n  // Check if DoD cert inclusion setting changed\n  if (UDSConfig.caBundle.includeDoDCerts !== (caBundle.includeDoDCerts === true)) {\n    return true;\n  }\n\n  // Check if public cert inclusion setting changed\n  if (UDSConfig.caBundle.includePublicCerts !== (caBundle.includePublicCerts === true)) {\n    return true;\n  }\n\n  // Check if DoD cert content changed (only if DoD certs are enabled)\n  if (caBundle.includeDoDCerts) {\n    if (UDSConfig.caBundle.dodCerts !== dodCerts) {\n      return true;\n    }\n  }\n\n  // Check if public cert content changed (only if public certs are enabled)\n  if (caBundle.includePublicCerts) {\n    if (UDSConfig.caBundle.publicCerts !== publicCerts) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Handles updates to CA bundle configuration including DoD and public certificates\n *\n * @param caBundle The CA bundle configuration from the ClusterConfig\n * @param updateClusterResources Whether to update cluster resources (ConfigMaps, etc.)\n */\nasync function handleCABundleUpdate(caBundle: ConfigCABundle, updateClusterResources?: boolean) {\n  // no caCert then set to empty string\n  if (!caBundle.certs) {\n    caBundle.certs = \"\";\n  }\n\n  // handle dev mode placeholder\n  if (caBundle.certs === \"###ZARF_VAR_CA_BUNDLE_CERTS###\") {\n    caBundle.certs = \"\";\n  } else if (caBundle.certs === \"###ZARF_VAR_CA_CERT###\") {\n    caBundle.certs = \"\";\n  }\n\n  // Load in the DoD and Public certs from the configmap\n  let caCertsConfigMap: kind.ConfigMap;\n  let dodCerts = \"\";\n  let publicCerts = \"\";\n\n  try {\n    caCertsConfigMap = await K8s(kind.ConfigMap).InNamespace(\"pepr-system\").Get(\"uds-ca-certs\");\n    // Extract cert data if ConfigMap exists\n    if (caCertsConfigMap.data) {\n      dodCerts = caCertsConfigMap.data[\"dodCACerts\"] || \"\";\n      publicCerts = caCertsConfigMap.data[\"publicCACerts\"] || \"\";\n    }\n  } catch (e) {\n    // Check if it's a 404 (ConfigMap not found) vs other K8s API failures\n    if (e?.status === 404) {\n      configLog.warn(\"CA certs ConfigMap not found, using empty values for DoD and public certs\");\n      // Continue with default empty values\n    } else {\n      configLog.error(\"Failed to fetch CA certs ConfigMap due to K8s API error\", e);\n      throw e; // Re-throw K8s API errors\n    }\n  }\n\n  // Check if CA bundle ConfigMaps need updates based on configuration changes\n  const caBundleConfigMapsNeedUpdate = shouldUpdateCaBundleConfigMaps(\n    caBundle,\n    dodCerts,\n    publicCerts,\n  );\n\n  if (UDSConfig.caBundle.certs !== caBundle.certs) {\n    UDSConfig.caBundle.certs = caBundle.certs || \"\";\n\n    // Handle changes to the Authservice configuration for CA Certs\n    if (updateClusterResources) {\n      await performAuthserviceUpdate(\"change to CA Cert\");\n    }\n  }\n\n  UDSConfig.caBundle.includeDoDCerts = caBundle.includeDoDCerts === true;\n  UDSConfig.caBundle.includePublicCerts = caBundle.includePublicCerts === true;\n  UDSConfig.caBundle.dodCerts = dodCerts;\n  UDSConfig.caBundle.publicCerts = publicCerts;\n\n  // Handle global updates to Trust Bundle Configmaps\n  if (caBundleConfigMapsNeedUpdate && updateClusterResources) {\n    await updateAllCaBundleConfigMaps();\n  }\n}\n\n/**\n * Processes ClusterConfig changes and updates the global UDS configuration\n *\n * For LOAD actions, the config is always processed regardless of pending state to ensure\n * initial configuration is loaded. For UPDATE actions, processing is skipped if the config\n * is pending or already processed.\n *\n * @param cfg The ClusterConfig custom resource to process\n * @param action The type of action being performed (LOAD or UPDATE)\n */\nexport async function handleCfg(cfg: ClusterConfig, action: ConfigAction) {\n  // Determine if we need to skip processing\n  // Don't skip on initial load - we need to process the config regardless of pending state\n  if (action !== ConfigAction.LOAD && shouldSkip(cfg)) {\n    return;\n  }\n\n  try {\n    // Patch the status to Pending and set currentGeneration while we process the update\n    await K8s(ClusterConfig).PatchStatus({\n      metadata: {\n        name: cfg.metadata!.name,\n      },\n      status: {\n        phase: Phase.Pending,\n      },\n    });\n\n    const resourceName = \"uds-operator-config ClusterConfig\";\n    configLog.info(getConfigLogMessage(action, ConfigStep.START, resourceName));\n\n    // Only update cluster resources in the watcher pod if not on the first load\n    const updateClusterResources = shouldUpdateClusterResources(action);\n\n    const { expose, policy, networking, caBundle } = cfg.spec!;\n\n    // Handle changes to the Authservice configuration for CA Cert\n    await handleCABundleUpdate(caBundle || {}, updateClusterResources);\n\n    // Handle changes to the kubeApiCidr\n    if (networking?.kubeApiCIDR !== UDSConfig.kubeApiCIDR) {\n      UDSConfig.kubeApiCIDR = networking?.kubeApiCIDR || \"\";\n      if (updateClusterResources) {\n        // This re-runs the \"init\" function to update netpols if necessary\n        configLog.debug(\"Updating KubeAPI network policies based on change to kubeApiCidr\");\n        await initAPIServerCIDR();\n      }\n    }\n\n    if (!areKubeNodeCidrsEqual(networking?.kubeNodeCIDRs, UDSConfig.kubeNodeCIDRs)) {\n      UDSConfig.kubeNodeCIDRs = networking?.kubeNodeCIDRs || [];\n      if (updateClusterResources) {\n        // This re-runs the \"init\" function to update netpols if necessary\n        configLog.debug(\"Updating KubeNodes network policies based on change to kubeNodeCidrs\");\n        await initAllNodesTarget();\n      }\n    }\n\n    if (expose.domain !== UDSConfig.domain || expose.adminDomain !== UDSConfig.adminDomain) {\n      if (expose.domain && expose.domain !== \"###ZARF_VAR_DOMAIN###\") {\n        UDSConfig.domain = expose.domain;\n      } else {\n        UDSConfig.domain = \"uds.dev\";\n      }\n      if (expose.adminDomain && expose.adminDomain !== \"###ZARF_VAR_ADMIN_DOMAIN###\") {\n        UDSConfig.adminDomain = expose.adminDomain;\n      } else {\n        UDSConfig.adminDomain = `admin.${UDSConfig.domain}`;\n      }\n      // todo: Add logic to handle domain changes and update across virtualservices, authservice config, etc\n    }\n\n    // Update other config values (no need for special handling)\n    UDSConfig.allowAllNSExemptions = policy.allowAllNsExemptions === true;\n\n    configLog.info(getConfigLogMessage(action, ConfigStep.FINISH, resourceName));\n\n    // Finally, patch status to Ready and set observedGeneration\n    await K8s(ClusterConfig).PatchStatus({\n      metadata: {\n        name: cfg.metadata!.name,\n      },\n      status: {\n        phase: Phase.Ready,\n        observedGeneration: cfg.metadata!.generation,\n      },\n    });\n  } catch (e) {\n    configLog.error(\"Error processing ClusterConfig\", e);\n\n    // patch status to Failed and set observedGeneration\n    await K8s(ClusterConfig).PatchStatus({\n      metadata: {\n        name: cfg.metadata!.name,\n      },\n      status: {\n        phase: Phase.Failed,\n        observedGeneration: cfg.metadata!.generation,\n      },\n    });\n\n    throw e;\n  }\n}\n\n/**\n * Loads the initial UDS configuration from ClusterConfig and operator secret on startup\n *\n * This function only runs in watcher pods or dev mode. It fetches the ClusterConfig\n * and operator secret, validates them, and populates the global UDS configuration.\n *\n * @throws {Error} When configuration resources cannot be found or are invalid\n */\nexport async function loadUDSConfig() {\n  // Run in Admission and Watcher pods\n  if (process.env.PEPR_WATCH_MODE || process.env.PEPR_MODE === \"dev\") {\n    let cfg: ClusterConfig = {};\n    let cfgSecret: kind.Secret = {};\n\n    try {\n      cfg = await K8s(ClusterConfig).Get(\"uds-cluster-config\");\n      // Make sure we got the cluster config even if K8s call succeeded\n      if (!cfg) {\n        throw new Error(\"'uds-cluster-config' not found\");\n      }\n    } catch (e) {\n      configLog.error(\"Error while fetching cluster config\", e);\n      throw new Error(\"Error while fetching cluster config\", { cause: e });\n    }\n\n    try {\n      cfgSecret = await K8s(kind.Secret).InNamespace(\"pepr-system\").Get(\"uds-operator-config\");\n      // Make sure we got the secret even if K8s call succeeded\n      if (!cfgSecret) {\n        throw new Error(\"'uds-operator-config' not found\");\n      }\n    } catch (e) {\n      configLog.error(\"Error while fetching operator config secret\", e);\n      throw new Error(\"Error while fetching operator config secret\", { cause: e });\n    }\n\n    try {\n      validateCfg(cfg);\n      await handleCfg(cfg, ConfigAction.LOAD);\n      await handleCfgSecret(cfgSecret, ConfigAction.LOAD);\n      configLog.info(redactConfig(), \"Loaded UDS Config\");\n    } catch (e) {\n      configLog.error(e);\n      throw e;\n    }\n  }\n}\n\n/**\n * Creates a redacted copy of UDS config for logging (hides sensitive or large values)\n *\n * @returns UDS config with sensitive or large fields replaced with masked values\n */\nfunction redactConfig() {\n  const authserviceRedisUri = UDSConfig.authserviceRedisUri ? \"****\" : \"\";\n  const dodCerts = UDSConfig.caBundle.dodCerts ? \"****\" : \"\";\n  const publicCerts = UDSConfig.caBundle.publicCerts ? \"****\" : \"\";\n  const certs = UDSConfig.caBundle.certs ? \"****\" : \"\";\n  const caBundle = { ...UDSConfig.caBundle, dodCerts, publicCerts, certs };\n  return { ...UDSConfig, authserviceRedisUri, caBundle };\n}\n\n// Helper function to detect if 2 lists of CIDRs are equal, irrespective of order\nfunction areKubeNodeCidrsEqual(newCidrs: string[] = [], currentCidrs: string[] = []): boolean {\n  if (newCidrs.length !== currentCidrs.length) {\n    return false;\n  }\n  const sortedNewCidrs = [...newCidrs].sort();\n  const sortedCurrentCidrs = [...currentCidrs].sort();\n  return sortedNewCidrs.every((cidr, index) => cidr === sortedCurrentCidrs[index]);\n}\n\n/**\n * Triggers an authservice configuration update with current global config values\n *\n * @param reason Description of what triggered the authservice update\n */\nasync function performAuthserviceUpdate(reason: string) {\n  const authserviceUpdate: AuthServiceEvent = {\n    name: \"global-config-update\",\n    action: Action.UpdateGlobalConfig,\n    // Base64 decode the CA cert before passing to the update function\n    trustedCA: atob(UDSConfig.caBundle.certs),\n    redisUri: UDSConfig.authserviceRedisUri,\n  };\n  configLog.debug(`Updating Authservice secret based on: ${reason}`);\n  await reconcileAuthservice(authserviceUpdate);\n}\n\n/**\n * Handles updates to the uds-ca-certs ConfigMap by updating the global UDS config\n * and propagating changes to all CA bundle ConfigMaps across the cluster\n *\n * @param configMap The updated uds-ca-certs ConfigMap\n */\nexport async function handleUDSCACertsConfigMapUpdate(configMap: kind.ConfigMap): Promise<void> {\n  try {\n    configLog.debug(\"Processing uds-ca-certs ConfigMap update\");\n\n    // Extract cert data from the ConfigMap\n    const dodCerts = configMap.data?.[\"dodCACerts\"] || \"\";\n    const publicCerts = configMap.data?.[\"publicCACerts\"] || \"\";\n\n    // Create a mock caBundle config using current UDSConfig values to check for changes\n    const currentCaBundle: ConfigCABundle = {\n      certs: UDSConfig.caBundle.certs,\n      includeDoDCerts: UDSConfig.caBundle.includeDoDCerts,\n      includePublicCerts: UDSConfig.caBundle.includePublicCerts,\n    };\n\n    // Check if updates are needed before making any changes\n    const needsUpdate = shouldUpdateCaBundleConfigMaps(currentCaBundle, dodCerts, publicCerts);\n\n    if (!needsUpdate) {\n      configLog.debug(\"No CA bundle updates needed, skipping\");\n      return;\n    }\n\n    // Update UDSConfig with the new DoD/public cert data\n    UDSConfig.caBundle.dodCerts = dodCerts;\n    UDSConfig.caBundle.publicCerts = publicCerts;\n    configLog.debug(\"Updated UDSConfig with new DoD and public CA certs\");\n\n    // Propagate the changes to all CA bundle ConfigMaps across the cluster\n    await updateAllCaBundleConfigMaps();\n    configLog.debug(\"Successfully updated all CA bundle ConfigMaps\");\n  } catch (error) {\n    configLog.error(error, \"Failed to process uds-ca-certs ConfigMap update\");\n    throw error;\n  }\n}\n\n/**\n * Starts a watch of the ClusterConfig resource for handling configuration updates\n *\n * This function only runs in admission controller pods or dev mode. It sets up\n * a watch to listen for changes to the ClusterConfig and processes\n * them using UPDATE actions.\n */\nexport async function startConfigWatch() {\n  // only run in admission controller or dev mode\n  if (process.env.PEPR_WATCH_MODE === \"false\" || process.env.PEPR_MODE === \"dev\") {\n    const watcher = K8s(ClusterConfig).Watch(async (cfg: ClusterConfig, phase: WatchPhase) => {\n      configLog.debug(`Processing cluster config update, phase ${phase}`);\n\n      if (cfg.metadata?.name !== \"uds-cluster-config\") {\n        // This should be impossible based on the schema, but we add this as a safeguard\n        return;\n      }\n\n      switch (phase) {\n        case WatchPhase.Added:\n        case WatchPhase.Modified:\n          try {\n            await handleCfg(cfg, ConfigAction.UPDATE);\n          } catch (e) {\n            configLog.error(e, \"Unexpected error during cluster config update\");\n          }\n          break;\n        // We don't expect/handle deletions of the cluster config\n      }\n    }, watchCfg);\n    // This will run until the process is terminated or the watch is aborted\n    configLog.debug(\"Starting cluster config watch...\");\n    registerWatchEventHandlers(watcher, configLog, \"ClusterConfig\");\n    await watcher.start();\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { PeprValidateRequest } from \"pepr\";\nimport { X509Certificate } from \"crypto\";\nimport { isBase64 } from \"../../controllers/utils\";\nimport { ClusterConfig } from \"../generated/clusterconfig-v1alpha1\";\n\nexport async function validateCfgUpdate(req: PeprValidateRequest<ClusterConfig>) {\n  try {\n    validateCfg(req.Raw);\n  } catch (e) {\n    return req.Deny(`Validation failed: ${e.message}`);\n  }\n  return req.Approve();\n}\n\nexport function validateCfg(cfg: ClusterConfig) {\n  // Validate that the caBundle.certs is base64 encoded and is a valid cert bundle\n  if (\n    cfg.spec?.caBundle?.certs &&\n    cfg.spec.caBundle.certs !== \"###ZARF_VAR_CA_BUNDLE_CERTS###\" &&\n    cfg.spec.caBundle.certs !== \"###ZARF_VAR_CA_CERT###\"\n  ) {\n    if (!isBase64(cfg.spec.caBundle.certs)) {\n      throw new Error(\"ClusterConfig: caBundle.certs must be base64 encoded; found invalid value\");\n    }\n\n    // Decode and validate certificate bundle\n    const decodedCerts = Buffer.from(cfg.spec.caBundle.certs, \"base64\").toString(\"utf8\");\n    const certBlocks = decodedCerts.match(\n      /-----BEGIN CERTIFICATE-----[\\s\\S]*?-----END CERTIFICATE-----/g,\n    );\n\n    if (!certBlocks || certBlocks.length === 0) {\n      throw new Error(\"ClusterConfig: No valid certificates found in bundle\");\n    }\n\n    // Validate each certificate in the bundle\n    certBlocks.forEach((certPem, index) => {\n      try {\n        new X509Certificate(certPem);\n      } catch (e) {\n        throw new Error(\n          `ClusterConfig: Invalid certificate at index ${index}: ${e instanceof Error ? e.message : String(e)}`,\n        );\n      }\n    });\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { GenericClass, GenericKind, WatchCfg, WatchEvent } from \"kubernetes-fluent-client\";\nimport { WatcherType } from \"kubernetes-fluent-client/dist/fluent/types\";\nimport { K8s, kind } from \"pepr\";\nimport { WatchEventArgs } from \"pepr/dist/lib/processors/watch-processor\";\nimport { Logger } from \"pino\";\nimport { UDSPackage } from \"../crd\";\n\nexport const PROMETHEUS_PRINCIPAL =\n  \"cluster.local/ns/monitoring/sa/kube-prometheus-stack-prometheus\";\n\n/**\n * Watch configuration for use in KFC watches\n * This is primarily used for any watches occurring in admission pods\n */\nexport const watchCfg: WatchCfg = {\n  resyncFailureMax: process.env.PEPR_RESYNC_FAILURE_MAX\n    ? parseInt(process.env.PEPR_RESYNC_FAILURE_MAX, 10)\n    : 5,\n  resyncDelaySec: process.env.PEPR_RESYNC_DELAY_SECONDS\n    ? parseInt(process.env.PEPR_RESYNC_DELAY_SECONDS, 10)\n    : 5,\n  lastSeenLimitSeconds: process.env.PEPR_LAST_SEEN_LIMIT_SECONDS\n    ? parseInt(process.env.PEPR_LAST_SEEN_LIMIT_SECONDS, 10)\n    : 300,\n  relistIntervalSec: process.env.PEPR_RELIST_INTERVAL_SECONDS\n    ? parseInt(process.env.PEPR_RELIST_INTERVAL_SECONDS, 10)\n    : 600,\n};\n\nexport function registerWatchEventHandlers(\n  watcher: WatcherType<GenericClass>,\n  log: Logger,\n  watchName: string,\n) {\n  const eventHandlers: {\n    [K in WatchEvent]?: (arg: WatchEventArgs<K, GenericClass>) => void;\n  } = {\n    [WatchEvent.GIVE_UP]: err => {\n      // If failure continues, log and exit\n      log.error(\n        `WatchEvent GiveUp (${watchName}): The watch has failed to start after several attempts: ${err.message}`,\n      );\n      process.exit(1);\n    },\n    [WatchEvent.DATA_ERROR]: err => log.warn(`WatchEvent DataError (${watchName}): ${err.message}`),\n    [WatchEvent.RECONNECT]: retryCount =>\n      log.debug(\n        `WatchEvent Reconnect (${watchName}): Reconnecting watch after ${retryCount} attempt${retryCount === 1 ? \"\" : \"s\"}`,\n      ),\n    [WatchEvent.ABORT]: err => log.warn(`WatchEvent Abort (${watchName}): ${err.message}`),\n    [WatchEvent.NETWORK_ERROR]: err =>\n      log.warn(`WatchEvent NetworkError (${watchName}): ${err.message}`),\n    [WatchEvent.LIST_ERROR]: err => log.warn(`WatchEvent ListError (${watchName}): ${err.message}`),\n  };\n  Object.entries(eventHandlers).forEach(([event, handler]) => {\n    watcher.events.on(event, handler);\n  });\n}\n\n/**\n * Sanitize a resource name to make it a valid Kubernetes resource name.\n *\n * @param name the name of the resource to sanitize\n * @returns the sanitized resource name\n */\nexport function sanitizeResourceName(name: string) {\n  return (\n    name\n      // The name must be lowercase\n      .toLowerCase()\n      // Replace sequences of non-alphanumeric characters with a single '-'\n      .replace(/[^a-z0-9]+/g, \"-\")\n      // Truncate the name to 250 characters\n      .slice(0, 250)\n      // Remove leading and trailing non-letter characters\n      .replace(/^[^a-z]+|[^a-z]+$/g, \"\")\n  );\n}\n\n/**\n * Get the owner reference for a custom resource\n * @param cr the custom resource to get the owner reference for\n * @returns the owner reference for the custom resource\n */\nexport function getOwnerRef(cr: GenericKind): V1OwnerReference[] {\n  const { name, uid } = cr.metadata!;\n\n  return [\n    {\n      apiVersion: cr.apiVersion!,\n      kind: cr.kind!,\n      uid: uid!,\n      name: name!,\n    },\n  ];\n}\n\n/**\n * Purges orphaned Kubernetes resources of a specified kind within a namespace that do not match the provided generation.\n *\n * @template T\n * @param {string} generation - The generation label to retain.\n * @param {string} namespace - The namespace to search for resources.\n * @param {string} pkgName - The package name label to filter resources.\n * @param {T} kind - The Kubernetes resource kind to purge.\n * @param {Logger} log - Logger instance for logging debug messages.\n * @param {Record<string, string>} [additionalLabels] - Optional additional label filters to further narrow down the resources to purge.\n * @returns {Promise<void>} - A promise that resolves when the operation is complete.\n */\nexport async function purgeOrphans<T extends GenericClass>(\n  generation: string,\n  namespace: string,\n  pkgName: string,\n  kind: T,\n  log: Logger,\n  additionalLabels?: Record<string, string> | undefined,\n) {\n  let query = K8s(kind).InNamespace(namespace).WithLabel(\"uds/package\", pkgName);\n\n  if (additionalLabels) {\n    for (const [key, value] of Object.entries(additionalLabels)) {\n      query = query.WithLabel(key, value);\n    }\n  }\n\n  const resources = await query.Get();\n\n  for (const resource of resources.items) {\n    if (resource.metadata?.labels?.[\"uds/generation\"] !== generation) {\n      log.debug({ resource }, `Deleting orphaned ${resource.kind!} ${resource.metadata!.name}`);\n      await K8s(kind).Delete(resource);\n    }\n  }\n}\n\n/**\n * Lightweight retry helper with a delay between attempts.\n *\n * @param {() => Promise<T>} fn - The async function to retry.\n * @param {Logger} log - Logger instance for logging debug messages.\n * @param {number} retries - Number of retry attempts.\n * @param {number} delayMs - Delay in milliseconds between attempts.\n * @returns {Promise<T>} - The result of the function if successful.\n * @throws {Error} - Throws an error after exhausting retries.\n */\nexport async function retryWithDelay<T>(\n  fn: () => Promise<T>,\n  log: Logger,\n  retries = 5,\n  delayMs = 2000,\n): Promise<T> {\n  let attempt = 0;\n  while (attempt < retries) {\n    try {\n      return await fn();\n    } catch (err) {\n      attempt++;\n      if (attempt >= retries) {\n        throw err; // Exceeded retries, rethrow the error.\n      }\n      // We need to account for cases where we are receiving a rejected promise with undefined error\n      let error = \"Unknown Error\";\n      if (err) {\n        error = `${JSON.stringify(err)}`;\n        // Error responses from network calls (i.e. K8s().Get() will be this shape)\n        if (err.data?.message) {\n          error = err.data.message;\n          // Other error types have a message\n        } else if (err.message) {\n          error = err.message;\n        }\n      }\n      log.warn(\n        { error },\n        `Attempt ${attempt} of ${fn.name || \"anonymous function\"} failed, retrying in ${delayMs}ms.`,\n      );\n      await new Promise(resolve => setTimeout(resolve, delayMs));\n    }\n  }\n\n  // This line should never be reached, but TypeScript wants it for safety.\n  throw new Error(\"Retry loop exited unexpectedly without returning.\");\n}\n\n/**\n * Node.js friendly base64 validator.\n *\n * @param {string} str - string to validate as base64\n * @returns {boolean} - The result of the validation.\n */\nexport function isBase64(str: string) {\n  try {\n    return Buffer.from(str, \"base64\").toString(\"base64\") === str;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Create a Kubernetes event for a resource\n *\n * @param resource The Kubernetes resource to create an event for\n * @param event Partial event object with optional type, reason, message, etc.\n * @param logger Logger instance for logging\n */\nexport async function createEvent(\n  resource: GenericKind,\n  event: Partial<kind.CoreEvent> = {},\n  log: Logger,\n): Promise<void> {\n  const name = resource.metadata?.name;\n  const namespace = resource.metadata?.namespace;\n  const resourceKind = resource.kind;\n\n  if (!name || !namespace || !resourceKind) {\n    const error = new Error(\"Cannot create event: resource missing name, namespace, or kind\");\n    log.error(error.message);\n    throw error;\n  }\n\n  // Create the event using CoreEvent type\n  await K8s(kind.CoreEvent).Create({\n    // Default values that can be overridden\n    type: \"Normal\",\n    reason: \"Update\",\n    // User provided overrides\n    ...event,\n    // Fixed values that cannot be overridden\n    metadata: {\n      namespace,\n      generateName: name,\n    },\n    involvedObject: {\n      apiVersion: resource.apiVersion,\n      kind: resourceKind,\n      name,\n      namespace,\n      uid: resource.metadata?.uid,\n    },\n    firstTimestamp: new Date(),\n    reportingComponent: \"uds.dev/operator\",\n    reportingInstance: process.env.HOSTNAME,\n  });\n}\n\n// Validate that namespace exists, optionally allowing for missing namespace\nexport async function validateNamespace(\n  namespace: string,\n  missingAllowed?: boolean,\n): Promise<kind.Namespace | null> {\n  try {\n    return await K8s(kind.Namespace).Get(namespace);\n  } catch (e) {\n    if (e?.status == 404) {\n      if (missingAllowed) {\n        return null;\n      } else {\n        throw e;\n      }\n    } else {\n      throw e;\n    }\n  }\n}\n\n/**\n * Get SSO clients with authservice enabled.\n * Filters to entries where enableAuthserviceSelector is present (not null/undefined).\n */\nexport function getAuthserviceClients(pkg: UDSPackage) {\n  const list = pkg.spec?.sso || [];\n  return list.filter(sso => sso?.enableAuthserviceSelector != null);\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\nimport { UDSPackage } from \"../../crd\";\nimport { UDSConfig } from \"../config/config\";\nimport { getOwnerRef, purgeOrphans } from \"../utils\";\nimport { Component, setupLogger } from \"../../../logger\";\n\nexport const CA_BUNDLE_CONFIGMAP_LABEL = \"uds/ca-bundle\"; // Label to identify CA bundle ConfigMaps\nconst DEFAULT_CONFIGMAP_NAME = \"uds-trust-bundle\";\nconst DEFAULT_CONFIGMAP_KEY = \"ca-bundle.pem\";\n\nconst log = setupLogger(Component.OPERATOR_CA_BUNDLE);\n\n/**\n * Creates or updates a CA Bundle ConfigMap for the given UDS Package in the specified namespace.\n * The ConfigMap contains the combined CA bundle from user-provided, DoD, and public certificates\n * as configured in the global UDS configuration.\n *\n * @param pkg The UDS Package CR that defines the ConfigMap configuration\n * @param namespace The target namespace where the ConfigMap will be created\n * @throws Error if ConfigMap creation or orphan cleanup fails\n */\nexport async function caBundleConfigMap(pkg: UDSPackage, namespace: string): Promise<void> {\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerRefs = getOwnerRef(pkg);\n\n  // Set Defaults\n  const configMapName = pkg.spec?.caBundle?.configMap?.name || DEFAULT_CONFIGMAP_NAME;\n  const configMapKey = pkg.spec?.caBundle?.configMap?.key || DEFAULT_CONFIGMAP_KEY;\n  const configMapLabels = pkg.spec?.caBundle?.configMap?.labels || {};\n  const configMapAnnotations = pkg.spec?.caBundle?.configMap?.annotations || {};\n\n  try {\n    log.debug(`Reconciling CA Bundle ConfigMap for ${pkgName}`);\n\n    // Build the CA bundle content by combining available certs\n    const caBundleContent = buildCABundleContent();\n\n    // If no CA bundle content, delete any existing ConfigMaps instead of creating empty ones\n    if (!caBundleContent || caBundleContent.trim() === \"\") {\n      log.debug(`No CA bundle content available, deleting any existing ConfigMaps for ${pkgName}`);\n\n      // Delete any existing ConfigMaps for this package\n      try {\n        await K8s(kind.ConfigMap)\n          .InNamespace(namespace)\n          .WithLabel(\"uds/package\", pkgName)\n          .WithLabel(CA_BUNDLE_CONFIGMAP_LABEL, \"true\")\n          .Delete();\n        log.debug(`Deleted existing CA bundle ConfigMaps for ${pkgName} in namespace ${namespace}`);\n      } catch {\n        // Don't fail if deletion fails (ConfigMap might not exist)\n      }\n\n      return;\n    }\n\n    // Create ConfigMap with CA bundle content\n    const configMapManifest: kind.ConfigMap = {\n      apiVersion: \"v1\",\n      kind: \"ConfigMap\",\n      metadata: {\n        name: configMapName,\n        namespace: namespace,\n        labels: {\n          \"uds/package\": pkgName,\n          \"uds/generation\": generation,\n          [CA_BUNDLE_CONFIGMAP_LABEL]: \"true\",\n          ...configMapLabels,\n        },\n        annotations: {\n          ...configMapAnnotations,\n        },\n        // Set owner reference to the UDS Package for proper cleanup\n        ownerReferences: ownerRefs,\n      },\n      data: {\n        [configMapKey]: caBundleContent,\n      },\n    };\n\n    // Apply the ConfigMap\n    await K8s(kind.ConfigMap).Apply(configMapManifest, { force: true });\n\n    // Purge any orphaned ConfigMaps from previous generations\n    await purgeOrphans(generation, namespace, pkgName, kind.ConfigMap, log, {\n      [CA_BUNDLE_CONFIGMAP_LABEL]: \"true\",\n    });\n  } catch (err) {\n    throw new Error(\n      `Failed to process CA Bundle ConfigMap for ${pkgName}, cause: ${JSON.stringify(err)}`,\n    );\n  }\n}\n\n/**\n * Builds the combined CA bundle content from all configured certificate sources.\n * Combines user-provided certificates, DoD certificates, and public certificates\n * based on the current UDS configuration settings.\n *\n * @returns The combined PEM-formatted certificate bundle as a string.\n *          Returns empty string if no certificate sources are configured.\n */\nfunction buildCABundleContent(): string {\n  const certs: string[] = [];\n\n  // Add user-provided certs (base64 encoded)\n  if (UDSConfig.caBundle.certs) {\n    const userCerts = atob(UDSConfig.caBundle.certs);\n    if (userCerts) {\n      certs.push(userCerts);\n    }\n  }\n\n  // Add DoD certs if included\n  if (UDSConfig.caBundle.includeDoDCerts && UDSConfig.caBundle.dodCerts) {\n    const dodCerts = atob(UDSConfig.caBundle.dodCerts);\n    if (dodCerts) {\n      certs.push(dodCerts);\n    }\n  }\n\n  // Add public certs if included\n  if (UDSConfig.caBundle.includePublicCerts && UDSConfig.caBundle.publicCerts) {\n    const publicCerts = atob(UDSConfig.caBundle.publicCerts);\n    if (publicCerts) {\n      certs.push(publicCerts);\n    }\n  }\n\n  // Join all certs with newlines, ensuring proper PEM format\n  return certs\n    .filter(cert => cert.trim())\n    .join(\"\\n\\n\")\n    .trim();\n}\n\n/**\n * Updates CA bundle ConfigMaps for all UDS packages in the cluster with the latest certificate data.\n * This function is typically called when the global UDS configuration changes (e.g., when\n * certificates are rotated or configuration is updated). It lists all UDS packages and calls\n * caBundleConfigMap for each package to ensure their CA bundle ConfigMaps are up to date.\n *\n * @throws Error if the package listing or ConfigMap update operations fail\n */\nexport async function updateAllCaBundleConfigMaps(): Promise<void> {\n  try {\n    log.debug(\"Starting CA bundle ConfigMap updates for all UDS packages\");\n\n    // Get all UDS packages across all namespaces\n    const packages = await K8s(UDSPackage).Get();\n\n    if (!packages.items || packages.items.length === 0) {\n      log.debug(\"No UDS packages found, no CA bundle ConfigMaps to update\");\n      return;\n    }\n\n    log.debug(`Found ${packages.items.length} UDS packages, processing CA bundle ConfigMaps`);\n\n    // Process each package and update/delete its CA bundle ConfigMap as needed\n    for (const pkg of packages.items) {\n      if (!pkg.metadata?.name || !pkg.metadata?.namespace) {\n        // This should not happen, but needed for type safety\n        continue;\n      }\n\n      const pkgName = pkg.metadata.name;\n      const namespace = pkg.metadata.namespace;\n\n      try {\n        log.debug(\n          `Processing CA bundle ConfigMap for package ${pkgName} in namespace ${namespace}`,\n        );\n        await caBundleConfigMap(pkg, namespace);\n      } catch (err) {\n        // Log the error but continue processing other packages\n        log.error(\n          `Failed to process CA bundle ConfigMap for package ${pkgName} in namespace ${namespace}`,\n          err,\n        );\n        // Don't throw here - we want to continue processing other packages\n      }\n    }\n\n    log.debug(\"Completed CA bundle ConfigMap updates for all UDS packages\");\n  } catch (err) {\n    log.error(\"Failed to update CA bundle ConfigMaps for all packages\", err);\n    throw new Error(\"Failed to update CA bundle ConfigMaps for all packages\", { cause: err });\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { R } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../../logger\";\nimport { K8sGateway, UDSPackage } from \"../../../crd\";\nimport { AuthserviceClient, Mode } from \"../../../crd/generated/package-v1alpha1\";\nimport { cleanupWaypointLabels, setupAmbientWaypoint } from \"../../istio/ambient-waypoint\";\nimport { getWaypointName } from \"../../istio/waypoint-utils\";\nimport { getAuthserviceClients, purgeOrphans } from \"../../utils\";\nimport { Client } from \"../types\";\nimport { UDSConfig, updatePolicy } from \"./authorization-policy\";\nimport {\n  getAuthserviceConfig,\n  operatorConfig,\n  setAuthserviceConfig,\n  updateAuthServiceSecret,\n} from \"./config\";\nimport {\n  Action,\n  AddOrRemoveClientEvent,\n  AuthServiceEvent,\n  AuthserviceConfig,\n  Chain,\n} from \"./types\";\n\nexport const log = setupLogger(Component.OPERATOR_AUTHSERVICE);\nlet lock = false;\n\nexport async function authservice(\n  pkg: UDSPackage,\n  clients: Map<string, Client>,\n): Promise<AuthserviceClient[]> {\n  if (!pkg.metadata?.namespace || !pkg.metadata?.name) {\n    throw new Error(\"Package metadata is missing required fields\");\n  }\n\n  // Get the requested service mesh mode, default to sidecar if not specified\n  const istioMode = pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar;\n  const previousMeshMode = pkg.status?.meshMode || Mode.Sidecar;\n  const isAmbient = istioMode === Mode.Ambient;\n\n  // Get the list of authservice-enabled clients from the package\n  const authServiceClients = getAuthserviceClients(pkg);\n\n  // Build the new client status objects\n  const newAuthserviceClients = authServiceClients.map(sso => ({\n    clientId: sso.clientId,\n    selector: sso.enableAuthserviceSelector || {},\n  }));\n\n  // Reconcile each client\n  for (const sso of authServiceClients) {\n    if (isAmbient) {\n      await setupAmbientWaypoint(pkg, sso);\n    }\n\n    const client = clients.get(sso.clientId);\n    if (!client) {\n      throw new Error(`Failed to get client ${sso.clientId}`);\n    }\n\n    // Get the full waypoint name for authorization policies\n    const fullWaypointName = getWaypointName(sso.clientId);\n\n    await reconcileAuthservice(\n      { name: sso.clientId, action: Action.AddClient, client },\n      sso.enableAuthserviceSelector!,\n      isAmbient,\n      pkg,\n      fullWaypointName,\n    );\n  }\n\n  // Cleanup logic now takes the new objects\n  await purgeAuthserviceClients(pkg, newAuthserviceClients, previousMeshMode, istioMode);\n\n  // Clean up any existing waypoint resources if SSO is not configured\n  await purgeOrphans(\n    (pkg.metadata?.generation ?? 0).toString(),\n    pkg.metadata.namespace,\n    pkg.metadata.name,\n    K8sGateway,\n    log,\n  );\n\n  // Return the new status objects for status update\n  return newAuthserviceClients;\n}\n\nexport async function purgeAuthserviceClients(\n  pkg: UDSPackage,\n  newAuthserviceClients: AuthserviceClient[] = [],\n  previousMeshMode: Mode,\n  currentMeshMode: Mode,\n): Promise<void> {\n  const prevClients = pkg.status?.authserviceClients || [];\n\n  // Check if mesh mode changed\n  const meshModeChanged = previousMeshMode !== currentMeshMode;\n\n  // First handle truly removed clients\n  const removedClients = prevClients.filter(\n    oldClient => !newAuthserviceClients.some(c => c.clientId === oldClient.clientId),\n  );\n\n  // Process removed clients\n  await Promise.all(\n    removedClients.map(async client => {\n      const fullWaypointName = getWaypointName(client.clientId);\n      log.info(`Removing authservice client ${client.clientId}`);\n\n      await reconcileAuthservice(\n        { name: client.clientId, action: Action.RemoveClient },\n        {},\n        false, // Don't need to update policy for removed clients\n        pkg,\n        fullWaypointName,\n      );\n\n      if (pkg.metadata?.namespace) {\n        await cleanupWaypointLabels(pkg.metadata.namespace, fullWaypointName);\n      }\n    }),\n  );\n\n  // Then handle updated clients (selector changes or mesh mode change)\n  const updatedWaypointClients = meshModeChanged\n    ? prevClients // All clients need update if mesh mode changed\n    : prevClients.filter(oldClient => {\n        const newClient = newAuthserviceClients.find(c => c.clientId === oldClient.clientId);\n        if (!newClient) return false; // Already handled by removedClients\n        return JSON.stringify(oldClient.selector) !== JSON.stringify(newClient.selector);\n      });\n\n  // Process updated clients (selector changes or mesh mode)\n  for (const client of updatedWaypointClients) {\n    const newClient = newAuthserviceClients.find(c => c.clientId === client.clientId);\n    const fullWaypointName = getWaypointName(client.clientId);\n    if (!newClient) continue;\n\n    log.info(\n      {\n        reason: meshModeChanged ? \"mesh_mode_change\" : \"selector_changed\",\n      },\n      `Updating authservice client ${client.clientId}`,\n    );\n\n    if (pkg.metadata?.namespace) {\n      await cleanupWaypointLabels(pkg.metadata.namespace, fullWaypointName);\n    }\n  }\n}\n\nfunction isAddOrRemoveClientEvent(event: AuthServiceEvent): event is AddOrRemoveClientEvent {\n  return event.action === Action.AddClient || event.action === Action.RemoveClient;\n}\n\nexport async function reconcileAuthservice(\n  event: AuthServiceEvent,\n  labelSelector: { [key: string]: string } = {},\n  isAmbient?: boolean,\n  pkg?: UDSPackage,\n  waypointName?: string,\n) {\n  await updateConfig(event);\n  if (isAddOrRemoveClientEvent(event)) {\n    if (!pkg) {\n      throw new Error(\"Package must be provided for AddClient or RemoveClient events\");\n    }\n    await updatePolicy(event, labelSelector, pkg, isAmbient, waypointName);\n  }\n}\n\n// Write authservice config to secret (ensure the new function name is referenced)\nexport async function updateConfig(event: AuthServiceEvent) {\n  // Lock to prevent concurrent updates\n  if (lock) {\n    log.debug(\"Lock is set for config update, retrying...\");\n    setTimeout(() => updateConfig(event), 0);\n    return;\n  }\n\n  let config: AuthserviceConfig;\n\n  try {\n    log.debug(\"Locking config for update\");\n    lock = true;\n\n    // build updated config based on event\n    config = await getAuthserviceConfig().then(config => {\n      return buildConfig(config, event);\n    });\n\n    // Update the in-memory config immediately\n    setAuthserviceConfig(config);\n  } catch (e) {\n    log.error({ event, e }, \"Failed to build in memory authservice secret for event\");\n    throw e;\n  } finally {\n    // unlock config\n    log.debug(\"Unlocking config for update\");\n    lock = false;\n  }\n\n  // apply the authservice secret\n  log.debug(\"Applying authservice secret\");\n  await updateAuthServiceSecret(config);\n}\n\nexport function buildConfig(config: AuthserviceConfig, event: AuthServiceEvent) {\n  let chains: Chain[];\n\n  if (event.action === Action.AddClient) {\n    // Add the new chain to the existing authservice config\n    chains = config.chains.filter(chain => chain.name !== event.name);\n    chains = chains.concat(buildChain(event));\n    // Sort the chains by their name before returning. Note that the accuracy of\n    // sorting here is not relevant, only the consistency.\n    const sortByName = R.sortBy(R.prop(\"name\"));\n    chains = sortByName(chains);\n  } else if (event.action === Action.RemoveClient) {\n    // Search in the existing chains for the chain to remove by name.\n    // Filtering here should preserve the order, so there is no need to re-sort.\n    chains = config.chains.filter(chain => chain.name !== event.name);\n    // Handle global config updates\n  } else if (event.action === Action.UpdateGlobalConfig) {\n    if (!event.redisUri) {\n      // Remove the redis session store config if a URI is not provided\n      delete config.default_oidc_config.redis_session_store_config;\n    } else {\n      // Update the redis session store config if a URI is provided\n      config.default_oidc_config.redis_session_store_config = {\n        server_uri: event.redisUri,\n      };\n    }\n    if (!event.trustedCA) {\n      // Remove the trusted certificate authority if a CA is not provided\n      delete config.default_oidc_config.trusted_certificate_authority;\n    } else {\n      // Update the trusted certificate authority if a CA is provided\n      config.default_oidc_config.trusted_certificate_authority = event.trustedCA;\n    }\n    chains = config.chains;\n  } else {\n    throw new Error(`Unhandled Action: ${event.action satisfies never}`);\n  }\n\n  // Add the new chains to the existing authservice config\n  return { ...config, chains } as AuthserviceConfig;\n}\n\nexport function buildChain(update: AuthServiceEvent) {\n  // TODO: get this from the package\n  // TODO: update to loop and build multiple chains on redirectUris\n  // Parse the hostname from the first client redirect URI\n  const hostname = new URL(update.client!.redirectUris[0]).hostname;\n\n  const chain: Chain = {\n    name: update.name,\n    match: {\n      header: \":authority\",\n      prefix: hostname,\n    },\n    filters: [\n      {\n        oidc_override: {\n          authorization_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/auth`,\n          token_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/token`,\n          callback_uri: update.client!.redirectUris[0],\n          client_id: update.client!.clientId,\n          client_secret: update.client!.secret,\n          scopes: [],\n          logout: {\n            path: \"/logout\",\n            redirect_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/logout`,\n          },\n          cookie_name_prefix: update.client!.clientId,\n        },\n      },\n    ],\n  };\n  return chain;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { a, K8s, kind } from \"pepr\";\nimport { K8sGateway, K8sGatewayFromType, UDSPackage } from \"../../crd\";\nimport { Mode, Sso } from \"../../crd/generated/package-v1alpha1\";\nimport { PackageStore } from \"../packages/package-store\";\nimport { getAuthserviceClients, getOwnerRef } from \"../utils\";\nimport { ambientEgressNamespace, sharedEgressPkgId } from \"./egress-ambient\";\nimport { getSharedAnnotationKey, log } from \"./istio-resources\";\nimport { getWaypointName, matchesLabels, serviceMatchesSelector } from \"./waypoint-utils\";\n\nexport const egressWaypointName = \"egress-waypoint\";\n\n// Constants for labels and configuration\nconst ISTIO_WAYPOINT_LABEL = \"istio.io/use-waypoint\"; // Label to enable waypoint injection\nconst UDS_MANAGED_LABEL = \"uds/managed-by\"; // Label to identify UDS-managed resources\n\n// Environment variables with defaults for waypoint health checking\nconst HEALTH_OPTS = {\n  intervalMs: 5000,\n  timeoutMs: 60000,\n};\n\n/**\n * Sets up an ambient waypoint for a package\n */\nexport async function setupAmbientWaypoint(pkg: UDSPackage, client: Sso): Promise<void> {\n  const { namespace, name } = pkg.metadata || {};\n  if (!namespace || !name) {\n    const error = \"Package metadata is missing namespace or name\";\n    log.error({ pkg }, error);\n    throw new Error(error);\n  }\n\n  log.info(`Starting ambient waypoint setup for package ${name} in ${namespace}`);\n\n  const waypointId = client.clientId;\n  const waypointName = getWaypointName(waypointId);\n\n  try {\n    await createWaypointGateway(pkg, waypointName);\n    await waitForWaypointPodHealthy(namespace, waypointName);\n    await reconcileExistingResources(pkg, client, waypointName);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    log.error(\n      { errorMessage },\n      `Error in ambient waypoint setup for waypoint ${waypointName} in ${namespace}`,\n    );\n    throw error;\n  }\n}\n\n/**\n * Creates a waypoint gateway for the given package\n */\nexport async function createWaypointGateway(pkg: UDSPackage, waypointName: string) {\n  const { namespace, name } = pkg.metadata || {};\n  if (!namespace || !name) throw new Error(\"Package metadata is missing namespace or name\");\n\n  log.info(`Creating waypoint gateway for package: ${namespace}/${name}`);\n\n  try {\n    const gateway = new K8sGateway();\n\n    gateway.metadata = {\n      name: waypointName,\n      namespace,\n      labels: {\n        [UDS_MANAGED_LABEL]: \"uds-operator\",\n        \"app.kubernetes.io/component\": \"ambient-waypoint\",\n        \"istio.io/waypoint-for\": \"all\",\n        \"istio.io/gateway-name\": waypointName,\n        \"uds/generation\": (pkg.metadata?.generation ?? 0).toString(),\n        \"uds/package\": pkg.metadata?.name ?? \"unknown\",\n      },\n      ownerReferences: getOwnerRef(pkg),\n    };\n\n    gateway.spec = {\n      gatewayClassName: \"istio-waypoint\",\n      listeners: [{ name: \"mesh\", port: 15008, protocol: \"HBONE\" }],\n    };\n\n    // Log the gateway object before applying\n    log.info(\n      {\n        namespace,\n        name: waypointName,\n        gatewayClassName: gateway.spec.gatewayClassName,\n        ownerReferences: JSON.stringify(gateway.metadata.ownerReferences),\n      },\n      \"Applying waypoint gateway\",\n    );\n\n    try {\n      await K8s(K8sGateway).Apply(gateway);\n      log.info({ namespace, waypointName }, \"Successfully created waypoint gateway\");\n      return waypointName;\n    } catch (applyError) {\n      // Detailed logging of the apply error\n      log.error(\n        { namespace, waypointName, errorType: typeof applyError, errorDetails: applyError },\n        \"Error creating waypoint gateway\",\n      );\n\n      throw new Error(\n        `Failed to create waypoint gateway: ${applyError instanceof Error ? applyError.message : String(applyError)}`,\n      );\n    }\n  } catch (error) {\n    // Capture all error details\n    log.error(\n      { namespace, waypointName, errorDetails: error },\n      \"Failed to create waypoint gateway\",\n    );\n\n    throw new Error(\n      `Failed to create waypoint gateway: ${error instanceof Error ? error.message : String(error)}`,\n    );\n  }\n}\n\n/**\n * Checks if a waypoint pod is healthy\n */\nexport async function isWaypointPodHealthy(\n  namespace: string,\n  waypointName: string,\n): Promise<boolean> {\n  try {\n    const pods = await K8s(a.Pod)\n      .InNamespace(namespace)\n      .WithLabel(`istio.io/gateway-name=${waypointName}`)\n      .Get();\n\n    return (\n      pods.items?.some(\n        pod =>\n          pod.status?.phase === \"Running\" && pod.status?.containerStatuses?.every(cs => cs.ready),\n      ) ?? false\n    );\n  } catch (error) {\n    log.warn(`Error checking waypoint pod health for ${waypointName} in ${namespace}:`, error);\n    return false;\n  }\n}\n\n/**\n * Waits for a waypoint pod to become healthy with retries\n */\nexport async function waitForWaypointPodHealthy(\n  namespace: string,\n  waypointName: string,\n): Promise<void> {\n  const start = Date.now();\n  const { intervalMs, timeoutMs } = HEALTH_OPTS;\n  let attempts = 0;\n\n  while (true) {\n    attempts++;\n    const elapsed = Date.now() - start;\n\n    if (elapsed >= timeoutMs) {\n      throw new Error(\n        `Timeout waiting for waypoint pod ${waypointName} in ${namespace} after ${elapsed}ms`,\n      );\n    }\n\n    const isHealthy = await isWaypointPodHealthy(namespace, waypointName);\n    if (isHealthy) {\n      log.debug(\n        `Waypoint pod ${waypointName} in ${namespace} is healthy after ${attempts} attempts and ${elapsed}ms`,\n      );\n      return;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, intervalMs));\n  }\n}\n\n/**\n * Reconciles a service to add waypoint labels\n */\nexport async function reconcileService(svc: a.Service): Promise<void> {\n  const namespace = svc.metadata?.namespace;\n  if (!namespace) {\n    return;\n  }\n\n  // Ensure labels object exists\n  if (!svc.metadata) {\n    svc.metadata = {};\n  }\n\n  if (!svc.metadata.labels) {\n    svc.metadata.labels = {};\n  }\n\n  // Skip if this is a waypoint service\n  if (\n    svc.metadata?.labels?.[\"app.kubernetes.io/component\"] === \"ambient-waypoint\" &&\n    svc.metadata?.labels?.[\"gateway.networking.k8s.io/gateway-name\"]?.includes(\"waypoint\")\n  ) {\n    return;\n  }\n\n  const pkg = PackageStore.getPackageByNamespace(namespace);\n  if (\n    !pkg ||\n    pkg.metadata?.deletionTimestamp ||\n    pkg.spec?.network?.serviceMesh?.mode !== Mode.Ambient\n  ) {\n    return;\n  }\n\n  // Find the SSO client that matches this service's selector (only authservice-enabled)\n  const authClients = getAuthserviceClients(pkg);\n  const matchingSso = authClients.find(sso =>\n    serviceMatchesSelector(svc, sso.enableAuthserviceSelector!),\n  );\n\n  if (!matchingSso?.clientId) return;\n\n  const waypointName = getWaypointName(matchingSso.clientId);\n\n  svc.metadata.labels = {\n    ...svc.metadata.labels,\n    [ISTIO_WAYPOINT_LABEL]: waypointName,\n    \"istio.io/ingress-use-waypoint\": \"true\",\n  };\n\n  log.info(\n    { namespace, waypointName, clientId: matchingSso.clientId, labels: svc.metadata.labels },\n    `Added waypoint labels to service ${svc.metadata?.name}`,\n  );\n}\n\n/**\n * Reconciles a pod to add waypoint labels\n */\nexport async function reconcilePod(pod: a.Pod): Promise<void> {\n  const namespace = pod.metadata?.namespace;\n  if (!namespace) {\n    return;\n  }\n\n  // Ensure labels object exists\n  if (!pod.metadata) {\n    pod.metadata = {};\n  }\n\n  if (!pod.metadata.labels) {\n    pod.metadata.labels = {};\n  }\n\n  // Skip if this is a waypoint service\n  if (\n    pod.metadata?.labels?.[\"app.kubernetes.io/component\"] === \"ambient-waypoint\" &&\n    pod.metadata?.labels?.[\"gateway.networking.k8s.io/gateway-name\"]?.includes(\"waypoint\")\n  ) {\n    return;\n  }\n\n  const pkg = PackageStore.getPackageByNamespace(namespace);\n  if (\n    !pkg ||\n    pkg.metadata?.deletionTimestamp ||\n    pkg.spec?.network?.serviceMesh?.mode !== Mode.Ambient\n  ) {\n    return;\n  }\n\n  // Find the SSO client that matches this pod's labels (only authservice-enabled)\n  const authClients = getAuthserviceClients(pkg);\n  const matchingSso = authClients.find(sso =>\n    matchesLabels(pod.metadata?.labels || {}, sso.enableAuthserviceSelector!),\n  );\n\n  if (!matchingSso?.clientId) return;\n\n  const waypointName = getWaypointName(matchingSso.clientId);\n\n  pod.metadata.labels = {\n    ...pod.metadata.labels,\n    [ISTIO_WAYPOINT_LABEL]: waypointName,\n  };\n\n  const podDisplayName = pod.metadata?.name || pod.metadata?.generateName || \"<unknown name>\";\n\n  log.info(\n    {\n      namespace,\n      waypointName,\n      clientId: matchingSso.clientId,\n    },\n    `Added waypoint labels to pod ${podDisplayName}`,\n  );\n}\n\n/**\n * Cleans up waypoint labels from pods and services that reference a specific waypoint\n */\nexport async function cleanupWaypointLabels(\n  namespace: string,\n  waypointName: string,\n): Promise<void> {\n  log.info(`Starting cleanup of waypoint labels: namespace=${namespace}, waypoint=${waypointName}`);\n\n  try {\n    // Clean up pods with the waypoint label\n    await cleanupPodsWithWaypointLabel(namespace, waypointName);\n\n    // Clean up services with the waypoint label\n    await cleanupServicesWithWaypointLabel(namespace, waypointName);\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    log.error(\n      {\n        namespace,\n        waypointName,\n        error: errorMessage,\n      },\n      \"Failed to clean up waypoint labels\",\n    );\n    // Don't throw here to allow other cleanup to continue\n  }\n}\n\n/**\n * Cleans up waypoint labels from pods\n */\nasync function cleanupPodsWithWaypointLabel(\n  namespace: string,\n  waypointName: string,\n): Promise<void> {\n  const pods = await K8s(a.Pod)\n    .InNamespace(namespace)\n    .WithLabel(ISTIO_WAYPOINT_LABEL, waypointName)\n    .Get();\n\n  await Promise.all(\n    pods.items.map(async pod => {\n      const podName = pod.metadata?.name;\n      if (!podName) return;\n\n      // Skip if pod is being deleted or doesn't have the label anymore\n      if (pod.metadata?.deletionTimestamp) {\n        log.debug({ namespace, podName }, \"Skipping pod: marked for deletion\");\n        return;\n      }\n\n      try {\n        await K8s(kind.Pod, {\n          name: podName,\n          namespace,\n        }).Patch([\n          {\n            op: \"remove\",\n            path: \"/metadata/labels/istio.io~1use-waypoint\",\n          },\n        ]);\n        log.info({ namespace, podName, waypointName }, \"Removed waypoint label from pod\");\n      } catch (error) {\n        log.error(\n          {\n            namespace,\n            podName,\n            waypointName,\n            error: error instanceof Error ? error.message : String(error),\n          },\n          \"Failed to remove waypoint label from pod\",\n        );\n      }\n    }),\n  );\n}\n\n/**\n * Cleans up waypoint labels from services\n */\nasync function cleanupServicesWithWaypointLabel(\n  namespace: string,\n  waypointName: string,\n): Promise<void> {\n  const services = await K8s(a.Service)\n    .InNamespace(namespace)\n    .WithLabel(ISTIO_WAYPOINT_LABEL, waypointName)\n    .Get();\n\n  await Promise.all(\n    services.items.map(async svc => {\n      const svcName = svc.metadata?.name;\n      if (!svcName) return;\n\n      // Skip if service is being deleted or doesn't have the label anymore\n      if (svc.metadata?.deletionTimestamp) {\n        log.debug({ namespace, svcName }, \"Skipping service: marked for deletion\");\n        return;\n      }\n\n      try {\n        await K8s(kind.Service, {\n          name: svcName,\n          namespace,\n        }).Patch([\n          {\n            op: \"remove\",\n            path: \"/metadata/labels/istio.io~1ingress-use-waypoint\",\n          },\n          {\n            op: \"remove\",\n            path: \"/metadata/labels/istio.io~1use-waypoint\",\n          },\n        ]);\n        log.info({ namespace, svcName, waypointName }, \"Removed waypoint labels from service\");\n      } catch (error) {\n        log.error(\n          {\n            namespace,\n            svcName,\n            waypointName,\n            error: error instanceof Error ? error.message : String(error),\n          },\n          \"Failed to remove waypoint labels from service\",\n        );\n      }\n    }),\n  );\n}\n\nexport async function reconcileExistingResources(\n  pkg: UDSPackage,\n  ssoClient: Sso,\n  waypointName: string,\n): Promise<void> {\n  const namespace = pkg.metadata?.namespace;\n  if (!namespace) {\n    log.warn({ pkg }, \"No namespace found in package metadata\");\n    return;\n  }\n\n  log.info(`Starting reconciliation of existing resources in ${namespace} for ${waypointName}`);\n\n  try {\n    const [services, pods] = await Promise.all([\n      K8s(kind.Service).InNamespace(namespace).Get(),\n      K8s(kind.Pod).InNamespace(namespace).Get(),\n    ]);\n\n    const matchingServices = services.items.filter(svc =>\n      serviceMatchesSelector(svc, ssoClient.enableAuthserviceSelector!),\n    );\n\n    const matchingPods = pods.items.filter(pod => {\n      const matches = matchesLabels(\n        pod.metadata?.labels || {},\n        ssoClient.enableAuthserviceSelector!,\n      );\n      return matches;\n    });\n\n    log.debug(`Found resource to update with waypoint labels in ${namespace}`);\n\n    // Process matching services\n    for (const svc of matchingServices) {\n      try {\n        await K8s(kind.Service, {\n          name: svc.metadata!.name!,\n          namespace: namespace,\n        }).Patch([\n          {\n            op: \"add\",\n            path: \"/metadata/labels/istio.io~1ingress-use-waypoint\",\n            value: \"true\",\n          },\n          {\n            op: \"add\",\n            path: `/metadata/labels/${ISTIO_WAYPOINT_LABEL.replace(/\\//g, \"~1\")}`,\n            value: waypointName,\n          },\n        ]);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        log.error({ errorMessage }, `Service reconciliation failed for ${namespace}`);\n      }\n    }\n\n    // Process matching pods\n    for (const pod of matchingPods) {\n      try {\n        await K8s(kind.Pod, {\n          name: pod.metadata!.name!,\n          namespace: namespace,\n        }).Patch([\n          {\n            op: \"add\",\n            path: `/metadata/labels/${ISTIO_WAYPOINT_LABEL.replace(/\\//g, \"~1\")}`,\n            value: waypointName,\n          },\n        ]);\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        log.info({ errorMessage }, `Pod reconciliation failed for ${namespace}`);\n      }\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    log.error({ errorMessage }, `Error in reconcileExistingResources()`);\n\n    // Re-throw to allow the caller to handle the error\n    throw error;\n  }\n}\n\n// Generate Waypoint for ambient egress\nexport function createEgressWaypointGateway(pkgs: Set<string>, generation: number) {\n  // Add annotations from resource\n  const annotations: Record<string, string> = {};\n  for (const pkgId of pkgs) {\n    annotations[`${getSharedAnnotationKey(pkgId)}`] = \"user\";\n  }\n\n  // Waypoint resource\n  const waypoint: K8sGateway = {\n    metadata: {\n      name: egressWaypointName,\n      namespace: ambientEgressNamespace,\n      annotations,\n      labels: {\n        \"uds/package\": sharedEgressPkgId,\n        \"uds/generation\": generation.toString(),\n        \"istio.io/gateway-name\": egressWaypointName,\n      },\n    },\n    spec: {\n      gatewayClassName: \"istio-waypoint\",\n      listeners: [\n        {\n          name: \"mesh\",\n          port: 15008,\n          protocol: \"HBONE\",\n          allowedRoutes: {\n            namespaces: {\n              from: K8sGatewayFromType.All,\n            },\n            kinds: [\n              {\n                group: \"networking.istio.io\",\n                kind: \"ServiceEntry\",\n              },\n            ],\n          },\n        },\n      ],\n      infrastructure: {\n        parametersRef: {\n          group: \"\",\n          kind: \"ConfigMap\",\n          name: \"egress-waypoint-config\",\n        },\n      },\n    },\n  };\n\n  return waypoint;\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n/**\n * A collection of functions related to watching UDSPackages\n * Manages an in-memory map of UDSPackage resources\n * Used in Pepr Validating Webhook Pods when vetting UDS Package resources for admission\n */\nimport { Component, setupLogger } from \"../../../logger\";\nimport { UDSPackage } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nconst log = setupLogger(Component.OPERATOR_PACKAGES);\n\n// Map structure: namespace -> (package name -> package)\nexport type PackageNamespaceMap = Map<string, Map<string, UDSPackage>>;\nlet packageNamespaceMap: PackageNamespaceMap;\nlet ssoIndex: Map<string, Set<string>>;\n\n/**\n * Initializes the package namespace map.\n *\n * This function creates a new `Map` object and assigns it to the `packageNamespaceMap` variable.\n * The `packageNamespaceMap` is used to store packages, using their namespace as the key.\n */\nfunction init(): void {\n  packageNamespaceMap = new Map();\n  ssoIndex = new Map();\n}\n\n/**\n * Adds a package to the package namespace map.\n *\n * @param {UDSPackage} pkg - The package to be added. It should contain metadata with a namespace and name.\n * @param {boolean} [logger=true] - Optional flag to enable logging. Defaults to true.\n *\n * This function retrieves the namespace and name from the package metadata and adds the package\n * to the packageNamespaceMap. If the namespace doesn't exist, it creates a new map for that namespace.\n * The function then adds or updates the package in the namespace map using the package name as the key.\n */\nfunction add(pkg: UDSPackage, logger: boolean = true): void {\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n  const namespace = pkg.metadata.namespace;\n  const name = pkg.metadata.name;\n\n  // Get or create the namespace map\n  if (!packageNamespaceMap.has(namespace)) {\n    packageNamespaceMap.set(namespace, new Map());\n  }\n\n  const namespaceMap = packageNamespaceMap.get(namespace)!;\n  const isUpdate = namespaceMap.has(name);\n\n  // Set the package\n  namespaceMap.set(name, pkg);\n\n  // Add SSO index if necessary\n  const clients = pkg.spec?.sso;\n  if (clients) {\n    clients.forEach(client => {\n      const clientId = client.clientId;\n      if (!ssoIndex.has(clientId)) {\n        ssoIndex.set(clientId, new Set());\n      }\n      // Store based on namespace since we only allow a single Package per namespace\n      ssoIndex.get(clientId)!.add(namespace);\n    });\n  }\n\n  if (logger) {\n    if (isUpdate) {\n      log.debug(`Updating PackageStore for package ${name} in namespace ${namespace}.`);\n    } else {\n      log.debug(`Added package: ${namespace}/${name} to package map`);\n    }\n  }\n}\n\n/**\n * Removes a package from the package namespace map.\n *\n * @param {UDSPackage} pkg - The package to be removed. It should contain metadata with a namespace and name.\n * @param {boolean} [logger=true] - Optional flag to enable logging. Defaults to true.\n *\n * This function retrieves the namespace and name from the package metadata and removes the package\n * from the packageNamespaceMap. If the namespace map becomes empty after removal, the namespace\n * is also removed from the packageNamespaceMap.\n */\nfunction remove(pkg: UDSPackage, logger: boolean = true): void {\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n\n  const namespace = pkg.metadata.namespace;\n  const name = pkg.metadata.name;\n\n  const namespaceMap = packageNamespaceMap.get(namespace);\n  if (!namespaceMap) {\n    // Namespace doesn't exist, nothing to remove\n    return;\n  }\n\n  // Remove the package\n  namespaceMap.delete(name);\n\n  // If namespace map is empty, remove the namespace\n  if (namespaceMap.size === 0) {\n    packageNamespaceMap.delete(namespace);\n  }\n\n  // Remove SSO index if necessary\n  const clients = pkg.spec?.sso;\n  if (clients) {\n    clients.forEach(client => {\n      const clientId = client.clientId;\n      const nsSet = ssoIndex.get(clientId);\n      if (!nsSet) return;\n      nsSet.delete(namespace);\n      if (nsSet.size === 0) {\n        ssoIndex.delete(clientId);\n      }\n    });\n  }\n\n  if (logger) {\n    log.debug(`Removed package: ${namespace}/${name} from package map`);\n  }\n}\n\n/**\n * Checks if a given namespace exists within the package namespace map.\n *\n * This function determines whether a namespace has been previously registered\n * in the `packageNamespaceMap`.  It provides a way to verify the existence\n * of a package in a given namespace.\n *\n * @param namespace The namespace to check for existence.\n * @returns `true` if the namespace exists in the map; otherwise, `false`.\n */\nfunction hasKey(namespace: string): boolean {\n  return packageNamespaceMap.has(namespace);\n}\n\n/**\n * Retrieves the package name associated with a given namespace.\n *\n * This function looks up the namespace in the `packageNamespaceMap` and, if found,\n * returns the name of the first package in that namespace.\n * If the namespace is not found or there are no packages, it returns null.\n *\n * @param namespace The namespace to look up in the `packageNamespaceMap`.\n * @returns The package name associated with the namespace, or null if not found.\n */\nfunction getPkgName(namespace: string): string | null {\n  const namespaceMap = packageNamespaceMap.get(namespace);\n  if (!namespaceMap || namespaceMap.size === 0) {\n    return null;\n  }\n\n  // Return the name of the first package in the namespace\n  return Array.from(namespaceMap.keys())[0];\n}\n\n/**\n * Finds packages that have an SSO client with the specified client ID.\n *\n * @param {string} clientId - The client ID to search for.\n * @returns {Array<{namespace: string, name: string, pkg: UDSPackage}>} - Array of namespaces with Packages using the specified client ID.\n */\nfunction findPackagesWithSsoClientId(clientId: string): Set<string> {\n  return ssoIndex.get(clientId) ?? new Set<string>();\n}\n\n/**\n * Finds all packages that have ambient waypoint enabled\n * @returns Array of UDSPackage objects with ambient waypoint enabled\n */\nfunction getAmbientPackages(): UDSPackage[] {\n  const result: UDSPackage[] = [];\n  for (const namespaceMap of packageNamespaceMap.values()) {\n    for (const pkg of namespaceMap.values()) {\n      if (pkg.spec?.network?.serviceMesh?.mode === Mode.Ambient) {\n        result.push(pkg);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the package for a specific namespace\n * @param namespace The namespace to get the package for\n * @returns The UDSPackage for the namespace, or undefined if not found\n */\nfunction getPackageByNamespace(namespace: string): UDSPackage | undefined {\n  const namespaceMap = packageNamespaceMap.get(namespace);\n  if (!namespaceMap || namespaceMap.size === 0) return undefined;\n\n  // Since we only allow one package per namespace, just return the first one\n  return Array.from(namespaceMap.values())[0];\n}\n\nexport const PackageStore = {\n  init,\n  add,\n  remove,\n  hasKey,\n  getPkgName,\n  findPackagesWithSsoClientId,\n  getAmbientPackages,\n  getPackageByNamespace,\n};\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { K8s } from \"pepr\";\nimport { Allow, IstioAuthorizationPolicy, IstioServiceEntry, K8sGateway } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { purgeOrphans } from \"../utils\";\nimport { createEgressWaypointGateway, waitForWaypointPodHealthy } from \"./ambient-waypoint\";\nimport { generateAmbientEgressAuthorizationPolicy } from \"./auth-policy\";\nimport { getHostPortsProtocol } from \"./egress\";\nimport { log } from \"./istio-resources\";\nimport { generateLocalEgressSEName, generateLocalEgressServiceEntry } from \"./service-entry\";\nimport { HostResourceMap } from \"./types\";\n\nexport const ambientEgressNamespace = \"istio-egress-ambient\";\nexport const sharedEgressPkgId = \"shared-ambient-egress-resource\";\n\n// Apply the ambient egress resources\nexport async function applyAmbientEgressResources(packageList: Set<string>, generation: number) {\n  // If no packages using ambient egress, don't create the waypoint\n  if (packageList.size === 0) {\n    return;\n  }\n\n  // Generate the waypoint payload\n  const waypoint = createEgressWaypointGateway(packageList, generation);\n  const waypointName = waypoint.metadata?.name ?? \"undefined\";\n\n  // Apply waypoint\n  log.debug(waypoint, `Applying Waypoint ${waypointName}`);\n\n  // Apply the Waypoint and force overwrite any existing resource\n  await K8s(K8sGateway).Apply(waypoint, { force: true });\n\n  // Wait for waypoint pod healthy\n  await waitForWaypointPodHealthy(ambientEgressNamespace, waypointName);\n}\n\n// Purge any orphaned ambient egress resources\nexport async function purgeAmbientEgressResources(generation: string) {\n  try {\n    await purgeOrphans(generation, ambientEgressNamespace, sharedEgressPkgId, K8sGateway, log);\n  } catch (e) {\n    const errText = `Failed to purge orphaned ambient egress resources`;\n    log.error(`Failed to purge orphaned ambient egress resources`, e);\n    throw errText;\n  }\n}\n\n// Create package owned ambient egress resources\nexport async function createAmbientWorkloadEgressResources(\n  hostResourceMap: HostResourceMap,\n  egressRequested: Allow[],\n  pkgName: string,\n  namespace: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  // Add service entry for each defined host\n  for (const host of Object.keys(hostResourceMap)) {\n    // Create Service Entry\n    const serviceEntry = generateLocalEgressServiceEntry(\n      host,\n      hostResourceMap[host],\n      pkgName,\n      namespace,\n      generation,\n      ownerRefs,\n      Mode.Ambient,\n    );\n\n    log.debug(serviceEntry, `Applying Service Entry ${serviceEntry.metadata?.name}`);\n\n    // Apply the ServiceEntry and force overwrite any existing resource\n    await K8s(IstioServiceEntry).Apply(serviceEntry, { force: true });\n  }\n\n  // Create Authorization Policy for service entry, use specified serviceAccount or use from namespace if no serviceAccount specified\n  for (const allow of egressRequested) {\n    const hostPortsProtocol = getHostPortsProtocol(allow);\n    if (!hostPortsProtocol) {\n      continue;\n    }\n    const { host, ports, protocol } = hostPortsProtocol;\n    const portsProtocol = ports.map(port => ({ port, protocol }));\n\n    // Create Authorization Policy\n    const authPolicy = generateAmbientEgressAuthorizationPolicy(\n      host,\n      pkgName,\n      namespace,\n      generation,\n      ownerRefs,\n      generateLocalEgressSEName(pkgName, portsProtocol, host),\n      allow.serviceAccount,\n    );\n\n    log.debug(authPolicy, `Applying Authorization Policy ${authPolicy.metadata?.name}`);\n\n    // Apply the AuthorizationPolicy and force overwrite any existing resource\n    await K8s(IstioAuthorizationPolicy).Apply(authPolicy, { force: true });\n  }\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { IstioAction, IstioAuthorizationPolicy } from \"../../crd\";\nimport { sanitizeResourceName } from \"../utils\";\n\n// Generate Authorization Policy for ambient egress\nexport function generateAmbientEgressAuthorizationPolicy(\n  host: string,\n  pkgName: string,\n  namespace: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n  serviceEntryName: string,\n  serviceAccount: string | undefined,\n) {\n  const source = serviceAccount\n    ? { principals: [`cluster.local/ns/${namespace}/sa/${serviceAccount}`] }\n    : { namespaces: [`${namespace}`] };\n\n  const authPolicy: IstioAuthorizationPolicy = {\n    metadata: {\n      name: generateAmbientEgressAuthorizationPolicyName(host, serviceAccount),\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n        \"uds/for\": \"egress\",\n      },\n      // Use the CR as the owner ref for each AuthorizationPolicy\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      action: IstioAction.Allow,\n      rules: [\n        {\n          from: [\n            {\n              source,\n            },\n          ],\n        },\n      ],\n      // ServiceEntry is target to gate egress to host\n      targetRef: {\n        group: \"networking.istio.io\",\n        kind: \"ServiceEntry\",\n        name: serviceEntryName,\n      },\n    },\n  };\n\n  return authPolicy;\n}\n\nexport function generateAmbientEgressAuthorizationPolicyName(\n  host: string,\n  serviceAccount: string | undefined,\n) {\n  return serviceAccount\n    ? sanitizeResourceName(`${host}-${serviceAccount}-egress`)\n    : sanitizeResourceName(`${host}-egress`);\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { K8s, kind } from \"pepr\";\nimport {\n  Allow,\n  IstioGateway,\n  IstioServiceEntry,\n  IstioSidecar,\n  IstioVirtualService,\n} from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { purgeOrphans, validateNamespace } from \"../utils\";\nimport { generateEgressGateway, warnMatchingExistingGateways } from \"./gateway\";\nimport { log } from \"./istio-resources\";\nimport { generateLocalEgressServiceEntry, generateSharedServiceEntry } from \"./service-entry\";\nimport { generateEgressSidecar } from \"./sidecar\";\nimport { EgressResource, EgressResourceMap, HostResourceMap, PackageHostMap } from \"./types\";\nimport {\n  generateEgressVirtualService,\n  warnMatchingExistingVirtualServices,\n} from \"./virtual-service\";\n\n// Sidecar Egress Gateway Namespace\nexport const sidecarEgressNamespace = \"istio-egress-gateway\";\nexport const sharedEgressPkgId = \"shared-egress-resource\";\n\n// Apply the egress resources for all hosts\nexport async function applySidecarEgressResources(\n  packageEgress: PackageHostMap,\n  generation: number,\n) {\n  // Re-map the package egress definitions to required egress resources\n  const egressResources = remapEgressResources(packageEgress);\n\n  // Apply the unique set of egress resources per defined host\n  const applyPromises: Promise<void>[] = [];\n\n  for (const host in egressResources) {\n    const resource = egressResources[host];\n\n    // Create a promise for applying this host's resources\n    const hostPromise = applyHostResources(host, resource, generation);\n    applyPromises.push(hostPromise);\n  }\n\n  // Wait for all host resources to be applied\n  await Promise.all(applyPromises);\n}\n\n// Purge any orphaned sidecar shared resources\nexport async function purgeSidecarEgressResources(generation: string) {\n  try {\n    await purgeOrphans(generation, sidecarEgressNamespace, sharedEgressPkgId, IstioGateway, log);\n    await purgeOrphans(\n      generation,\n      sidecarEgressNamespace,\n      sharedEgressPkgId,\n      IstioVirtualService,\n      log,\n    );\n    await purgeOrphans(\n      generation,\n      sidecarEgressNamespace,\n      sharedEgressPkgId,\n      IstioServiceEntry,\n      log,\n    );\n  } catch (e) {\n    const errText = `Failed to purge orphaned sidecar egress resources`;\n    log.error(`Failed to purge orphaned sidecar egress resources`, e);\n    throw errText;\n  }\n}\n\n// Remap the package egress definitions to required egress resources\nexport function remapEgressResources(packageEgress: PackageHostMap) {\n  const egressResources: EgressResourceMap = {};\n  for (const pkgId in packageEgress) {\n    const hostResourceMap = packageEgress[pkgId];\n    for (const host in hostResourceMap) {\n      const portProtocols = hostResourceMap[host].portProtocol;\n\n      egressResources[host] ??= {\n        packages: [],\n        portProtocols: [],\n      };\n\n      if (!egressResources[host].packages.includes(pkgId)) {\n        egressResources[host].packages.push(pkgId);\n      }\n\n      for (const portProtocol of portProtocols) {\n        const existingPortProtocol = egressResources[host].portProtocols.find(\n          pp => pp.port === portProtocol.port && pp.protocol === portProtocol.protocol,\n        );\n\n        if (!existingPortProtocol) {\n          egressResources[host].portProtocols.push(portProtocol);\n        }\n      }\n    }\n  }\n\n  return egressResources;\n}\n\n// Apply resources for a given host\nasync function applyHostResources(host: string, resource: EgressResource, generation: number) {\n  try {\n    // Check if matching hosts exist for Gateway and Virtual Service\n    await warnMatchingExistingGateways(host);\n    await warnMatchingExistingVirtualServices(host);\n\n    // Apply each resource type with individual error handling\n    const resourcePromises: Promise<void>[] = [];\n\n    // Generate and Apply the egress gateway\n    const gatewayPromise = (async () => {\n      try {\n        const gateway = generateEgressGateway(host, resource, generation);\n        log.debug(gateway, `Applying Egress Gateway ${gateway.metadata?.name}`);\n        await K8s(IstioGateway).Apply(gateway, { force: true });\n      } catch (e) {\n        const errText = `Failed to apply Gateway for host ${host}`;\n        log.error(errText, e);\n        throw new Error(errText);\n      }\n    })();\n    resourcePromises.push(gatewayPromise);\n\n    // Generate and Apply the egress Virtual Service\n    const virtualServicePromise = (async () => {\n      try {\n        const virtualService = generateEgressVirtualService(host, resource, generation);\n        log.debug(\n          virtualService,\n          `Applying Egress Virtual Service ${virtualService.metadata?.name}`,\n        );\n        await K8s(IstioVirtualService).Apply(virtualService, { force: true });\n      } catch (e) {\n        const errText = `Failed to apply Virtual Service for host ${host}`;\n        log.error(errText, e);\n        throw new Error(errText);\n      }\n    })();\n    resourcePromises.push(virtualServicePromise);\n\n    // Generate and Apply the egress Service Entry\n    const serviceEntryPromise = (async () => {\n      try {\n        const serviceEntry = generateSharedServiceEntry(host, resource, generation);\n        log.debug(serviceEntry, `Applying Service Entry ${serviceEntry.metadata?.name}`);\n        await K8s(IstioServiceEntry).Apply(serviceEntry, { force: true });\n      } catch (e) {\n        const errText = `Failed to apply Service Entry for host ${host}`;\n        log.error(errText, e);\n        throw new Error(errText);\n      }\n    })();\n    resourcePromises.push(serviceEntryPromise);\n\n    // Wait for all resource applications to complete\n    await Promise.all(resourcePromises);\n  } catch (e) {\n    log.error(`Failed to apply egress resources for host ${host} of generation ${generation}`, e);\n    throw e;\n  }\n}\n\n// Validate that namespace exists and ports are exposed by the Istio egress gateway\nexport async function validateEgressGateway(hostResourceMap: HostResourceMap) {\n  // Error if egress gateway is not enabled in the cluster\n  try {\n    await validateNamespace(sidecarEgressNamespace);\n  } catch (e) {\n    let errText = `Unable to get the egress gateway namespace ${sidecarEgressNamespace}.`;\n    if (e?.status == 404) {\n      errText = `Egress gateway is not enabled in the cluster. Please enable the egress gateway and retry.`;\n    }\n    log.error(errText);\n    throw new Error(errText);\n  }\n\n  // Check the desired ports are exposed by the service\n  const service = await K8s(kind.Service).InNamespace(sidecarEgressNamespace).Get(\"egressgateway\");\n\n  const ports = service.spec?.ports ?? [];\n  for (const host in hostResourceMap) {\n    for (const portProtocol of hostResourceMap[host].portProtocol) {\n      const port = ports.find(p => p.port === portProtocol.port);\n      if (!port) {\n        const errText = `Egress gateway does not expose port ${portProtocol.port} for host ${host}. Please update the egress gateway service to expose this port.`;\n        log.error(errText);\n        throw new Error(errText);\n      }\n    }\n  }\n}\n\n// Create package owned sidecar egress resources\nexport async function createSidecarWorkloadEgressResources(\n  hostResourceMap: HostResourceMap,\n  egressRequested: Allow[],\n  pkgName: string,\n  namespace: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  // Add service entry for each defined host\n  for (const host of Object.keys(hostResourceMap)) {\n    // Create Service Entry\n    const serviceEntry = generateLocalEgressServiceEntry(\n      host,\n      hostResourceMap[host],\n      pkgName,\n      namespace,\n      generation,\n      ownerRefs,\n      Mode.Sidecar,\n    );\n\n    log.debug(serviceEntry, `Applying Service Entry ${serviceEntry.metadata?.name}`);\n\n    // Apply the ServiceEntry and force overwrite any existing resource\n    await K8s(IstioServiceEntry).Apply(serviceEntry, { force: true });\n  }\n\n  // Workloads with egressRequested\n  const selectedWorkloads = new Set(egressRequested.map(allow => allow.selector || undefined));\n  const uniqueWorkloads = new Set<string>();\n\n  // Add sidecar for each unique workload\n  for (const workload of selectedWorkloads) {\n    // Skip if we've already processed this workload\n    if (uniqueWorkloads.has(JSON.stringify(workload))) {\n      continue;\n    }\n    uniqueWorkloads.add(JSON.stringify(workload));\n\n    // Create Sidecar\n    const sidecar = generateEgressSidecar(workload, pkgName, namespace, generation, ownerRefs);\n\n    log.debug(sidecar, `Applying Sidecar ${sidecar.metadata?.name}`);\n\n    // Apply the Sidecar and force overwrite any existing resource\n    await K8s(IstioSidecar).Apply(sidecar, { force: true });\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s } from \"pepr\";\nimport { IstioGateway, IstioServer, IstioTLSMode, RemoteProtocol } from \"../../crd\";\nimport { getSharedAnnotationKey, log } from \"./istio-resources\";\nimport { sidecarEgressNamespace as namespace, sharedEgressPkgId } from \"./egress-sidecar\";\nimport { sanitizeResourceName } from \"../utils\";\nimport { EgressResource } from \"./types\";\n\n/**\n * Create the egress gateway resource\n *\n * @param host\n * @param resource\n * @param generation\n */\nexport function generateEgressGateway(host: string, resource: EgressResource, generation: number) {\n  const name = generateGatewayName(host);\n\n  // Add annotations from resource\n  const annotations: Record<string, string> = {};\n  for (const pkgId of resource.packages) {\n    annotations[`${getSharedAnnotationKey(pkgId)}`] = \"user\";\n  }\n\n  // Add the gateway servers\n  const servers: IstioServer[] = [];\n  for (const portProtocol of resource.portProtocols) {\n    const port = portProtocol.port;\n    const protocol = portProtocol.protocol;\n    const server = generateGatewayServer(host, protocol, port);\n    servers.push(server);\n  }\n\n  // Define the gateway\n  const gateway: IstioGateway = {\n    metadata: {\n      name,\n      namespace,\n      annotations,\n      labels: {\n        \"uds/generation\": generation.toString(),\n        \"uds/package\": sharedEgressPkgId,\n      },\n    },\n    spec: {\n      selector: {\n        app: \"egressgateway\",\n      },\n      servers,\n    },\n  };\n\n  return gateway;\n}\n\n// Generate the gateway server portion of the spec\nfunction generateGatewayServer(host: string, protocol: RemoteProtocol, port: number) {\n  return {\n    hosts: [host],\n    port: {\n      name: `${protocol.toLowerCase()}-${port.toString()}`,\n      number: port,\n      protocol: protocol,\n    },\n    tls: {\n      mode: IstioTLSMode.Passthrough,\n    },\n  };\n}\n\n// Check for other gateways that might conflict - gateways that are not added by the operator\n// Note: Users adding their own Istio resources will need to understand the possible conflicts with the spec. This is not an operation\n// blocked by K8s, but will be identified as invalid by Istio. The UDS operator will only manage/deconflict resources it creates or those\n// that follow the deterministic naming convention.\nexport async function warnMatchingExistingGateways(host: string) {\n  const gateways = await K8s(IstioGateway).Get();\n  const name = generateGatewayName(host);\n\n  // Match any gateways with matching hosts\n  for (const gw of gateways.items) {\n    if (gw.metadata?.name === name && gw.metadata?.namespace === namespace) {\n      // Don't warn if the gateway is the one we created\n      continue;\n    }\n    if (gw.spec && gw.spec.servers) {\n      for (const srv of gw.spec.servers) {\n        for (const srvHost of srv.hosts) {\n          if (srvHost === host) {\n            const errText = `Found existing Gateway ${gw.metadata?.name}/${gw.metadata?.namespace} with matching host. Istio will not behave properly with multiple Gateways using the same hosts.`;\n            log.error(errText);\n            throw new Error(errText);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Deterministically generate the gateway name\nexport function generateGatewayName(host: string) {\n  return sanitizeResourceName(`gateway-${host}`);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../logger\";\nimport {\n  IstioAuthorizationPolicy,\n  IstioServiceEntry,\n  IstioSidecar,\n  IstioVirtualService,\n  UDSPackage,\n} from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { getOwnerRef, purgeOrphans, validateNamespace } from \"../utils\";\nimport {\n  createHostResourceMap,\n  egressRequestedFromNetwork,\n  reconcileSharedEgressResources,\n} from \"./egress\";\nimport { ambientEgressNamespace, createAmbientWorkloadEgressResources } from \"./egress-ambient\";\nimport { createSidecarWorkloadEgressResources, validateEgressGateway } from \"./egress-sidecar\";\nimport { generateIngressServiceEntry } from \"./service-entry\";\nimport { PackageAction } from \"./types\";\nimport { generateIngressVirtualService } from \"./virtual-service\";\n\n// configure subproject logger\nexport const log = setupLogger(Component.OPERATOR_ISTIO);\n\n/**\n * Creates a VirtualService and ServiceEntry for each exposed service in the package\n * and creates or merges Istio resources for allowing egress traffic to external services\n *\n * @param pkg\n * @param namespace\n */\nexport async function istioResources(pkg: UDSPackage, namespace: string) {\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerRefs = getOwnerRef(pkg);\n\n  // Get the list of exposed services\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  // Create a Set of processed hosts (to maintain uniqueness)\n  const hosts = new Set<string>();\n\n  // Track which ServiceEntries we've created\n  const serviceEntryNames: Map<string, boolean> = new Map();\n\n  // Iterate over each exposed service\n  for (const expose of exposeList) {\n    // Generate a VirtualService for this `expose` entry\n    const vsPayload = generateIngressVirtualService(\n      expose,\n      namespace,\n      pkgName,\n      generation,\n      ownerRefs,\n    );\n\n    log.debug(vsPayload, `Applying VirtualService ${vsPayload.metadata?.name}`);\n\n    // Apply the VirtualService and force overwrite any existing policy\n    await K8s(IstioVirtualService).Apply(vsPayload, { force: true });\n\n    vsPayload.spec!.hosts!.forEach(h => hosts.add(h));\n\n    // Generate a ServiceEntry for this `expose` entry\n    const sePayload = generateIngressServiceEntry(\n      expose,\n      namespace,\n      pkgName,\n      generation,\n      ownerRefs,\n    );\n\n    // If we have already made a ServiceEntry with this name, skip (i.e. if advancedHTTP was used)\n    if (serviceEntryNames.get(sePayload.metadata!.name!)) {\n      continue;\n    }\n\n    log.debug(sePayload, `Applying ServiceEntry ${sePayload.metadata?.name}`);\n\n    // Apply the ServiceEntry and force overwrite any existing policy\n    await K8s(IstioServiceEntry).Apply(sePayload, { force: true });\n\n    serviceEntryNames.set(sePayload.metadata!.name!, true);\n  }\n\n  // Reconcile any egress requested\n  await istioEgressResources(pkg, namespace);\n\n  // Purge any orphaned resources\n  await purgeOrphans(generation, namespace, pkgName, IstioVirtualService, log);\n  await purgeOrphans(generation, namespace, pkgName, IstioServiceEntry, log); // for ingress and egress\n  await purgeOrphans(generation, namespace, pkgName, IstioSidecar, log); // for egress only\n  await purgeOrphans(generation, namespace, pkgName, IstioAuthorizationPolicy, log, {\n    \"uds/for\": \"egress\",\n  }); // for egress only\n\n  // Return the list of unique hostnames\n  return [...hosts];\n}\n\n/**\n * Creates a ServiceEntry and Sidecar resource for egress traffic and reconciles\n * shared egress resources\n *\n * @param pkg\n * @param namespace\n */\nexport async function istioEgressResources(pkg: UDSPackage, namespace: string) {\n  // Get package data\n  const istioMode = pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar;\n  const pkgId = getPackageId(pkg);\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerRefs = getOwnerRef(pkg);\n\n  // Get the map of host resources as egress endpoints\n  const hostResourceMap = createHostResourceMap(pkg);\n\n  // Get the list of allowed egress services\n  const allowList = egressRequestedFromNetwork(pkg.spec?.network?.allow ?? []);\n\n  // Add needed service entries and sidecars if egress is requested\n  if (hostResourceMap) {\n    if (istioMode === Mode.Ambient) {\n      // Validate existing egress waypoint namespace\n      try {\n        await validateNamespace(ambientEgressNamespace);\n      } catch (e) {\n        let errText = `Unable to get the egress waypoint namespace ${ambientEgressNamespace}.`;\n        if (e?.status == 404) {\n          errText = `The '${ambientEgressNamespace}' namespace was not found. Ensure the 'istio-egress-ambient' component is deployed and try again.`;\n        }\n        log.error(errText);\n        throw new Error(errText);\n      }\n\n      // For ambient workloads\n      await createAmbientWorkloadEgressResources(\n        hostResourceMap,\n        allowList,\n        pkgName,\n        namespace,\n        generation,\n        ownerRefs,\n      );\n    } else {\n      // Validate existing egress gateway namespace and service\n      await validateEgressGateway(hostResourceMap);\n\n      // Create sidecar and service entry resources\n      await createSidecarWorkloadEgressResources(\n        hostResourceMap,\n        allowList,\n        pkgName,\n        namespace,\n        generation,\n        ownerRefs,\n      );\n    }\n  }\n\n  // Reconcile shared egress resources\n  try {\n    await reconcileSharedEgressResources(\n      hostResourceMap,\n      pkgId,\n      PackageAction.AddOrUpdate,\n      istioMode,\n    );\n  } catch (e) {\n    log.error(`Failed to reconcile shared egress resources for package ${pkgId}`, e);\n    throw e;\n  }\n}\n\n// Get the shared annotation key for the package\nexport function getSharedAnnotationKey(pkgId: string) {\n  return `uds.dev/user-${pkgId}`;\n}\n\n// Get the unique package ID\nexport function getPackageId(pkg: UDSPackage) {\n  return `${pkg.metadata?.name}-${pkg.metadata?.namespace}`;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\n\nimport {\n  Expose,\n  Gateway,\n  IstioEndpoint,\n  IstioLocation,\n  IstioPort,\n  IstioResolution,\n  IstioServiceEntry,\n} from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { UDSConfig } from \"../config/config\";\nimport { getSharedAnnotationKey } from \"./istio-resources\";\nimport {\n  sidecarEgressNamespace,\n  sharedEgressPkgId as sidecarSharedEgressPkgId,\n} from \"./egress-sidecar\";\nimport { ambientEgressNamespace } from \"./egress-ambient\";\nimport { sanitizeResourceName } from \"../utils\";\nimport { HostResource, EgressResource, PortProtocol } from \"./types\";\nimport { egressWaypointName } from \"./ambient-waypoint\";\n\n/**\n * Creates a ServiceEntry for each exposed service in the package\n *\n * @param pkg\n * @param namespace\n */\nexport function generateIngressServiceEntry(\n  expose: Expose,\n  namespace: string,\n  pkgName: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  const { gateway = Gateway.Tenant, host } = expose;\n\n  const name = generateSEName(pkgName, expose);\n\n  // Get the correct domain based on gateway\n  const domain = gateway === Gateway.Admin ? UDSConfig.adminDomain : UDSConfig.domain;\n\n  // Add the host to the domain, unless this is the reserved root domain host (`.`)\n  let fqdn = \"\";\n  if (host === \".\") {\n    fqdn = domain;\n  } else {\n    fqdn = `${host}.${domain}`;\n  }\n\n  const serviceEntryPort: IstioPort = {\n    name: \"https\",\n    number: 443,\n    protocol: \"HTTPS\",\n  };\n\n  const serviceEntryEndpoint: IstioEndpoint = {\n    // Map the gateway (admin, passthrough or tenant) to the ServiceEntry\n    address: `${gateway}-ingressgateway.istio-${gateway}-gateway.svc.cluster.local`,\n  };\n\n  const payload: IstioServiceEntry = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      // Use the CR as the owner ref for each ServiceEntry\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      // Append the UDS Domain to the host\n      hosts: [fqdn],\n      location: IstioLocation.MeshInternal,\n      resolution: IstioResolution.DNS,\n      ports: [serviceEntryPort],\n      endpoints: [serviceEntryEndpoint],\n    },\n  };\n\n  return payload;\n}\n\nexport function generateSEName(pkgName: string, expose: Expose) {\n  const { gateway = Gateway.Tenant, host } = expose;\n\n  // Ensure the resource name is valid\n  const sanitizedHost = host === \".\" ? \"root-domain\" : host;\n  const name = sanitizeResourceName(`${pkgName}-${gateway}-${sanitizedHost}`);\n\n  return name;\n}\n\n/**\n * Creates a ServiceEntry for allowed external hosts in the package\n *\n * @param host\n * @param hostResource\n * @param pkgName\n * @param namespace\n * @param generation\n * @param ownerRefs\n */\nexport function generateLocalEgressServiceEntry(\n  host: string,\n  hostResource: HostResource,\n  pkgName: string,\n  namespace: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n  istioMode: Mode,\n) {\n  const { portProtocol } = hostResource;\n\n  const name = generateLocalEgressSEName(pkgName, portProtocol, host);\n\n  // Update the ports array\n  const ports: IstioPort[] = portProtocol.map(pp => ({\n    name: `${pp.protocol.toLowerCase()}-${pp.port.toString()}`,\n    number: pp.port,\n    protocol: pp.protocol,\n  }));\n\n  const serviceEntry: IstioServiceEntry = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      // Use the CR as the owner ref for each ServiceEntry\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      hosts: [host],\n      location: IstioLocation.MeshExternal,\n      resolution: IstioResolution.DNS,\n      ports,\n      exportTo: [\".\"],\n    },\n  };\n\n  // If ambient, add labels for service entry to use waypoint proxy\n  if (istioMode === Mode.Ambient) {\n    serviceEntry.metadata!.labels![\"istio.io/use-waypoint\"] = egressWaypointName;\n    serviceEntry.metadata!.labels![\"istio.io/use-waypoint-namespace\"] = ambientEgressNamespace;\n  }\n\n  return serviceEntry;\n}\n\nexport function generateSharedServiceEntry(\n  host: string,\n  resource: EgressResource,\n  generation: number,\n) {\n  const name = generateSharedEgressSEName(host);\n\n  // Add annotations from resource\n  const annotations: Record<string, string> = {};\n  for (const pkgId of resource.packages) {\n    annotations[`${getSharedAnnotationKey(pkgId)}`] = \"user\";\n  }\n\n  // Add the gateway servers\n  const ports = resource.portProtocols.map(pp => ({\n    name: `${pp.protocol.toLowerCase()}-${pp.port.toString()}`,\n    number: pp.port,\n    protocol: pp.protocol,\n  }));\n\n  const serviceEntry: IstioServiceEntry = {\n    metadata: {\n      name,\n      namespace: sidecarEgressNamespace,\n      annotations,\n      labels: {\n        \"uds/package\": sidecarSharedEgressPkgId,\n        \"uds/generation\": generation.toString(),\n      },\n    },\n    spec: {\n      hosts: [host],\n      location: IstioLocation.MeshExternal,\n      resolution: IstioResolution.DNS,\n      ports,\n      exportTo: [\".\"],\n    },\n  };\n\n  return serviceEntry;\n}\n\nexport function generateLocalEgressSEName(\n  pkgName: string,\n  portProtocol: PortProtocol[],\n  host: string,\n) {\n  const ppString = portProtocol\n    .map(pp => `${pp.port.toString()}-${pp.protocol.toLowerCase()}`)\n    .join(\"-\");\n  return sanitizeResourceName(`${pkgName}-egress-${host}-${ppString}`);\n}\n\nfunction generateSharedEgressSEName(host: string) {\n  return sanitizeResourceName(`service-entry-${host}`);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\n\nimport { K8s } from \"pepr\";\nimport {\n  Expose,\n  Gateway,\n  IstioHTTP,\n  IstioHTTPRoute,\n  IstioTLS,\n  IstioVirtualService,\n} from \"../../crd\";\nimport { UDSConfig } from \"../config/config\";\nimport { sanitizeResourceName } from \"../utils\";\nimport { sidecarEgressNamespace as namespace, sharedEgressPkgId } from \"./egress-sidecar\";\nimport { generateGatewayName } from \"./gateway\";\nimport { getSharedAnnotationKey, log } from \"./istio-resources\";\nimport { EgressResource } from \"./types\";\n\n/**\n * Creates a VirtualService for each exposed service in the package\n *\n * @param pkg\n * @param namespace\n */\nexport function generateIngressVirtualService(\n  expose: Expose,\n  namespace: string,\n  pkgName: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  const { gateway = Gateway.Tenant, host, port, service, advancedHTTP = {} } = expose;\n\n  const name = generateVSName(pkgName, expose);\n\n  // Get the correct domain based on gateway or custom domain\n  let domain = UDSConfig.domain;\n  if (expose.domain) {\n    domain = expose.domain;\n  } else if (gateway === Gateway.Admin || gateway.includes(\"admin\")) {\n    domain = UDSConfig.adminDomain;\n  }\n\n  // Add the host to the domain, unless this is the reserved root domain host (`.`)\n  let fqdn = \"\";\n  if (host === \".\") {\n    fqdn = domain;\n  } else {\n    fqdn = `${host}.${domain}`;\n  }\n\n  const http: IstioHTTP = { ...advancedHTTP };\n\n  // Create the route to the service\n  const route: IstioHTTPRoute[] = [\n    {\n      destination: {\n        // Use the service name as the host\n        host: `${service}.${namespace}.svc.cluster.local`,\n        // The CRD only uses numeric ports\n        port: { number: port },\n      },\n    },\n  ];\n\n  if (!advancedHTTP.directResponse && !advancedHTTP.redirect) {\n    // Create the route to the service if not using advancedHTTP.directResponse\n    http.route = route;\n  }\n\n  const payload: IstioVirtualService = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      // Use the CR as the owner ref for each VirtualService\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      // Append the UDS Domain to the host\n      hosts: [fqdn],\n      // Map the gateway (admin, passthrough or tenant) to the VirtualService\n      gateways: [`istio-${gateway}-gateway/${gateway}-gateway`],\n      // Apply the route to the VirtualService\n      http: [http],\n    },\n  };\n\n  // If the gateway is the passthrough gateway or includes passthrough in the name, apply the TLS match\n  if (gateway === Gateway.Passthrough || gateway.includes(\"passthrough\")) {\n    payload.spec!.tls = [\n      {\n        match: [{ port: 443, sniHosts: [fqdn] }],\n        route,\n      },\n    ];\n  }\n  return payload;\n}\n\nexport function generateVSName(pkgName: string, expose: Expose) {\n  const { gateway = Gateway.Tenant, host, port, service, description, advancedHTTP } = expose;\n\n  // Ensure the resource name is valid\n  const matchHash = advancedHTTP?.match?.flatMap(m => m.name).join(\"-\") || \"\";\n  const sanitizedHost = host === \".\" ? \"root-domain\" : host;\n  const nameSuffix = description || `${sanitizedHost}-${port}-${service}-${matchHash}`;\n  const name = sanitizeResourceName(`${pkgName}-${gateway}-${nameSuffix}`);\n\n  return name;\n}\n\n/**\n * Create the egress Virtual Service resource\n *\n * @param host\n * @param resource\n * @param generation\n */\nexport function generateEgressVirtualService(\n  host: string,\n  resource: EgressResource,\n  generation: number,\n) {\n  const name = generateEgressVSName(host);\n\n  // Add annotations from resource\n  const annotations: Record<string, string> = {};\n  for (const pkgId of resource.packages) {\n    annotations[`${getSharedAnnotationKey(pkgId)}`] = \"user\";\n  }\n\n  // Add the gateway servers\n  const httpRoutes: IstioHTTP[] = [];\n  const tlsRoutes: IstioTLS[] = [];\n  for (const portProtocol of resource.portProtocols) {\n    const port = portProtocol.port;\n    const protocol = portProtocol.protocol;\n    const route = generateVirtualServiceRoutes(host, port, protocol);\n    if (protocol == \"TLS\") {\n      tlsRoutes.push(...(route as IstioTLS[]));\n    } else if (protocol == \"HTTP\") {\n      httpRoutes.push(...(route as IstioHTTP[]));\n    }\n  }\n\n  // Define the gateway\n  const vs: IstioVirtualService = {\n    metadata: {\n      name,\n      namespace,\n      annotations,\n      labels: {\n        \"uds/generation\": generation.toString(),\n        \"uds/package\": sharedEgressPkgId,\n      },\n    },\n    spec: {\n      hosts: [host],\n      gateways: [\"mesh\", `${generateGatewayName(host)}`],\n      ...(tlsRoutes.length > 0 && { tls: tlsRoutes }),\n      ...(httpRoutes.length > 0 && { http: httpRoutes }),\n    },\n  };\n\n  return vs;\n}\n\n// Generates the HTTP/TLS routes for the virtual service\nfunction generateVirtualServiceRoutes(host: string, port: number, protocol: string) {\n  const meshMatch = {\n    gateways: [\"mesh\"],\n    port,\n    ...(protocol == \"TLS\" && { sniHosts: [host] }),\n  };\n\n  const gatewayMatch = {\n    gateways: [`${generateGatewayName(host)}`],\n    port,\n    ...(protocol == \"TLS\" && { sniHosts: [host] }),\n  };\n\n  return [\n    {\n      match: [meshMatch],\n      route: [\n        {\n          destination: {\n            host: `egressgateway.${namespace}.svc.cluster.local`,\n            port: { number: port },\n          },\n        },\n      ],\n    },\n    {\n      match: [gatewayMatch],\n      route: [\n        {\n          destination: {\n            host,\n            port: { number: port },\n          },\n        },\n      ],\n    },\n  ];\n}\n\n// Check for other virtual services that might conflict - virtual services that are not added by the operator\n// Note: Users adding their own Istio resources will need to understand the possible conflicts with the spec. This is not an operation\n// blocked by K8s, but will be identified as invalid by Istio. The UDS operator will only manage/deconflict resources it creates or those\n// that follow the naming convention.\nexport async function warnMatchingExistingVirtualServices(host: string) {\n  const virtualServices = await K8s(IstioVirtualService).Get();\n  const name = generateEgressVSName(host);\n\n  // Match any virtual services with matching hosts\n  for (const vs of virtualServices.items) {\n    if (vs.metadata?.name === name && vs.metadata?.namespace === namespace) {\n      // Don't warn if the virtual service is the one we created\n      continue;\n    }\n    if (vs.spec && vs.spec.hosts) {\n      for (const vsHost of vs.spec.hosts) {\n        if (vsHost === host) {\n          const errText = `Found existing Virtual Service ${vs.metadata?.name}/${vs.metadata?.namespace} with matching host. Istio will not behave properly with multiple Virtual Services using the same hosts.`;\n          log.error(errText);\n          throw new Error(errText);\n        }\n      }\n    }\n  }\n}\n\nexport function generateEgressVSName(host: string) {\n  return sanitizeResourceName(`egress-vs-${host}`);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { IstioSidecar, IstioOutboundTrafficPolicyMode } from \"../../crd\";\nimport { sanitizeResourceName } from \"../utils\";\n\n/**\n * Creates a Sidecar to enforce outbound traffic policies\n *\n * @param hostPortsProtocol\n * @param selector\n * @param pkgName\n * @param namespace\n * @param generation\n * @param ownerRefs\n */\nexport function generateEgressSidecar(\n  selector: Record<string, string> | undefined,\n  pkgName: string,\n  namespace: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  const name = generateSidecarName(pkgName, selector);\n\n  const sidecar: IstioSidecar = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      // Use the CR as the owner ref for each Sidecar\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      outboundTrafficPolicy: { mode: IstioOutboundTrafficPolicyMode.RegistryOnly },\n      ...(selector && { workloadSelector: { labels: selector } }),\n    },\n  };\n\n  return sidecar;\n}\nfunction generateSidecarName(pkgName: string, selector: Record<string, string> | undefined) {\n  const selectorString = selector\n    ? Object.entries(selector)\n        .map(([key, value]) => `${key}-${value}`)\n        .join(\"-\")\n    : \"default\";\n  return sanitizeResourceName(`${pkgName}-egress-${selectorString}`);\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\nimport { Allow, RemoteProtocol, UDSPackage } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { validateNamespace } from \"../utils\";\nimport {\n  ambientEgressNamespace,\n  applyAmbientEgressResources,\n  purgeAmbientEgressResources,\n} from \"./egress-ambient\";\nimport {\n  applySidecarEgressResources,\n  purgeSidecarEgressResources,\n  sidecarEgressNamespace,\n} from \"./egress-sidecar\";\nimport { log } from \"./istio-resources\";\nimport { HostPortsProtocol, HostResourceMap, PackageAction, PackageHostMap } from \"./types\";\n\n// Cache for in-memory sidecar-only shared egress resources from package CRs\nexport const inMemoryPackageMap: PackageHostMap = {};\n\n// Lock to prevent concurrent updates to the inMemoryPackageMap\nlet sidecarLock = false;\n// eslint-disable-next-line prefer-const\nlet sidecarLockQueue: (() => void)[] = [];\n\n// Cache for in-memory ambient egress resources from package CRs\nexport const inMemoryAmbientPackageMap: PackageHostMap = {};\nlet ambientLock = false;\n// eslint-disable-next-line prefer-const\nlet ambientLockQueue: (() => void)[] = [];\n\n// Mutexes to prevent concurrent reconciliation operations for each mode\nlet reconciliationMutex: Promise<void> | null = null;\n\n// Track which packages were included in the last reconciliation\nexport let lastReconciliationPackages: Set<string> = new Set();\n\n// Generation counters for shared egress resources (separate for each mode)\nlet sidecarGeneration = 0;\nlet ambientGeneration = 0;\n\n// reconcileSharedEgressResources reconciles the egress resources based on the config\n// Handles mode transitions by updating both sidecar and ambient in-memory maps appropriately\nexport async function reconcileSharedEgressResources(\n  hostResourceMap: HostResourceMap | undefined,\n  pkgId: string,\n  action: PackageAction,\n  istioMode: Mode,\n) {\n  // Update in-memory maps based on the target mode\n  if (istioMode === Mode.Ambient) {\n    // Remove from sidecar map (handles sidecar -> ambient transition)\n    await updateInMemoryPackageMap(hostResourceMap, pkgId, PackageAction.Remove);\n\n    // Update ambient package list\n    await updateInMemoryAmbientPackageMap(hostResourceMap, pkgId, action);\n  } else {\n    // Update sidecar map\n    await updateInMemoryPackageMap(hostResourceMap, pkgId, action);\n\n    // Remove from ambient list (handles ambient -> sidecar transition)\n    await updateInMemoryAmbientPackageMap(hostResourceMap, pkgId, PackageAction.Remove);\n  }\n\n  // Reconcile both modes to ensure proper cleanup and application\n  // This handles mode transitions and prevents resource conflicts\n  return await performEgressReconciliationWithMutex(pkgId);\n}\n\n// Mutex-based reconciliation to prevent overwhelming the operator\nexport async function performEgressReconciliationWithMutex(pkgId: string): Promise<void> {\n  // If there's already a reconciliation in progress, wait for it to complete\n  if (reconciliationMutex) {\n    try {\n      await reconciliationMutex;\n      // Check if this package was included in the last reconciliation\n      if (lastReconciliationPackages.has(pkgId)) {\n        return;\n      }\n    } catch {\n      // If the previous reconciliation failed, we still need to try our own reconciliation\n      // Clear the failed mutex so we can start a new one\n      reconciliationMutex = null;\n    }\n  }\n\n  // Start a new reconciliation\n  reconciliationMutex = performEgressReconciliation();\n\n  try {\n    await reconciliationMutex;\n  } catch (e) {\n    // Log the error and re-throw to maintain error propagation\n    log.error(\"Egress reconciliation failed\", e);\n    throw e;\n  } finally {\n    // Clear the mutex when done\n    reconciliationMutex = null;\n  }\n}\n\n// Perform sidecar egress resources reconciliation\nexport async function performEgressReconciliation() {\n  // Capture which packages were included in this reconciliation\n  updateLastReconciliationPackages();\n\n  // Array to collect any errors that occur during reconciliation\n  const errors: Error[] = [];\n\n  // Reconcile sidecar egress resources if namespace is found\n  try {\n    const egressSidecarNamespace = await validateNamespace(sidecarEgressNamespace, true);\n    if (egressSidecarNamespace) {\n      sidecarGeneration++;\n\n      // Apply any sidecar egress resources\n      await applySidecarEgressResources(inMemoryPackageMap, sidecarGeneration);\n\n      // Purge any orphaned sidecar shared resources\n      await purgeSidecarEgressResources(sidecarGeneration.toString());\n    }\n  } catch (e) {\n    const errText = `Failed to reconcile sidecar egress resources`;\n    log.error(errText, e);\n    errors.push(new Error(errText));\n  }\n\n  // Reconcile ambient egress resources if namespace is found\n  try {\n    const egressAmbientNamespace = await validateNamespace(ambientEgressNamespace, true);\n    if (egressAmbientNamespace) {\n      ambientGeneration++;\n\n      // Apply ambient egress resources (waypoint)\n      const packageSet = new Set(Object.keys(inMemoryAmbientPackageMap));\n      await applyAmbientEgressResources(packageSet, ambientGeneration);\n\n      // Purge any orphaned ambient resources (waypoint)\n      await purgeAmbientEgressResources(ambientGeneration.toString());\n    }\n  } catch (e) {\n    const errText = `Failed to reconcile ambient egress resources`;\n    log.error(errText, e);\n    errors.push(new Error(errText));\n  }\n\n  // If any errors occurred, aggregate them and throw\n  if (errors.length > 0) {\n    const aggregatedMessage = errors.map(err => err.message).join(\"; \");\n    throw new Error(`Egress reconciliation failed: ${aggregatedMessage}`);\n  }\n}\n\n// Update the inMemoryPackageMap with the latest hostResourceMap\nexport async function updateInMemoryPackageMap(\n  hostResourceMap: HostResourceMap | undefined,\n  pkgId: string,\n  action: PackageAction,\n) {\n  // Wait for lock to be available using a promise-based queue\n  if (sidecarLock) {\n    await new Promise<void>(resolve => {\n      sidecarLockQueue.push(resolve);\n    });\n  }\n\n  try {\n    log.debug(\"Locking egress package map for update\");\n    sidecarLock = true;\n\n    if (action == PackageAction.AddOrUpdate) {\n      if (hostResourceMap) {\n        // Validate for protocol conflicts before updating\n        validateProtocolConflicts(inMemoryPackageMap, hostResourceMap, pkgId);\n        // update inMemoryPackageMap\n        inMemoryPackageMap[pkgId] = hostResourceMap;\n      } else {\n        removeMapResources(inMemoryPackageMap, pkgId);\n      }\n    } else if (action == PackageAction.Remove) {\n      removeMapResources(inMemoryPackageMap, pkgId);\n    }\n  } catch (e) {\n    log.error({ action, e }, \"Failed to update in memory egress package map for event\");\n    throw e;\n  } finally {\n    // unlock inMemoryPackageMap and notify next waiter\n    log.debug(\"Unlocking egress package map for update\");\n    sidecarLock = false;\n    const nextResolve = sidecarLockQueue.shift();\n    if (nextResolve) {\n      nextResolve();\n    }\n  }\n}\n\n// Update the inMemoryAmbientPackages list with the latest package\nexport async function updateInMemoryAmbientPackageMap(\n  hostResourceMap: HostResourceMap | undefined,\n  pkgId: string,\n  action: PackageAction,\n) {\n  // Wait for lock to be available using a promise-based queue\n  if (ambientLock) {\n    await new Promise<void>(resolve => {\n      ambientLockQueue.push(resolve);\n    });\n  }\n\n  try {\n    log.debug(\"Locking ambient package map for update\");\n    ambientLock = true;\n\n    if (action == PackageAction.AddOrUpdate) {\n      if (hostResourceMap) {\n        // Validate for port conflicts before updating\n        const newPackageMap = validatePortProtocolConflicts(\n          inMemoryAmbientPackageMap,\n          hostResourceMap,\n          pkgId,\n        );\n\n        // Set newly calculated package map if no port conflicts\n        inMemoryAmbientPackageMap[pkgId] = newPackageMap;\n      } else {\n        removeMapResources(inMemoryAmbientPackageMap, pkgId);\n      }\n    } else if (action == PackageAction.Remove) {\n      removeMapResources(inMemoryAmbientPackageMap, pkgId);\n    }\n  } catch (e) {\n    log.error({ action, e }, \"Failed to update in memory ambient package map for event\");\n    throw e;\n  } finally {\n    // unlock inMemoryAmbientPackages and notify next waiter\n    log.debug(\"Unlocking ambient package map for update\");\n    ambientLock = false;\n    const nextResolve = ambientLockQueue.shift();\n    if (nextResolve) {\n      nextResolve();\n    }\n  }\n}\n\n// Update lastReconciliationPackages\nexport function updateLastReconciliationPackages() {\n  lastReconciliationPackages = new Set([\n    ...Object.keys(inMemoryPackageMap),\n    ...Object.keys(inMemoryAmbientPackageMap),\n  ]);\n  return lastReconciliationPackages;\n}\n\n// Validate that there are no protocol conflicts for the same host/port combination\nexport function validateProtocolConflicts(\n  currentPackageMap: PackageHostMap,\n  newHostResourceMap: HostResourceMap,\n  newPkgId: string,\n): void {\n  // Create a map of host:port -> protocol for existing packages (excluding the package being updated)\n  const existingHostPortProtocols: Record<string, { protocol: RemoteProtocol; packageId: string }> =\n    {};\n\n  for (const [pkgId, hostResourceMap] of Object.entries(currentPackageMap)) {\n    // Skip the package being updated since it will be replaced\n    if (pkgId === newPkgId) {\n      continue;\n    }\n\n    for (const [host, hostResource] of Object.entries(hostResourceMap)) {\n      for (const portProtocol of hostResource.portProtocol) {\n        const key = `${host}:${portProtocol.port}`;\n        existingHostPortProtocols[key] = {\n          protocol: portProtocol.protocol,\n          packageId: pkgId,\n        };\n      }\n    }\n  }\n\n  // Check the new host resource map for conflicts\n  for (const [host, hostResource] of Object.entries(newHostResourceMap)) {\n    for (const portProtocol of hostResource.portProtocol) {\n      const key = `${host}:${portProtocol.port}`;\n      const existing = existingHostPortProtocols[key];\n\n      if (existing && existing.protocol !== portProtocol.protocol) {\n        const errorMsg =\n          `Protocol conflict detected for ${host}:${portProtocol.port}. ` +\n          `Package \"${newPkgId}\" wants to use ${portProtocol.protocol} but package \"${existing.packageId}\" ` +\n          `is already using ${existing.protocol} for the same host and port combination.`;\n        log.error(errorMsg);\n        throw new Error(errorMsg);\n      }\n    }\n  }\n}\n\n// Validate that there are no port/protocol conflicts across packages for the same host\nexport function validatePortProtocolConflicts(\n  currentPackageMap: PackageHostMap,\n  newHostResourceMap: HostResourceMap,\n  newPkgId: string,\n): HostResourceMap {\n  // Default to returning the new host resource map\n  const calculatedPackageMap = newHostResourceMap;\n\n  for (const [pkgId, hostResourceMap] of Object.entries(currentPackageMap)) {\n    // Skip the package being updated since it will be replaced\n    if (pkgId === newPkgId) {\n      continue;\n    }\n\n    for (const [host, hostResource] of Object.entries(hostResourceMap)) {\n      const portProtocolList = hostResource.portProtocol.map(pp => `${pp.port}-${pp.protocol}`);\n      for (const [newHost, newHostResource] of Object.entries(newHostResourceMap)) {\n        if (host === newHost) {\n          // If the host is defined in both maps, validate port/protocols don't conflict\n          const newPortProtocolList = newHostResource.portProtocol.map(\n            pp => `${pp.port}-${pp.protocol}`,\n          );\n\n          // Ensure all newPortProtocolList items are in portProtocolList\n          if (!newPortProtocolList.every(pp => portProtocolList.includes(pp))) {\n            const errorMsg =\n              `Port/Protocol conflict detected for ${host}. ` +\n              `Package \"${pkgId}\" is using different port/protocol combination for the same host.`;\n            log.error(errorMsg);\n            throw new Error(errorMsg);\n          }\n\n          // Copy portProtocols from hostResource -> newHostResource to ensure it's the superset\n          calculatedPackageMap[newHost].portProtocol = hostResource.portProtocol;\n        }\n      }\n    }\n  }\n\n  return calculatedPackageMap;\n}\n\n// Create a host resource map from a UDSPackage\nexport function createHostResourceMap(pkg: UDSPackage) {\n  const hostResourceMap: HostResourceMap = {};\n\n  for (const allow of pkg.spec?.network?.allow ?? []) {\n    const hostPortsProtocol = getHostPortsProtocol(allow);\n\n    if (hostPortsProtocol) {\n      // Check if the host already exists in the map\n      if (!hostResourceMap[hostPortsProtocol.host]) {\n        hostResourceMap[hostPortsProtocol.host] = {\n          portProtocol: [],\n        };\n      }\n\n      // Iterate over the ports array to add port/protocol pairs\n      for (const port of hostPortsProtocol.ports) {\n        // Check if the port/protocol already exists\n        const existingPortProtocol = hostResourceMap[hostPortsProtocol.host].portProtocol.find(\n          pp => pp.port === port && pp.protocol === hostPortsProtocol.protocol,\n        );\n\n        // If it doesn't exist, add it to the list\n        if (!existingPortProtocol) {\n          hostResourceMap[hostPortsProtocol.host].portProtocol.push({\n            port: port,\n            protocol: hostPortsProtocol.protocol,\n          });\n        }\n      }\n    }\n  }\n\n  if (Object.keys(hostResourceMap).length > 0) {\n    return hostResourceMap;\n  }\n  return undefined;\n}\n\n// Get the host, ports, and protocol from an Allow\nexport function getHostPortsProtocol(allow: Allow) {\n  let hostPortsProtocol: HostPortsProtocol | undefined = undefined;\n\n  const host = allow.remoteHost;\n  const protocol = allow.remoteProtocol ?? RemoteProtocol.TLS;\n\n  // reconcile ports\n  let ports = [];\n  if (allow.ports) {\n    ports = allow.ports;\n  } else if (allow.port) {\n    ports = [allow.port];\n  } else {\n    ports = [443];\n  }\n\n  if (host) {\n    hostPortsProtocol = {\n      host,\n      ports,\n      protocol,\n    };\n  }\n  return hostPortsProtocol;\n}\n\n// Remove resources from a given package map\nexport function removeMapResources(packageMap: PackageHostMap, pkgId: string) {\n  if (packageMap[pkgId]) {\n    delete packageMap[pkgId];\n  } else {\n    log.debug({ pkgId }, \"No resources found for package\");\n  }\n}\n\n// Check if egress is requested from the network from the Allow list\nexport function egressRequestedFromNetwork(allowList: Allow[]) {\n  return allowList.filter(allow => {\n    return allow.remoteHost;\n  });\n}\n", "/**\n * Waypoint utility module for standardized waypoint operations\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { UDSPackage } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\n\n// Constants for waypoint configuration\nconst WAYPOINT_SUFFIX = \"-waypoint\"; // Suffix for waypoint resource names\n\n/**\n * Determines if a package should use ambient waypoint networking\n */\nexport const shouldUseAmbientWaypoint = (pkg: UDSPackage): boolean => {\n  return pkg.spec?.network?.serviceMesh?.mode === Mode.Ambient && hasAuthserviceSSO(pkg);\n};\n\n/**\n * Checks if a package has authservice SSO configuration\n */\nexport const hasAuthserviceSSO = (pkg: UDSPackage): boolean =>\n  pkg.spec?.sso?.some(s => s.enableAuthserviceSelector !== undefined) || false;\n\n/**\n * Generates a consistent waypoint name from an ID\n */\nexport const getWaypointName = (id: string): string => {\n  // Validate input\n  if (!id || id.trim() === \"\") {\n    throw new Error(\"Waypoint ID cannot be empty\");\n  }\n\n  // Generate standardized name\n  let waypointName = id;\n\n  // Don't add the suffix if it already exists\n  if (!waypointName.endsWith(WAYPOINT_SUFFIX)) {\n    waypointName = `${waypointName}${WAYPOINT_SUFFIX}`;\n  }\n\n  return waypointName;\n};\n\n/**\n * Gets the appropriate pod selector based on whether ambient waypoint is enabled\n */\nexport function getPodSelector(\n  pkg: UDSPackage,\n  selector: Record<string, string>,\n  waypointName: string,\n): Record<string, string> {\n  if (shouldUseAmbientWaypoint(pkg)) {\n    return { \"istio.io/gateway-name\": waypointName };\n  }\n  return selector;\n}\n\n/**\n * Checks if a service's spec.selector matches the given selector\n */\nexport function serviceMatchesSelector(\n  svc: { spec?: { selector?: Record<string, string> } },\n  selector: Record<string, string>,\n): boolean {\n  const svcSelector = svc.spec?.selector || {};\n  return Object.entries(selector).every(([k, v]) => svcSelector[k] === v);\n}\n\n/**\n * Checks if pod labels match a selector\n */\nexport function matchesLabels(\n  labels: Record<string, string>,\n  selector: Record<string, string>,\n): boolean {\n  return Object.entries(selector).every(([k, v]) => labels[k] === v);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s } from \"pepr\";\n\nimport {\n  IstioAction,\n  IstioAuthorizationPolicy,\n  IstioRequestAuthentication,\n  Monitor,\n  UDSPackage,\n} from \"../../../crd\";\nimport { UDSConfig } from \"../../config/config\";\nimport { matchesLabels } from \"../../istio/waypoint-utils\";\nimport { PROMETHEUS_PRINCIPAL, getOwnerRef, purgeOrphans, sanitizeResourceName } from \"../../utils\";\nimport { log } from \"./authservice\";\nimport { AddOrRemoveClientEvent, Action as AuthServiceAction } from \"./types\";\n\nconst operationMap: {\n  [AuthServiceAction.AddClient]: \"Apply\";\n  [AuthServiceAction.RemoveClient]: \"Delete\";\n} = {\n  [AuthServiceAction.AddClient]: \"Apply\",\n  [AuthServiceAction.RemoveClient]: \"Delete\",\n};\n\n/**\n * Sets the target for an Istio policy spec based on ambient mode.\n * If ambient mode is enabled and a waypoint name is provided, sets targetRef to the Gateway.\n * Otherwise, sets a pod selector for non-ambient mode. Ensures only one targeting field is present.\n */\nfunction setPolicyTarget(\n  spec: NonNullable<IstioAuthorizationPolicy[\"spec\"]>,\n  isAmbient: boolean,\n  waypointName: string | undefined,\n  labelSelector: { [key: string]: string },\n) {\n  if (isAmbient && waypointName) {\n    spec.targetRef = {\n      group: \"gateway.networking.k8s.io\",\n      kind: \"Gateway\",\n      name: waypointName,\n    };\n    delete spec.selector;\n  } else {\n    spec.selector = { matchLabels: labelSelector };\n    delete spec.targetRef;\n  }\n}\n\ninterface MonitorExemption {\n  port?: string;\n  path?: string;\n}\n\n// Build 'to.operation' entries that represent NON-metrics traffic for the\n// given monitor exemptions (i.e., all ports/paths except the metrics\n// endpoints captured in the exemptions).\nfunction buildNonMetricsOperations(\n  monitorExemptions: MonitorExemption[],\n): Array<{ operation: { ports?: string[]; notPorts?: string[]; notPaths?: string[] } }> {\n  const entries: Array<{\n    operation: { ports?: string[]; notPorts?: string[]; notPaths?: string[] };\n  }> = [];\n\n  // Group monitor exemptions by port -> set of paths\n  const portToPaths = new Map<string, Set<string>>();\n  for (const ex of monitorExemptions) {\n    if (!ex.port) continue;\n    const paths = portToPaths.get(ex.port) ?? new Set<string>();\n    if (ex.path) paths.add(ex.path);\n    portToPaths.set(ex.port, paths);\n  }\n\n  // Per-port entries: ports:[P], notPaths:[...paths] to exempt only listed paths on that port\n  for (const [port, paths] of portToPaths.entries()) {\n    const arrPaths = Array.from(paths);\n    if (arrPaths.length > 0) {\n      entries.push({ operation: { ports: [port], notPaths: arrPaths } });\n    } else {\n      // If no paths recorded, default to exempting '/metrics'\n      entries.push({ operation: { ports: [port], notPaths: [\"/metrics\"] } });\n    }\n  }\n\n  // Catch-all for all other ports: notPorts:[all exempt ports]\n  const monitorPorts = Array.from(portToPaths.keys());\n  if (monitorPorts.length > 0) {\n    entries.push({ operation: { notPorts: monitorPorts } });\n  }\n\n  return entries;\n}\n\n// Build 'to.operation' entries that represent the METRICS traffic for the\n// given monitor exemptions (the exact port + path combinations to treat as\n// metrics endpoints).\nfunction buildMetricsOperations(\n  monitorExemptions: MonitorExemption[],\n): Array<{ operation: { ports?: string[]; paths?: string[] } }> {\n  const entries: Array<{ operation: { ports?: string[]; paths?: string[] } }> = [];\n\n  const portToPaths = new Map<string, Set<string>>();\n  for (const ex of monitorExemptions) {\n    if (!ex.port) continue;\n    const paths = portToPaths.get(ex.port) ?? new Set<string>();\n    if (ex.path) paths.add(ex.path);\n    portToPaths.set(ex.port, paths);\n  }\n\n  for (const [port, paths] of portToPaths.entries()) {\n    const arrPaths = Array.from(paths);\n    if (arrPaths.length > 0) {\n      entries.push({ operation: { ports: [port], paths: arrPaths } });\n    } else {\n      // If no paths recorded, default to treating '/metrics' as the metrics endpoint\n      entries.push({ operation: { ports: [port], paths: [\"/metrics\"] } });\n    }\n  }\n\n  return entries;\n}\n\nfunction authserviceAuthorizationPolicy(\n  labelSelector: { [key: string]: string },\n  name: string,\n  namespace: string,\n  isAmbient = false,\n  waypointName?: string,\n  monitorExemptions: MonitorExemption[] = [],\n): IstioAuthorizationPolicy {\n  const nonMetricsOps = buildNonMetricsOperations(monitorExemptions);\n  const unauthenticatedWhen = [\n    {\n      key: \"request.headers[authorization]\",\n      notValues: [\"*\"],\n    },\n  ];\n  const rules: NonNullable<IstioAuthorizationPolicy[\"spec\"]>[\"rules\"] = [];\n  const hasMonitorExemptions = nonMetricsOps.length > 0;\n\n  if (!hasMonitorExemptions) {\n    // No monitor-based exemptions: send all unauthenticated traffic to Authservice.\n    rules.push({\n      when: unauthenticatedWhen,\n    });\n  } else {\n    // With monitor exemptions present, treat all metrics endpoints as outside of Authservice\n    // and send only non-metrics unauthenticated traffic through Authservice.\n    rules.push({\n      to: nonMetricsOps,\n      when: unauthenticatedWhen,\n    });\n  }\n\n  const policy: IstioAuthorizationPolicy & { spec: NonNullable<IstioAuthorizationPolicy[\"spec\"]> } =\n    {\n      kind: \"AuthorizationPolicy\",\n      metadata: {\n        name: sanitizeResourceName(`${name}-authservice`),\n        namespace,\n      },\n      spec: {\n        action: IstioAction.Custom,\n        provider: {\n          name: \"authservice\",\n        },\n        rules,\n      },\n    };\n\n  setPolicyTarget(policy.spec, isAmbient, waypointName, labelSelector);\n  return policy;\n}\n\nfunction jwtAuthZAuthorizationPolicy(\n  labelSelector: { [key: string]: string },\n  name: string,\n  namespace: string,\n  isAmbient = false,\n  waypointName?: string,\n  monitorExemptions: MonitorExemption[] = [],\n): IstioAuthorizationPolicy {\n  // Create a base policy with the common properties\n  const metricsOps = buildMetricsOperations(monitorExemptions);\n  const nonMetricsOps = buildNonMetricsOperations(monitorExemptions);\n\n  const rules: NonNullable<IstioAuthorizationPolicy[\"spec\"]>[\"rules\"] = [];\n\n  const ssoJwtSource = {\n    notRequestPrincipals: [`https://sso.${UDSConfig.domain}/realms/uds/*`],\n  };\n\n  const prometheusOrSsoJwtSource = {\n    ...ssoJwtSource,\n    notPrincipals: [PROMETHEUS_PRINCIPAL],\n  };\n\n  const hasMonitorExemptions = metricsOps.length > 0;\n\n  if (!hasMonitorExemptions) {\n    // No monitor-based exemptions: deny any request that does not present a UDS JWT principal.\n    rules.push({\n      from: [\n        {\n          source: ssoJwtSource,\n        },\n      ],\n    });\n  } else {\n    // Deny metrics requests for callers that are not Prometheus and do not have a valid UDS JWT principal.\n    rules.push({\n      from: [\n        {\n          source: prometheusOrSsoJwtSource,\n        },\n      ],\n      to: metricsOps,\n    });\n\n    // Deny requests to all other endpoints that do not present a valid UDS JWT principal.\n    rules.push({\n      from: [\n        {\n          source: ssoJwtSource,\n        },\n      ],\n      to: nonMetricsOps,\n    });\n  }\n\n  const policy: IstioAuthorizationPolicy = {\n    kind: \"AuthorizationPolicy\",\n    metadata: {\n      name: sanitizeResourceName(`${name}-jwt-authz`),\n      namespace,\n    },\n    spec: {\n      action: IstioAction.Deny,\n      rules,\n    },\n  };\n\n  setPolicyTarget(policy.spec!, isAmbient, waypointName, labelSelector);\n  return policy;\n}\n\nfunction authNRequestAuthentication(\n  labelSelector: { [key: string]: string },\n  name: string,\n  namespace: string,\n  isAmbient = false,\n  waypointName?: string,\n): IstioRequestAuthentication {\n  // Create base policy with spec explicitly typed\n  const policy: IstioRequestAuthentication & {\n    spec: NonNullable<IstioRequestAuthentication[\"spec\"]>;\n  } = {\n    kind: \"RequestAuthentication\",\n    metadata: {\n      name: sanitizeResourceName(`${name}-jwt-authn`),\n      namespace,\n    },\n    spec: {\n      jwtRules: [\n        {\n          audiences: [name],\n          forwardOriginalToken: true,\n          issuer: `https://sso.${UDSConfig.domain}/realms/uds`,\n          jwksUri: `https://sso.${UDSConfig.domain}/realms/uds/protocol/openid-connect/certs`,\n        },\n      ],\n    },\n  };\n\n  setPolicyTarget(policy.spec!, isAmbient, waypointName, labelSelector);\n  return policy;\n}\n\nasync function updatePolicy(\n  event: AddOrRemoveClientEvent,\n  labelSelector: { [key: string]: string },\n  pkg: UDSPackage,\n  isAmbient?: boolean,\n  waypointName?: string,\n) {\n  // type safe map event to operation (either Apply or Delete)\n  const operation = operationMap[event.action];\n  const namespace = pkg.metadata!.namespace!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerReferences = getOwnerRef(pkg);\n\n  // Compute per-monitor exemptions (port + path) that should bypass authservice/JWT deny\n  const monitorExemptions = computeMonitorExemptions(pkg, labelSelector);\n  if (!isAmbient) {\n    // Add 15020 /stats/prometheus like a monitor exemption for sidecar mode\n    monitorExemptions.push({ port: \"15020\", path: \"/stats/prometheus\" });\n  }\n\n  const updateMetadata = (resource: IstioAuthorizationPolicy | IstioRequestAuthentication) => {\n    resource!.metadata!.ownerReferences = ownerReferences;\n    resource!.metadata!.labels = {\n      \"uds/package\": pkg.metadata!.name!,\n      \"uds/generation\": generation,\n    };\n    return resource;\n  };\n\n  try {\n    // Apply the authservice authorization policy\n    await K8s(IstioAuthorizationPolicy)[operation](\n      updateMetadata(\n        authserviceAuthorizationPolicy(\n          labelSelector,\n          event.name,\n          namespace,\n          isAmbient,\n          waypointName,\n          monitorExemptions,\n        ),\n      ),\n      { force: true },\n    );\n\n    // Apply the JWT authentication policy\n    await K8s(IstioRequestAuthentication)[operation](\n      updateMetadata(\n        authNRequestAuthentication(labelSelector, event.name, namespace, isAmbient, waypointName),\n      ),\n      { force: true },\n    );\n\n    // Apply the JWT authorization policy\n    await K8s(IstioAuthorizationPolicy)[operation](\n      updateMetadata(\n        jwtAuthZAuthorizationPolicy(\n          labelSelector,\n          event.name,\n          namespace,\n          isAmbient,\n          waypointName,\n          monitorExemptions,\n        ),\n      ),\n      { force: true },\n    );\n  } catch (e) {\n    const msg = `Failed to update auth policy for ${event.name} in ${namespace}: ${e}`;\n    log.error(e, msg);\n    throw new Error(msg, {\n      cause: e,\n    });\n  }\n\n  try {\n    await purgeOrphanPolicies(generation, namespace, pkg.metadata!.name!);\n  } catch (e) {\n    log.error(e, `Failed to purge orphan auth policies ${event.name} in ${namespace}: ${e}`);\n  }\n}\n\nasync function purgeOrphanPolicies(generation: string, namespace: string, pkgName: string) {\n  for (const kind of [IstioAuthorizationPolicy, IstioRequestAuthentication]) {\n    await purgeOrphans(generation, namespace, pkgName, kind, log);\n  }\n}\n\nexport {\n  UDSConfig,\n  authNRequestAuthentication,\n  authserviceAuthorizationPolicy,\n  computeMonitorExemptions,\n  jwtAuthZAuthorizationPolicy,\n  updatePolicy,\n};\n\n/**\n * Compute monitor-based exemptions for authservice policies by selecting monitors\n * whose selectors intersect with the protected labelSelector. If the labelSelector\n * is empty (namespace-wide protection), all monitors in the package are exempted.\n */\nfunction computeMonitorExemptions(\n  pkg: UDSPackage,\n  labelSelector: Record<string, string>,\n): MonitorExemption[] {\n  const monitors: Monitor[] = pkg.spec?.monitor ?? [];\n  const out: MonitorExemption[] = [];\n\n  for (const m of monitors) {\n    const sel: Record<string, string> = m.podSelector ?? m.selector;\n    // If labelSelector is empty, treat as namespace-wide (matches all);\n    // otherwise require ALL labels in labelSelector to match the monitor selector\n    const labelSelectorIsEmpty = Object.keys(labelSelector).length === 0;\n    if (labelSelectorIsEmpty || matchesLabels(sel, labelSelector)) {\n      out.push({ port: String(m.targetPort), path: m.path || \"/metrics\" });\n    }\n  }\n\n  return out;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { createHash } from \"crypto\";\nimport { K8s, kind } from \"pepr\";\n\nimport { UDSConfig } from \"../../config/config\";\nimport { Client } from \"../types\";\nimport { buildChain, log } from \"./authservice\";\nimport { Action, AuthserviceConfig } from \"./types\";\n\nlet pendingSecretFetch: Promise<AuthserviceConfig> | null = null;\n\n// Cache for in-memory secret to avoid unnecessary Kubernetes secret lookups\nlet inMemorySecret: AuthserviceConfig | null = null;\n\n// Track pending package updates and their resolve functions\nconst pendingPackages: Map<\n  AuthserviceConfig,\n  { resolve: () => void; reject: (reason?: Error) => void }\n> = new Map();\n\n// Backup for the last known successful state of the secret\nlet lastSuccessfulSecret: AuthserviceConfig | null = null;\n\n// Timer for debouncing updates to the secret\nlet debounceTimer: NodeJS.Timeout | null = null;\n\n// Debounce duration (1 seconds) to reduce excessive updates, configurable via environment variable\nconst DEBOUNCE_DURATION = parseInt(process.env.DEBOUNCE_DURATION || \"1000\", 10);\n\nexport let operatorConfig: Record<string, string> = {};\n\nexport function initializeOperatorConfig() {\n  operatorConfig = {\n    namespace: \"authservice\",\n    secretName: \"authservice-uds\",\n    baseDomain: `https://sso.${UDSConfig.domain}`,\n    realm: \"uds\",\n  };\n\n  log.info(operatorConfig, `Authservice operator config initialized`);\n}\n/**\n * Sets up the initial authservice secret in the Kubernetes cluster.\n * If in dev mode, it ensures the namespace exists and initializes\n * the secret if it does not already exist.\n */\nexport async function setupAuthserviceSecret() {\n  if (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n    initializeOperatorConfig();\n\n    log.info(\"One-time authservice secret initialization\");\n    // Ensure the namespace exists in the Kubernetes cluster\n    await K8s(kind.Namespace).Apply({\n      metadata: {\n        name: operatorConfig.namespace,\n      },\n    });\n\n    // Create the secret if it doesn't exist\n    try {\n      const secret = await K8s(kind.Secret)\n        .InNamespace(operatorConfig.namespace)\n        .Get(operatorConfig.secretName);\n      log.info(`Authservice Secret exists, skipping creation - ${secret.metadata?.name}`);\n    } catch {\n      log.info(\"Secret does not exist, creating authservice secret\");\n      try {\n        // Build and create the initial secret configuration\n        await updateAuthServiceSecret(buildInitialSecret(), false); // False to skip checksum on initial creation.\n      } catch (err) {\n        log.error(err, \"Failed to create UDS managed authservice secret.\");\n        throw new Error(\"Failed to create UDS managed authservice secret.\", { cause: err });\n      }\n    }\n  }\n}\n\n/**\n * Builds the initial authservice configuration to be stored in the secret.\n * This config acts as a placeholder until the first chain is created.\n *\n * @returns {AuthserviceConfig} - The initial configuration for the authservice.\n */\nexport function buildInitialSecret(): AuthserviceConfig {\n  const config: AuthserviceConfig = {\n    allow_unmatched_requests: false,\n    listen_address: \"0.0.0.0\",\n    listen_port: \"10003\",\n    log_level: \"info\",\n    default_oidc_config: {\n      skip_verify_peer_cert: false,\n      authorization_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/auth`,\n      token_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/token`,\n      jwks_fetcher: {\n        jwks_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/certs`,\n        periodic_fetch_interval_sec: 60,\n      },\n      client_id: \"global_id\",\n      client_secret: \"global_secret\",\n      id_token: {\n        preamble: \"Bearer\",\n        header: \"Authorization\",\n      },\n      trusted_certificate_authority: `${atob(UDSConfig.caBundle.certs)}`,\n      logout: {\n        path: \"/globallogout\",\n        redirect_uri: `https://sso.${UDSConfig.domain}/realms/${operatorConfig.realm}/protocol/openid-connect/token/logout`,\n      },\n      absolute_session_timeout: \"0\",\n      idle_session_timeout: \"0\",\n      scopes: [],\n    },\n    threads: 8,\n    chains: [\n      buildChain({\n        name: \"placeholder\",\n        action: Action.AddClient,\n        client: {\n          clientId: \"placeholder\",\n          secret: \"placeholder\",\n          redirectUris: [\"https://localhost/login\"],\n        } as Client,\n      }),\n    ],\n  };\n\n  // Optionally add Redis session store configuration if provided\n  if (UDSConfig.authserviceRedisUri) {\n    config.default_oidc_config.redis_session_store_config = {\n      server_uri: UDSConfig.authserviceRedisUri!,\n    };\n  }\n\n  return config;\n}\n\n/**\n * Sets the in memory configuration for Authservce.\n *\n * @param config - The configuration object for Authservice.\n */\nexport function setAuthserviceConfig(config: AuthserviceConfig) {\n  inMemorySecret = config;\n}\n\n/**\n * Retrieves the authservice configuration, either from the in-memory cache\n * or from the Kubernetes secret if not already cached.\n *\n * @returns {Promise<AuthserviceConfig>} - The authservice configuration.\n */\nexport async function getAuthserviceConfig(): Promise<AuthserviceConfig> {\n  if (inMemorySecret) {\n    log.info(\"Returning in-memory authservice secret\");\n    return Promise.resolve(inMemorySecret);\n  }\n\n  // Fetch the authservice secret from Kubernetes if not in cache\n  // Null check is to prevent multiple concurrent fetches\n  if (pendingSecretFetch === null) {\n    pendingSecretFetch = K8s(kind.Secret)\n      .InNamespace(operatorConfig.namespace)\n      .Get(operatorConfig.secretName)\n      .then(secret => {\n        const config = JSON.parse(atob(secret.data![\"config.json\"])) as AuthserviceConfig;\n\n        inMemorySecret = config;\n        lastSuccessfulSecret = config;\n        return config;\n      })\n      .finally(() => {\n        pendingSecretFetch = null;\n      });\n  }\n\n  return pendingSecretFetch;\n}\n\n/**\n * Update the authservice secret in memory and debounce the write to the Kubernetes cluster.\n * The in-memory secret is updated immediately, while the actual write to Kubernetes is debounced\n * to prevent excessive writes. Rollback is handled if the update fails.\n *\n * @param {AuthserviceConfig} authserviceConfig - The updated authservice configuration.\n * @param {boolean} [checksum=true] - Whether to add a checksum to the deployment after the update.\n */\nexport async function updateAuthServiceSecret(\n  authserviceConfig: AuthserviceConfig,\n  checksum = true,\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Add the package config and its resolve function to the pending packages map\n    pendingPackages.set(authserviceConfig, { resolve, reject });\n\n    // Clear the previous debounce timer, if it exists\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    // Set a new debounce timer to apply the update after the delay\n    debounceTimer = setTimeout(async () => {\n      try {\n        log.info(\n          `Applying debounced secret update for packages: ${\n            Array.from(pendingPackages.keys()).length\n          } pending packages`,\n        );\n\n        // Prepare the config to be written (assumes that all packages share the same secret)\n        const { base64EncodedConfig, hash } = encodeConfig(authserviceConfig!);\n\n        // Apply the authservice config secret\n        lastSuccessfulSecret = await applySecret(base64EncodedConfig);\n\n        log.info(`Updated authservice secret successfully for all pending packages.`);\n\n        // Apply the checksum if required\n        if (checksum) {\n          log.info(`Adding checksum to deployment for authservice secret`);\n          await checksumDeployment(hash);\n        }\n\n        // Resolve the promises for all pending packages after the secret update\n        pendingPackages.forEach(p => {\n          p.resolve();\n        });\n      } catch (e) {\n        log.error(e, `Failed to write authservice secret`);\n\n        // Rollback to the last known successful state if the update fails\n        inMemorySecret = lastSuccessfulSecret;\n        log.info(\"Reverted to last successful secret state.\");\n\n        // Reject all promises for the pending packages on error\n        pendingPackages.forEach(p => {\n          p.reject(new Error(`Failed to write authservice secret for config`, { cause: e }));\n        });\n      } finally {\n        // Clear pending packages on error\n        pendingPackages.clear();\n\n        // Reset debounce timer\n        debounceTimer = null;\n      }\n    }, DEBOUNCE_DURATION);\n  });\n}\n\n/**\n * Applies a checksum to the Kubernetes authservice deployment to force a rollout.\n *\n * @param {string} checksum - The checksum value to apply to the deployment.\n */\nasync function checksumDeployment(checksum: string) {\n  try {\n    await K8s(kind.Deployment, { name: \"authservice\", namespace: operatorConfig.namespace }).Patch([\n      {\n        op: \"add\",\n        path: \"/spec/template/metadata/annotations/pepr.dev~1checksum\",\n        value: checksum,\n      },\n    ]);\n\n    log.info(`Successfully applied the checksum to authservice`);\n  } catch (e) {\n    log.error(e, `Failed to apply the checksum to authservice`);\n    throw new Error(\"Failed to apply the checksum to authservice\", { cause: e });\n  }\n}\n\n/**\n * Applies a checksum to the Kubernetes authservice deployment to force a rollout.\n *\n * @param {string} base64EncodedConfig - The base64 encoded AuthserviceConfig to apply.\n */\nasync function applySecret(base64EncodedConfig: string) {\n  try {\n    return await K8s(kind.Secret)\n      .Apply(\n        {\n          metadata: {\n            namespace: operatorConfig.namespace,\n            name: operatorConfig.secretName,\n          },\n          data: {\n            \"config.json\": base64EncodedConfig,\n          },\n        },\n        { force: true },\n      )\n      .then(secret => JSON.parse(atob(secret.data![\"config.json\"])) as AuthserviceConfig);\n  } catch (e) {\n    log.error(e, `Failed to apply the authservice config secret`);\n    throw new Error(\"Failed to apply the authservice secret\", { cause: e });\n  }\n}\n\n/**\n * Encodes the authservice configuration and generates a hash for the configuration.\n *\n * @param {AuthserviceConfig} c - The authservice configuration to encode.\n * @returns {{ base64EncodedConfig: string, hash: string }} - The base64 encoded configuration and hash.\n */\nfunction encodeConfig(c: AuthserviceConfig): { base64EncodedConfig: string; hash: string } {\n  const config = btoa(JSON.stringify(c));\n  const hash = createHash(\"sha256\").update(config).digest(\"hex\");\n\n  return { base64EncodedConfig: config, hash };\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { KubernetesListObject, V1NetworkPolicyPeer, V1NodeAddress } from \"@kubernetes/client-node\";\nimport { K8s, kind, R } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../../logger\";\nimport { RemoteGenerated } from \"../../../crd\";\nimport { AuthorizationPolicy } from \"../../../crd/generated/istio/authorizationpolicy-v1beta1\";\nimport { UDSConfig } from \"../../config/config\";\nimport { retryWithDelay } from \"../../utils\";\nimport { anywhere } from \"./anywhere\";\n\nconst log = setupLogger(Component.OPERATOR_GENERATORS);\n\n// Maintain a set of all node internal IPs\nconst nodeSet = new Set<string>();\n\n// Maintain a map of node names to their internal IPs\nconst nodeNameToIPMap = new Map<string, string>();\n\n// Track whether AuthorizationPolicies are available yet (Pepr installs before Istio)\nlet authorizationPolicyExists = false;\n\n/**\n * Initialize the node targets by fetching the current nodes in the cluster\n * and populating the nodeSet with their Internal IPs.\n */\nexport async function initAllNodesTarget() {\n  if (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n    // if a list of CIDRs is defined, use those\n    if (UDSConfig.kubeNodeCIDRs.length > 0) {\n      for (const nodeCidr of UDSConfig.kubeNodeCIDRs) {\n        nodeSet.add(nodeCidr);\n      }\n      await updateKubeNodesNetworkPolicies();\n      await updateKubeNodesAuthorizationPolicies();\n      return;\n    }\n\n    try {\n      const nodes = await retryWithDelay(fetchKubernetesNodes, log);\n      nodeSet.clear();\n\n      for (const node of nodes.items) {\n        const ip = getNodeInternalIP(node);\n        const nodeName = node.metadata!.name!;\n\n        if (ip) {\n          nodeSet.add(ip);\n          nodeNameToIPMap.set(nodeName, ip);\n        }\n      }\n      await updateKubeNodesNetworkPolicies();\n      await updateKubeNodesAuthorizationPolicies();\n    } catch (err) {\n      log.error(\"error fetching node IPs:\", err);\n    }\n  }\n}\n\n/**\n * Returns the egress CIDRs of all known nodes as network policy peers.\n * If none are known, defaults to 0.0.0.0/0 and logs a warning.\n */\nexport function kubeNodes(): V1NetworkPolicyPeer[] {\n  const policies = buildNodePolicies([...nodeSet]);\n  if (policies.length > 0) return policies;\n\n  log.warn(\"Unable to get Node CIDRs, defaulting to 0.0.0.0/0\");\n  return [anywhere];\n}\n\n/**\n * When a node is created or updated, if it's Ready, add its IP to the nodeSet and nodeNameToIPMap,\n * rebuild the policies, and update the NetworkPolicies.\n */\nexport async function updateKubeNodesFromCreateUpdate(node: kind.Node) {\n  const ip = getNodeInternalIP(node);\n  const nodeName = node.metadata!.name!;\n\n  if (ip) {\n    const oldIP = nodeNameToIPMap.get(nodeName);\n\n    nodeSet.add(ip);\n    nodeNameToIPMap.set(nodeName, ip);\n\n    // If the node's IP has changed, remove the old IP from the set\n    if (oldIP && oldIP !== ip) {\n      nodeSet.delete(oldIP);\n    }\n  }\n\n  await updateKubeNodesNetworkPolicies();\n  await updateKubeNodesAuthorizationPolicies();\n}\n\n/**\n * When a node is deleted, remove its IP from the set, rebuild the policies,\n * and update the NetworkPolicies.\n */\nexport async function updateKubeNodesFromDelete(node: kind.Node) {\n  const ip = getNodeInternalIP(node);\n  const nodeName = node.metadata!.name!;\n  if (ip) {\n    nodeSet.delete(ip);\n    nodeNameToIPMap.delete(nodeName);\n  }\n\n  await updateKubeNodesNetworkPolicies();\n  await updateKubeNodesAuthorizationPolicies();\n}\n\n/**\n * Fetch all Kubernetes nodes.\n */\nasync function fetchKubernetesNodes(): Promise<KubernetesListObject<kind.Node>> {\n  return K8s(kind.Node).Get();\n}\n\n/**\n * Update all NetworkPolicies labeled with uds/generated=KubeNodes to\n * reflect the given node CIDRs.\n */\nexport async function updateKubeNodesNetworkPolicies() {\n  const newNodes = buildNodePolicies([...nodeSet]);\n  const netPols = await K8s(kind.NetworkPolicy)\n    .WithLabel(\"uds/generated\", RemoteGenerated.KubeNodes)\n    .Get();\n\n  for (const netPol of netPols.items) {\n    if (!netPol.spec) {\n      log.warn(\n        `KubeNodes NetworkPolicy ${netPol.metadata?.namespace}/${netPol.metadata?.name} is missing spec.`,\n      );\n      continue;\n    }\n\n    let updateRequired = false;\n    if (netPol.spec.egress) {\n      netPol.spec.egress[0] = netPol.spec.egress[0] || { to: [] };\n      const oldNodes = netPol.spec.egress[0].to;\n      if (!R.equals(oldNodes, newNodes)) {\n        updateRequired = true;\n        netPol.spec.egress[0].to = newNodes;\n      }\n    } else if (netPol.spec.ingress) {\n      netPol.spec.ingress[0] = netPol.spec.ingress[0] || { from: [] };\n      const oldNodes = netPol.spec.ingress[0].from;\n      if (!R.equals(oldNodes, newNodes)) {\n        updateRequired = true;\n        netPol.spec.ingress[0].from = newNodes;\n      }\n    }\n\n    // If the policy required a change, apply the new policy\n    if (updateRequired) {\n      if (netPol.metadata) {\n        // Remove managed fields to prevent server-side apply errors\n        netPol.metadata.managedFields = undefined;\n      }\n\n      log.debug(\n        `Updating KubeNodes NetworkPolicy ${netPol.metadata?.namespace}/${netPol.metadata?.name} with new CIDRs.`,\n      );\n\n      try {\n        await K8s(kind.NetworkPolicy).Apply(netPol, { force: true });\n      } catch (err) {\n        let message = err.data?.message || \"Unknown error while applying KubeNode network policies\";\n        if (UDSConfig.kubeNodeCIDRs.length > 0) {\n          message +=\n            \", ensure that the KUBENODE_CIDRS override configured for the operator is correct.\";\n        }\n        throw new Error(message);\n      }\n    }\n  }\n}\n\n/**\n * Updates the AuthorizationPolicies for KubeNodes.\n *\n * This function rebuilds the current set of node peers from the in-memory node set,\n * extracts their CIDR strings, and then queries for all AuthorizationPolicies that are labeled\n * with \"uds/generated\" equal to RemoteGenerated.KubeNodes. For each matching policy, it checks\n * whether the current IP blocks in the policy's \"from\" source match the newly computed IP blocks.\n * If they differ, the policy is updated (with managedFields cleared to avoid server-side apply issues)\n * and then re-applied.\n *\n * @returns {Promise<void>} A promise that resolves once the update process is complete.\n */\nexport async function updateKubeNodesAuthorizationPolicies(): Promise<void> {\n  // Build the current set of node peers from nodeSet.\n  const newPeers = buildNodePolicies([...nodeSet]);\n  // Extract CIDR strings from the new peers.\n  const newIpBlocks = newPeers\n    .map(peer => peer.ipBlock?.cidr)\n    .filter((cidr): cidr is string => typeof cidr === \"string\");\n\n  // Check if AuthorizationPolicy is available in the cluster\n  if (!authorizationPolicyExists) {\n    try {\n      await K8s(kind.CustomResourceDefinition).Get(\"authorizationpolicies.security.istio.io\");\n      authorizationPolicyExists = true;\n    } catch {\n      log.warn(\n        \"AuthorizationPolicy CRD is not present in the cluster, skipping KubeNodes AuthorizationPolicy updates\",\n      );\n      return;\n    }\n  }\n\n  const authPols = await K8s(AuthorizationPolicy)\n    .WithLabel(\"uds/generated\", RemoteGenerated.KubeNodes)\n    .Get();\n\n  if (authPols.items.length > 0) {\n    const summary = authPols.items\n      .map(pol => `name: ${pol.metadata?.name}, namespace: ${pol.metadata?.namespace}`)\n      .join(\" | \");\n    log.trace(`Fetched ${authPols.items.length} AuthorizationPolicies: ${summary}`);\n  }\n\n  for (const pol of authPols.items) {\n    // Ensure the policy has rules.\n    if (!pol.spec || !pol.spec.rules || pol.spec.rules.length === 0) {\n      log.warn(\n        `AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name} is missing rules.`,\n      );\n      continue;\n    }\n\n    let updateRequired = false;\n    const rule = pol.spec.rules[0];\n\n    // Check if a \"from\" entry exists with ipBlocks.\n    if (rule.from && rule.from.length > 0 && rule.from[0].source?.ipBlocks) {\n      const oldIpBlocks = rule.from[0].source.ipBlocks;\n      if (!R.equals(oldIpBlocks, newIpBlocks)) {\n        rule.from[0].source.ipBlocks = newIpBlocks;\n        updateRequired = true;\n      }\n    } else {\n      // Otherwise, create a \"from\" entry.\n      rule.from = [{ source: { ipBlocks: newIpBlocks } }];\n      updateRequired = true;\n    }\n\n    if (updateRequired) {\n      // Clear managedFields to avoid server-side apply issues.\n      if (pol.metadata) {\n        pol.metadata.managedFields = undefined;\n      }\n      try {\n        await K8s(AuthorizationPolicy).Apply(pol, { force: true });\n        log.debug(\n          `Updated KubeNodes AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name}`,\n        );\n      } catch (err) {\n        log.error(\n          err,\n          `Failed to update AuthorizationPolicy ${pol.metadata?.namespace}/${pol.metadata?.name}`,\n        );\n      }\n    }\n  }\n}\n\n/**\n * Build V1NetworkPolicyPeer array from a list of node IPs.\n */\nfunction buildNodePolicies(nodeIPs: string[]): V1NetworkPolicyPeer[] {\n  return nodeIPs.map(ip => ({\n    ipBlock: {\n      cidr: format32cidr(ip),\n    },\n  }));\n}\n\n/**\n * Utility function conditionally format an IP as a 32-bit CIDR.\n */\nfunction format32cidr(ip: string): string {\n  // Check if the input already appears to have CIDR notation\n  if (ip.includes(\"/\")) {\n    return ip;\n  }\n  // If not, append \"/32\"\n  return `${ip}/32`;\n}\n\n/**\n * Utility function to get the InternalIP of a node.\n */\nfunction getNodeInternalIP(node: kind.Node): string | undefined {\n  return node.status?.addresses?.find((addr: V1NodeAddress) => addr.type === \"InternalIP\")?.address;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\n\nexport const META_IP = \"169.254.169.254/32\";\n\n/**\n * The cloud metadata endpoint is a common cloud address that can be used to\n * access cloud provider metadata.\n *\n * AWS: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\n *\n * GCP: https://cloud.google.com/compute/docs/storing-retrieving-metadata\n *\n * Azure: https://docs.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service\n *\n * DigitalOcean: https://www.digitalocean.com/docs/droplets/resources/metadata/\n *\n * @returns A NetworkPolicyPeer that matches the cloud metadata service\n */\nexport const cloudMetadata: V1NetworkPolicyPeer[] = [\n  {\n    ipBlock: { cidr: META_IP },\n  },\n];\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\nimport { META_IP } from \"./cloudMetadata\";\n\n/** Matches any endpoint EXCEPT the Cloud Meta endpoint */\nexport const anywhere: V1NetworkPolicyPeer = {\n  ipBlock: {\n    cidr: \"0.0.0.0/0\",\n    except: [META_IP],\n  },\n};\n\n/** Matches any endpoint in cluster\n * This is primarily to support Cilium where IP based policies do not match/allow anything in-cluster\n * Ref: https://github.com/defenseunicorns/uds-core/issues/871 and https://github.com/cilium/cilium/blob/v1.16.2/Documentation/network/kubernetes/policy.rst#networkpolicy\n */\nexport const anywhereInCluster: V1NetworkPolicyPeer = {\n  namespaceSelector: {},\n};\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { createHash } from \"crypto\";\nimport { K8s, kind } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { retryWithDelay } from \"../utils\";\nimport { reloadPods } from \"./reload-utils\";\n\nconst log = setupLogger(Component.OPERATOR_SECRETS);\n\n// Define resource types\nexport type ResourceType = \"Secret\" | \"ConfigMap\";\n\n// Maps to store resource checksums for change detection\n// Exported for testing purposes\nexport const secretChecksumCache = new Map<string, string>();\nexport const configMapChecksumCache = new Map<string, string>();\n\n/**\n * Computes a SHA256 checksum of the resource data\n *\n * @param data The resource data to compute the checksum for\n * @returns A hex-encoded SHA256 checksum\n */\nexport function computeResourceChecksum(data: Record<string, string>): string {\n  // Sort keys to ensure consistent hashing regardless of key order\n  const sortedKeys = Object.keys(data).sort();\n  const hash = createHash(\"sha256\");\n\n  // Add each key-value pair to the hash\n  for (const key of sortedKeys) {\n    hash.update(`${key}=${data[key]}`);\n  }\n\n  return hash.digest(\"hex\");\n}\n\n/**\n * Auto-discovers pods that use the given secret\n *\n * @param namespace Namespace of the secret\n * @param secretName Name of the secret\n * @returns Array of pods that mount or reference the secret\n */\nexport async function discoverSecretConsumers(namespace: string, secretName: string) {\n  // Get all pods in the namespace\n  const pods = await K8s(kind.Pod).InNamespace(namespace).Get();\n\n  // Filter pods that use the secret either as a volume or env var source\n  return pods.items.filter(pod => {\n    if (!pod.spec) return false;\n\n    // Check volume mounts for direct secret volumes\n    const usesSecretVolume = pod.spec.volumes?.some(\n      volume => volume.secret && volume.secret.secretName === secretName,\n    );\n    if (usesSecretVolume) return true;\n\n    // Check for projected volumes that include the secret\n    const usesProjectedSecretVolume = pod.spec.volumes?.some(volume =>\n      volume.projected?.sources?.some(source => source.secret?.name === secretName),\n    );\n    if (usesProjectedSecretVolume) return true;\n\n    // Check environment variables\n    const containers = [...(pod.spec.containers || []), ...(pod.spec.initContainers || [])];\n    const usesSecretEnv = containers.some(\n      container =>\n        container.env?.some(env => env.valueFrom?.secretKeyRef?.name === secretName) ||\n        container.envFrom?.some(envFrom => envFrom.secretRef?.name === secretName),\n    );\n\n    return usesSecretEnv;\n  });\n}\n\n/**\n * Parse a key=value selector string from an annotation\n * @param value The string value to parse (format: \"key1=value1,key2=value2\")\n * @returns The parsed object or null if invalid\n */\nexport function parseSelectorString(value: string): Record<string, string> | null {\n  try {\n    // Handle key=value format (like \"app=falco-pod\")\n    const result: Record<string, string> = {};\n\n    // Split by commas if multiple key=value pairs\n    const pairs = value.split(\",\");\n\n    for (const pair of pairs) {\n      const [key, val] = pair.trim().split(\"=\");\n      if (key && val) {\n        result[key.trim()] = val.trim();\n      } else {\n        // Invalid format\n        return null;\n      }\n    }\n\n    return Object.keys(result).length > 0 ? result : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Auto-discovers pods that use the given ConfigMap\n *\n * @param namespace Namespace of the ConfigMap\n * @param configMapName Name of the ConfigMap\n * @returns Array of pods that mount or reference the ConfigMap\n */\nexport async function discoverConfigMapConsumers(namespace: string, configMapName: string) {\n  // Get all pods in the namespace\n  const pods = await K8s(kind.Pod).InNamespace(namespace).Get();\n\n  // Filter pods that use the ConfigMap either as a volume or env var source\n  return pods.items.filter(pod => {\n    if (!pod.spec) return false;\n\n    // Check volume mounts for direct ConfigMap volumes\n    const usesConfigMapVolume = pod.spec.volumes?.some(\n      volume => volume.configMap && volume.configMap.name === configMapName,\n    );\n    if (usesConfigMapVolume) return true;\n\n    // Check for projected volumes that include the ConfigMap\n    const usesProjectedConfigMapVolume = pod.spec.volumes?.some(volume =>\n      volume.projected?.sources?.some(source => source.configMap?.name === configMapName),\n    );\n    if (usesProjectedConfigMapVolume) return true;\n\n    // Check environment variables\n    const containers = [...(pod.spec.containers || []), ...(pod.spec.initContainers || [])];\n    const usesConfigMapEnv = containers.some(\n      container =>\n        container.env?.some(env => env.valueFrom?.configMapKeyRef?.name === configMapName) ||\n        container.envFrom?.some(envFrom => envFrom.configMapRef?.name === configMapName),\n    );\n\n    return usesConfigMapEnv;\n  });\n}\n\n/**\n * Generic function to handle resource updates (Secret or ConfigMap)\n *\n * @param resource The Kubernetes resource that was updated\n * @param checksumCache The cache to use for this resource type\n * @param discoverResourceConsumers Function to discover pods using this resource\n * @param resourceType Type of resource (\"Secret\" or \"ConfigMap\")\n */\nexport async function handleResourceUpdate(\n  resource: kind.Secret | kind.ConfigMap,\n  checksumCache: Map<string, string>,\n  discoverResourceConsumers: (namespace: string, name: string) => Promise<kind.Pod[]>,\n  resourceType: ResourceType,\n) {\n  if (!resource.metadata?.name || !resource.metadata?.namespace) {\n    return;\n  }\n\n  const { name, namespace } = resource.metadata;\n  const cacheKey = `${namespace}/${name}`;\n\n  // Use an empty object if data is undefined or null\n  const data = resource.data || {};\n\n  // Compute checksum of the current resource data\n  const currentChecksum = computeResourceChecksum(data);\n\n  // Check if we've seen this resource before\n  const previousChecksum = checksumCache.get(cacheKey);\n\n  // Update the cache regardless of whether we process this update\n  checksumCache.set(cacheKey, currentChecksum);\n\n  // If this is the first time we're seeing this resource, or if the data hasn't changed, exit early\n  if (!previousChecksum || previousChecksum === currentChecksum) {\n    return;\n  }\n\n  log.info(\n    { resource: name, namespace, type: resourceType },\n    `${resourceType} data changed, processing pod reload`,\n  );\n\n  // Determine which pods to reload based on the strategy\n  let podsToReload: kind.Pod[] = [];\n\n  // Check if we have an explicit pod selector in annotations\n  const selectorStr = resource.metadata?.annotations?.[\"uds.dev/pod-reload-selector\"];\n\n  if (selectorStr) {\n    const selector = parseSelectorString(selectorStr);\n    if (!selector) {\n      const errorMsg = `Invalid selector format in uds.dev/pod-reload-selector annotation for ${resourceType.toLowerCase()} ${namespace}/${name}: ${selectorStr}. Expected format: key1=value1,key2=value2`;\n      log.error({ resource: name, namespace, selector: selectorStr, type: resourceType }, errorMsg);\n      return;\n    }\n\n    log.debug(\n      { resource: name, namespace, selector, type: resourceType },\n      `Using explicit pod selector from ${resourceType.toLowerCase()} annotation for reload`,\n    );\n\n    // Build query with each label\n    let podQuery = K8s(kind.Pod).InNamespace(namespace);\n    for (const [key, value] of Object.entries(selector)) {\n      podQuery = podQuery.WithLabel(key, value);\n    }\n\n    try {\n      async function getPodsWithSelector() {\n        return podQuery.Get();\n      }\n\n      const pods = await retryWithDelay(getPodsWithSelector, log);\n      podsToReload = pods.items;\n    } catch (error) {\n      log.error(\n        { resource: name, namespace, selector, error, type: resourceType },\n        `Failed to get pods using selector from ${resourceType.toLowerCase()} annotation`,\n      );\n      return;\n    }\n  } else {\n    // No explicit selector, use auto-discovery\n    log.debug(\n      { resource: name, namespace, type: resourceType },\n      `Auto-discovering ${resourceType.toLowerCase()} consumers`,\n    );\n    try {\n      async function getPodsUsingResource() {\n        return discoverResourceConsumers(namespace, name);\n      }\n      podsToReload = await retryWithDelay(getPodsUsingResource, log);\n    } catch (error) {\n      log.error(\n        { resource: name, namespace, error, type: resourceType },\n        `Failed to discover ${resourceType.toLowerCase()} consumers`,\n      );\n      return;\n    }\n  }\n\n  // If no pods found, log and exit\n  if (podsToReload.length === 0) {\n    log.warn(\n      { resource: name, namespace, type: resourceType },\n      `No pods found to reload for ${resourceType.toLowerCase()} change`,\n    );\n    return;\n  }\n\n  // Reload the pods\n  log.info(\n    { resource: name, namespace, podCount: podsToReload.length, type: resourceType },\n    `Reloading ${podsToReload.length} pods due to ${resourceType.toLowerCase()} change`,\n  );\n\n  try {\n    await reloadPods(\n      namespace,\n      podsToReload,\n      `${resourceType} ${name} change`,\n      log,\n      `${resourceType}Changed`,\n    );\n  } catch (error) {\n    log.error(\n      { resource: name, namespace, podCount: podsToReload.length, error, type: resourceType },\n      `Failed to reload pods after ${resourceType.toLowerCase()} change`,\n    );\n    return;\n  }\n}\n\n/**\n * Generic function to handle resource deletion (Secret or ConfigMap)\n *\n * @param resource The Kubernetes resource that was deleted\n * @param checksumCache The cache to use for this resource type\n */\nexport function handleResourceDelete(\n  resource: kind.Secret | kind.ConfigMap,\n  checksumCache: Map<string, string>,\n) {\n  if (!resource.metadata?.name || !resource.metadata?.namespace) {\n    return;\n  }\n\n  const { name, namespace } = resource.metadata;\n  const cacheKey = `${namespace}/${name}`;\n\n  // Clean up the cache entry\n  checksumCache.delete(cacheKey);\n}\n\n/**\n * Handles a secret update event\n *\n * @param secret The Kubernetes secret that was updated\n */\nexport async function handleSecretUpdate(secret: kind.Secret) {\n  await handleResourceUpdate(secret, secretChecksumCache, discoverSecretConsumers, \"Secret\");\n}\n\n/**\n * Handles a secret deletion event\n *\n * @param secret The Kubernetes secret that was deleted\n */\nexport function handleSecretDelete(secret: kind.Secret) {\n  handleResourceDelete(secret, secretChecksumCache);\n}\n\n/**\n * Handles a ConfigMap update event\n *\n * @param configMap The Kubernetes ConfigMap that was updated\n */\nexport async function handleConfigMapUpdate(configMap: kind.ConfigMap) {\n  await handleResourceUpdate(\n    configMap,\n    configMapChecksumCache,\n    discoverConfigMapConsumers,\n    \"ConfigMap\",\n  );\n}\n\n/**\n * Handles a ConfigMap deletion event\n *\n * @param configMap The Kubernetes ConfigMap that was deleted\n */\nexport function handleConfigMapDelete(configMap: kind.ConfigMap) {\n  handleResourceDelete(configMap, configMapChecksumCache);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { GenericClass } from \"kubernetes-fluent-client\";\nimport { K8s, kind } from \"pepr\";\nimport { Logger } from \"pino\";\nimport { createEvent, retryWithDelay } from \"../utils\";\n\n/**\n * Reload a list of pods using controller-based rolling restart when possible,\n * falling back to direct pod eviction when necessary.\n *\n * For Deployments, StatefulSets, DaemonSets, and ReplicaSets, it will trigger a\n * rolling restart by apply an update to the controller with a restartedAt annotation.\n *\n * For standalone pods or when controller handling fails, it will use direct pod eviction.\n *\n * @param namespace The namespace containing the pods\n * @param pods List of pods to evict or restart\n * @param message The reason for eviction/restart (for logging)\n * @param log Logger instance for logging\n * @param reason Resource type responsible for eviction/restart (for logging)\n */\nexport async function reloadPods(\n  namespace: string,\n  pods: kind.Pod[],\n  message: string,\n  log: Logger,\n  reason: string,\n) {\n  if (pods.length === 0) {\n    log.warn(`No pods provided for eviction in namespace ${namespace}`);\n    return;\n  }\n\n  log.info(`Processing ${pods.length} pods for restart/eviction in namespace ${namespace}`);\n\n  // Track which controllers we've already handled to avoid duplicate restarts\n  const handledControllers: Record<string, boolean> = {};\n  const standalonePodsToEvict: kind.Pod[] = [];\n\n  // First pass - identify controllers and standalone pods\n  for (const pod of pods) {\n    // Skip pods that don't need to be reloaded (succeeded or failed pods are not automatically restarted)\n    const phase = pod.status?.phase;\n    if (phase === \"Succeeded\" || phase === \"Failed\") {\n      log.debug(`Ignoring Pod ${namespace}/${pod.metadata?.name} (phase: ${phase})`);\n      continue;\n    }\n    // Skip pods that already have a deletion timestamp\n    if (pod.metadata?.deletionTimestamp) {\n      log.debug(`Ignoring Pod ${namespace}/${pod.metadata?.name}, already being deleted`);\n      continue;\n    }\n\n    const ownerRefs = pod.metadata?.ownerReferences || [];\n    const controllerRef = ownerRefs.find(ref => ref.controller === true);\n\n    if (!controllerRef) {\n      // No controller reference, handle as standalone pod\n      standalonePodsToEvict.push(pod);\n      continue;\n    }\n\n    // Build a unique key for this controller to avoid duplicate handling\n    const controllerKey = `${controllerRef.kind}:${controllerRef.name}`;\n    if (handledControllers[controllerKey]) {\n      // We've already processed this controller\n      continue;\n    }\n\n    try {\n      if (controllerRef.kind === \"ReplicaSet\") {\n        // For ReplicaSets, try to find the parent Deployment\n        await handleReplicaSetOwner(namespace, controllerRef.name, message, log, reason);\n      } else if (controllerRef.kind === \"Deployment\") {\n        // Handle Deployment directly\n        await restartController(\n          namespace,\n          kind.Deployment,\n          controllerRef.name,\n          message,\n          log,\n          reason,\n        );\n      } else if (controllerRef.kind === \"StatefulSet\") {\n        // Handle StatefulSet directly\n        await restartController(\n          namespace,\n          kind.StatefulSet,\n          controllerRef.name,\n          message,\n          log,\n          reason,\n        );\n      } else if (controllerRef.kind === \"DaemonSet\") {\n        // Handle DaemonSet directly\n        await restartController(\n          namespace,\n          kind.DaemonSet,\n          controllerRef.name,\n          message,\n          log,\n          reason,\n        );\n      } else {\n        // Unhandled controller type, evict the pod directly\n        standalonePodsToEvict.push(pod);\n        continue;\n      }\n\n      // Mark this controller as handled\n      handledControllers[controllerKey] = true;\n    } catch (error) {\n      log.error(\n        {\n          pod: pod.metadata?.name,\n          namespace,\n          controller: controllerRef.kind,\n          controllerName: controllerRef.name,\n          error,\n        },\n        `Failed to handle controller for pod: ${message}`,\n      );\n    }\n  }\n\n  // Now handle any standalone pods with direct eviction\n  if (standalonePodsToEvict.length > 0) {\n    await evictStandalonePods(namespace, standalonePodsToEvict, message, log);\n  }\n}\n\n/**\n * Handle ReplicaSet by finding its parent Deployment or handling it directly\n */\nasync function handleReplicaSetOwner(\n  namespace: string,\n  replicaSetName: string,\n  message: string,\n  log: Logger,\n  reason: string,\n): Promise<void> {\n  try {\n    // Get the ReplicaSet\n    async function getReplicaSet() {\n      return K8s(kind.ReplicaSet).InNamespace(namespace).Get(replicaSetName);\n    }\n    const rs = await retryWithDelay(getReplicaSet, log);\n\n    // Look for a Deployment owner\n    const deploymentOwner = rs.metadata?.ownerReferences?.find(ref => ref.kind === \"Deployment\");\n\n    if (deploymentOwner?.name) {\n      // Found a Deployment owner, restart it\n      await restartController(\n        namespace,\n        kind.Deployment,\n        deploymentOwner.name,\n        message,\n        log,\n        reason,\n      );\n    } else {\n      // Standalone ReplicaSet - restart it directly using the same annotation pattern\n      await restartController(namespace, kind.ReplicaSet, replicaSetName, message, log, reason);\n    }\n  } catch (error) {\n    log.error(\n      { replicaSet: replicaSetName, namespace, error },\n      `Failed to handle ReplicaSet owner: ${message}`,\n    );\n    throw error;\n  }\n}\n\n/**\n * Restart a controller (Deployment, StatefulSet, DaemonSet, ReplicaSet) using the kubectl-style annotation\n */\nexport async function restartController(\n  namespace: string,\n  controllerKind: GenericClass,\n  name: string,\n  message: string,\n  log: Logger,\n  reason: string,\n): Promise<void> {\n  // Get the controller kind name for logging\n  const controllerKindName = controllerKind?.name ?? String(controllerKind);\n\n  // Create a list of allowed controller kinds\n  const allowedKinds = [kind.Deployment, kind.StatefulSet, kind.DaemonSet, kind.ReplicaSet];\n\n  // Check if the provided kind is in our allowed list\n  // We use strict equality to check if it's the same object reference\n  const isAllowedKind = allowedKinds.some(k => k === controllerKind);\n\n  if (!isAllowedKind) {\n    throw new Error(`Unsupported controller kind: ${controllerKindName}`);\n  }\n\n  // Get the controller resource for the event\n  async function getController() {\n    return K8s(controllerKind).InNamespace(namespace).Get(name);\n  }\n  const controller = await retryWithDelay(getController, log);\n\n  try {\n    // Setup parent fields if any are missing to ensure our apply doesn't hit errors\n    if (!controller.spec) controller.spec = {};\n    if (!controller.spec.template) controller.spec.template = {};\n    if (!controller.spec.template.metadata) controller.spec.template.metadata = {};\n    if (!controller.spec.template.metadata.annotations)\n      controller.spec.template.metadata.annotations = {};\n    controller.spec.template.metadata.annotations[\"uds.dev/restartedAt\"] = new Date().toISOString();\n    // Clear managedFields before apply\n    delete controller.metadata?.managedFields;\n\n    // Update the annotation in the controller object and apply\n    async function applyControllerAnnotation() {\n      return K8s(controllerKind, { name, namespace }).Apply(controller);\n    }\n    await retryWithDelay(applyControllerAnnotation, log);\n  } catch (error) {\n    log.error(\n      { controller: controllerKindName, name, namespace, error },\n      `Failed to apply ${controllerKindName} controller update: ${message}`,\n    );\n    throw error;\n  }\n\n  try {\n    // Create an event for this controller restart\n    async function createControllerEvent() {\n      return createEvent(\n        controller,\n        {\n          type: \"Normal\",\n          reason: `${reason}`,\n          message: `Restarted due to: ${message}`,\n        },\n        log,\n      );\n    }\n    await retryWithDelay(createControllerEvent, log);\n  } catch (error) {\n    log.warn(\n      { controller: controllerKindName, name, namespace, error },\n      `Controller ${controllerKindName}/${name} was restarted, but failed to create event notification`,\n    );\n    // Don't rethrow this error since the apply was successful\n  }\n\n  // Log success if we got here (apply was successful)\n  log.info(`Successfully restarted ${controllerKindName} ${namespace}/${name}: ${message}`);\n}\n\n/**\n * Evict standalone pods directly using the Evict API with fallback to Delete\n */\nexport async function evictStandalonePods(\n  namespace: string,\n  pods: kind.Pod[],\n  reason: string,\n  log: Logger,\n) {\n  if (pods.length === 0) return;\n\n  log.info(`Directly evicting ${pods.length} standalone pods in namespace ${namespace}`);\n\n  // Group pods by owner UID for ordered eviction (handling StatefulSets differently)\n  const groups: Record<string, kind.Pod[]> = {};\n\n  for (const pod of pods) {\n    // Get the UID of the owner of the pod or default to \"other\"\n    const controlledBy =\n      pod.metadata?.ownerReferences?.find((ref: V1OwnerReference) => ref.controller)?.uid ||\n      \"other\";\n    groups[controlledBy] = groups[controlledBy] || [];\n    groups[controlledBy].push(pod);\n  }\n\n  // Evict each group of pods\n  for (const group of Object.values(groups)) {\n    for (const pod of group) {\n      log.info(`Evicting pod ${namespace}/${pod.metadata?.name} due to ${reason}`);\n\n      try {\n        // Try to use the Evict API\n        async function evictPod() {\n          return K8s(kind.Pod).InNamespace(namespace).Evict(pod.metadata!.name!);\n        }\n        await retryWithDelay(evictPod, log);\n        log.info(`Successfully evicted pod ${namespace}/${pod.metadata?.name}`);\n      } catch (err) {\n        // Fall back to Delete with grace period if Evict fails\n        log.warn(\n          `Failed to evict pod ${namespace}/${pod.metadata?.name} using Evict API, falling back to Delete: ${err.message}`,\n        );\n        try {\n          async function deletePod() {\n            return K8s(kind.Pod).Delete(pod);\n          }\n          await retryWithDelay(deletePod, log);\n          log.info(\n            `Successfully initiated graceful deletion of pod ${namespace}/${pod.metadata?.name}`,\n          );\n        } catch (deleteErr) {\n          log.error(\n            `Failed to delete pod ${namespace}/${pod.metadata?.name}: ${deleteErr.message}`,\n          );\n        }\n      }\n    }\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Monitor } from \"../../crd\";\nimport { sanitizeResourceName } from \"../utils\";\n\nexport function generateMonitorName(pkgName: string, monitor: Monitor) {\n  const { selector, portName, description } = monitor;\n\n  // Ensure the resource name is valid\n  const nameSuffix = description || `${Object.values(selector)}-${portName}`;\n  const name = sanitizeResourceName(`${pkgName}-${nameSuffix}`);\n\n  return name;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\n\n/** Matches any pod in the namespace */\nexport const intraNamespace: V1NetworkPolicyPeer = {\n  podSelector: {\n    matchLabels: {},\n  },\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\n\n/** Matches a specific custom cidr without any exclusions */\nexport function remoteCidr(cidr: string): V1NetworkPolicyPeer {\n  return {\n    ipBlock: {\n      cidr,\n    },\n  };\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer } from \"@kubernetes/client-node\";\nimport { ambientEgressNamespace } from \"../../istio/egress-ambient\";\nimport { sidecarEgressNamespace } from \"../../istio/egress-sidecar\";\n\n/* Matches the egress gateway resource */\nexport const egressGateway: V1NetworkPolicyPeer = {\n  namespaceSelector: {\n    matchLabels: {\n      \"kubernetes.io/metadata.name\": sidecarEgressNamespace,\n    },\n  },\n  podSelector: {\n    matchLabels: {\n      app: \"egressgateway\",\n    },\n  },\n};\n\n/* Matches the egress waypoint resource */\nexport const egressWaypoint: V1NetworkPolicyPeer = {\n  namespaceSelector: {\n    matchLabels: {\n      \"kubernetes.io/metadata.name\": ambientEgressNamespace,\n    },\n  },\n  podSelector: {\n    matchLabels: {\n      \"gateway.networking.k8s.io/gateway-name\": \"egress-waypoint\",\n    },\n  },\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1NetworkPolicyPeer, V1NetworkPolicyPort } from \"@kubernetes/client-node\";\nimport { kind } from \"pepr\";\n\nimport { Allow, RemoteGenerated } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { anywhere, anywhereInCluster } from \"./generators/anywhere\";\nimport { cloudMetadata } from \"./generators/cloudMetadata\";\nimport { intraNamespace } from \"./generators/intraNamespace\";\nimport { kubeAPI } from \"./generators/kubeAPI\";\nimport { kubeNodes } from \"./generators/kubeNodes\";\nimport { remoteCidr } from \"./generators/remoteCidr\";\nimport { egressGateway, egressWaypoint } from \"./generators/egress\";\n\nfunction isWildcardNamespace(namespace: string) {\n  return namespace === \"\" || namespace === \"*\";\n}\n\nfunction getPeers(policy: Allow, istioMode: Mode | undefined): V1NetworkPolicyPeer[] {\n  let peers: V1NetworkPolicyPeer[] = [];\n\n  if (policy.remoteGenerated) {\n    switch (policy.remoteGenerated) {\n      case RemoteGenerated.KubeAPI:\n        peers = kubeAPI();\n        break;\n\n      case RemoteGenerated.KubeNodes:\n        peers = kubeNodes();\n        break;\n\n      case RemoteGenerated.CloudMetadata:\n        peers = cloudMetadata;\n        break;\n\n      case RemoteGenerated.IntraNamespace:\n        peers = [intraNamespace];\n        break;\n\n      case RemoteGenerated.Anywhere:\n        peers = [anywhere, anywhereInCluster];\n        break;\n    }\n  } else if (policy.remoteNamespace !== undefined || policy.remoteSelector !== undefined) {\n    const peer: V1NetworkPolicyPeer = {};\n\n    if (policy.remoteNamespace !== undefined) {\n      if (isWildcardNamespace(policy.remoteNamespace)) {\n        peer.namespaceSelector = {};\n      } else {\n        peer.namespaceSelector = {\n          matchLabels: { \"kubernetes.io/metadata.name\": policy.remoteNamespace },\n        };\n      }\n    }\n\n    if (policy.remoteSelector !== undefined) {\n      peer.podSelector = {\n        matchLabels: policy.remoteSelector,\n      };\n    }\n\n    peers.push(peer);\n  } else if (policy.remoteCidr !== undefined) {\n    peers = [remoteCidr(policy.remoteCidr)];\n  } else if (policy.remoteHost) {\n    if (istioMode === Mode.Ambient) {\n      peers = [egressWaypoint];\n    } else {\n      peers = [egressGateway];\n    }\n  }\n\n  return peers;\n}\n\nexport function generate(namespace: string, policy: Allow, istioMode?: Mode): kind.NetworkPolicy {\n  // Generate a unique name for the NetworkPolicy\n  const name = generateName(policy);\n\n  // Create the NetworkPolicy\n  const generated: kind.NetworkPolicy = {\n    apiVersion: \"networking.k8s.io/v1\",\n    kind: \"NetworkPolicy\",\n    metadata: {\n      name,\n      namespace,\n      labels: { ...policy.labels },\n    },\n    spec: {\n      policyTypes: [policy.direction],\n      podSelector: {\n        matchLabels: policy.selector,\n      },\n    },\n  };\n\n  // Add the description if it exists to the annotations in case of truncation of the name\n  if (policy.description) {\n    generated.metadata!.annotations = {\n      \"uds/description\": policy.description,\n    };\n  }\n\n  // Add the generated policy label (used to track KubeAPI and KubeNodes policies)\n  if (policy.remoteGenerated) {\n    generated.metadata!.labels![\"uds/generated\"] = policy.remoteGenerated;\n  }\n\n  // Create the network policy peers\n  const peers: V1NetworkPolicyPeer[] = getPeers(policy, istioMode);\n\n  // Define the ports to allow from the ports property\n  const ports: V1NetworkPolicyPort[] = (policy.ports ?? []).map(port => ({ port }));\n\n  // Add the individual port if it exists\n  if (policy.port) {\n    ports.push({\n      port: policy.port,\n    });\n  }\n\n  // Add the ingress or egress rule\n  switch (policy.direction) {\n    case \"Ingress\":\n      generated.spec!.ingress = [{ from: peers, ports }];\n      break;\n\n    case \"Egress\":\n      generated.spec!.egress = [{ to: peers, ports }];\n      break;\n  }\n\n  return generated;\n}\n\n/**\n * Generates a unique name for the NetworkPolicy based on the policy.\n * Will use the description if it exists, otherwise it will use the\n * direction and combination of remote properties.\n *\n * @param policy The policy to generate a name for\n */\nexport function generateName(policy: Allow) {\n  const name =\n    // Use the description if it exists\n    policy.description ||\n    // Otherwise use the direction, and combination of remote properties\n    [\n      Object.values(policy.selector || [\"all pods\"]),\n      policy.remoteGenerated || [\n        policy.remoteNamespace,\n        Object.values(policy.remoteSelector || [\"all pods\"]),\n      ],\n    ]\n      // Flatten the array\n      .flat(1)\n      .join(\"-\");\n\n  return `${policy.direction}-${name}`;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { PkgStatus, Sso, UDSPackage } from \".\";\nimport { AuthserviceClient } from \"./generated/package-v1alpha1\";\n\n/**\n * Migrates the package to the latest version\n *\n * @param pkg the package to migrate\n * @returns\n */\nexport function migrate(pkg: UDSPackage) {\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  for (const expose of exposeList) {\n    // Migrate expose[].match -> expose[].advancedHTTP.match\n    if (expose.match) {\n      expose.advancedHTTP = expose.advancedHTTP ?? {};\n      expose.advancedHTTP.match = expose.match;\n      delete expose.match;\n    }\n  }\n\n  const allowList = pkg.spec?.network?.allow ?? [];\n\n  for (const allow of allowList) {\n    // Migrate allow[].podLabels -> allow[].selector\n    if (allow.podLabels) {\n      allow.selector = allow.podLabels;\n      delete allow.podLabels;\n    }\n\n    // Migrate allow[].remotePodLabels -> allow[].remoteSelector\n    if (allow.remotePodLabels) {\n      allow.remoteSelector = allow.remotePodLabels;\n      delete allow.remotePodLabels;\n    }\n  }\n\n  // Migrate status fields (aggregates all status migrations)\n  migrateStatus(pkg);\n\n  return pkg;\n}\n\n/**\n * Returns a migrated authserviceClients array for the given package status.\n * - If status.authserviceClients is undefined/empty, returns undefined\n * - If it's a legacy string[] (client IDs), returns object[] using selectors from spec.sso\n * - If it's already object[], returns it as-is\n */\nexport function buildMigratedAuthserviceStatus(pkg: UDSPackage): AuthserviceClient[] | undefined {\n  const raw = pkg.status?.authserviceClients as unknown;\n  if (!Array.isArray(raw) || raw.length === 0) return undefined;\n\n  const first = (raw as unknown[])[0];\n  // Already migrated\n  if (typeof first === \"object\") {\n    return raw as AuthserviceClient[];\n  }\n\n  // Legacy: string[] -> migrate using spec.sso selectors\n  if (typeof first === \"string\") {\n    const ssoList = (pkg.spec?.sso as Sso[] | undefined) || [];\n    return (raw as string[]).map(id => {\n      const match = ssoList.find(s => s.clientId === id);\n      return {\n        clientId: id,\n        selector: match?.enableAuthserviceSelector || {},\n      } as AuthserviceClient;\n    });\n  }\n\n  return undefined;\n}\n\n/**\n * Mutates the package status in-place to migrate legacy authserviceClients string[] to object[]\n */\nexport function migrateAuthserviceStatus(pkg: UDSPackage) {\n  const migrated = buildMigratedAuthserviceStatus(pkg);\n  if (!migrated) return;\n\n  const current: PkgStatus = (pkg.status as PkgStatus) ?? ({} as PkgStatus);\n  pkg.status = { ...current, authserviceClients: migrated } as PkgStatus;\n}\n\n/**\n * Aggregates all status migrations. Add new status migrations here over time.\n */\nexport function migrateStatus(pkg: UDSPackage) {\n  migrateAuthserviceStatus(pkg);\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { PeprValidateRequest } from \"pepr\";\n\nimport { Gateway, Protocol, UDSPackage } from \"..\";\nimport { generateVSName } from \"../../controllers/istio/virtual-service\";\nimport { generateMonitorName } from \"../../controllers/monitoring/common\";\nimport { generateName } from \"../../controllers/network/generate\";\nimport { PackageStore } from \"../../controllers/packages/package-store\";\nimport { sanitizeResourceName } from \"../../controllers/utils\";\nimport { Kind, Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { migrate } from \"../migrate\";\n\nconst invalidNamespaces = [\"kube-system\", \"kube-public\", \"_unknown_\", \"pepr-system\"];\n\nexport async function validator(req: PeprValidateRequest<UDSPackage>) {\n  const pkg = migrate(req.Raw);\n\n  const pkgName = pkg.metadata?.name ?? \"_unknown_\";\n  const ns = pkg.metadata?.namespace ?? \"_unknown_\";\n  const deletionTimestamp = pkg.metadata?.deletionTimestamp ?? null;\n  const istioMode = pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar;\n\n  if (invalidNamespaces.includes(ns)) {\n    return req.Deny(\"invalid namespace\");\n  }\n\n  // Check if a package already exists in the target namespace\n  if (PackageStore.hasKey(ns) && !deletionTimestamp) {\n    const existingPkgName = PackageStore.getPkgName(ns);\n    // Since this function is called on admission, we need to allow updating existing packages\n    if (existingPkgName !== pkgName) {\n      return req.Deny(\n        `A package with the name \"${existingPkgName}\" already exists in the namespace \"${ns}\". Only one package can exist in a namespace.`,\n      );\n    }\n  }\n\n  // Helper function to check if a gateway name is one of the standard gateways\n  const isStandardGateway = (g: string): g is Gateway =>\n    (Object.values(Gateway) as string[]).includes(g);\n\n  const exposeList = pkg.spec?.network?.expose ?? [];\n\n  // Track the names of the virtual services to ensure they are unique\n  const virtualServiceNames = new Set<string>();\n\n  for (const expose of exposeList) {\n    // Validate gateway name format if it's a custom gateway\n    if (expose.gateway && !isStandardGateway(expose.gateway)) {\n      // Check if gateway name is a valid Kubernetes resource name\n      const sanitizedName = sanitizeResourceName(expose.gateway);\n      if (sanitizedName !== expose.gateway) {\n        return req.Deny(\n          `Gateway name \"${expose.gateway}\" is not a valid Kubernetes resource name. It should only contain lowercase alphanumeric characters, '-', or '.'`,\n        );\n      }\n    }\n    if (expose.gateway && isStandardGateway(expose.gateway) && expose.domain) {\n      return req.Deny(\n        \"domain cannot be set for the standard gateways (tenant, admin, or passthrough)\",\n      );\n    }\n\n    if (expose.gateway === Gateway.Passthrough || expose.gateway?.includes(\"passthrough\")) {\n      if (expose.advancedHTTP) {\n        return req.Deny(\"advancedHTTP cannot be used with a passthrough gateway\");\n      }\n    }\n\n    // directResponse cannot be combined with service, port or pod configs\n    if (\n      expose.advancedHTTP?.directResponse &&\n      (expose.service || expose.selector || expose.port || expose.targetPort)\n    ) {\n      return req.Deny(\"directResponse cannot be combined with service, port, selector, targetPort\");\n    }\n\n    // Ensure the service name is unique\n    const name = generateVSName(pkgName, expose);\n    if (virtualServiceNames.has(name)) {\n      return req.Deny(\n        `The combination of characteristics of this expose entry would create a duplicate VirtualService. ` +\n          `Verify you do not have duplicate values, or add a unique \"description\" field for this rule. ` +\n          `The duplicate rule would be named \"${name}\".`,\n      );\n    }\n\n    // Add the name to the set to track it\n    virtualServiceNames.add(name);\n  }\n\n  const networkPolicy = pkg.spec?.network?.allow ?? [];\n\n  // Track the names of the network policies to ensure they are unique\n  const networkPolicyNames = new Set<string>();\n\n  for (const policy of networkPolicy) {\n    // If 'remoteGenerated' is set, it cannot be combined with 'remoteNamespace', 'remoteSelector', 'remoteCidr', 'remoteHost', or 'remoteProtocol'.\n    if (\n      policy.remoteGenerated &&\n      (policy.remoteNamespace ||\n        policy.remoteSelector ||\n        policy.remoteCidr ||\n        policy.remoteHost ||\n        policy.remoteProtocol)\n    ) {\n      return req.Deny(\n        \"remoteGenerated cannot be combined with remoteNamespace, remoteSelector, remoteCidr, remoteHost, or remoteProtocol\",\n      );\n    }\n\n    // If either 'remoteNamespace' or 'remoteSelector' is set, they cannot be combined with 'remoteGenerated', 'remoteCidr', 'remoteHost', or 'remoteProtocol'.\n    if (\n      (policy.remoteNamespace || policy.remoteSelector) &&\n      (policy.remoteGenerated || policy.remoteCidr || policy.remoteHost || policy.remoteProtocol)\n    ) {\n      return req.Deny(\n        \"remoteNamespace and remoteSelector cannot be combined with remoteGenerated, remoteCidr, remoteHost, or remoteProtocol\",\n      );\n    }\n\n    // If 'remoteCidr' is set, it cannot be combined with 'remoteGenerated', 'remoteNamespace', 'remoteSelector', 'remoteHost', or 'remoteProtocol'.\n    if (\n      policy.remoteCidr &&\n      (policy.remoteGenerated ||\n        policy.remoteNamespace ||\n        policy.remoteSelector ||\n        policy.remoteHost ||\n        policy.remoteProtocol)\n    ) {\n      return req.Deny(\n        \"remoteCidr cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, remoteHost, or remoteProtocol\",\n      );\n    }\n\n    // If 'remoteHost' is set, it cannot be combined with 'remoteGenerated', 'remoteNamespace', 'remoteSelector', or 'remoteCidr'.\n    if (\n      policy.remoteHost &&\n      (policy.remoteGenerated ||\n        policy.remoteNamespace ||\n        policy.remoteSelector ||\n        policy.remoteCidr)\n    ) {\n      return req.Deny(\n        \"remoteHost cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, or remoteCidr\",\n      );\n    }\n\n    // If 'remoteProtocol' is set, it cannot be combined with 'remoteGenerated', 'remoteNamespace', 'remoteSelector', or 'remoteCidr'and must have 'remoteHost'.\n    if (\n      policy.remoteProtocol &&\n      (policy.remoteGenerated ||\n        policy.remoteNamespace ||\n        policy.remoteSelector ||\n        policy.remoteCidr ||\n        !policy.remoteHost)\n    ) {\n      return req.Deny(\n        \"remoteProtocol cannot be combined with remoteGenerated, remoteNamespace, remoteSelector, or remoteCidr and must have remoteHost\",\n      );\n    }\n\n    // The 'remoteHost' and 'remoteProtocol' cannot be used with 'Ingress'.\n    if ((policy.remoteHost || policy.remoteProtocol) && policy.direction == \"Ingress\") {\n      return req.Deny(\"remoteHost and/or remoteProtocol cannot be used with Ingress\");\n    }\n\n    // The 'remoteHost' does not support wildcard domains.\n    if (policy.remoteHost && policy.remoteHost.includes(\"*\")) {\n      return req.Deny(\"remoteHost does not support wildcard domains\");\n    }\n\n    // The 'serviceAccount' cannot be used if `remoteHost` is not specified.\n    if (policy.serviceAccount && !(policy.remoteHost && istioMode === Mode.Ambient)) {\n      return req.Deny(\"serviceAccount is only valid for Ambient mode when using remoteHost\");\n    }\n\n    // Ensure the policy name is unique\n    const name = sanitizeResourceName(`allow-${pkg.metadata?.name}-${generateName(policy)}`);\n    if (networkPolicyNames.has(name)) {\n      return req.Deny(\n        `The combination of characteristics of this network allow rule would create a duplicate NetworkPolicy. ` +\n          `Verify you do not have duplicate allow rules, or add a unique \"description\" field for this rule. ` +\n          `The duplicate rule would be named \"${name}\".`,\n      );\n    }\n    // Add the name to the set to track it\n    networkPolicyNames.add(name);\n  }\n\n  const ssoClients = pkg.spec?.sso ?? [];\n\n  // Ensure the client IDs are unique\n  const clientIDs = new Set<string>();\n\n  const allowedClientAttributes = new Set([\n    \"oidc.ciba.grant.enabled\",\n    \"backchannel.logout.session.required\",\n    \"backchannel.logout.revoke.offline.tokens\",\n    \"post.logout.redirect.uris\",\n    \"oauth2.device.authorization.grant.enabled\",\n    \"pkce.code.challenge.method\",\n    \"client.session.idle.timeout\",\n    \"client.session.max.lifespan\",\n    \"access.token.lifespan\",\n    \"saml.assertion.signature\",\n    \"saml.client.signature\",\n    \"saml_assertion_consumer_url_post\",\n    \"saml_assertion_consumer_url_redirect\",\n    \"saml_single_logout_service_url_post\",\n    \"saml_single_logout_service_url_redirect\",\n    \"saml_idp_initiated_sso_url_name\",\n    \"use.refresh.tokens\",\n    \"saml.encrypt\",\n    \"saml_name_id_format\",\n    \"saml.signing.certificate\",\n  ]);\n\n  for (const client of ssoClients) {\n    // Check for local uniqueness (within this package)\n    if (clientIDs.has(client.clientId)) {\n      return req.Deny(`The client ID \"${client.clientId}\" is not unique within this package`);\n    }\n    clientIDs.add(client.clientId);\n\n    // Check for global uniqueness (across all packages/namespaces)\n    const namespacesWithClientId = PackageStore.findPackagesWithSsoClientId(client.clientId);\n\n    // If we find namespaces with this client ID, make sure it's only the current namespace being updated\n    if (namespacesWithClientId.size > 0) {\n      const isOwnedByCurrentPackage = namespacesWithClientId.has(ns);\n\n      // If this client ID exists in other namespaces, deny the request\n      if (!isOwnedByCurrentPackage) {\n        return req.Deny(`The client ID \"${client.clientId}\" is already in use by another package.`);\n      }\n    }\n    // Don't allow illegal k8s resource names for the secret name\n    if (client.secretName && client.secretName !== sanitizeResourceName(client.secretName)) {\n      return req.Deny(\n        `The client ID \"${client.clientId}\" uses an invalid secret name ${client.secretName}`,\n      );\n    }\n    // If standardFlowEnabled is undefined (defaults to `true`) or explicitly true and there are no redirectUris set, deny the req\n    if (client.standardFlowEnabled !== false && !client.redirectUris) {\n      return req.Deny(\n        `The client ID \"${client.clientId}\" must specify redirectUris if standardFlowEnabled is turned on (it is enabled by default)`,\n      );\n    }\n    // If serviceAccountsEnabled is true, do not allow standard flow\n    if (client.serviceAccountsEnabled && client.standardFlowEnabled) {\n      return req.Deny(\n        `The client ID \"${client.clientId}\" serviceAccountsEnabled is disallowed with standardFlowEnabled`,\n      );\n    }\n    // If this is a public client ensure that it only sets itself up as an OAuth Device Flow client\n    if (\n      client.publicClient &&\n      (client.standardFlowEnabled !== false /* default true */ ||\n        client.serviceAccountsEnabled /* default false */ ||\n        client.secret !== undefined ||\n        client.secretName !== undefined ||\n        client.secretTemplate !== undefined ||\n        client.enableAuthserviceSelector !== undefined ||\n        client.protocol === Protocol.Saml ||\n        client.attributes?.[\"oauth2.device.authorization.grant.enabled\"] !== \"true\")\n    ) {\n      return req.Deny(\n        `The client ID \"${client.clientId}\" sets options incompatible with publicClient`,\n      );\n    }\n    // Check if client.attributes contain any disallowed attributes\n    if (client.attributes) {\n      for (const attr of Object.keys(client.attributes)) {\n        if (!allowedClientAttributes.has(attr)) {\n          return req.Deny(\n            `The client ID \"${client.clientId}\" contains an unsupported attribute \"${attr}\"`,\n          );\n        }\n      }\n    }\n    // If this is an authservice client ensure it does not contain a `:`, see https://github.com/istio-ecosystem/authservice/issues/263\n    if (client.enableAuthserviceSelector && client.clientId.includes(\":\")) {\n      return req.Deny(\n        `The client ID \"${client.clientId}\" is invalid as an Authservice client - Authservice does not support client IDs with the \":\" character`,\n      );\n    }\n  }\n\n  const monitors = pkg.spec?.monitor ?? [];\n\n  // Ensure service and pod monitors use a unique description or selector/portName used for generating the resource name\n  const podMonitorNames = new Set<string>();\n  const svcMonitorNames = new Set<string>();\n\n  for (const monitor of monitors) {\n    const monitorName = generateMonitorName(pkgName, monitor);\n    if (monitor.kind === Kind.PodMonitor) {\n      if (podMonitorNames.has(monitorName)) {\n        return req.Deny(\n          `The combination of characteristics of this monitor entry would create a duplicate PodMonitor. ` +\n            `Verify you do not have duplicate values, or add a unique \"description\" field for this monitor. ` +\n            `The duplicate rule would be named \"${monitorName}\".`,\n        );\n      }\n      podMonitorNames.add(monitorName);\n    } else {\n      if (svcMonitorNames.has(monitorName)) {\n        return req.Deny(\n          `The combination of characteristics of this monitor entry would create a duplicate ServiceMonitor. ` +\n            `Verify you do not have duplicate values, or add a unique \"description\" field for this monitor. ` +\n            `The duplicate rule would be named \"${monitorName}\".`,\n        );\n      }\n      svcMonitorNames.add(monitorName);\n    }\n  }\n\n  return req.Approve();\n}\n", "\n/*! js-yaml 4.1.1 https://github.com/nodeca/js-yaml @license MIT */\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nvar isNothing_1      = isNothing;\nvar isObject_1       = isObject;\nvar toArray_1        = toArray;\nvar repeat_1         = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1         = extend;\n\nvar common = {\n\tisNothing: isNothing_1,\n\tisObject: isObject_1,\n\ttoArray: toArray_1,\n\trepeat: repeat_1,\n\tisNegativeZero: isNegativeZero_1,\n\textend: extend_1\n};\n\n// YAML error class. http://stackoverflow.com/questions/8458984\n\n\nfunction formatError(exception, compact) {\n  var where = '', message = exception.reason || '(unknown reason)';\n\n  if (!exception.mark) return message;\n\n  if (exception.mark.name) {\n    where += 'in \"' + exception.mark.name + '\" ';\n  }\n\n  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n  if (!compact && exception.mark.snippet) {\n    where += '\\n\\n' + exception.mark.snippet;\n  }\n\n  return message + ' ' + where;\n}\n\n\nfunction YAMLException$1(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\n\n\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + ': ' + formatError(this, compact);\n};\n\n\nvar exception = YAMLException$1;\n\n// get snippet for a single line, respecting maxLength\nfunction getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n  var head = '';\n  var tail = '';\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n  if (position - lineStart > maxHalfLength) {\n    head = ' ... ';\n    lineStart = position - maxHalfLength + head.length;\n  }\n\n  if (lineEnd - position > maxHalfLength) {\n    tail = ' ...';\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n\n  return {\n    str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, '\u2192') + tail,\n    pos: position - lineStart + head.length // relative position\n  };\n}\n\n\nfunction padStart(string, max) {\n  return common.repeat(' ', max - string.length) + string;\n}\n\n\nfunction makeSnippet(mark, options) {\n  options = Object.create(options || null);\n\n  if (!mark.buffer) return null;\n\n  if (!options.maxLength) options.maxLength = 79;\n  if (typeof options.indent      !== 'number') options.indent      = 1;\n  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [ 0 ];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n\n  while ((match = re.exec(mark.buffer))) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n\n  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n  var result = '', i, line;\n  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n  for (i = 1; i <= options.linesBefore; i++) {\n    if (foundLineNo - i < 0) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n' + result;\n  }\n\n  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n    ' | ' + line.str + '\\n';\n  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n  for (i = 1; i <= options.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length) break;\n    line = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n  }\n\n  return result.replace(/\\n$/, '');\n}\n\n\nvar snippet = makeSnippet;\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'multi',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'representName',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type$1(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.options       = options; // keep original options in case user wants to extend this type later\n  this.tag           = tag;\n  this.kind          = options['kind']          || null;\n  this.resolve       = options['resolve']       || function () { return true; };\n  this.construct     = options['construct']     || function (data) { return data; };\n  this.instanceOf    = options['instanceOf']    || null;\n  this.predicate     = options['predicate']     || null;\n  this.represent     = options['represent']     || null;\n  this.representName = options['representName'] || null;\n  this.defaultStyle  = options['defaultStyle']  || null;\n  this.multi         = options['multi']         || false;\n  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nvar type = Type$1;\n\n/*eslint-disable max-len*/\n\n\n\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\n\n\nSchema$1.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n      throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type$1.multi) {\n      throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema$1.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nvar schema = Schema$1;\n\nvar str = new type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\nvar seq = new type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\nvar map = new type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nvar _null = new type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; },\n    empty:     function () { return '';     }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nvar bool = new type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'o') {\n      // base 8\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isOctCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n  }\n\n  // base 10 (except 0)\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  return true;\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch;\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nvar int = new type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nvar float = new type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\n\nvar core = json;\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nvar timestamp = new type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nvar merge = new type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n/*eslint-disable no-bitwise*/\n\n\n\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  return new Uint8Array(result);\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n}\n\nvar binary = new type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString$2.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nvar omap = new type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\nvar _toString$1 = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString$1.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nvar pairs = new type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty$2.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nvar set = new type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\n\n/*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\n// set a property of a literal object, while protecting against prototype pollution,\n// see https://github.com/nodeca/js-yaml/issues/164 for more details\nfunction setProperty(object, key, value) {\n  // used for this specific key only because Object.defineProperty is slow\n  if (key === '__proto__') {\n    Object.defineProperty(object, key, {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: value\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State$1(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || _default;\n  this.onWarning = options['onWarning'] || null;\n  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n  // if such documents have no explicit %YAML directive\n  this.legacy    = options['legacy']    || false;\n\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  // position of first leading tab in the current line,\n  // used to make sure there are no tabs in the indentation\n  this.firstTabInLine = -1;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  var mark = {\n    name:     state.filename,\n    buffer:   state.input.slice(0, -1), // omit trailing \\0\n    position: state.position,\n    line:     state.line,\n    column:   state.position - state.lineStart\n  };\n\n  mark.snippet = snippet(mark);\n\n  return new exception(message, mark);\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, 'tag prefix is malformed: ' + prefix);\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty$1.call(destination, key)) {\n      setProperty(destination, key, source[key]);\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n  startLine, startLineStart, startPos) {\n\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n        _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n\n    setProperty(_result, keyNode, valueNode);\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _lineStart,\n      _pos,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = Object.create(null),\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    } else if (ch === 0x2C/* , */) {\n      // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n      throwError(state, \"expected the node content, but found ','\");\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line; // Save the current line.\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _keyLine,\n      _keyLineStart,\n      _keyPos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = Object.create(null),\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  // there is a leading tab before this token, so it can't be a block sequence/mapping;\n  // it can still be flow sequence/mapping or a scalar\n  if (state.firstTabInLine !== -1) return false;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, 'tab characters must not be used in indentation');\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        // Neither implicit nor explicit notation.\n        // Reading is done. Go to the epilogue.\n        break;\n      }\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, 'tag name is malformed: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      typeList,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n\n  } else if (state.tag === '?') {\n    // Implicit resolving is not allowed for non-scalar types, and '?'\n    // non-specific tag is only automatically assigned to plain scalars.\n    //\n    // We only need to check kind conformity in case user explicitly assigns '?'\n    // tag, for example like this: \"!<?> [0]\"\n    //\n    if (state.result !== null && state.kind !== 'scalar') {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type = state.implicitTypes[typeIndex];\n\n      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        state.result = type.construct(state.result);\n        state.tag = type.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== '!') {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n    } else {\n      // looking for multi type\n      type = null;\n      typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n\n    if (!type) {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n\n    if (state.result !== null && type.kind !== state.kind) {\n      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n    }\n\n    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n    } else {\n      state.result = type.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = Object.create(null);\n  state.anchorMap = Object.create(null);\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State$1(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll$1(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load$1(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception('expected a single document in the stream, but found more');\n}\n\n\nvar loadAll_1 = loadAll$1;\nvar load_1    = load$1;\n\nvar loader = {\n\tloadAll: loadAll_1,\n\tload: load_1\n};\n\n/*eslint-disable no-use-before-define*/\n\n\n\n\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || _default;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn\u2019t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  \u21D2 ns-plain-safe-out\n//                             c = flow-in   \u21D2 ns-plain-safe-in\n//                             c = block-key \u21D2 ns-plain-safe-out\n//                             c = flow-key  \u21D2 ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - \u201C:\u201D - \u201C#\u201D )\n//                            | ( /* An ns-char preceding */ \u201C#\u201D )\n//                            | ( \u201C:\u201D /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( \u201C?\u201D | \u201C:\u201D | \u201C-\u201D ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // \u201C-\u201D | \u201C?\u201D | \u201C:\u201D | \u201C,\u201D | \u201C[\u201D | \u201C]\u201D | \u201C{\u201D | \u201C}\u201D\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | \u201C#\u201D | \u201C&\u201D | \u201C*\u201D | \u201C!\u201D | \u201C|\u201D | \u201C=\u201D | \u201C>\u201D | \u201C'\u201D | \u201C\"\u201D\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | \u201C%\u201D | \u201C@\u201D | \u201C`\u201D)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    \u2022 No ending newline => unaffected; already using strip \"-\" chomping.\n//    \u2022 Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth \u2264 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string) + '\"';\n      default:\n        throw new exception('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines\u2014\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new exception('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new exception('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | \u201C-\u201D\n      // [39] ns-uri-char     ::=  \u201C%\u201D ns-hex-digit ns-hex-digit | ns-word-char | \u201C#\u201D\n      //                         | \u201C;\u201D | \u201C/\u201D | \u201C?\u201D | \u201C:\u201D | \u201C@\u201D | \u201C&\u201D | \u201C=\u201D | \u201C+\u201D | \u201C$\u201D | \u201C,\u201D\n      //                         | \u201C_\u201D | \u201C.\u201D | \u201C!\u201D | \u201C~\u201D | \u201C*\u201D | \u201C'\u201D | \u201C(\u201D | \u201C)\u201D | \u201C[\u201D | \u201C]\u201D\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump$1(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nvar dump_1 = dump$1;\n\nvar dumper = {\n\tdump: dump_1\n};\n\nfunction renamed(from, to) {\n  return function () {\n    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n      'Use yaml.' + to + ' instead, which is now safe by default.');\n  };\n}\n\n\nvar Type                = type;\nvar Schema              = schema;\nvar FAILSAFE_SCHEMA     = failsafe;\nvar JSON_SCHEMA         = json;\nvar CORE_SCHEMA         = core;\nvar DEFAULT_SCHEMA      = _default;\nvar load                = loader.load;\nvar loadAll             = loader.loadAll;\nvar dump                = dumper.dump;\nvar YAMLException       = exception;\n\n// Re-export all types in case user wants to create custom schema\nvar types = {\n  binary:    binary,\n  float:     float,\n  map:       map,\n  null:      _null,\n  pairs:     pairs,\n  set:       set,\n  timestamp: timestamp,\n  bool:      bool,\n  int:       int,\n  merge:     merge,\n  omap:      omap,\n  seq:       seq,\n  str:       str\n};\n\n// Removed functions from JS-YAML 3.0.x\nvar safeLoad            = renamed('safeLoad', 'load');\nvar safeLoadAll         = renamed('safeLoadAll', 'loadAll');\nvar safeDump            = renamed('safeDump', 'dump');\n\nvar jsYaml = {\n\tType: Type,\n\tSchema: Schema,\n\tFAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n\tJSON_SCHEMA: JSON_SCHEMA,\n\tCORE_SCHEMA: CORE_SCHEMA,\n\tDEFAULT_SCHEMA: DEFAULT_SCHEMA,\n\tload: load,\n\tloadAll: loadAll,\n\tdump: dump,\n\tYAMLException: YAMLException,\n\ttypes: types,\n\tsafeLoad: safeLoad,\n\tsafeLoadAll: safeLoadAll,\n\tsafeDump: safeDump\n};\n\nexport { CORE_SCHEMA, DEFAULT_SCHEMA, FAILSAFE_SCHEMA, JSON_SCHEMA, Schema, Type, YAMLException, jsYaml as default, dump, load, loadAll, safeDump, safeLoad, safeLoadAll, types };\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport yaml from \"js-yaml\";\nimport { K8s, kind } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { reloadPods } from \"../reload/reload-utils\";\n\nexport const TENANT_GATEWAY_NAMESPACE = \"istio-tenant-gateway\";\nexport const ADMIN_GATEWAY_NAMESPACE = \"istio-admin-gateway\";\nexport const RESTART_REASON = \"Restarting Gateway Pods to apply new Istio configuration\";\n\nconst log = setupLogger(Component.OPERATOR_ISTIO);\n\ninterface IstioConfiguration {\n  defaultConfig?: {\n    gatewayTopology?: {\n      forwardClientCertDetails?: string;\n      numTrustedProxies?: number;\n    };\n  };\n}\n\nlet lastSeenMeshConfig: IstioConfiguration | undefined;\n\nexport async function restartGatewayPods(istioConfig: kind.ConfigMap): Promise<void> {\n  const mesh = istioConfig?.data?.[\"mesh\"];\n\n  if (mesh) {\n    const meshConfig = yaml.load(mesh) as IstioConfiguration;\n    if (\n      meshConfig.defaultConfig?.gatewayTopology?.numTrustedProxies !=\n        lastSeenMeshConfig?.defaultConfig?.gatewayTopology?.numTrustedProxies ||\n      meshConfig.defaultConfig?.gatewayTopology?.forwardClientCertDetails !=\n        lastSeenMeshConfig?.defaultConfig?.gatewayTopology?.forwardClientCertDetails\n    ) {\n      lastSeenMeshConfig = meshConfig;\n\n      const tenantGatewayPods = await K8s(kind.Pod).InNamespace(TENANT_GATEWAY_NAMESPACE).Get();\n      const adminGatewayPods = await K8s(kind.Pod).InNamespace(ADMIN_GATEWAY_NAMESPACE).Get();\n\n      log.info({ TENANT_GATEWAY_NAMESPACE }, \"Restarting {} pods to apply new configuration\");\n      await reloadPods(\n        TENANT_GATEWAY_NAMESPACE,\n        tenantGatewayPods.items,\n        RESTART_REASON,\n        log,\n        \"ConfigMapChanged\",\n      );\n\n      log.info({ ADMIN_GATEWAY_NAMESPACE }, \"Restarting {} pods to apply new configuration\");\n      await reloadPods(\n        ADMIN_GATEWAY_NAMESPACE,\n        adminGatewayPods.items,\n        RESTART_REASON,\n        log,\n        \"ConfigMapChanged\",\n      );\n    }\n  }\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Component, setupLogger } from \"../../../logger\";\n\nexport const KEYCLOAK_CLIENT_SECRET_KEY = \"uds-operator\";\n\nexport const KEYCLOAK_CLIENTS_SECRET_NAMESPACE = \"keycloak\";\nexport const KEYCLOAK_CLIENTS_SECRET_NAME = \"keycloak-client-secrets\";\n\nconst log = setupLogger(Component.OPERATOR_CONFIG);\n\n/**\n * Updates the Keycloak client secret in the provided config.\n * If the secret does not exist or forceRotation is true, a new secret is generated.\n * The secret is then applied to the Kubernetes cluster.\n *\n * @param {kind.Secret} config - The Kubernetes Secret object to update.\n * @param {boolean} [forceRotation=false] - Whether to force rotation of the secret.\n */\nexport async function updateKeycloakClientsSecret(\n  config: kind.Secret,\n  forceRotation: boolean = false,\n) {\n  config.data = config.data || {};\n\n  // This might be a bug but it seems Zarf adds managedFields, which is prohibited in Secrets.\n  delete config.metadata?.managedFields;\n\n  if (!config.data[KEYCLOAK_CLIENT_SECRET_KEY] || forceRotation) {\n    log.info(\"Generating new Keycloak client secret\");\n    config.data[KEYCLOAK_CLIENT_SECRET_KEY] = Buffer.from(uuidv4()).toString(\"base64\");\n    await K8s(kind.Secret).Apply(config);\n  }\n}\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import { randomFillSync } from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n", "import { randomUUID } from 'node:crypto';\nexport default { randomUUID };\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { PeprValidateRequest } from \"pepr\";\nimport { MatcherKind, Policy, UDSExemption } from \"..\";\nimport { UDSConfig } from \"../../controllers/config/config\";\n\nfunction checkForSlashes(name: string) {\n  return name[0] === \"/\" && name[name.length - 1] === \"/\";\n}\n\nconst validNs = \"uds-policy-exemptions\";\nconst kindToPolicyMap = new Map<MatcherKind, Policy[]>([\n  [\n    MatcherKind.Pod,\n    Object.values(Policy).filter(\n      p => p !== Policy.DisallowNodePortServices && p !== Policy.RestrictExternalNames,\n    ),\n  ],\n  [MatcherKind.Service, [Policy.RestrictExternalNames, Policy.DisallowNodePortServices]],\n]);\n\nexport async function exemptValidator(req: PeprValidateRequest<UDSExemption>) {\n  const exempt = req.Raw;\n  const exemptions = exempt.spec?.exemptions ?? [];\n\n  // Validate exemption namespace is uds-policy-exempts unless allowAllNSExemptions is true\n  if (!UDSConfig.allowAllNSExemptions) {\n    if (exempt.metadata?.namespace !== validNs) {\n      return req.Deny(\n        `Invalid namespace \"${exempt.metadata?.namespace}\" for UDSExemption ${exempt.metadata?.name}: must be \"${validNs}\"`,\n      );\n    }\n  }\n\n  // Validate exemption element policies and matcher kind are compatible\n  for (const e of exemptions) {\n    const policies = kindToPolicyMap.get(e.matcher.kind!)!;\n    for (const p of e.policies) {\n      if (!policies.includes(p)) {\n        const validKind =\n          e.matcher.kind === MatcherKind.Pod ? MatcherKind.Service : MatcherKind.Pod;\n        return req.Deny(\n          `Invalid kind \"${e.matcher.kind}\" for matcher \"${e.matcher.name}\" with policy \"${p}\": \"${p}\" can only be exempted for kind \"${validKind}\"`,\n        );\n      }\n    }\n  }\n\n  // Validate that each matcher name does not contain leading or trailing slashes and is a valid regex pattern\n  for (const e of exemptions) {\n    if (checkForSlashes(e.matcher.name)) {\n      return req.Deny(\n        `Invalid matcher name \"${e.matcher.name}\": please remove the leading and trailing slashes`,\n      );\n    }\n\n    try {\n      new RegExp(e.matcher.name);\n    } catch (err) {\n      return req.Deny(`Invalid regular expression pattern ${e.matcher.name}: ${err}`);\n    }\n  }\n\n  return req.Approve();\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\n\nimport { GenericKind } from \"kubernetes-fluent-client\";\nimport { Component, setupLogger } from \"../../logger\";\nimport { Phase, PkgStatus, UDSPackage } from \"../crd\";\nimport { buildMigratedAuthserviceStatus } from \"../crd/migrate\";\nimport {\n  AuthserviceClient,\n  StatusObject as Status,\n  StatusEnum,\n} from \"../crd/generated/package-v1alpha1\";\n\nexport const uidSeen = new Set<string>();\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_RECONCILERS);\n\n/**\n * Checks if the CRD is pending or the current generation has been processed\n *\n * @param cr The custom resource to check\n * @returns true if the CRD is removing, pending, or the current generation has already been processed\n */\nexport function shouldSkip(cr: UDSPackage) {\n  const isRetrying = cr.status?.phase === Phase.Retrying;\n  const isPending = cr.status?.phase === Phase.Pending;\n  // Check for status removing OR a deletion timestamp present\n  const isRemoving =\n    cr.metadata?.deletionTimestamp ||\n    cr.status?.phase === Phase.Removing ||\n    cr.status?.phase === Phase.RemovalFailed;\n  const isCurrentGeneration = cr.metadata?.generation === cr.status?.observedGeneration;\n\n  // First check if the CR has been seen before and return false if it has not\n  // This ensures that all CRs are processed at least once by this version of pepr-core\n  if (!uidSeen.has(cr.metadata!.uid!)) {\n    log.trace(cr, `Should skip? No, first time processed during this pod's lifetime`);\n    return false;\n  }\n\n  // If the CR is retrying, it should not be skipped\n  if (isRetrying) {\n    log.debug(cr, `Should skip? No, retrying`);\n    return false;\n  }\n\n  // If the CR is removing, it should be skipped\n  if (isRemoving) {\n    log.debug(cr, `Should skip? Yes, removing`);\n    return true;\n  }\n\n  // This is the second time the CR has been seen, so check if it is pending or the current generation\n  if (isPending || isCurrentGeneration) {\n    log.trace(cr, `Should skip? Yes, pending or current generation and not first time seen`);\n    return true;\n  }\n\n  log.trace(cr, `Should skip? No, not pending or current generation and not first time seen`);\n\n  return false;\n}\n\n/**\n * Updates the status of the package\n *\n * @param cr The custom resource to update\n * @param status The new status\n */\nexport async function updateStatus(cr: UDSPackage, status: PkgStatus) {\n  log.debug(`Updating ${cr.metadata?.name}/${cr.metadata?.namespace} status to ${status.phase}`);\n\n  // Migrate legacy fields before patching status to satisfy CRD validation\n  // Specifically, older packages stored authserviceClients as string[]; new schema expects object[]\n  const migratedStatus: PkgStatus & { authserviceClients?: AuthserviceClient[] } = { ...status };\n  const normalized = buildMigratedAuthserviceStatus(cr);\n  if (normalized) {\n    migratedStatus.authserviceClients = normalized;\n  }\n\n  // Update the status of the CRD\n  await K8s(UDSPackage).PatchStatus({\n    metadata: {\n      name: cr.metadata!.name,\n      namespace: cr.metadata!.namespace,\n    },\n    status: migratedStatus,\n  });\n\n  // Track the UID of the CRD to know if it has been seen before\n  uidSeen.add(cr.metadata!.uid!);\n}\n\n/**\n * Write a K8s event for the CRD\n *\n * @param cr The custom resource to write the event for\n * @param message A human-readable message for the event\n * @param type The type of event to write\n */\nexport async function writeEvent(cr: GenericKind, event: Partial<kind.CoreEvent>) {\n  log.debug(`Writing ${cr.metadata?.name}/${cr.metadata?.namespace} event: ${event.message}`);\n\n  await K8s(kind.CoreEvent).Create({\n    type: \"Warning\",\n    reason: \"ReconciliationFailed\",\n    ...event,\n    // Fixed values\n    metadata: {\n      namespace: cr.metadata!.namespace,\n      generateName: cr.metadata!.name,\n    },\n    involvedObject: {\n      apiVersion: cr.apiVersion,\n      kind: cr.kind,\n      name: cr.metadata!.name,\n      namespace: cr.metadata!.namespace,\n      uid: cr.metadata!.uid,\n    },\n    firstTimestamp: new Date(),\n    reportingComponent: \"uds.dev/operator\",\n    reportingInstance: process.env.HOSTNAME,\n  });\n}\n\n/**\n * Handles a failure by updating the status of the CRD and writing an event\n *\n * @param err The error-like object\n * @param cr The custom resource that failed\n */\nexport async function handleFailure(\n  err: { status: number; message: string; data?: { message?: string; reason?: string } },\n  cr: UDSPackage,\n) {\n  const metadata = cr.metadata!;\n  const identifier = `${metadata.namespace}/${metadata.name}`;\n  let status: Status;\n\n  // todo: identify exact 404 we are targeting, possibly in `updateStatus`\n  if (err.status === 404) {\n    log.warn({ err }, `Package metadata seems to have been deleted`);\n    return;\n  }\n\n  // Extract the most detailed error message available\n  const detailedMessage = err.data?.message || err.message;\n\n  const retryAttempt = cr.status?.retryAttempt || 0;\n\n  // retryAttempt starts at 0, we perform 4 retries, 5 total attempts\n  if (retryAttempt < 4) {\n    const currRetry = retryAttempt + 1;\n    log.error({ err }, `Reconciliation attempt ${currRetry} failed for ${identifier}, retrying...`);\n\n    status = {\n      phase: Phase.Retrying,\n      conditions: getReadinessConditions(false),\n      retryAttempt: currRetry,\n    };\n  } else {\n    log.error({ err }, `Error configuring ${identifier}, maxed out retries`);\n\n    status = {\n      phase: Phase.Failed,\n      conditions: getReadinessConditions(false),\n      observedGeneration: metadata.generation,\n      retryAttempt: 0, // todo: make this nullable when kfc generates the type\n    };\n  }\n\n  // Write an event for the error with the most detailed message available\n  await writeEvent(cr, { message: detailedMessage });\n\n  // Update the status of the package with the error\n  updateStatus(cr, status).catch(finalErr => {\n    // If the status update fails, write log the error and and try to write an event\n    log.error({ err: finalErr }, `Error updating status for ${identifier} failed`);\n    void writeEvent(cr, { message: finalErr.message });\n  });\n}\n\nexport function getReadinessConditions(ready: boolean = true) {\n  return [\n    {\n      type: \"Ready\",\n      status: ready === true ? StatusEnum.True : StatusEnum.False,\n      lastTransitionTime: new Date(),\n      message:\n        ready === true ? \"The package is ready for use.\" : \"The package is not ready for use.\",\n      reason: \"ReconciliationComplete\",\n    },\n  ];\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind, R } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { UDSPackage } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_ISTIO);\n\nconst INJECTION_LABEL = \"istio-injection\";\nconst AMBIENT_LABEL = \"istio.io/dataplane-mode\";\nconst ISTIO_STATE_ANNOTATION = \"uds.dev/original-istio-state\";\n\nexport enum IstioState {\n  Sidecar = Mode.Sidecar,\n  Ambient = Mode.Ambient,\n  None = \"none\",\n}\n\n/**\n * Determine the proper istio mode (ambient or sidecar) and enable for the package namespace\n *\n * @param pkg\n * @returns string mode\n */\nexport async function enableIstio(pkg: UDSPackage) {\n  // This should be impossible in practice but added here so that we can assume these are defined in the rest of the function\n  // The types for the GenericKind here allow metadata to be undefined technically\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n\n  const sourceNS = await K8s(kind.Namespace).Get(pkg.metadata.namespace);\n  const labels = { ...(sourceNS.metadata?.labels || {}) };\n  const annotations = { ...(sourceNS.metadata?.annotations || {}) };\n  const pkgKey = `uds.dev/pkg-${pkg.metadata.name}`;\n  const currentIstioState = getCurrentIstioState(labels);\n\n  // Mark the original namespace istio setting for if packages are removed\n  if (!annotations[ISTIO_STATE_ANNOTATION]) {\n    annotations[ISTIO_STATE_ANNOTATION] = currentIstioState;\n  }\n\n  let targetIstioState = IstioState.None;\n  annotations[pkgKey] = \"true\";\n\n  // Handle labels based on ambient opt-in or sidecar default\n  if (pkg.spec?.network?.serviceMesh?.mode === Mode.Ambient) {\n    // Ambient mode requested\n    targetIstioState = IstioState.Ambient;\n  } else {\n    // Sidecar mode requested/by default\n    targetIstioState = IstioState.Sidecar;\n  }\n\n  const result = getIstioLabels(labels, targetIstioState, currentIstioState);\n\n  // Apply namespace updates and restart pods if needed\n  await applyNamespaceUpdates(\n    pkg.metadata.namespace,\n    result.labels,\n    annotations,\n    sourceNS.metadata?.labels,\n    sourceNS.metadata?.annotations,\n  );\n\n  await restartPodsIfNeeded(pkg.metadata.namespace, result.shouldRestartPods, targetIstioState);\n}\n\n/**\n * Cleanup the namespace by removing Istio labels if there are no remaining packages\n * Or adjust the Istio mode if existing packages change it\n *\n * @param pkg the package to cleanup\n */\nexport async function cleanupNamespace(pkg: UDSPackage) {\n  if (!pkg.metadata?.namespace || !pkg.metadata.name) {\n    throw new Error(`Invalid Package definition, missing namespace or name`);\n  }\n\n  const sourceNS = await K8s(kind.Namespace).Get(pkg.metadata.namespace);\n  const labels = { ...(sourceNS.metadata?.labels || {}) };\n  const annotations = { ...(sourceNS.metadata?.annotations || {}) };\n  const currentState = getCurrentIstioState(labels);\n  const originalIstioState = annotations[ISTIO_STATE_ANNOTATION] as IstioState;\n\n  // Remove the package annotation\n  delete annotations[`uds.dev/pkg-${pkg.metadata.name}`];\n\n  // Check if there are any other package annotations\n  // Backwards compatibility for multiple package CRs in a single namespace\n  const hasOtherPackages = Object.keys(annotations).some(key => key.startsWith(\"uds.dev/pkg-\"));\n\n  // Only modify Istio labels if this is the last package\n  let result;\n  if (hasOtherPackages) {\n    // Keep existing labels if other packages are still present, don't cycle pods/change istio state\n    result = { labels, shouldRestartPods: false };\n  } else {\n    // Set labels based on the original state and determine if pods need to be restarted\n    result = getIstioLabels(labels, originalIstioState, currentState);\n\n    // Delete the annotation since we're restoring to original state\n    delete annotations[ISTIO_STATE_ANNOTATION];\n  }\n\n  // Apply the updated Namespace\n  await applyNamespaceUpdates(\n    pkg.metadata.namespace,\n    result.labels,\n    annotations,\n    sourceNS.metadata?.labels,\n    sourceNS.metadata?.annotations,\n    `Updating namespace ${pkg.metadata.namespace}, removing ${pkg.metadata.name} state.`,\n  );\n\n  // Restart pods if needed\n  await restartPodsIfNeeded(pkg.metadata.namespace, result.shouldRestartPods, originalIstioState);\n}\n\n/**\n * Forces deletion of pods with the incorrect istio sidecar state\n *\n * @param ns The namespace to target\n * @param wantSidecar Whether injection is being enabled\n */\nexport async function killPods(ns: string, wantSidecar: boolean) {\n  // Get all pods in the namespace\n  const pods = await K8s(kind.Pod).InNamespace(ns).Get();\n  const groups: Record<string, kind.Pod[]> = {};\n\n  // Group the pods by owner UID\n  for (const pod of pods.items) {\n    // Ignore pods that already have a deletion timestamp\n    if (pod.metadata?.deletionTimestamp) {\n      log.debug(`Ignoring Pod ${ns}/${pod.metadata?.name}, already being deleted`);\n      continue;\n    }\n\n    // Checks both container (haven't switched to native sidecars yet) and initContainers for native sidecars\n    const foundSidecar =\n      pod.spec?.containers?.some(c => c.name === \"istio-proxy\") ||\n      pod.spec?.initContainers?.some(c => c.name === \"istio-proxy\");\n\n    // If enabling injection, ignore pods that already have the istio sidecar\n    if (wantSidecar && foundSidecar) {\n      log.debug(`Ignoring Pod ${ns}/${pod.metadata?.name}, already has sidecar`);\n      continue;\n    }\n\n    // If disabling injection, ignore pods that don't have the istio sidecar\n    if (!wantSidecar && !foundSidecar) {\n      log.debug(`Ignoring Pod ${ns}/${pod.metadata?.name}, injection disabled`);\n      continue;\n    }\n\n    // Get the UID of the owner of the pod or default to \"other\" (shouldn't happen)\n    const controlledBy = pod.metadata?.ownerReferences?.find(ref => ref.controller)?.uid || \"other\";\n    groups[controlledBy] = groups[controlledBy] || [];\n    log.debug(`Adding Pod ${ns}/${pod.metadata?.name} to ${controlledBy} deletion list.`);\n    groups[controlledBy].push(pod);\n  }\n\n  // Delete each group of pods\n  for (const group of Object.values(groups)) {\n    // If this is a statefulset, delete the pods in reverse name order\n    if (group[0].metadata?.ownerReferences?.find(ref => ref.kind === \"StatefulSet\")) {\n      group.sort((a, b) => (b.metadata?.name || \"\").localeCompare(a.metadata?.name || \"\"));\n    }\n\n    for (const pod of group) {\n      const action = wantSidecar ? \"enable\" : \"remove\";\n      log.info(`Deleting pod ${ns}/${pod.metadata?.name} to ${action} the istio sidecar`);\n      await K8s(kind.Pod).Delete(pod);\n    }\n  }\n}\n\n/**\n * Get the current Istio state of a namespace based on its labels\n *\n * @param labels The namespace labels\n * @returns The current Istio state\n */\nexport function getCurrentIstioState(labels: Record<string, string>): IstioState {\n  return labels[INJECTION_LABEL] === \"enabled\"\n    ? IstioState.Sidecar\n    : labels[AMBIENT_LABEL] === \"ambient\"\n      ? IstioState.Ambient\n      : IstioState.None;\n}\n\n/**\n * Apply namespace updates if there are changes to labels or annotations\n *\n * @param namespace The namespace name\n * @param labels The updated labels\n * @param annotations The updated annotations\n * @param originalLabels The original labels\n * @param originalAnnotations The original annotations\n * @param logMessage Optional log message\n * @returns Whether updates were applied\n */\nexport async function applyNamespaceUpdates(\n  namespace: string,\n  labels: Record<string, string>,\n  annotations: Record<string, string>,\n  originalLabels: Record<string, string> | undefined,\n  originalAnnotations: Record<string, string> | undefined,\n  logMessage?: string,\n): Promise<boolean> {\n  const updatedNamespace = {\n    metadata: {\n      name: namespace,\n      labels,\n      annotations,\n    },\n  };\n\n  if (!R.equals(originalLabels, labels) || !R.equals(originalAnnotations, annotations)) {\n    log.debug(logMessage || `Applying updates to namespace ${namespace}.`);\n    await K8s(kind.Namespace).Apply(updatedNamespace, { force: true });\n    return true;\n  } else {\n    log.debug(`No namespace updates needed for ${namespace}.`);\n    return false;\n  }\n}\n\n/**\n * Restart pods if the Istio state has changed\n *\n * @param namespace The namespace name\n * @param shouldRestart Whether pods should be restarted\n * @param istioState The target Istio state\n */\nasync function restartPodsIfNeeded(\n  namespace: string,\n  shouldRestart: boolean,\n  targetIstioState: IstioState,\n): Promise<void> {\n  if (shouldRestart) {\n    log.debug(\n      `Restarting pods in ${namespace} due to configuration changes (switching to ${targetIstioState} Istio state)`,\n    );\n    if (targetIstioState === IstioState.Sidecar) {\n      await killPods(namespace, true);\n    } else if (targetIstioState === IstioState.Ambient || targetIstioState === IstioState.None) {\n      await killPods(namespace, false);\n    }\n  }\n}\n\n/**\n * Gets the appropriate Istio labels based on the target state and determines if pods need to be restarted\n *\n * @param labels The current labels\n * @param targetState The target Istio state\n * @param currentState The current Istio state\n * @returns Updated labels and whether pods should be restarted\n */\nexport function getIstioLabels(\n  labels: Record<string, string>,\n  targetState: IstioState,\n  currentState: IstioState,\n): { labels: Record<string, string>; shouldRestartPods: boolean } {\n  let shouldRestartPods = false;\n\n  if (targetState === IstioState.Sidecar) {\n    labels[INJECTION_LABEL] = \"enabled\";\n    delete labels[AMBIENT_LABEL];\n    // Add sidecar if not present or coming from ambient\n    if (currentState !== IstioState.Sidecar) {\n      shouldRestartPods = true;\n    }\n  } else if (targetState === IstioState.Ambient) {\n    labels[AMBIENT_LABEL] = \"ambient\";\n    delete labels[INJECTION_LABEL];\n    // Remove sidecar if present\n    if (currentState === IstioState.Sidecar) {\n      shouldRestartPods = true;\n    }\n  } else {\n    // None state - remove all Istio labels\n    delete labels[INJECTION_LABEL];\n    delete labels[AMBIENT_LABEL];\n    // Remove sidecar if present\n    if (currentState === IstioState.Sidecar) {\n      shouldRestartPods = true;\n    }\n  }\n\n  return { labels, shouldRestartPods };\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { fetch, K8s, kind } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../logger\";\nimport { Sso, UDSPackage } from \"../../crd\";\nimport { getOwnerRef, purgeOrphans, sanitizeResourceName } from \"../utils\";\nimport { credentialsCreateOrUpdate, credentialsDelete } from \"./clients/client-credentials\";\nimport { Client, clientKeys } from \"./types\";\n\nconst samlDescriptorUrl =\n  \"http://keycloak-http.keycloak.svc.cluster.local:8080/realms/uds/protocol/saml/descriptor\";\n\n// Template regex to match clientField() references, see https://regex101.com/r/e41Dsk/3 for details\nconst secretTemplateRegex = new RegExp(\n  'clientField\\\\(([a-zA-Z]+)\\\\)(?:\\\\[\"?([\\\\w]+)\"?\\\\]|(\\\\.json\\\\(\\\\)))?',\n  \"gm\",\n);\n\n// Template regex to match IDPSSODescriptor in the SAML IDP Descriptor XML, see https://regex101.com/r/DGvzjd/1\nconst idpSSODescriptorRegex = new RegExp(\n  /<[^>]*:IDPSSODescriptor[^>]*>((.|[\\n\\r])*)<\\/[^>]*:IDPSSODescriptor>/,\n);\n\n// Template regex to match the X509Certificate within the IDPSSODescriptor XML, see https://regex101.com/r/NjGZF5/1\nconst x509CertRegex = new RegExp(\n  /<[^>]*:X509Certificate[^>]*>((.|[\\n\\r])*)<\\/[^>]*:X509Certificate>/,\n);\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_KEYCLOAK);\n\n/**\n * Create or update the Keycloak clients for the package\n *\n * @param pkg the package to process\n *\n * @returns the list of client refs\n */\nexport async function keycloak(pkg: UDSPackage) {\n  // Get the list of clients from the package\n  const clientReqs = pkg.spec?.sso || [];\n  const clients: Map<string, Client> = new Map();\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n\n  for (const clientReq of clientReqs) {\n    const client = await syncClient(clientReq, pkg);\n    clients.set(client.clientId, client);\n  }\n\n  // Purge orphaned clients\n  try {\n    await purgeSSOClients(pkg, [...clients.keys()]);\n  } catch (e) {\n    log.error(e, `Failed to purge orphaned clients in for ${pkg.metadata!.name!}: ${e}`);\n  }\n\n  // Purge orphaned SSO secrets\n  try {\n    await purgeOrphans(generation, pkg.metadata!.namespace!, pkg.metadata!.name!, kind.Secret, log);\n  } catch (e) {\n    log.error(e, `Failed to purge orphaned SSO secrets in for ${pkg.metadata!.name!}: ${e}`);\n  }\n\n  return clients;\n}\n\n/**\n * Remove any remaining clients that are not in the refs list\n *\n * @param pkg the package to process\n * @param refs the list of client refs to keep\n */\nexport async function purgeSSOClients(pkg: UDSPackage, newClients: string[] = []) {\n  // Check for any clients that are no longer in the package and remove them\n  const currentClients = pkg.status?.ssoClients || [];\n  const toRemove = currentClients.filter(client => !newClients.includes(client));\n  for (const ref of toRemove) {\n    try {\n      await credentialsDelete({ clientId: ref });\n    } catch (err) {\n      log.warn(\n        pkg.metadata,\n        `Failed to remove client ${ref}, package ${pkg.metadata?.namespace}/${pkg.metadata?.name}. Error: ${err.message}`,\n      );\n      throw new Error(\n        `Failed to remove client ${ref}, package ${pkg.metadata?.namespace}/${pkg.metadata?.name}. Error: ${err.message}`,\n      );\n    }\n  }\n}\n\n/**\n * Need to convert the SSO object into a Client Object to avoid\n * passing groups to keycloak and attributes to the package.sso\n * @param sso\n * @returns\n */\nexport function convertSsoToClient(sso: Partial<Sso>): Client {\n  const client: Partial<Client> = {};\n\n  // Iterate over the properties of Client and check if they exist in sso\n  for (const key of clientKeys) {\n    if (key in sso) {\n      (client as Record<string, unknown>)[key] = sso[key as keyof Sso];\n    }\n  }\n\n  // Group auth based on sso group membership\n  client.attributes = client.attributes || {};\n\n  if (sso.groups?.anyOf) {\n    client.attributes[\"uds.core.groups\"] = JSON.stringify(sso.groups);\n  } else {\n    client.attributes[\"uds.core.groups\"] = \"\";\n  }\n\n  // Assert that the result conforms to Client type\n  return client as Client;\n}\n\nexport async function syncClient(\n  { secretName, secretTemplate, ...clientReq }: Sso,\n  pkg: UDSPackage,\n  isRetry = false,\n) {\n  log.debug(pkg.metadata, `Processing client request: ${clientReq.clientId}`);\n\n  // Not including the CR data in the ref because Keycloak client IDs must be unique already\n  const name = `sso-client-${clientReq.clientId}`;\n  let client = convertSsoToClient(clientReq);\n\n  try {\n    client = await credentialsCreateOrUpdate(client);\n  } catch (err) {\n    const msg =\n      `Failed to process Keycloak request for client '${client.clientId}', package ` +\n      `${pkg.metadata?.namespace}/${pkg.metadata?.name}. Error: ${err.message}`;\n\n    // Throw the error if this is the retry or was an initial client creation attempt\n    if (isRetry) {\n      log.error(`${msg}, retry failed.`);\n      // Throw the original error captured from the first attempt\n      throw new Error(msg);\n    } else {\n      // Retry the request in case it is an intermittent failure\n      log.error(`${msg}, retrying...`);\n\n      try {\n        // Ensure we pass the same inputs bass to this function, including the secret name/template\n        return await syncClient({ secretName, secretTemplate, ...clientReq }, pkg, true);\n      } catch (retryErr) {\n        // If the retry fails, log the retry error and throw the original error\n        const retryMsg =\n          `Retry of Keycloak request failed for client '${client.clientId}', package ` +\n          `${pkg.metadata?.namespace}/${pkg.metadata?.name}. Error: ${retryErr.message}`;\n        log.error(retryMsg);\n        // Throw the error from the original attempt since our retry failed\n        throw new Error(msg);\n      }\n    }\n  }\n\n  // Remove the registrationAccessToken from the client object to avoid problems (one-time use token)\n  delete client.registrationAccessToken;\n\n  if (client.protocol === \"saml\") {\n    client.samlIdpCertificate = await getSamlCertificate();\n  }\n\n  // Create or update the client secret\n  if (!client.publicClient) {\n    const generation = (pkg.metadata?.generation ?? 0).toString();\n    const sanitizedSecretName = sanitizeResourceName(secretName || name);\n\n    // Prepare default labels\n    const secretLabels: Record<string, string> = {\n      \"uds/package\": pkg.metadata!.name || \"\",\n      \"uds/generation\": generation,\n    };\n\n    // Apply any additional user-defined labels from the CRD\n    if (clientReq.secretLabels) {\n      Object.assign(secretLabels, clientReq.secretLabels);\n    }\n\n    // Prepare annotations if defined in the CRD\n    const secretAnnotations: Record<string, string> = {};\n\n    // Apply any user-defined annotations from the CRD\n    if (clientReq.secretAnnotations) {\n      Object.assign(secretAnnotations, clientReq.secretAnnotations);\n    }\n\n    await K8s(kind.Secret).Apply({\n      metadata: {\n        namespace: pkg.metadata!.namespace,\n        // Use the CR secret name if provided, otherwise use the client name\n        name: sanitizedSecretName,\n        labels: secretLabels,\n        annotations: secretAnnotations,\n\n        // Use the CR as the owner ref for each VirtualService\n        ownerReferences: getOwnerRef(pkg),\n      },\n      data: generateSecretData(client, secretTemplate),\n    });\n  }\n\n  return client;\n}\n\nexport function generateSecretData(client: Client, secretTemplate?: { [key: string]: string }) {\n  if (secretTemplate) {\n    log.debug(`Using secret template for client: ${client.clientId}`);\n    // Iterate over the secret template entry and process each value\n    return templateData(secretTemplate, client);\n  }\n\n  const stringMap: Record<string, string> = {};\n\n  log.debug(`Using client data for secret: ${client.clientId}`);\n\n  // iterate over the client object and convert all values to strings\n  for (const [key, value] of Object.entries(client)) {\n    // For objects and arrays, convert to a JSON string\n    const processed = typeof value === \"object\" ? JSON.stringify(value) : String(value);\n\n    // Convert the value to a base64 encoded string\n    stringMap[key] = Buffer.from(processed).toString(\"base64\");\n  }\n\n  return stringMap;\n}\n\nexport async function getSamlCertificate() {\n  const resp = await fetch<string>(samlDescriptorUrl);\n\n  if (!resp.ok) {\n    return undefined;\n  }\n\n  return extractSamlCertificateFromXML(resp.data);\n}\n\nexport function extractSamlCertificateFromXML(xmlString: string) {\n  const extractedIDPSSODescriptor = xmlString.match(idpSSODescriptorRegex)?.[1] || \"\";\n  return extractedIDPSSODescriptor.match(x509CertRegex)?.[1] || \"\";\n}\n\n/**\n * Process the secret template and convert the client data to base64 encoded strings for use in a secret\n *\n * @param secretTemplate The template to use for generating the secret\n * @param client\n * @returns\n */\nfunction templateData(secretTemplate: { [key: string]: string }, client: Client) {\n  const stringMap: Record<string, string> = {};\n\n  // Iterate over the secret template and process each entry\n  for (const [key, value] of Object.entries(secretTemplate)) {\n    // Replace any clientField() references with the actual client data\n    const templated = value.replace(\n      secretTemplateRegex,\n      (_match, fieldName: keyof Client, key, json) => {\n        // Make typescript happy with a more generic type\n        const value = client[fieldName] as Record<string | number, string> | string;\n\n        // If a key is provided, use it to get the value\n        if (key) {\n          return String(value[key] ?? \"\");\n        }\n\n        // If .json() is provided, convert the value to a JSON string\n        if (json) {\n          return JSON.stringify(value);\n        }\n\n        // Otherwise, convert the value to a string\n        return value !== undefined ? String(value) : \"\";\n      },\n    );\n\n    // Convert the templated value to a base64 encoded string\n    stringMap[key] = Buffer.from(templated).toString(\"base64\");\n  }\n\n  // Return the processed secret template without any further processing\n  return stringMap;\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { fetch, K8s, kind } from \"pepr\";\nimport { Client } from \"../types\";\nimport { baseUrl, log, throwErrorIfNeeded } from \"./common\";\n\nexport interface ClientWithId extends Client {\n  id: string;\n}\n\nexport interface KeycloakAccessTokenResponse {\n  access_token: string;\n}\n\nexport function parseKeycloakToken(token: string) {\n  return JSON.parse(Buffer.from(token.split(\".\")[1], \"base64\").toString()) as KeycloakToken;\n}\n\nconst clientsAdminUrl = `${baseUrl}/admin/realms/uds/clients`;\nconst clientCredentialsUrl = `${baseUrl}/realms/uds/protocol/openid-connect/token`;\nconst SECRET_NAMESPACE = \"keycloak\";\nconst SECRET_NAME = \"keycloak-client-secrets\";\nconst UDS_OPERATOR_CLIENT_ID = \"uds-operator\";\nlet cachedToken: string | null = null;\n\nexport interface KeycloakToken {\n  exp: number;\n  resource_access: {\n    \"realm-management\": {\n      roles: string[];\n    };\n    [key: string]: unknown;\n  };\n\n  [key: string]: unknown;\n}\n\nexport function resetCachedToken() {\n  cachedToken = null;\n}\n\nexport async function credentialsGetAccessToken() {\n  if (cachedToken) {\n    try {\n      const jwt = parseKeycloakToken(cachedToken);\n      if (jwt.exp && jwt.exp > Math.floor(Date.now() / 1000) + 5) return cachedToken;\n    } catch (e) {\n      log.error(e, \"Failed to parse cached token\");\n      cachedToken = null;\n    }\n  }\n\n  const secret = await K8s(kind.Secret).InNamespace(SECRET_NAMESPACE).Get(SECRET_NAME);\n  if (!secret) throw new Error(\"Missing secret\");\n  const encodedSecret = secret.data?.[UDS_OPERATOR_CLIENT_ID];\n  if (!encodedSecret) throw new Error(\"Missing client secret\");\n\n  const clientSecret = Buffer.from(encodedSecret, \"base64\").toString(\"utf-8\");\n  const params = new URLSearchParams();\n  params.append(\"grant_type\", \"client_credentials\");\n  params.append(\"client_id\", UDS_OPERATOR_CLIENT_ID);\n  params.append(\"client_secret\", clientSecret);\n\n  const response = await fetch<KeycloakAccessTokenResponse>(clientCredentialsUrl, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n    body: params.toString(),\n  });\n  await throwErrorIfNeeded(response);\n  cachedToken = response.data.access_token;\n  return cachedToken;\n}\n\nexport async function credentialsCreateOrUpdate(client: Partial<Client>) {\n  log.info(`credentialsCreateOrUpdate: creating/updating client ${JSON.stringify(client)}`);\n  const existingClient = await credentialsGet(client);\n  if (existingClient) {\n    return credentialsUpdate(client);\n  } else {\n    return credentialsCreate(client);\n  }\n}\n\nexport async function credentialsCreate(client: Partial<Client>) {\n  log.info(`credentialsCreate: creating client ${JSON.stringify(client)}`);\n  const token = await credentialsGetAccessToken();\n  const response = await fetch(clientsAdminUrl, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${token}` },\n    body: JSON.stringify(client),\n  });\n  await throwErrorIfNeeded(response, () => {\n    resetCachedToken();\n  });\n  return credentialsGet(client);\n}\n\nexport async function credentialsGet(client: Partial<Client>) {\n  log.info(`credentialsGet: retrieving client ${JSON.stringify(client)}`);\n  const token = await credentialsGetAccessToken();\n  const url = `${clientsAdminUrl}?clientId=${encodeURIComponent(client.clientId!)}`;\n  // There's no Client GET REST endpoint that obtains a client based on client_id (the logical client name, like uds-operator).\n  // All Admin REST endpoints for client operator on the database Client ID, which is a UUID. The only interface that allows to\n  // obtain the Client using the client_id is the collection interface which returns a singular collection with\n  // the Client in it.\n  const response = await fetch<ClientWithId[]>(url, {\n    method: \"GET\",\n    headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${token}` },\n  });\n  await throwErrorIfNeeded(response, () => {\n    resetCachedToken();\n  });\n  return response.data[0];\n}\n\nexport async function credentialsUpdate(client: Partial<Client>) {\n  log.info(`credentialsUpdate: updating client ${JSON.stringify(client)}`);\n  const token = await credentialsGetAccessToken();\n  const existing = await credentialsGet(client);\n  if (!existing || !existing.id) {\n    throw new Error(`Failed to retrieve existing client, ${client.clientId}`);\n  }\n  const url = `${clientsAdminUrl}/${encodeURIComponent(existing.id)}`;\n  const response = await fetch(url, {\n    method: \"PUT\",\n    headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${token}` },\n    body: JSON.stringify(client),\n  });\n  await throwErrorIfNeeded(response, () => {\n    resetCachedToken();\n  });\n  return credentialsGet(client);\n}\n\nexport async function credentialsDelete(client: Partial<Client>) {\n  log.info(`credentialsDelete: deleting client ${JSON.stringify(client)}`);\n  const token = await credentialsGetAccessToken();\n  const existing = await credentialsGet(client);\n  if (!existing || !existing.id) {\n    throw new Error(`Failed to retrieve existing client, ${client.clientId}`);\n  }\n  const url = `${clientsAdminUrl}/${encodeURIComponent(existing.id)}`;\n  const response = await fetch(url, {\n    method: \"DELETE\",\n    headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${token}` },\n  });\n  await throwErrorIfNeeded(response, () => {\n    resetCachedToken();\n  });\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Component, setupLogger } from \"../../../../logger\";\n\nexport let baseUrl = \"http://keycloak-http.keycloak.svc.cluster.local:8080\";\n// Support dev mode with port-forwarded keycloak svc\nif (process.env.PEPR_MODE === \"dev\") {\n  baseUrl = \"http://localhost:8080\";\n}\n\nexport const log = setupLogger(Component.OPERATOR_KEYCLOAK);\n\nexport interface RestResponse {\n  ok: boolean;\n  status: number;\n  statusText: string;\n  data: unknown;\n}\n\nexport async function throwErrorIfNeeded(response: RestResponse, onError?: (error: Error) => void) {\n  if (!response.ok) {\n    const { status, statusText, data } = response;\n    const err = new Error(`${status}, ${statusText}, ${data ? JSON.stringify(data) : \"\"}`);\n    if (onError) {\n      onError(err);\n    }\n    throw err;\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { ProtocolMapper } from \"../../crd/generated/package-v1alpha1\";\n\nexport interface Client {\n  alwaysDisplayInConsole: boolean;\n  attributes: Record<string, string>;\n  authenticationFlowBindingOverrides: Record<string, string>;\n  bearerOnly: boolean;\n  clientAuthenticatorType: string;\n  clientId: string;\n  consentRequired: boolean;\n  defaultClientScopes: string[];\n  defaultRoles: string[];\n  directAccessGrantsEnabled: boolean;\n  enabled: boolean;\n  frontchannelLogout: boolean;\n  fullScopeAllowed: boolean;\n  implicitFlowEnabled: boolean;\n  name: string;\n  nodeReRegistrationTimeout: number;\n  notBefore: number;\n  optionalClientScopes: string[];\n  protocol: string;\n  protocolMappers?: ProtocolMapper[];\n  publicClient: boolean;\n  redirectUris: string[];\n  registrationAccessToken?: string;\n  secret: string;\n  serviceAccountsEnabled: boolean;\n  standardFlowEnabled: boolean;\n  surrogateAuthRequired: boolean;\n  webOrigins: string[];\n  samlIdpCertificate?: string;\n}\n\n// Define a constant array of keys\nexport const clientKeys = [\n  \"adminUrl\",\n  \"alwaysDisplayInConsole\",\n  \"attributes\",\n  \"authenticationFlowBindingOverrides\",\n  \"baseUrl\",\n  \"bearerOnly\",\n  \"clientAuthenticatorType\",\n  \"clientId\",\n  \"consentRequired\",\n  \"defaultClientScopes\",\n  \"defaultRoles\",\n  \"directAccessGrantsEnabled\",\n  \"enabled\",\n  \"frontchannelLogout\",\n  \"fullScopeAllowed\",\n  \"implicitFlowEnabled\",\n  \"name\",\n  \"nodeReRegistrationTimeout\",\n  \"notBefore\",\n  \"optionalClientScopes\",\n  \"protocol\",\n  \"protocolMappers\",\n  \"publicClient\",\n  \"redirectUris\",\n  \"registrationAccessToken\",\n  \"secret\",\n  \"serviceAccountsEnabled\",\n  \"standardFlowEnabled\",\n  \"surrogateAuthRequired\",\n  \"webOrigins\",\n  \"samlIdpCertificate\",\n] as const;\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { K8s } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { Monitor, PrometheusPodMonitor, UDSPackage } from \"../../crd\";\nimport { Kind } from \"../../crd/generated/package-v1alpha1\";\nimport { FallbackScrapeProtocol } from \"../../crd/generated/prometheus/podmonitor-v1\";\nimport { getOwnerRef, purgeOrphans } from \"../utils\";\nimport { generateMonitorName } from \"./common\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_MONITORING);\n\n/**\n * Generate a pod monitor for a pod\n *\n * @param pkg UDS Package\n * @param namespace\n */\nexport async function podMonitor(pkg: UDSPackage, namespace: string) {\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerRefs = getOwnerRef(pkg);\n\n  log.debug(`Reconciling PodMonitors for ${pkgName}`);\n\n  // Get the list of monitored services\n  const monitorList = pkg.spec?.monitor ?? [];\n\n  // Create a list of generated PodMonitors\n  const payloads: PrometheusPodMonitor[] = [];\n\n  try {\n    for (const monitor of monitorList) {\n      if (monitor.kind === Kind.PodMonitor) {\n        const payload = generatePodMonitor(monitor, namespace, pkgName, generation, ownerRefs);\n\n        log.debug(payload, `Applying PodMonitor ${payload.metadata?.name}`);\n\n        // Apply the PodMonitor and force overwrite any existing policy\n        await K8s(PrometheusPodMonitor).Apply(payload, { force: true });\n\n        payloads.push(payload);\n      }\n    }\n\n    await purgeOrphans(generation, namespace, pkgName, PrometheusPodMonitor, log);\n  } catch (err) {\n    throw new Error(`Failed to process PodMonitors for ${pkgName}, cause: ${JSON.stringify(err)}`);\n  }\n\n  // Return the list of monitor names\n  return [...payloads.map(m => m.metadata!.name!)];\n}\n\nexport function generatePodMonitor(\n  monitor: Monitor,\n  namespace: string,\n  pkgName: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  const { selector, podSelector, portName } = monitor;\n  const name = generateMonitorName(pkgName, monitor);\n  const payload: PrometheusPodMonitor = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      podMetricsEndpoints: [\n        {\n          port: portName,\n          path: monitor.path || \"/metrics\",\n          authorization: monitor.authorization,\n        },\n      ],\n      selector: {\n        matchLabels: podSelector ?? selector,\n      },\n      // Fallback to the Prometheus 2.x default if not defined\n      fallbackScrapeProtocol:\n        monitor.fallbackScrapeProtocol || FallbackScrapeProtocol.PrometheusText004,\n    },\n  };\n\n  return payload;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s } from \"pepr\";\n\nimport { V1OwnerReference } from \"@kubernetes/client-node\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { Monitor, PrometheusServiceMonitor, UDSPackage } from \"../../crd\";\nimport { Kind } from \"../../crd/generated/package-v1alpha1\";\nimport { FallbackScrapeProtocol } from \"../../crd/generated/prometheus/servicemonitor-v1\";\nimport { getOwnerRef, purgeOrphans } from \"../utils\";\nimport { generateMonitorName } from \"./common\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_MONITORING);\n\n/**\n * Generate a service monitor for a service\n *\n * @param pkg UDS Package\n * @param namespace\n */\nexport async function serviceMonitor(pkg: UDSPackage, namespace: string) {\n  const pkgName = pkg.metadata!.name!;\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n  const ownerRefs = getOwnerRef(pkg);\n\n  log.debug(`Reconciling ServiceMonitors for ${pkgName}`);\n\n  // Get the list of monitored services\n  const monitorList = pkg.spec?.monitor ?? [];\n\n  // Create a list of generated ServiceMonitors\n  const payloads: PrometheusServiceMonitor[] = [];\n\n  try {\n    for (const monitor of monitorList) {\n      if (monitor.kind !== Kind.PodMonitor) {\n        const payload = generateServiceMonitor(monitor, namespace, pkgName, generation, ownerRefs);\n\n        log.debug(payload, `Applying ServiceMonitor ${payload.metadata?.name}`);\n\n        // Apply the ServiceMonitor and force overwrite any existing policy\n        await K8s(PrometheusServiceMonitor).Apply(payload, { force: true });\n\n        payloads.push(payload);\n      }\n    }\n\n    await purgeOrphans(generation, namespace, pkgName, PrometheusServiceMonitor, log);\n  } catch (err) {\n    throw new Error(\n      `Failed to process ServiceMonitors for ${pkgName}, cause: ${JSON.stringify(err)}`,\n    );\n  }\n\n  // Return the list of monitor names\n  return [...payloads.map(m => m.metadata!.name!)];\n}\n\nexport function generateServiceMonitor(\n  monitor: Monitor,\n  namespace: string,\n  pkgName: string,\n  generation: string,\n  ownerRefs: V1OwnerReference[],\n) {\n  const { selector, portName } = monitor;\n  const name = generateMonitorName(pkgName, monitor);\n  const payload: PrometheusServiceMonitor = {\n    metadata: {\n      name,\n      namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n      },\n      ownerReferences: ownerRefs,\n    },\n    spec: {\n      endpoints: [\n        {\n          port: portName,\n          path: monitor.path || \"/metrics\",\n          authorization: monitor.authorization,\n        },\n      ],\n      selector: {\n        matchLabels: selector,\n      },\n      // Fallback to the Prometheus 2.x default if not defined\n      fallbackScrapeProtocol:\n        monitor.fallbackScrapeProtocol || FallbackScrapeProtocol.PrometheusText004,\n    },\n  };\n\n  return payload;\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { Allow, Expose, Gateway, Monitor, RemoteGenerated, UDSPackage } from \"../../crd\";\nimport {\n  Action,\n  AuthorizationPolicy,\n  Rule,\n  Source,\n} from \"../../crd/generated/istio/authorizationpolicy-v1beta1\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { IstioState } from \"../istio/namespace\";\nimport { getWaypointName, shouldUseAmbientWaypoint } from \"../istio/waypoint-utils\";\nimport {\n  PROMETHEUS_PRINCIPAL,\n  getAuthserviceClients,\n  getOwnerRef,\n  purgeOrphans,\n  sanitizeResourceName,\n} from \"../utils\";\nimport { META_IP } from \"./generators/cloudMetadata\";\nimport { kubeAPI } from \"./generators/kubeAPI\";\nimport { kubeNodes } from \"./generators/kubeNodes\";\n\nconst log = setupLogger(Component.OPERATOR_NETWORK);\n\n/**\n * Generates a unique name for a Monitor rule.\n * Combines the target port and a derived name from the pod selector or fallback selector.\n * Prioritizes \"app\" or \"app.kubernetes.io/name\" label values to form a stable, readable base.\n * Falls back to joining all selector values, or \"workload\" if none exist.\n */\nfunction generateMonitorName(monitor: Monitor): string {\n  const selector = monitor.podSelector ?? monitor.selector ?? {};\n  const portPart = monitor.targetPort?.toString() ?? \"unknown-port\";\n  const baseName =\n    selector[\"app\"]?.replace(/-pod$/, \"\") ??\n    (selector[\"app.kubernetes.io/name\"]\n      ? selector[\"app.kubernetes.io/name\"].replace(/-pod$/, \"\") + \"-workload\"\n      : undefined) ??\n    (Object.values(selector).join(\"-\") || \"workload\");\n  return `monitor-${portPart}-${baseName}`;\n}\n\n/**\n * Generates a unique name for an Allow rule.\n * Uses the description if provided; otherwise a combination of the selector values\n * and remote properties is used.\n */\nfunction generateAllowName(rule: Allow): string {\n  const { description, selector, remoteGenerated, remoteNamespace, remoteSelector } = rule;\n  const baseName =\n    description ||\n    [\n      Object.values(selector || { default: \"all pods\" }).join(\"-\"),\n      remoteGenerated || [\n        remoteNamespace || \"default\",\n        Object.values(remoteSelector || { default: \"all pods\" }).join(\"-\"),\n      ],\n    ]\n      .flat()\n      .join(\"-\");\n  return `ingress-${baseName}`;\n}\n\n/**\n * Generates a unique name for an Expose rule using effective port, selector, and gateway.\n */\nfunction generateExposeName(rule: Expose): string {\n  const effectivePort = rule.targetPort ?? rule.port;\n  const selPart = rule.selector ? Object.values(rule.selector).join(\"-\") : \"all\";\n  const gateway = rule.gateway || \"tenant\";\n  return `ingress-${effectivePort}-${selPart}-istio-${gateway}-gateway`;\n}\n\n/**\n * Processes an Allow rule to extract its effective source and ports.\n */\nfunction processAllowRule(rule: Allow, pkgNamespace: string): { source: Source; ports: string[] } {\n  const ports: string[] = [];\n  if (rule.port !== undefined) ports.push(rule.port.toString());\n  if (rule.ports) ports.push(...rule.ports.map(p => p.toString()));\n\n  let source: Source = {};\n\n  const hasRemoteSA = rule.remoteServiceAccount?.trim();\n  const hasRemoteNS = rule.remoteNamespace?.trim();\n\n  if (hasRemoteSA) {\n    const ns = hasRemoteNS || pkgNamespace;\n    source = {\n      principals: [`cluster.local/ns/${ns}/sa/${rule.remoteServiceAccount}`],\n    };\n  } else if (rule.remoteCidr) {\n    source = { ipBlocks: [rule.remoteCidr] };\n  } else if (rule.remoteGenerated) {\n    switch (rule.remoteGenerated) {\n      case RemoteGenerated.CloudMetadata:\n        source = { ipBlocks: [META_IP] };\n        break;\n      case RemoteGenerated.KubeAPI:\n        source = {\n          ipBlocks: kubeAPI()\n            .map((peer: { ipBlock?: { cidr: string } }) => peer.ipBlock?.cidr)\n            .filter((cidr): cidr is string => typeof cidr === \"string\"),\n        };\n        break;\n      case RemoteGenerated.KubeNodes:\n        source = {\n          ipBlocks: kubeNodes()\n            .map((peer: { ipBlock?: { cidr: string } }) => peer.ipBlock?.cidr)\n            .filter((cidr): cidr is string => typeof cidr === \"string\"),\n        };\n        break;\n      case RemoteGenerated.IntraNamespace:\n        source = { namespaces: [pkgNamespace] };\n        break;\n      case RemoteGenerated.Anywhere:\n        source = {};\n        break;\n    }\n  } else if (rule.remoteNamespace === \"\" || rule.remoteNamespace === \"*\") {\n    source = {};\n  } else if (rule.remoteNamespace) {\n    source = { namespaces: [rule.remoteNamespace] };\n  }\n  return { source, ports };\n}\n\n/**\n * Processes an Expose rule to extract its effective source and ports.\n */\nfunction processExposeRule(rule: Expose): { source: Source; ports: string[] } {\n  const ports: string[] = [];\n  const effectivePort = rule.targetPort ?? rule.port;\n  if (effectivePort !== undefined) {\n    ports.push(effectivePort.toString());\n  }\n  const gateway = rule.gateway ?? Gateway.Tenant;\n  const source = {\n    principals: [`cluster.local/ns/istio-${gateway}-gateway/sa/${gateway}-ingressgateway`],\n  };\n  return { source, ports };\n}\n\n/**\n * Helper to determine if an object is empty.\n */\nfunction isEmpty(obj: object): boolean {\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Helper to build an AuthorizationPolicy from rule details.\n * If the computed source is empty, the \"from\" field is omitted.\n */\nfunction buildAuthPolicy(\n  policyName: string,\n  pkg: UDSPackage,\n  selector: Record<string, string> | undefined,\n  source: Source,\n  ports: string[],\n  additionalLabels?: Record<string, string>,\n): AuthorizationPolicy {\n  const ruleEntry: Rule = {};\n  if (!isEmpty(source)) {\n    ruleEntry.from = [{ source }];\n  }\n  if (ports.length > 0) {\n    ruleEntry.to = [{ operation: { ports } }];\n  }\n\n  const pkgName = pkg.metadata?.name ?? \"unknown\";\n  const pkgNamespace = pkg.metadata?.namespace ?? \"default\";\n  const generation = pkg.metadata?.generation?.toString() ?? \"0\";\n\n  return {\n    apiVersion: \"security.istio.io/v1beta1\",\n    kind: \"AuthorizationPolicy\",\n    metadata: {\n      name: policyName,\n      namespace: pkgNamespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": generation,\n        \"uds/for\": \"network\",\n        ...additionalLabels,\n      },\n      ownerReferences: getOwnerRef(pkg),\n    },\n    spec: {\n      action: Action.Allow,\n      ...(selector ? { selector: { matchLabels: selector } } : {}),\n      rules: [ruleEntry],\n    },\n  };\n}\n\n/**\n * Generate and apply Istio Authorization Policies for a given UDSPackage.\n */\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b16a\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaStart a9d420a8-1ad2-479f-a438-aa4ca0f57473\nexport async function generateAuthorizationPolicies(\n  pkg: UDSPackage,\n  pkgNamespace: string,\n  istioMode: string,\n): Promise<AuthorizationPolicy[]> {\n  const pkgName = pkg.metadata?.name ?? \"unknown\";\n  const generation = pkg.metadata?.generation?.toString() ?? \"0\";\n  log.info(\n    `Starting authorization policy generation for package \"${pkgName}\" in namespace \"${pkgNamespace}\" (generation ${generation}).`,\n  );\n\n  const policies: AuthorizationPolicy[] = [];\n\n  // Process allow rules.\n  if (pkg.spec?.network?.allow) {\n    for (const rule of pkg.spec.network.allow) {\n      if (rule.direction === \"Egress\") continue;\n\n      const sso = findMatchingSsoClient(pkg, rule.selector);\n      const { source, ports } = processAllowRule(rule, pkgNamespace);\n\n      if (sso) {\n        // Waypoint service handling for allow rules\n        const waypointName = getWaypointName(sso.clientId);\n        const waypointSelector = { \"istio.io/gateway-name\": waypointName };\n\n        const policyName = sanitizeResourceName(\n          `protect-${pkgName}-allow-${generateAllowName(rule)}-${waypointName}`,\n        );\n\n        const additionalLabels: Record<string, string> | undefined = rule.remoteGenerated\n          ? { \"uds/generated\": rule.remoteGenerated, \"uds/waypoint\": waypointName }\n          : { \"uds/waypoint\": waypointName };\n\n        const authPolicy = buildAuthPolicy(\n          policyName,\n          pkg,\n          waypointSelector,\n          source,\n          ports,\n          additionalLabels,\n        );\n        policies.push(authPolicy);\n        log.trace(`Generated waypoint allow authpol: ${authPolicy.metadata?.name}`);\n      } else {\n        // Regular allow rule processing\n        const policyName = sanitizeResourceName(`protect-${pkgName}-${generateAllowName(rule)}`);\n        const additionalLabels: Record<string, string> | undefined = rule.remoteGenerated\n          ? { \"uds/generated\": rule.remoteGenerated }\n          : undefined;\n        const authPolicy = buildAuthPolicy(\n          policyName,\n          pkg,\n          rule.selector,\n          source,\n          ports,\n          additionalLabels,\n        );\n        policies.push(authPolicy);\n        log.trace(`Generated allow authpol: ${authPolicy.metadata?.name}`);\n      }\n    }\n  }\n\n  // Process expose rules\n  if (pkg.spec?.network?.expose) {\n    for (const rule of pkg.spec.network.expose) {\n      const sso = findMatchingSsoClient(pkg, rule.selector);\n\n      if (sso) {\n        // Waypoint service handling\n        const waypointName = getWaypointName(sso.clientId);\n        const { source } = processExposeRule(rule);\n        const waypointPorts = rule.port ? [rule.port.toString()] : [];\n\n        if (waypointPorts.length > 0) {\n          const labelString =\n            Object.entries(rule.selector || {})\n              .map(([k, v]) => `${k}-${v}`)\n              .join(\"-\") || \"all\";\n\n          const policyName = sanitizeResourceName(\n            `protect-${pkgName}-ingress-${rule.port || \"http\"}-${labelString}-${waypointName}`,\n          );\n\n          const waypointSelector = { \"istio.io/gateway-name\": waypointName };\n          const authPolicy = buildAuthPolicy(\n            policyName,\n            pkg,\n            waypointSelector,\n            source,\n            waypointPorts,\n          );\n          policies.push(authPolicy);\n          log.trace(`Generated waypoint authpol: ${authPolicy.metadata?.name}`);\n        } else {\n          log.warn(\n            {\n              selector: rule.selector,\n              package: pkgName,\n            },\n            `No exposed port found for waypoint policy`,\n          );\n        }\n      } else {\n        // Regular expose rule processing\n        const { source, ports } = processExposeRule(rule);\n        const policyName = sanitizeResourceName(`protect-${pkgName}-${generateExposeName(rule)}`);\n        const authPolicy = buildAuthPolicy(policyName, pkg, rule.selector, source, ports);\n        policies.push(authPolicy);\n        log.trace(`Generated authpol: ${authPolicy.metadata?.name}`);\n      }\n    }\n  }\n\n  // Process monitor rules.\n  if (pkg.spec?.monitor) {\n    for (const monitor of pkg.spec.monitor) {\n      const selector = monitor.podSelector ?? monitor.selector;\n      const source: Source = { principals: [PROMETHEUS_PRINCIPAL] };\n      const ports: string[] = [monitor.targetPort.toString()];\n\n      // Check if this monitor's selector matches an SSO client\n      const sso = findMatchingSsoClient(pkg, selector);\n\n      if (sso) {\n        // Waypoint service handling for monitor rules\n        const waypointName = getWaypointName(sso.clientId);\n        const waypointSelector = { \"istio.io/gateway-name\": waypointName };\n\n        const policyName = sanitizeResourceName(\n          `protect-${pkgName}-monitor-${generateMonitorName(monitor)}-${waypointName}`,\n        );\n\n        const authPolicy = buildAuthPolicy(policyName, pkg, waypointSelector, source, ports, {\n          \"uds/waypoint\": waypointName,\n        });\n        policies.push(authPolicy);\n        log.trace(`Generated waypoint monitor authpol: ${authPolicy.metadata?.name}`);\n      } else {\n        // Regular monitor rule processing\n        const policyName = sanitizeResourceName(\n          `protect-${pkgName}-${generateMonitorName(monitor)}`,\n        );\n        const authPolicy = buildAuthPolicy(policyName, pkg, selector, source, ports);\n        policies.push(authPolicy);\n        log.trace(`Generated monitor authpol: ${authPolicy.metadata?.name}`);\n      }\n    }\n  }\n\n  // Process waypoint deny-all policies for SSO clients\n  if (pkg.spec?.sso && shouldUseAmbientWaypoint(pkg)) {\n    for (const sso of pkg.spec.sso) {\n      if (!sso.enableAuthserviceSelector) continue;\n\n      const waypointName = getWaypointName(sso.clientId);\n      const appSelector = sso.enableAuthserviceSelector;\n\n      // Add deny-all policy that only allows traffic from the waypoint\n      const denyPolicy = createDenyAllExceptWaypointPolicy(pkg, waypointName, appSelector);\n      policies.push(denyPolicy);\n    }\n  }\n\n  // With Prometheus in Ambient mode, all traffic is sent over mTLS and the\n  // destination sidecar requires an ALLOW policy to expose sidecar metrics.\n  // Add an AuthorizationPolicy to allow all traffic on port 15020 for the package's namespace.\n  if (istioMode === IstioState.Sidecar) {\n    const extraPolicyName = sanitizeResourceName(\n      `protect-${pkgName}-ingress-15020-sidecar-metric-scraping`,\n    );\n    const extraPolicy = buildAuthPolicy(\n      extraPolicyName,\n      pkg,\n      {}, // empty selector to apply to all workloads in the namespace\n      { principals: [PROMETHEUS_PRINCIPAL] },\n      [\"15020\"],\n    );\n    policies.push(extraPolicy);\n    log.trace(\n      `Generated extra ambient allow authpol for port 15020: ${extraPolicy.metadata?.name}`,\n    );\n  }\n\n  // Apply policies concurrently.\n  for (const policy of policies) {\n    try {\n      await K8s(AuthorizationPolicy).Apply(policy, { force: true });\n      log.trace(\n        `Applied AuthorizationPolicy ${policy.metadata?.name} in namespace ${policy.metadata?.namespace}`,\n      );\n    } catch (err) {\n      log.error(\n        err,\n        `Error applying AuthorizationPolicy ${policy.metadata?.name} in namespace ${policy.metadata?.namespace}`,\n      );\n      throw err; // Rethrow to fail the reconciliation process.\n    }\n  }\n\n  await purgeOrphans(generation, pkgNamespace, pkgName, AuthorizationPolicy, log, {\n    \"uds/for\": \"network\",\n  });\n\n  return policies;\n}\n// @lulaEnd a9d420a8-1ad2-479f-a438-aa4ca0f57473\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b16a\n/**\n * Finds the first SSO client that matches the given selector.\n * @returns The matching SSO client, or undefined if no match found\n */\nexport function findMatchingSsoClient(\n  pkg: UDSPackage,\n  selector: Record<string, string> | undefined,\n) {\n  if (!selector || pkg.spec?.network?.serviceMesh?.mode !== Mode.Ambient) {\n    return undefined;\n  }\n\n  const authserviceClients = getAuthserviceClients(pkg);\n  return authserviceClients.find(client => {\n    const waypointSelector = client.enableAuthserviceSelector;\n\n    // Empty object means namespace-wide protection\n    if (Object.keys(waypointSelector!).length === 0) {\n      return true;\n    }\n\n    // For non-empty selectors, require all labels to match\n    return Object.entries(waypointSelector!).every(([key, value]) => selector[key] === value);\n  });\n}\n\n/**\n * Creates a deny-all AuthorizationPolicy that only allows traffic from the specified waypoint.\n * This policy is used in ambient mode to ensure all traffic to application pods\n * must go through the waypoint proxy.\n */\nexport function createDenyAllExceptWaypointPolicy(\n  pkg: UDSPackage,\n  waypointName: string,\n  appSelector: Record<string, string>,\n): AuthorizationPolicy {\n  const pkgName = pkg.metadata?.name ?? \"unknown\";\n  const policyName = sanitizeResourceName(`deny-all-except-waypoint-${waypointName}`);\n\n  // Create the base policy with required fields\n  const policy: AuthorizationPolicy = {\n    apiVersion: \"security.istio.io/v1beta1\",\n    kind: \"AuthorizationPolicy\",\n    metadata: {\n      name: policyName,\n      namespace: pkg.metadata?.namespace,\n      labels: {\n        \"uds/package\": pkgName,\n        \"uds/generation\": pkg.metadata?.generation?.toString() ?? \"0\",\n        \"uds/for\": \"network\",\n        \"uds/ambient-waypoint\": waypointName,\n      },\n      ownerReferences: getOwnerRef(pkg),\n    },\n    spec: {\n      action: Action.Deny,\n      rules: [\n        {\n          from: [\n            {\n              source: {\n                notPrincipals: [`cluster.local/ns/${pkg.metadata?.namespace}/sa/${waypointName}`],\n              },\n            },\n          ],\n        },\n      ],\n    },\n  };\n\n  // Only add selector if it has at least one label, this allows\n  // for adding an empty appSelector for protecting the whole namespace\n  if (appSelector && Object.keys(appSelector).length > 0) {\n    policy.spec!.selector = {\n      matchLabels: appSelector,\n    };\n  }\n\n  return policy;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../../logger\";\nimport { Allow, Direction, Gateway, RemoteGenerated, UDSPackage } from \"../../crd\";\nimport { Mode } from \"../../crd/generated/package-v1alpha1\";\nimport { UDSConfig } from \"../config/config\";\nimport { getPodSelector, getWaypointName, shouldUseAmbientWaypoint } from \"../istio/waypoint-utils\";\nimport { getAuthserviceClients, getOwnerRef, purgeOrphans, sanitizeResourceName } from \"../utils\";\nimport { allowEgressDNS } from \"./defaults/allow-egress-dns\";\nimport { allowEgressIstiod } from \"./defaults/allow-egress-istiod\";\nimport { allowIngressSidecarMonitoring } from \"./defaults/allow-ingress-sidecar-monitoring\";\nimport { defaultDenyAll } from \"./defaults/default-deny-all\";\nimport { generate } from \"./generate\";\nimport { allowAmbientHealthprobes } from \"./generators/ambientHealthprobes\";\n\n/**\n * Finds an SSO client that matches the given pod labels.\n * - If the selector is an empty object ({}), it matches all pods in the namespace.\n * - If the client has a selector, it matches only pods with all the specified labels\n */\nexport function findMatchingClient(pkg: UDSPackage, podLabels: Record<string, string>) {\n  const authserviceClients = getAuthserviceClients(pkg);\n\n  if (!podLabels || authserviceClients.length === 0) return undefined;\n\n  return authserviceClients.find(sso => {\n    const selector = sso.enableAuthserviceSelector;\n\n    // If the selector is empty, it matches all pods in the namespace\n    if (Object.keys(selector!).length === 0) {\n      return true;\n    }\n\n    // Otherwise, check that every label in the selector exists and matches in podLabels\n    return Object.entries(selector!).every(\n      ([key, value]) => key in podLabels && podLabels[key] === value,\n    );\n  });\n}\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_NETWORK);\n\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b16a\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaStart a9d420a8-1ad2-479f-a438-aa4ca0f57473\nexport async function networkPolicies(pkg: UDSPackage, namespace: string, istioMode: string) {\n  const customPolicies = pkg.spec?.network?.allow ?? [];\n  const pkgName = pkg.metadata!.name!;\n\n  // Get the current generation of the package\n  const generation = (pkg.metadata?.generation ?? 0).toString();\n\n  log.debug(pkg.metadata, `Generating NetworkPolicies for generation ${generation}`);\n\n  // Create default policies\n  const policies = [\n    // All traffic must be explicitly allowed\n    defaultDenyAll(namespace),\n\n    // Allow DNS lookups\n    allowEgressDNS(namespace),\n  ];\n\n  // Istio rules for sidecars\n  if (istioMode === Mode.Sidecar) {\n    policies.push(allowEgressIstiod(namespace));\n    policies.push(allowIngressSidecarMonitoring(namespace));\n  }\n\n  // Istio rules for ambient mode\n  if (istioMode === Mode.Ambient) {\n    policies.push(allowAmbientHealthprobes(namespace));\n  }\n\n  // Process custom policies\n  for (const policy of customPolicies) {\n    // Only process ingress policies that have a selector\n    if (policy.direction === Direction.Ingress && policy.selector) {\n      // Find if this policy's selector matches an authservice-protected workload\n      const matchingClient = findMatchingClient(pkg, policy.selector);\n      const waypointName = matchingClient ? getWaypointName(matchingClient.clientId) : undefined;\n\n      // If we found a matching client with a waypoint, update the selector\n      if (waypointName) {\n        policy.selector = getPodSelector(pkg, policy.selector, waypointName);\n      }\n    }\n\n    const generatedPolicy = generate(namespace, policy, istioMode as Mode);\n    policies.push(generatedPolicy);\n  }\n\n  // Generate NetworkPolicies for any VirtualServices that are generated\n  const exposeList = pkg.spec?.network?.expose ?? [];\n  // Iterate over each exposed service, excluding directResponse services\n  for (const expose of exposeList.filter(exp => !exp.advancedHTTP?.directResponse)) {\n    const { gateway = Gateway.Tenant, port, selector = {}, targetPort } = expose;\n    const policyPort = targetPort ?? port;\n\n    // Find if this service has a matching client with waypoint\n    const matchingClient = findMatchingClient(pkg, selector);\n    const waypointName = matchingClient ? getWaypointName(matchingClient.clientId) : undefined;\n\n    // Use waypoint selector only if we have a waypoint and the package is configured for ambient waypoint\n    const podSelector = waypointName ? getPodSelector(pkg, selector, waypointName) : selector;\n\n    // Create the NetworkPolicy for the VirtualService\n    const policy: Allow = {\n      direction: Direction.Ingress,\n      // Use the waypoint selector if in ambient mode with a matching client\n      selector: podSelector,\n      remoteNamespace: `istio-${gateway}-gateway`,\n      remoteSelector: {\n        app: `${gateway}-ingressgateway`,\n      },\n      port: policyPort,\n      description: `${policyPort}-${Object.values(selector).join(\"-\")} Istio ${gateway} gateway`,\n    };\n\n    // Generate the policy\n    const generatedPolicy = generate(namespace, policy, istioMode as Mode);\n    policies.push(generatedPolicy);\n  }\n\n  // Add network policies for each SSO client with authservice enabled\n  const ssos = getAuthserviceClients(pkg);\n\n  for (const sso of ssos) {\n    const waypointName = getWaypointName(sso.clientId);\n    const netpolSelector = getPodSelector(pkg, sso.enableAuthserviceSelector!, waypointName);\n\n    const policy: Allow = {\n      direction: Direction.Egress,\n      selector: netpolSelector,\n      remoteNamespace: \"authservice\",\n      remoteSelector: { \"app.kubernetes.io/name\": \"authservice\" },\n      port: 10003,\n      description: `${sanitizeResourceName(sso.clientId)} authservice egress`,\n    };\n\n    // Generate the workload to keycloak for JWKS endpoint policy\n    const generatedPolicy = generate(namespace, policy, istioMode as Mode);\n    policies.push(generatedPolicy);\n\n    const keycloakPolicy: Allow = {\n      direction: Direction.Egress,\n      selector: netpolSelector,\n      remoteNamespace: \"keycloak\",\n      remoteSelector: { \"app.kubernetes.io/name\": \"keycloak\" },\n      port: 8080,\n      description: `${sanitizeResourceName(sso.clientId)} keycloak JWKS egress`,\n    };\n\n    // Generate the policy\n    const keycloakGeneratedPolicy = generate(namespace, keycloakPolicy, istioMode as Mode);\n    policies.push(keycloakGeneratedPolicy);\n\n    // Add waypoint network policies for ambient mode\n    if (shouldUseAmbientWaypoint(pkg)) {\n      const waypointName = getWaypointName(sso.clientId);\n      const appSelector = sso.enableAuthserviceSelector;\n\n      // Egress policy: Allow traffic from waypoint to istiod\n      const istiodPolicy = allowEgressIstiod(namespace, sso.clientId, netpolSelector);\n\n      // Add labels to the generated policy\n      istiodPolicy.metadata = {\n        ...istiodPolicy.metadata,\n        labels: {\n          ...istiodPolicy.metadata?.labels,\n          \"uds/sso-client\": sso.clientId,\n        },\n      };\n      policies.push(istiodPolicy);\n\n      // Egress policy: Allow traffic from waypoint to app pods\n      policies.push(\n        generate(namespace, {\n          direction: Direction.Egress,\n          selector: { \"istio.io/gateway-name\": waypointName },\n          remoteSelector: appSelector,\n          description: `Allow traffic from ${waypointName} to app`,\n        }),\n      );\n\n      // Add ingress policy to app pods to allow traffic from waypoint\n      policies.push(\n        generate(namespace, {\n          direction: Direction.Ingress,\n          selector: appSelector,\n          remoteSelector: { \"istio.io/gateway-name\": waypointName },\n          description: `Allow traffic from ${waypointName} to app pods`,\n        }),\n      );\n\n      // Health check policy: Allow monitoring access to waypoint\n      policies.push(\n        generate(namespace, {\n          direction: Direction.Ingress,\n          selector: { \"istio.io/gateway-name\": waypointName },\n          remoteNamespace: \"monitoring\",\n          remoteSelector: { app: \"prometheus\" },\n          ports: [\n            15020, // Envoy admin port\n          ],\n          description: `Allow health checks from monitoring to ${waypointName}`,\n        }),\n      );\n    }\n  }\n\n  // Generate NetworkPolicies for any monitors that are generated\n  const monitorList = pkg.spec?.monitor ?? [];\n  // Iterate over each monitor\n  for (const monitor of monitorList) {\n    const { selector, targetPort, podSelector } = monitor;\n\n    // Find if this service has a matching client with waypoint\n    const matchingClient = findMatchingClient(pkg, selector);\n    const waypointName = matchingClient ? getWaypointName(matchingClient.clientId) : undefined;\n\n    // Use waypoint selector only if we have a waypoint and the package is configured for ambient waypoint\n    const allowSelector = waypointName\n      ? getPodSelector(pkg, podSelector ?? selector, waypointName)\n      : (podSelector ?? selector);\n\n    // Create the NetworkPolicy for the monitor\n    const policy: Allow = {\n      direction: Direction.Ingress,\n      selector: allowSelector,\n      remoteNamespace: \"monitoring\",\n      remoteSelector: {\n        app: \"prometheus\",\n      },\n      port: targetPort,\n      // Use the targetPort and selector to generate a description for the monitoring derived policies\n      description: `${targetPort}-${Object.values(selector)} Metrics`,\n    };\n    // Generate the policy\n    const generatedPolicy = generate(namespace, policy, istioMode as Mode);\n    policies.push(generatedPolicy);\n  }\n\n  // Iterate over each policy and apply it\n  for (const [idx, policy] of policies.entries()) {\n    // Add the package name and generation to the labels\n    policy.metadata = policy.metadata ?? {};\n    policy.metadata.labels = policy.metadata?.labels ?? {};\n    policy.metadata.labels[\"uds/package\"] = pkgName;\n    policy.metadata.labels[\"uds/generation\"] = generation;\n\n    // Add the package name to the name of the policy to ensure uniqueness\n    if (idx < 1) {\n      policy.metadata.name = `deny-${pkgName}-${policy.metadata.name}`;\n    } else {\n      policy.metadata.name = `allow-${pkgName}-${policy.metadata.name}`;\n    }\n\n    // Loop through all ports in ingress/egress policies and add port 15008 for ztunnel\n    if (policy.spec?.ingress) {\n      for (const ingress of policy.spec.ingress) {\n        // Only add the port if there is a port restriction\n        if (ingress.ports && ingress.ports.some(port => port.protocol !== \"UDP\")) {\n          ingress.ports.push({ port: 15008 });\n        }\n      }\n    } else if (policy.spec?.egress) {\n      for (const egress of policy.spec.egress) {\n        // Don't add port 15008 for egress destinations that we know are not in-mesh or not in-cluster\n        if (\n          policy.metadata?.labels?.[\"uds/generated\"] === RemoteGenerated.KubeNodes ||\n          policy.metadata?.labels?.[\"uds/generated\"] === RemoteGenerated.KubeAPI ||\n          policy.metadata?.labels?.[\"uds/generated\"] === RemoteGenerated.CloudMetadata\n        ) {\n          continue;\n        }\n        // Only add the port if there is a port restriction\n        if (egress.ports && egress.ports.some(port => port.protocol !== \"UDP\")) {\n          egress.ports.push({ port: 15008 });\n        }\n      }\n    }\n\n    // Ensure the name is a valid resource name\n    policy.metadata.name = sanitizeResourceName(policy.metadata.name);\n\n    // Use the CR as the owner ref for each NetworkPolicy\n    policy.metadata.ownerReferences = getOwnerRef(pkg);\n\n    // Apply the NetworkPolicy and force overwrite any existing policy\n    try {\n      await K8s(kind.NetworkPolicy).Apply(policy, { force: true });\n    } catch (err) {\n      let message = err.data?.message || \"Unknown error while applying network policies\";\n      if (\n        UDSConfig.kubeApiCIDR &&\n        policy.metadata.labels[\"uds/generated\"] === RemoteGenerated.KubeAPI\n      ) {\n        message +=\n          \", ensure that the KUBEAPI_CIDR override configured for the operator is correct.\";\n      }\n      if (\n        UDSConfig.kubeNodeCIDRs.length > 0 &&\n        policy.metadata.labels[\"uds/generated\"] === RemoteGenerated.KubeNodes\n      ) {\n        message +=\n          \", ensure that the KUBENODE_CIDRS override configured for the operator is correct.\";\n      }\n      throw new Error(message);\n    }\n  }\n\n  await purgeOrphans(generation, namespace, pkgName, kind.NetworkPolicy, log);\n\n  // Return the list of policies\n  return policies;\n}\n// @lulaEnd a9d420a8-1ad2-479f-a438-aa4ca0f57473\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b16a\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowEgressDNS = (namespace: string) => {\n  const netPol = generate(namespace, {\n    direction: Direction.Egress,\n    description: \"DNS lookup via CoreDNS\",\n    remoteNamespace: \"kube-system\",\n    remoteSelector: {\n      \"k8s-app\": \"kube-dns\",\n    },\n    port: 53,\n  });\n\n  // Override the generated policy to use UDP instead of TCP\n  netPol.spec!.egress![0].ports![0].protocol = \"UDP\";\n\n  return netPol;\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowEgressIstiod = (\n  namespace: string,\n  clientId?: string,\n  podSelector?: Record<string, string>,\n) => {\n  const policy = {\n    direction: Direction.Egress,\n    description: clientId ? `Istiod communication for ${clientId}` : \"Istiod communication\",\n    remoteNamespace: \"istio-system\",\n    remoteSelector: {\n      istio: \"pilot\",\n    },\n    port: 15012,\n    // Add the pod selector if provided\n    ...(podSelector && { selector: podSelector }),\n  };\n\n  return generate(namespace, policy);\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\nexport const allowIngressSidecarMonitoring = (namespace: string) =>\n  generate(namespace, {\n    direction: Direction.Ingress,\n    description: \"Sidecar monitoring\",\n    remoteNamespace: \"monitoring\",\n    remoteSelector: {\n      app: \"prometheus\",\n    },\n    port: 15020,\n  });\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { kind } from \"pepr\";\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b16a\n// @lulaStart cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaStart 4abf5c2b-08f7-4eb3-b50e-030ae1c23d59\nexport function defaultDenyAll(namespace: string): kind.NetworkPolicy {\n  return {\n    apiVersion: \"networking.k8s.io/v1\",\n    kind: \"NetworkPolicy\",\n    metadata: {\n      name: \"default\",\n      namespace,\n    },\n    spec: {\n      podSelector: {},\n      policyTypes: [\"Ingress\", \"Egress\"],\n      ingress: [],\n      egress: [],\n    },\n  };\n}\n// @lulaEnd 4abf5c2b-08f7-4eb3-b50e-030ae1c23d59\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b18f\n// @lulaEnd cd540e07-153b-424c-90e0-c0daec56b16a\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Direction } from \"../../../crd\";\nimport { generate } from \"../generate\";\n\n// See https://istio.io/latest/docs/ambient/usage/networkpolicy/#ambient-health-probes-and-kubernetes-networkpolicy\nexport const allowAmbientHealthprobes = (namespace: string) =>\n  generate(namespace, {\n    direction: Direction.Ingress,\n    description: \"Ambient Healthprobes\",\n    remoteCidr: \"169.254.7.127/32\",\n  });\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { getReadinessConditions, handleFailure, shouldSkip, updateStatus, writeEvent } from \".\";\nimport { Component, setupLogger } from \"../../logger\";\nimport { UDSConfig } from \"../controllers/config/config\";\nimport {\n  egressRequestedFromNetwork,\n  reconcileSharedEgressResources,\n} from \"../controllers/istio/egress\";\nimport { getPackageId, istioResources } from \"../controllers/istio/istio-resources\";\nimport { cleanupNamespace, enableIstio } from \"../controllers/istio/namespace\";\nimport { PackageAction } from \"../controllers/istio/types\";\nimport {\n  authservice,\n  purgeAuthserviceClients,\n} from \"../controllers/keycloak/authservice/authservice\";\nimport { keycloak, purgeSSOClients } from \"../controllers/keycloak/client-sync\";\nimport { Client } from \"../controllers/keycloak/types\";\nimport { podMonitor } from \"../controllers/monitoring/pod-monitor\";\nimport { serviceMonitor } from \"../controllers/monitoring/service-monitor\";\nimport { generateAuthorizationPolicies } from \"../controllers/network/authorizationPolicies\";\nimport { networkPolicies } from \"../controllers/network/policies\";\nimport { retryWithDelay } from \"../controllers/utils\";\nimport { caBundleConfigMap } from \"../controllers/ca-bundles/ca-bundle\";\nimport { Phase, UDSPackage } from \"../crd\";\nimport { AuthserviceClient, Mode } from \"../crd/generated/package-v1alpha1\";\nimport { migrate } from \"../crd/migrate\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_RECONCILERS);\n\n/**\n * The reconciler is called from the queue and is responsible for reconciling the state of the package\n * with the cluster. This includes creating the network policies, virtual services, sso, and monitoring config.\n *\n * @param pkg the package to reconcile\n */\nexport async function packageReconciler(pkg: UDSPackage) {\n  const metadata = pkg.metadata!;\n  const { namespace, name } = metadata;\n\n  log.info(\n    `Processing Package ${namespace}/${name}, status.phase: ${pkg.status?.phase}, observedGeneration: ${pkg.status?.observedGeneration}, retryAttempt: ${pkg.status?.retryAttempt}`,\n  );\n\n  if (shouldSkip(pkg)) {\n    log.info(\n      `Skipping Package ${namespace}/${name}, status.phase: ${pkg.status?.phase}, observedGeneration: ${pkg.status?.observedGeneration}, retryAttempt: ${pkg.status?.retryAttempt}`,\n    );\n    return;\n  }\n\n  // Migrate the package to the latest version\n  migrate(pkg);\n\n  if (pkg.status?.retryAttempt && pkg.status?.retryAttempt > 0) {\n    // calculate exponential backoff where backoffSeconds = 3^retryAttempt\n    const backOffSeconds = 3 ** pkg.status.retryAttempt;\n\n    log.info(\n      metadata,\n      `Waiting ${backOffSeconds} seconds before processing package ${namespace}/${name}, status.phase: ${pkg.status?.phase}, observedGeneration: ${pkg.status?.observedGeneration}, retryAttempt: ${pkg.status?.retryAttempt}`,\n    );\n\n    await writeEvent(pkg, {\n      message: `Waiting ${backOffSeconds} seconds before retrying package`,\n    });\n\n    // wait for backOff seconds before retrying\n    await new Promise(resolve => setTimeout(resolve, backOffSeconds * 1000));\n  }\n\n  try {\n    await updateStatus(pkg, { phase: Phase.Pending, conditions: getReadinessConditions(false) });\n    await reconcilePackageFlow(pkg);\n  } catch (err) {\n    await handleFailure(err, pkg);\n  }\n}\n\n/**\n * Orchestrates the main reconciliation flow for a package.\n * Handles status updates, resource creation, and sequencing.\n */\nasync function reconcilePackageFlow(pkg: UDSPackage): Promise<void> {\n  const metadata = pkg.metadata!;\n  const { namespace } = metadata;\n\n  // Get the requested service mesh mode, default to sidecar if not specified\n  const istioMode = pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar;\n\n  // 1. First, ensure network policies are in place\n  const netPol = await networkPolicies(pkg, namespace!, istioMode);\n  const authPol = await generateAuthorizationPolicies(pkg, namespace!, istioMode);\n\n  // 2. Now enable Istio injection (this may restart pods in sidecar mode)\n  await enableIstio(pkg);\n\n  let endpoints: string[] = [];\n  let ssoClients = new Map<string, Client>();\n  let authserviceClients: AuthserviceClient[] = [];\n\n  if (UDSConfig.isIdentityDeployed) {\n    // Configure SSO\n    ssoClients = await keycloak(pkg);\n    authserviceClients = await authservice(pkg, ssoClients);\n  } else if (pkg.spec?.sso) {\n    log.error(\"Identity & Authorization is not deployed, but the package has SSO configuration\");\n    throw new Error(\n      \"Identity & Authorization is not deployed, but the package has SSO configuration\",\n    );\n  }\n\n  // Create the Istio Resources per the package configuration\n  endpoints = await istioResources(pkg, namespace!);\n\n  // Get quantity of authorization policies created - only if istioMode = ambient\n  let numEgressAuthPols = 0;\n  if (istioMode === Mode.Ambient && pkg.spec?.network?.allow) {\n    numEgressAuthPols = egressRequestedFromNetwork(pkg.spec!.network!.allow!).length;\n  }\n\n  // Configure the ServiceMonitors\n  const monitors: string[] = [];\n  monitors.push(...(await podMonitor(pkg, namespace!)));\n  monitors.push(...(await serviceMonitor(pkg, namespace!)));\n\n  // Create the CA Bundle Config Map if needed\n  await caBundleConfigMap(pkg, namespace!);\n\n  await updateStatus(pkg, {\n    phase: Phase.Ready,\n    conditions: getReadinessConditions(true),\n    ssoClients: [...ssoClients.keys()],\n    authserviceClients,\n    endpoints,\n    monitors,\n    networkPolicyCount: netPol.length,\n    authorizationPolicyCount: authPol.length + authserviceClients.length * 2 + numEgressAuthPols,\n    meshMode: istioMode,\n    observedGeneration: metadata.generation,\n    retryAttempt: 0, // todo: make this nullable when kfc generates the type\n  });\n}\n\n/**\n * The finalizer is called when an update with a deletion timestamp happens.\n * This function removes any SSO/Authservice clients and ensures that Istio Injection is restored to the original state.\n * Return values indicate whether the finalizer should be removed from the CR based on failure or success of cleanup.\n *\n * @param pkg the package to finalize\n */\nexport async function packageFinalizer(pkg: UDSPackage) {\n  // Skip running the finalizer if it is already running\n  if (pkg.status?.phase === Phase.Removing || pkg.status?.phase === Phase.RemovalFailed) {\n    // Trace log since this can be confusing when the finalizer hits quickly for the status patch\n    log.trace(\n      `Skipping finalizer for ${pkg.metadata?.namespace}/${pkg.metadata?.name}, removal already in progress or failed.`,\n    );\n    return false;\n  }\n\n  // Skip running the finalizer if the CR has not completed initial reconciliation - running this during reconciliation can lead to orphaned resources and failed cleanup\n  if (pkg.status?.phase !== Phase.Ready && pkg.status?.phase !== Phase.Failed) {\n    log.debug(\n      `Waiting to finalize package ${pkg.metadata?.namespace}/${pkg.metadata?.name}, package has not completed initial reconciliation.`,\n    );\n    return false;\n  }\n\n  log.debug(`Processing removal of package ${pkg.metadata?.namespace}/${pkg.metadata?.name}`);\n\n  // Update Package to indicate removal in progress\n  await updateStatus(pkg, { phase: Phase.Removing });\n\n  // Cleanup Istio status on namespace\n  try {\n    await writeEvent(pkg, {\n      message: `Restoring original Istio injection status on namespace`,\n      reason: \"RemovalInProgress\",\n      type: \"Normal\",\n    });\n    // Cleanup the namespace - retry on failure\n    await retryWithDelay(async function cleanupIstioConfig() {\n      return cleanupNamespace(pkg);\n    }, log);\n  } catch (e) {\n    log.debug(\n      `Restoration of Istio injection status during finalizer failed for ${pkg.metadata?.namespace}/${pkg.metadata?.name}: ${e.message}`,\n    );\n    await writeEvent(pkg, {\n      message: `Restoration of Istio injection status failed: ${e.message}. Istio status must be manually restored, by updating or deleting the istio-injection label and cycling pods.`,\n      reason: \"RemovalFailed\",\n      type: \"Warning\",\n    });\n    await updateStatus(pkg, { phase: Phase.RemovalFailed });\n    return false;\n  }\n\n  // Cleanup AuthService Clients\n  try {\n    await writeEvent(pkg, {\n      message: `Removing AuthService configuration for package`,\n      reason: \"RemovalInProgress\",\n      type: \"Normal\",\n    });\n    // Remove any Authservice configuration - retry on failure\n    await retryWithDelay(async function cleanupAuthserviceConfig() {\n      const currentMeshMode = pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar;\n      return purgeAuthserviceClients(pkg, [], currentMeshMode, currentMeshMode);\n    }, log);\n  } catch (e) {\n    log.debug(\n      `Removal of AuthService configuration during finalizer failed for ${pkg.metadata?.namespace}/${pkg.metadata?.name}: ${e.message}`,\n    );\n    await writeEvent(pkg, {\n      message: `Removal of AuthService configuration failed: ${e.message}. AuthService configuration secret should be reviewed and cleaned up as needed.`,\n      reason: \"RemovalFailed\",\n      type: \"Warning\",\n    });\n    await updateStatus(pkg, { phase: Phase.RemovalFailed });\n    return false;\n  }\n\n  // Cleanup SSO Clients\n  try {\n    await writeEvent(pkg, {\n      message: `Removing SSO clients for package`,\n      reason: \"RemovalInProgress\",\n      type: \"Normal\",\n    });\n    // Remove any SSO clients - retry on failure\n    await retryWithDelay(async function cleanupSSOClients() {\n      return purgeSSOClients(pkg, []);\n    }, log);\n  } catch (e) {\n    log.debug(\n      `Removal of SSO clients during finalizer failed for ${pkg.metadata?.namespace}/${pkg.metadata?.name}: ${e.message}`,\n    );\n    await writeEvent(pkg, {\n      message: `Removal of SSO clients failed: ${e.message}. Clients must be manually removed from Keycloak.`,\n      reason: \"RemovalFailed\",\n      type: \"Warning\",\n    });\n    await updateStatus(pkg, { phase: Phase.RemovalFailed });\n    return false;\n  }\n\n  // Clean up any shared egress resources\n  try {\n    await writeEvent(pkg, {\n      message: `Reconciling any shared egress resources`,\n      reason: \"RemovalInProgress\",\n      type: \"Normal\",\n    });\n    // Clean annotations and/or remove any shared egress resources\n    await retryWithDelay(async function cleanupSharedEgressResources() {\n      await reconcileSharedEgressResources(\n        undefined,\n        getPackageId(pkg),\n        PackageAction.Remove,\n        pkg.spec?.network?.serviceMesh?.mode || Mode.Sidecar,\n      );\n    }, log);\n  } catch (e) {\n    log.debug(\n      `Removal of shared egress resources during finalizer failed for ${pkg.metadata?.namespace}/${pkg.metadata?.name}: ${e.message}`,\n    );\n    await writeEvent(pkg, {\n      message: `Removal of shared egress resources failed: ${e.message}`,\n      reason: \"RemovalFailed\",\n      type: \"Warning\",\n    });\n    await updateStatus(pkg, { phase: Phase.RemovalFailed });\n    return false;\n  }\n\n  // Indicate success - all other resources (network policies, virtual services, etc) are cleaned up through owner references\n  // See https://kubernetes.io/docs/concepts/overview/working-with-objects/owners-dependents/#ownership-and-finalizers\n  log.debug(`Package ${pkg.metadata?.namespace}/${pkg.metadata?.name} removed successfully`);\n  return true;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\nimport {\n  KEYCLOAK_CLIENTS_SECRET_NAME,\n  KEYCLOAK_CLIENTS_SECRET_NAMESPACE,\n  updateKeycloakClientsSecret,\n} from \"./client-secret-sync\";\nimport { Component, setupLogger } from \"../../../logger\";\n\nexport const log = setupLogger(Component.OPERATOR_KEYCLOAK);\n\nexport async function setupKeycloakClientSecret() {\n  if (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n    // Ensure the namespace exists in the Kubernetes cluster\n    await K8s(kind.Namespace).Apply({\n      metadata: {\n        name: KEYCLOAK_CLIENTS_SECRET_NAMESPACE,\n      },\n    });\n\n    // Create the secret if it doesn't exist\n    try {\n      await K8s(kind.Secret)\n        .InNamespace(KEYCLOAK_CLIENTS_SECRET_NAMESPACE)\n        .Get(KEYCLOAK_CLIENTS_SECRET_NAME);\n      log.info(`Keycloak Clients Secret exists, skipping creation`);\n    } catch {\n      log.info(\"Keycloak Clients Secret does not exist, creating it\");\n      try {\n        const secret = {\n          metadata: {\n            namespace: KEYCLOAK_CLIENTS_SECRET_NAMESPACE,\n            name: KEYCLOAK_CLIENTS_SECRET_NAME,\n          },\n          type: \"Opaque\",\n        };\n        await updateKeycloakClientsSecret(secret, false);\n      } catch (err) {\n        log.error(err, \"Failed to create Keycloak Clients Secret\");\n        throw err;\n      }\n    }\n  }\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { WatchPhase } from \"kubernetes-fluent-client/dist/fluent/shared-types\";\nimport { K8s } from \"pepr\";\nimport { Component, setupLogger } from \"../../../logger\";\nimport { UDSPackage } from \"../../crd\";\nimport { registerWatchEventHandlers, watchCfg } from \"../utils\";\nimport { PackageStore } from \"./package-store\";\n/**\n * Processes exemptions based on the watch phase.\n * This function determines how to handle a UDSPackage based on whether it has been added or deleted\n * during a watch operation.  It uses a switch statement to execute the appropriate logic\n * based on the provided WatchPhase.\n *\n * @param {UDSPackage} pkg - The UDSPackage to process.  UDSPackage is assumed to be a defined type/interface\n *                           representing a package of exemptions.\n * @param {WatchPhase} phase - The phase of the watch operation (Added or Deleted).\n *                             WatchPhase is assumed to be an enum or a set of constant values.\n * @returns {void} This function does not return a value; it performs actions based on the input.\n */\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_RECONCILERS);\nexport async function startPackageWatch() {\n  PackageStore.init();\n  // only run in admission controller or dev mode\n  if (process.env.PEPR_WATCH_MODE === \"false\" || process.env.PEPR_MODE === \"dev\") {\n    const watcher = K8s(UDSPackage).Watch(async (pkg, phase) => {\n      log.debug(`Processing package ${pkg.metadata?.name}, watch phase: ${phase}`);\n\n      processPackages(pkg, phase);\n    }, watchCfg);\n    // This will run until the process is terminated or the watch is aborted\n    log.debug(\"Starting package watch...\");\n    registerWatchEventHandlers(watcher, log, \"UDSPackage\");\n    await watcher.start();\n  }\n}\n\nexport function processPackages(pkg: UDSPackage, phase: WatchPhase) {\n  switch (phase) {\n    case WatchPhase.Added:\n    case WatchPhase.Modified:\n      PackageStore.add(pkg);\n      break;\n\n    case WatchPhase.Deleted:\n      PackageStore.remove(pkg);\n      break;\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { K8s, kind } from \"pepr\";\n\nimport { Component, setupLogger } from \"../../logger\";\nimport { v1alpha1 as clusterConfig } from \"./sources/cluster-config/v1alpha1\";\nimport { v1alpha1 as exemption } from \"./sources/exemption/v1alpha1\";\nimport { v1alpha1 as pkg } from \"./sources/package/v1alpha1\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_CRD);\n\nexport async function registerClusterConfig() {\n  // Register the ClusterConfig CRD\n  await K8s(kind.CustomResourceDefinition)\n    .Apply(\n      {\n        apiVersion: \"apiextensions.k8s.io/v1\",\n        kind: \"CustomResourceDefinition\",\n        metadata: {\n          name: \"clusterconfig.uds.dev\",\n        },\n        spec: {\n          group: \"uds.dev\",\n          versions: [clusterConfig],\n          scope: \"Cluster\",\n          names: {\n            plural: \"clusterconfig\",\n            singular: \"clusterconfig\",\n            kind: \"ClusterConfig\",\n          },\n        },\n      },\n      { force: true },\n    )\n    .then(() => {\n      log.info(\"ClusterConfig CRD registered\");\n    })\n    .catch(err => {\n      log.error({ err }, \"Failed to register ClusterConfig CRD\");\n\n      // Sad times, let's exit\n      process.exit(1);\n    });\n}\n\nexport async function registerCRDs() {\n  // Register the Package CRD if we're in watch or dev mode\n  if (process.env.PEPR_WATCH_MODE === \"true\" || process.env.PEPR_MODE === \"dev\") {\n    await K8s(kind.CustomResourceDefinition)\n      .Apply(\n        {\n          apiVersion: \"apiextensions.k8s.io/v1\",\n          kind: \"CustomResourceDefinition\",\n          metadata: {\n            name: \"packages.uds.dev\",\n          },\n          spec: {\n            group: \"uds.dev\",\n            versions: [pkg],\n            scope: \"Namespaced\",\n            names: {\n              plural: \"packages\",\n              singular: \"package\",\n              kind: \"Package\",\n              shortNames: [\"pkg\"],\n            },\n          },\n        },\n        { force: true },\n      )\n      .then(() => {\n        log.info(\"Package CRD registered\");\n      })\n      .catch(err => {\n        log.error({ err }, \"Failed to register Package CRD\");\n\n        // Sad times, let's exit\n        process.exit(1);\n      });\n  }\n\n  // Register the Exemption CRD if we're in \"admission\" or dev mode (Exemptions are watched by the admission controllers)\n  if (process.env.PEPR_WATCH_MODE === \"false\" || process.env.PEPR_MODE === \"dev\") {\n    await K8s(kind.CustomResourceDefinition)\n      .Apply(\n        {\n          apiVersion: \"apiextensions.k8s.io/v1\",\n          kind: \"CustomResourceDefinition\",\n          metadata: {\n            name: \"exemptions.uds.dev\",\n          },\n          spec: {\n            group: \"uds.dev\",\n            versions: [exemption],\n            scope: \"Namespaced\",\n            names: {\n              plural: \"exemptions\",\n              singular: \"exemption\",\n              kind: \"Exemption\",\n              shortNames: [\"exempt\"],\n            },\n          },\n        },\n        { force: true },\n      )\n      .then(() => {\n        log.info(\"Exemption CRD registered\");\n      })\n      .catch(err => {\n        log.error({ err }, \"Failed to register Exemption CRD\");\n\n        // Sad times, let's exit\n        process.exit(1);\n      });\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1CustomResourceDefinitionVersion, V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nexport const v1alpha1: V1CustomResourceDefinitionVersion = {\n  name: \"v1alpha1\",\n  served: true,\n  storage: true,\n  schema: {\n    openAPIV3Schema: {\n      type: \"object\",\n      properties: {\n        spec: {\n          type: \"object\",\n          required: [\"exemptions\"],\n          properties: {\n            exemptions: {\n              type: \"array\",\n              minItems: 1,\n              description: \"Policy exemptions\",\n              items: {\n                type: \"object\",\n                required: [\"policies\", \"matcher\"],\n                properties: {\n                  title: {\n                    type: \"string\",\n                    description: \"title to give the exemption for reporting purposes\",\n                  },\n                  description: {\n                    type: \"string\",\n                    description: \"Reasons as to why this exemption is needed\",\n                  },\n                  policies: {\n                    description: \"A list of policies to override\",\n                    type: \"array\",\n                    items: {\n                      type: \"string\",\n                      enum: [\n                        \"DisallowHostNamespaces\",\n                        \"DisallowNodePortServices\",\n                        \"DisallowPrivileged\",\n                        \"DisallowSELinuxOptions\",\n                        \"DropAllCapabilities\",\n                        \"RequireNonRootUser\",\n                        \"RestrictCapabilities\",\n                        \"RestrictExternalNames\",\n                        \"RestrictHostPathWrite\",\n                        \"RestrictHostPorts\",\n                        \"RestrictIstioAmbientOverrides\",\n                        \"RestrictIstioSidecarOverrides\",\n                        \"RestrictIstioTrafficOverrides\",\n                        \"RestrictIstioUser\",\n                        \"RestrictProcMount\",\n                        \"RestrictSeccomp\",\n                        \"RestrictSELinuxType\",\n                        \"RestrictVolumeTypes\",\n                      ],\n                    },\n                  },\n                  matcher: {\n                    description: \"Resource to exempt (Regex allowed for name)\",\n                    type: \"object\",\n                    required: [\"namespace\", \"name\"],\n                    properties: {\n                      namespace: {\n                        type: \"string\",\n                      },\n                      name: {\n                        type: \"string\",\n                      },\n                      kind: {\n                        type: \"string\",\n                        enum: [\"pod\", \"service\"],\n                        default: \"pod\",\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        } as V1JSONSchemaProps,\n      },\n    },\n  },\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nconst matchRequired = [{ required: [\"exact\"] }, { required: [\"prefix\"] }, { required: [\"regex\"] }];\nconst matchTemplate = {\n  oneOf: [\n    {\n      not: {\n        anyOf: matchRequired,\n      },\n    },\n    ...matchRequired,\n  ],\n  properties: {\n    exact: {\n      type: \"string\",\n    },\n    prefix: {\n      type: \"string\",\n    },\n    regex: {\n      description: \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n      type: \"string\",\n    },\n  },\n  type: \"object\",\n};\n\nexport const advancedHTTP: V1JSONSchemaProps = {\n  description: \"Advanced HTTP settings for the route.\",\n  properties: {\n    corsPolicy: {\n      description: \"Cross-Origin Resource Sharing policy (CORS).\",\n      properties: {\n        allowCredentials: {\n          description:\n            \"Indicates whether the caller is allowed to send the actual request (not the preflight) using credentials.\",\n          nullable: true,\n          type: \"boolean\",\n        },\n        allowHeaders: {\n          description: \"List of HTTP headers that can be used when requesting the resource.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowMethods: {\n          description: \"List of HTTP methods allowed to access the resource.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowOrigin: {\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        allowOrigins: {\n          description: \"String patterns that match allowed origins.\",\n          items: matchTemplate,\n          type: \"array\",\n        },\n        exposeHeaders: {\n          description: \"A list of HTTP headers that the browsers are allowed to access.\",\n          items: {\n            type: \"string\",\n          },\n          type: \"array\",\n        },\n        maxAge: {\n          description: \"Specifies how long the results of a preflight request can be cached.\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n    directResponse: {\n      description:\n        \"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\",\n      properties: {\n        body: {\n          description: \"Specifies the content of the response body.\",\n          oneOf: [\n            {\n              not: {\n                anyOf: [\n                  {\n                    required: [\"string\"],\n                  },\n                  {\n                    required: [\"bytes\"],\n                  },\n                ],\n              },\n            },\n            {\n              required: [\"string\"],\n            },\n            {\n              required: [\"bytes\"],\n            },\n          ],\n          properties: {\n            bytes: {\n              description: \"response body as base64 encoded bytes.\",\n              format: \"binary\",\n              type: \"string\",\n            },\n            string: {\n              type: \"string\",\n            },\n          },\n          type: \"object\",\n        },\n        status: {\n          description: \"Specifies the HTTP response status to be returned.\",\n          type: \"integer\",\n        },\n      },\n      required: [\"status\"],\n      type: \"object\",\n    },\n    headers: {\n      properties: {\n        request: {\n          properties: {\n            add: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n            remove: {\n              items: {\n                type: \"string\",\n              },\n              type: \"array\",\n            },\n            set: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n          },\n          type: \"object\",\n        },\n        response: {\n          properties: {\n            add: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n            remove: {\n              items: {\n                type: \"string\",\n              },\n              type: \"array\",\n            },\n            set: {\n              additionalProperties: {\n                type: \"string\",\n              },\n              type: \"object\",\n            },\n          },\n          type: \"object\",\n        },\n      },\n      type: \"object\",\n    },\n    match: {\n      description:\n        \"Match the incoming request based on custom rules. Not permitted when using the passthrough gateway.\",\n      items: {\n        properties: {\n          ignoreUriCase: {\n            description: \"Flag to specify whether the URI matching should be case-insensitive.\",\n            type: \"boolean\",\n          },\n          method: matchTemplate,\n          name: {\n            description: \"The name assigned to a match.\",\n            type: \"string\",\n          },\n          queryParams: {\n            additionalProperties: matchTemplate,\n            description: \"Query parameters for matching.\",\n            type: \"object\",\n          },\n          uri: matchTemplate,\n        },\n        required: [\"name\"],\n        type: \"object\",\n      },\n      type: \"array\",\n    },\n    rewrite: {\n      description: \"Rewrite HTTP URIs and Authority headers.\",\n      properties: {\n        authority: {\n          description: \"rewrite the Authority/Host header with this value.\",\n          type: \"string\",\n        },\n        uri: {\n          description: \"rewrite the path (or the prefix) portion of the URI with this value.\",\n          type: \"string\",\n        },\n        uriRegexRewrite: {\n          description: \"rewrite the path portion of the URI with the specified regex.\",\n          properties: {\n            match: {\n              description:\n                \"RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).\",\n              type: \"string\",\n            },\n            rewrite: {\n              description: \"The string that should replace into matching portions of original URI.\",\n              type: \"string\",\n            },\n          },\n          type: \"object\",\n        },\n      },\n      type: \"object\",\n    },\n    redirect: {\n      description:\n        \"A HTTP rule can either return a direct_response, redirect or forward (default) traffic.\",\n      oneOf: [\n        {\n          not: {\n            anyOf: [\n              {\n                required: [\"port\"],\n              },\n              {\n                required: [\"derivePort\"],\n              },\n            ],\n          },\n        },\n        {\n          required: [\"port\"],\n        },\n        {\n          required: [\"derivePort\"],\n        },\n      ],\n      properties: {\n        authority: {\n          description:\n            \"On a redirect, overwrite the Authority/Host portion of the URL with this value.\",\n          type: \"string\",\n        },\n        port: {\n          description: \"On a redirect, overwrite the port portion of the URL with this value.\",\n          maximum: 4294967295,\n          minimum: 0,\n          type: \"integer\",\n        },\n        derivePort: {\n          description:\n            \"On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80 for HTTP and 443 for HTTPS.\\n\\nValid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT\",\n          enum: [\"FROM_PROTOCOL_DEFAULT\", \"FROM_REQUEST_PORT\"],\n          type: \"string\",\n        },\n        redirectCode: {\n          description:\n            \"On a redirect, Specifies the HTTP status code to use in the redirect response.\",\n          maximum: 4294967295,\n          minimum: 0,\n          type: \"integer\",\n        },\n        scheme: {\n          description: \"On a redirect, overwrite the scheme portion of the URL with this value.\",\n          type: \"string\",\n        },\n        uri: {\n          description: \"On a redirect, overwrite the Path portion of the URL with this value.\",\n          type: \"string\",\n        },\n      },\n      type: \"object\",\n    },\n    retries: {\n      description: \"Retry policy for HTTP requests.\",\n      properties: {\n        attempts: {\n          description: \"Number of retries to be allowed for a given request.\",\n          format: \"int32\",\n          type: \"integer\",\n        },\n        perTryTimeout: {\n          description:\n            \"Timeout per attempt for a given request, including the initial call and any retries.\",\n          type: \"string\",\n        },\n        retryOn: {\n          description: \"Specifies the conditions under which retry takes place.\",\n          type: \"string\",\n        },\n        retryRemoteLocalities: {\n          description: \"Flag to specify whether the retries should retry to other localities.\",\n          nullable: true,\n          type: \"boolean\",\n        },\n      },\n      type: \"object\",\n    },\n    weight: {\n      description:\n        \"Weight specifies the relative proportion of traffic to be forwarded to the destination.\",\n      format: \"int32\",\n      type: \"integer\",\n    },\n    timeout: {\n      description: \"Timeout for HTTP requests, default is disabled.\",\n      type: \"string\",\n    },\n  },\n  type: \"object\",\n} as V1JSONSchemaProps;\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1CustomResourceDefinitionVersion, V1JSONSchemaProps } from \"@kubernetes/client-node\";\n\nimport { advancedHTTP } from \"../istio/virtualservice-v1beta1\";\n\nconst AuthorizationSchema: V1JSONSchemaProps = {\n  description: \"Authorization settings.\",\n  type: \"object\",\n  properties: {\n    credentials: {\n      description:\n        \"Selects a key of a Secret in the namespace that contains the credentials for authentication.\",\n      type: \"object\",\n      properties: {\n        key: {\n          description: \"The key of the secret to select from. Must be a valid secret key.\",\n          type: \"string\",\n        },\n        name: {\n          description:\n            \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\",\n          type: \"string\",\n        },\n        optional: {\n          description: \"Specify whether the Secret or its key must be defined\",\n          type: \"boolean\",\n        },\n      },\n      required: [\"key\"], // Ensure key is required in the schema\n    },\n    type: {\n      description:\n        'Defines the authentication type. The value is case-insensitive. \"Basic\" is not a supported value. Default: \"Bearer\"',\n      type: \"string\",\n    },\n  },\n  required: [\"credentials\"], // Ensure credentials is required in the schema\n};\n\nconst allow = {\n  description: \"Allow specific traffic (namespace will have a default-deny policy)\",\n  type: \"array\",\n  items: {\n    type: \"object\",\n    required: [\"direction\"],\n    properties: {\n      labels: {\n        description: \"The labels to apply to the policy\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      description: {\n        type: \"string\",\n        description: \"A description of the policy, this will become part of the policy name\",\n      },\n      direction: {\n        description: \"The direction of the traffic\",\n        enum: [\"Ingress\", \"Egress\"],\n        type: \"string\",\n      },\n      selector: {\n        description:\n          \"Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all pods in the namespace\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remoteNamespace: {\n        description:\n          \"The remote namespace to allow traffic to/from. Use * or empty string to allow all namespaces\",\n        type: \"string\",\n      },\n      remoteSelector: {\n        description: \"The remote pod selector labels to allow traffic to/from\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remoteGenerated: {\n        description: \"Custom generated remote selector for the policy\",\n        type: \"string\",\n        enum: [\"KubeAPI\", \"KubeNodes\", \"IntraNamespace\", \"CloudMetadata\", \"Anywhere\"],\n      },\n      remoteCidr: {\n        description: \"Custom generated policy CIDR\",\n        type: \"string\",\n      },\n      remoteHost: {\n        description: \"Remote host to allow traffic out to\",\n        type: \"string\",\n      },\n      remoteProtocol: {\n        description: \"Protocol used for external connection\",\n        type: \"string\",\n        enum: [\"TLS\", \"HTTP\"],\n      },\n      port: {\n        description: \"The port to allow (protocol is always TCP)\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      ports: {\n        description: \"A list of ports to allow (protocol is always TCP)\",\n        type: \"array\",\n        items: {\n          minimum: 1,\n          maximum: 65535,\n          type: \"number\",\n        },\n      },\n      remoteServiceAccount: {\n        description:\n          \"The remote service account to restrict incoming traffic from within the remote namespace. \\\n          Only valid for Ingress rules.\",\n        type: \"string\",\n      },\n      serviceAccount: {\n        description:\n          \"The service account to restrict outgoing traffic from within the package namespace. \\\n          Only valid for Egress rules.\",\n        type: \"string\",\n      },\n      // Deprecated fields\n      podLabels: {\n        description: \"Deprecated: use selector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      remotePodLabels: {\n        description: \"Deprecated: use remoteSelector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nconst expose = {\n  type: \"array\",\n  description: \"Expose a service on an Istio Gateway\",\n  items: {\n    type: \"object\",\n    required: [\"host\"],\n    anyOf: [\n      {\n        required: [\"service\", \"podLabels\", \"port\"],\n      },\n      {\n        required: [\"service\", \"selector\", \"port\"],\n      },\n      {\n        required: [\"advancedHTTP\"],\n      },\n    ],\n    properties: {\n      description: {\n        type: \"string\",\n        description:\n          \"A description of this expose entry, this will become part of the VirtualService name\",\n      },\n      host: {\n        description: \"The hostname to expose the service on\",\n        type: \"string\",\n      },\n      gateway: {\n        description: \"The name of the gateway to expose the service on (default: tenant)\",\n        type: \"string\",\n        default: \"tenant\",\n      },\n      domain: {\n        description:\n          \"The domain to expose the service on, only valid for additional gateways (not tenant, admin, or passthrough)\",\n        type: \"string\",\n      },\n      service: {\n        description: \"The name of the service to expose\",\n        type: \"string\",\n      },\n      port: {\n        description: \"The port number to expose\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      selector: {\n        description:\n          \"Selector for Pods targeted by the selected Services (so the NetworkPolicy can be generated correctly).\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      targetPort: {\n        description:\n          \"The service targetPort. This defaults to port and is only required if the service port is different from the target port (so the NetworkPolicy can be generated correctly).\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      advancedHTTP,\n      // Deprecated field\n      match: {\n        description: \"Deprecated: use advancedHTTP.match\",\n        ...advancedHTTP.properties?.match,\n      },\n      podLabels: {\n        description: \"Deprecated: use selector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nconst serviceMesh = {\n  description: \"Service Mesh configuration for the package\",\n  type: \"object\",\n  properties: {\n    mode: {\n      type: \"string\",\n      enum: [\"sidecar\", \"ambient\"],\n      default: \"sidecar\",\n      description: \"Set the service mesh mode for this package (namespace), defaults to sidecar\",\n    },\n  },\n} as V1JSONSchemaProps;\n\nconst monitor = {\n  description: \"Create Service or Pod Monitor configurations\",\n  type: \"array\",\n  items: {\n    type: \"object\",\n    required: [\"portName\", \"selector\", \"targetPort\"],\n    properties: {\n      description: {\n        type: \"string\",\n        description:\n          \"A description of this monitor entry, this will become part of the ServiceMonitor name\",\n      },\n      portName: {\n        description: \"The port name for the serviceMonitor\",\n        type: \"string\",\n      },\n      targetPort: {\n        description:\n          \"The service targetPort. This is required so the NetworkPolicy can be generated correctly.\",\n        minimum: 1,\n        maximum: 65535,\n        type: \"number\",\n      },\n      selector: {\n        description: \"Selector for Services that expose metrics to scrape\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      podSelector: {\n        description:\n          \"Selector for Pods targeted by the selected Services (so the NetworkPolicy can be generated correctly). Defaults to `selector` when not specified.\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      path: {\n        description: \"HTTP path from which to scrape for metrics, defaults to `/metrics`\",\n        type: \"string\",\n      },\n      kind: {\n        description:\n          \"The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the default.\",\n        enum: [\"PodMonitor\", \"ServiceMonitor\"],\n        type: \"string\",\n      },\n      fallbackScrapeProtocol: {\n        description:\n          \"The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise invalid Content-Type\",\n        // Enum copied from upstream Prometheus supported values\n        enum: [\n          \"OpenMetricsText0.0.1\",\n          \"OpenMetricsText1.0.0\",\n          \"PrometheusProto\",\n          \"PrometheusText0.0.4\",\n          \"PrometheusText1.0.0\",\n        ],\n        type: \"string\",\n      },\n      authorization: AuthorizationSchema,\n    },\n  },\n};\n\nconst sso = {\n  description: \"Create SSO client configurations\",\n  type: \"array\",\n  items: {\n    type: \"object\",\n    required: [\"clientId\", \"name\"],\n    properties: {\n      enableAuthserviceSelector: {\n        description:\n          \"Labels to match pods to automatically protect with authservice. Leave empty to disable authservice protection\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      secretName: {\n        description: \"The name of the secret to store the client secret\",\n        type: \"string\",\n      },\n      secretLabels: {\n        description:\n          \"Additional labels to apply to the generated secret, can be used for pod reloading\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      secretAnnotations: {\n        description:\n          \"Additional annotations to apply to the generated secret, can be used for pod reloading with a selector\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      secretTemplate: {\n        description: \"A template for the generated secret\",\n        // Create a map of the secret data\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      clientId: {\n        description: \"The client identifier registered with the identity provider.\",\n        type: \"string\",\n      },\n      secret: {\n        description: \"The client secret. Typically left blank and auto-generated.\",\n        type: \"string\",\n      },\n      name: {\n        description: \"Specifies display name of the client\",\n        type: \"string\",\n      },\n      description: {\n        description:\n          \"A description for the client, can be a URL to an image to replace the login logo\",\n        type: \"string\",\n      },\n      baseUrl: {\n        description:\n          \"Default URL to use when the auth server needs to redirect or link back to the client.\",\n        type: \"string\",\n      },\n      adminUrl: {\n        description:\n          \"This URL will be used for every binding to both the SP's Assertion Consumer and Single Logout Services.\",\n        type: \"string\",\n      },\n      protocol: {\n        description: \"Specifies the protocol of the client, either 'openid-connect' or 'saml'\",\n        type: \"string\",\n        enum: [\"openid-connect\", \"saml\"],\n      },\n      attributes: {\n        description: \"Specifies attributes for the client.\",\n        type: \"object\",\n        additionalProperties: {\n          type: \"string\",\n        },\n      },\n      protocolMappers: {\n        description: \"Protocol Mappers to configure on the client\",\n        type: \"array\",\n        default: [],\n        items: {\n          type: \"object\",\n          required: [\"name\", \"protocol\", \"protocolMapper\"],\n          properties: {\n            name: {\n              description: \"Name of the mapper\",\n              type: \"string\",\n            },\n            protocol: {\n              description: \"Protocol of the mapper\",\n              type: \"string\",\n              enum: [\"openid-connect\", \"saml\"],\n            },\n            protocolMapper: {\n              description: \"Protocol Mapper type of the mapper\",\n              type: \"string\",\n            },\n            consentRequired: {\n              description: \"Whether user consent is required for this mapper\",\n              type: \"boolean\",\n              default: false,\n            },\n            config: {\n              description: \"Configuration options for the mapper.\",\n              type: \"object\",\n              additionalProperties: {\n                type: \"string\",\n              },\n            },\n          },\n        },\n      },\n      rootUrl: {\n        description: \"Root URL appended to relative URLs\",\n        type: \"string\",\n      },\n      redirectUris: {\n        description:\n          \"Valid URI pattern a browser can redirect to after a successful login. Simple wildcards are allowed such as 'https://unicorns.uds.dev/*'\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n        minItems: 1,\n      },\n      webOrigins: {\n        description:\n          \"Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does not include the '*' wildcard though. To permit all origins, explicitly add '*'.\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n      },\n      enabled: {\n        description: \"Whether the SSO client is enabled\",\n        type: \"boolean\",\n        default: true,\n      },\n      alwaysDisplayInConsole: {\n        description:\n          \"Always list this client in the Account UI, even if the user does not have an active session.\",\n        type: \"boolean\",\n        default: false,\n      },\n      standardFlowEnabled: {\n        description:\n          \"Enables the standard OpenID Connect redirect based authentication with authorization code.\",\n        type: \"boolean\",\n        default: true,\n      },\n      serviceAccountsEnabled: {\n        description:\n          \"Enables the client credentials grant based authentication via OpenID Connect protocol.\",\n        type: \"boolean\",\n        default: false,\n      },\n      publicClient: {\n        description: \"Defines whether the client requires a client secret for authentication\",\n        type: \"boolean\",\n        default: false,\n      },\n      clientAuthenticatorType: {\n        description: \"The client authenticator type\",\n        type: \"string\",\n        enum: [\"client-secret\", \"client-jwt\"],\n      },\n      defaultClientScopes: {\n        description: \"Default client scopes\",\n        type: \"array\",\n        items: {\n          type: \"string\",\n        },\n      },\n      groups: {\n        description: \"The client SSO group type\",\n        type: \"object\",\n        properties: {\n          anyOf: {\n            description: \"List of groups allowed to access the client\",\n            type: \"array\",\n            items: {\n              type: \"string\",\n            },\n          },\n        },\n      },\n    },\n  } as V1JSONSchemaProps,\n} as V1JSONSchemaProps;\n\nconst caBundle = {\n  description: \"CA bundle configuration for the package\",\n  type: \"object\",\n  properties: {\n    configMap: {\n      description: \"ConfigMap configuration for CA bundle\",\n      type: \"object\",\n      properties: {\n        name: {\n          description: \"The name of the ConfigMap to create (default: uds-trust-bundle)\",\n          type: \"string\",\n          default: \"uds-trust-bundle\",\n        },\n        key: {\n          description: \"The key name inside the ConfigMap (default: ca-bundle.pem)\",\n          type: \"string\",\n          default: \"ca-bundle.pem\",\n        },\n        labels: {\n          description: \"Additional labels to apply to the generated ConfigMap (default: {})\",\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\",\n          },\n          default: {},\n        },\n        annotations: {\n          description: \"Additional annotations to apply to the generated ConfigMap (default: {})\",\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\",\n          },\n          default: {},\n        },\n      },\n    },\n  },\n} as V1JSONSchemaProps;\n\nexport const v1alpha1: V1CustomResourceDefinitionVersion = {\n  name: \"v1alpha1\",\n  served: true,\n  storage: true,\n  additionalPrinterColumns: [\n    {\n      name: \"Status\",\n      type: \"string\",\n      description: \"The status of the package\",\n      jsonPath: \".status.phase\",\n    },\n    {\n      name: \"SSO Clients\",\n      type: \"string\",\n      description: \"SSO Clients created by the package\",\n      jsonPath: \".status.ssoClients\",\n    },\n    {\n      name: \"Endpoints\",\n      type: \"string\",\n      description: \"Service endpoints exposed by the package\",\n      jsonPath: \".status.endpoints\",\n    },\n    {\n      name: \"Monitors\",\n      type: \"string\",\n      description: \"Service monitors for the package\",\n      jsonPath: \".status.monitors\",\n    },\n    {\n      name: \"Network Policies\",\n      type: \"integer\",\n      description: \"The number of network policies created by the package\",\n      jsonPath: \".status.networkPolicyCount\",\n    },\n    {\n      name: \"Authorization Policies\",\n      type: \"integer\",\n      description: \"The number of authorization policies created by the package\",\n      jsonPath: \".status.authorizationPolicyCount\",\n    },\n    {\n      name: \"Age\",\n      type: \"date\",\n      description: \"The age of the package\",\n      jsonPath: \".metadata.creationTimestamp\",\n    },\n  ],\n  subresources: {\n    status: {},\n  },\n  schema: {\n    openAPIV3Schema: {\n      type: \"object\",\n      properties: {\n        status: {\n          type: \"object\",\n          properties: {\n            observedGeneration: {\n              type: \"integer\",\n            },\n            conditions: {\n              description: \"Status conditions following Kubernetes-style conventions\",\n              type: \"array\",\n              items: {\n                type: \"object\",\n                required: [\"type\", \"status\", \"lastTransitionTime\", \"reason\", \"message\"],\n                properties: {\n                  type: {\n                    description:\n                      \"Type of condition in CamelCase or in foo.example.com/CamelCase format\",\n                    type: \"string\",\n                  },\n                  status: {\n                    description: \"Status of the condition, one of True, False, Unknown\",\n                    type: \"string\",\n                    enum: [\"True\", \"False\", \"Unknown\"],\n                  },\n                  observedGeneration: {\n                    description:\n                      \"Represents the .metadata.generation that the condition was set based upon\",\n                    type: \"integer\",\n                  },\n                  lastTransitionTime: {\n                    description:\n                      \"The last time the condition transitioned from one status to another\",\n                    type: \"string\",\n                    format: \"date-time\",\n                  },\n                  reason: {\n                    description:\n                      \"A programmatic identifier indicating the reason for the condition's last transition\",\n                    type: \"string\",\n                  },\n                  message: {\n                    description: \"A human-readable message indicating details about the transition\",\n                    type: \"string\",\n                  },\n                },\n              },\n            },\n            phase: {\n              enum: [\"Pending\", \"Ready\", \"Failed\", \"Retrying\", \"Removing\", \"RemovalFailed\"],\n              type: \"string\",\n            },\n            ssoClients: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n            authserviceClients: {\n              type: \"array\",\n              items: {\n                type: \"object\",\n                required: [\"clientId\"],\n                properties: {\n                  clientId: { type: \"string\" },\n                  selector: {\n                    type: \"object\",\n                    additionalProperties: { type: \"string\" },\n                  },\n                },\n              },\n            },\n            meshMode: {\n              type: \"string\",\n              enum: [\"ambient\", \"sidecar\"],\n              description: \"The current service mesh mode for this package\",\n            },\n            endpoints: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n            monitors: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n            },\n            networkPolicyCount: {\n              type: \"integer\",\n            },\n            authorizationPolicyCount: {\n              type: \"integer\",\n            },\n            retryAttempt: {\n              type: \"integer\",\n              nullable: true,\n            },\n          },\n        } as V1JSONSchemaProps,\n        spec: {\n          type: \"object\",\n          properties: {\n            network: {\n              type: \"object\",\n              description: \"Network configuration for the package\",\n              properties: {\n                expose,\n                allow,\n                serviceMesh,\n              },\n            },\n            monitor,\n            sso,\n            caBundle,\n          },\n        } as V1JSONSchemaProps,\n      },\n    },\n  },\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Capability } from \"pepr\";\n\nexport const patches = new Capability({\n  name: \"patches\",\n  description: \"UDS Core Capability for patching miscellaneous things.\",\n});\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\n// Various validation actions for Kubernetes resources from Big Bang\nimport { K8s } from \"pepr\";\nimport { Component, setupLogger } from \"../logger\";\nimport { ExemptionStore } from \"../operator/controllers/exemptions/exemption-store\";\nimport { processExemptions } from \"../operator/controllers/exemptions/exemptions\";\nimport { registerWatchEventHandlers, watchCfg } from \"../operator/controllers/utils\";\nimport { Matcher, Policy, UDSExemption } from \"../operator/crd\";\nimport \"./istio\";\nimport \"./networking\";\nimport \"./security\";\nimport \"./storage\";\n\n// configure subproject logger\nconst log = setupLogger(Component.POLICIES);\n\nexport { policies } from \"./common\";\n\nexport type StoredMatcher = Matcher & { owner: string };\nexport type PolicyMap = Map<Policy, StoredMatcher[]>;\n\nexport async function startExemptionWatch() {\n  ExemptionStore.init();\n\n  // only run in admission controller or dev mode\n  if (process.env.PEPR_WATCH_MODE === \"false\" || process.env.PEPR_MODE === \"dev\") {\n    const watcher = K8s(UDSExemption).Watch(async (exemption, phase) => {\n      log.debug(`Processing exemption ${exemption.metadata?.name}, watch phase: ${phase}`);\n\n      processExemptions(exemption, phase);\n    }, watchCfg);\n\n    // This will run until the process is terminated or the watch is aborted\n    log.debug(\"Starting exemption watch...\");\n    registerWatchEventHandlers(watcher, log, \"UDSExemption\");\n    await watcher.start();\n  }\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Component, setupLogger } from \"../../../logger\";\nimport { StoredMatcher } from \"../../../policies\";\nimport { Matcher, Policy, UDSExemption } from \"../../crd\";\n\n// configure subproject logger\nconst log = setupLogger(Component.OPERATOR_EXEMPTIONS);\n\nexport type PolicyOwnerMap = Map<string, UDSExemption>;\nexport type PolicyMap = Map<Policy, StoredMatcher[]>;\nlet policyExemptionMap: PolicyMap;\nlet policyOwnerMap: PolicyOwnerMap;\n\nfunction init(): void {\n  policyExemptionMap = new Map();\n  policyOwnerMap = new Map();\n  for (const p of Object.values(Policy)) {\n    policyExemptionMap.set(p, []);\n  }\n}\n\nfunction getByPolicy(policy: Policy): StoredMatcher[] {\n  return policyExemptionMap.get(policy) || [];\n}\n\nfunction setByPolicy(policy: Policy, matchers: StoredMatcher[]): void {\n  policyExemptionMap.set(policy, matchers);\n}\n\nfunction addMatcher(matcher: Matcher, p: Policy, owner: string = \"\"): void {\n  const storedMatcher = {\n    ...matcher,\n    owner,\n  };\n\n  const storedMatchers = getByPolicy(p);\n  storedMatchers.push(storedMatcher);\n}\n\n// Iterate through each exemption block of CR and add matchers to PolicyMap\nfunction add(exemption: UDSExemption, logger: boolean = true) {\n  // Remove any existing exemption for this owner, in case of WatchPhase.Modified\n  remove(exemption);\n  const owner = exemption.metadata?.uid || \"\";\n  policyOwnerMap.set(owner, exemption);\n\n  for (const e of exemption.spec?.exemptions ?? []) {\n    const policies = e.policies ?? [];\n    for (const p of policies) {\n      // Append the matcher to the list of stored matchers for this policy\n      addMatcher(e.matcher, p, owner);\n      if (logger) {\n        log.debug(`Added exemption to ${p}: ${JSON.stringify(e.matcher)}`);\n      }\n    }\n  }\n}\n\nfunction remove(exemption: UDSExemption) {\n  const owner = exemption.metadata?.uid || \"\";\n  const prevExemption = policyOwnerMap.get(owner);\n\n  if (prevExemption) {\n    for (const e of prevExemption.spec?.exemptions ?? []) {\n      const policies = e.policies ?? [];\n      for (const p of policies) {\n        const existingMatchers = getByPolicy(p);\n        const filteredList = existingMatchers.filter(m => {\n          return m.owner !== owner;\n        });\n        setByPolicy(p, filteredList);\n      }\n    }\n    policyOwnerMap.delete(owner);\n    log.debug(`Removed all policy exemptions for ${owner}`);\n  } else {\n    log.debug(`No existing exemption for owner ${owner}`);\n  }\n}\n\n// export object with all included export as properties\nexport const ExemptionStore = {\n  init,\n  add,\n  remove,\n  getByPolicy,\n};\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { WatchPhase } from \"kubernetes-fluent-client/dist/fluent/shared-types\";\nimport { UDSExemption } from \"../../crd\";\nimport { ExemptionStore } from \"./exemption-store\";\n\n// Handle adding, updating, and deleting exemptions from Policymap\nexport function processExemptions(exemption: UDSExemption, phase: WatchPhase) {\n  switch (phase) {\n    case WatchPhase.Added:\n    case WatchPhase.Modified:\n      ExemptionStore.add(exemption);\n      break;\n\n    case WatchPhase.Deleted:\n      ExemptionStore.remove(exemption);\n      break;\n  }\n}\n", "/**\n * Copyright 2025 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { a, sdk } from \"pepr\";\n\nimport { V1Container, V1Pod, V1PodSecurityContext } from \"@kubernetes/client-node\";\nimport { Policy } from \"../operator/crd\";\nimport { isIstioProxyContainer, When } from \"./common\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\nconst { containers } = sdk;\n\n/**\n * This policy prevents the usage of Istio annotations to override sidecar behavior/configuration.\n *\n * Istio annotations can be used to override the default sidecar behavior, which can lead to\n * security vulnerabilities or misconfigurations. This policy ensures that annotations that can\n * potentially override secure sidecar behavior are not used on pods.\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictIstioSidecarOverrides))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictIstioSidecarOverrides)) {\n      return request.Approve();\n    }\n\n    const violations = checkIstioSidecarOverrides(request.Raw);\n\n    if (violations.length > 0) {\n      return request.Deny(\n        `The following istio annotations can modify secure sidecar configuration and are not allowed: ${violations.join(\", \")}`,\n      );\n    }\n\n    return request.Approve();\n  });\n\nexport function checkIstioSidecarOverrides(pod: V1Pod) {\n  // ref: https://istio.io/latest/docs/reference/config/annotations/\n  const blockedAnnotations = [\n    \"sidecar.istio.io/bootstrapOverride\", // Overrides entire Envoy bootstrap config\n    \"sidecar.istio.io/discoveryAddress\", // Can redirect sidecar to an untrusted control plane\n    \"sidecar.istio.io/proxyImage\", // Allows use of arbitrary proxy images\n    \"proxy.istio.io/config\", // Fully overrides proxy configuration\n    \"sidecar.istio.io/userVolume\", // Adds custom volumes to the sidecar container\n    \"sidecar.istio.io/userVolumeMount\", // Adds custom volume mounts to the sidecar container\n  ];\n\n  const annotations = pod.metadata?.annotations || {};\n  return Object.keys(annotations)\n    .filter(annotation => {\n      return blockedAnnotations.includes(annotation);\n    })\n    .sort((a, b) => a.localeCompare(b));\n}\n\n/**\n * This policy prevents the usage of Istio annotations or labels that override traffic interception behavior.\n *\n * Istio traffic annotations or labels can be used to modify how traffic is intercepted and routed, which can\n * lead to security bypasses or unintended network paths. This policy ensures that annotations or labels that\n * can potentially bypass secure networking controls are not used on pods.\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictIstioTrafficOverrides))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictIstioTrafficOverrides)) {\n      return request.Approve();\n    }\n\n    const podContainers = containers(request);\n\n    // Combine all violations and sort\n    const violations = checkIstioTrafficInterceptionOverrides(podContainers, request.Raw);\n\n    if (violations.length > 0) {\n      return request.Deny(\n        `The following istio annotations or labels can modify secure traffic interception are not allowed: ${violations.join(\", \")}`,\n      );\n    }\n\n    return request.Approve();\n  });\n\nexport function checkIstioTrafficInterceptionOverrides(podContainers: V1Container[], pod: V1Pod) {\n  const namespace = pod.metadata?.namespace || \"default\";\n  const annotations = pod.metadata?.annotations || {};\n  const labels = pod.metadata?.labels || {};\n  const blockedTrafficAnnotations = [\n    \"sidecar.istio.io/inject\", // Can disable sidecar injection\n    \"traffic.sidecar.istio.io/excludeInboundPorts\", // Can bypass inbound port interception\n    \"traffic.sidecar.istio.io/excludeInterfaces\", // Can exclude network interfaces from interception\n    \"traffic.sidecar.istio.io/excludeOutboundIPRanges\", // Can bypass outbound IP range interception\n    \"traffic.sidecar.istio.io/excludeOutboundPorts\", // Can bypass outbound port interception\n    \"traffic.sidecar.istio.io/includeInboundPorts\", // Can modify inbound port interception\n    \"traffic.sidecar.istio.io/includeOutboundIPRanges\", // Can modify outbound IP range interception\n    \"traffic.sidecar.istio.io/includeOutboundPorts\", // Can modify outbound port interception\n    \"sidecar.istio.io/interceptionMode\", // Can change interception mode (REDIRECT/TPROXY)\n    \"traffic.sidecar.istio.io/kubevirtInterfaces\", // Can modify kubevirt interface handling\n    \"istio.io/redirect-virtual-interfaces\", // Can modify virtual interface traffic handling\n  ];\n  const blockedTrafficLabels = [\n    \"sidecar.istio.io/inject\", // Can disable sidecar injection\n  ];\n  // Check annotations for violations\n  const annotationViolations = Object.entries(annotations)\n    .filter(([key]) => {\n      if (\n        // Ignore 'sidecar.istio.io/inject' annotation in istio-system namespace\n        (key === \"sidecar.istio.io/inject\" && namespace === \"istio-system\") ||\n        // Ignore 'sidecar.istio.io/inject=true' annotation\n        (key === \"sidecar.istio.io/inject\" && annotations[key].trim() === \"true\")\n      ) {\n        return false;\n      }\n\n      return blockedTrafficAnnotations.includes(key);\n    })\n    .map(([key]) => `annotation ${key}`);\n\n  // Check if the pod is an Istio waypoint pod so we can ignore it when checking side inject label\n  let isIstioWaypointPod = false;\n  for (const container of podContainers) {\n    if (\n      isIstioProxyContainer(container) && // Waypoints run istio-proxy containers\n      container.args?.some((arg: string) => arg === \"waypoint\")\n    ) {\n      isIstioWaypointPod = true;\n      break;\n    }\n  }\n\n  // Check labels for violations\n  const labelViolations = Object.entries(labels)\n    .filter(([key, value]) => {\n      if (\n        // Ignore 'sidecar.istio.io/inject' label in istio-system namespace\n        (key === \"sidecar.istio.io/inject\" && namespace === \"istio-system\") ||\n        // Ignore 'sidecar.istio.io/inject=true' label\n        (key === \"sidecar.istio.io/inject\" && value.trim() === \"true\") ||\n        // Ignore labels on Istio waypoint pods\n        (key === \"sidecar.istio.io/inject\" && isIstioWaypointPod)\n      ) {\n        return false;\n      }\n\n      return blockedTrafficLabels.includes(key);\n    })\n    .map(([key]) => `label ${key}`);\n\n  return [...annotationViolations, ...labelViolations].sort((a, b) => a.localeCompare(b));\n}\n\n/**\n * This policy prevents the use of any Istio Annotations that override default secure ambient mesh behavior on Pods.\n *\n * Istio allows some annotations to be used to override default secure ambient mesh behavior, such as traffic interception\n * This policy blocks all such annotations to prevent security vulnerabilities or misconfigurations.\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictIstioAmbientOverrides))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictIstioAmbientOverrides)) {\n      return request.Approve();\n    }\n\n    const violations = checkIstioAmbientOverrides(request.Raw);\n\n    if (violations.length > 0) {\n      return request.Deny(\n        `The following istio ambient annotations that can modify secure mesh behavior are not allowed: ${violations.join(\", \")}`,\n      );\n    }\n\n    return request.Approve();\n  });\n\nexport function checkIstioAmbientOverrides(pod: V1Pod) {\n  const annotations = pod.metadata?.annotations || {};\n  const ambientBlockedAnnotations = [\n    \"ambient.istio.io/bypass-inbound-capture\", // Bypasses inbound traffic capture in ambient mesh mode\n  ];\n\n  return Object.keys(annotations)\n    .filter(annotation => ambientBlockedAnnotations.includes(annotation))\n    .sort((a, b) => a.localeCompare(b));\n}\n\n/**\n * This policy restricts the use of the Istio proxy user/group (1337) to only be used by Istio proxy containers.\n * It allows specific Istio components (waypoints, ztunnel, and sidecars) to use these IDs.\n * This prevents unauthorized pods from running with elevated privileges that could be used to bypass security controls.\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictIstioUser))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictIstioUser)) {\n      return request.Approve();\n    }\n\n    // Check pod-level security context for UID/GID 1337\n    if (isPodUsingIstioUserID(request.Raw)) {\n      return request.Deny(\n        \"Pods cannot use UID/GID 1337 (Istio proxy) unless they are trusted Istio components\",\n      );\n    }\n\n    const podContainers = containers(request);\n\n    const violatingContainer = findContainerUsingIstioUserID(podContainers);\n    if (violatingContainer) {\n      return request.Deny(\n        `Container '${violatingContainer}' cannot use UID/GID 1337 (Istio proxy) as it is not a trusted Istio component`,\n      );\n    }\n\n    return request.Approve();\n  });\n\nexport function isPodUsingIstioUserID(pod: V1Pod) {\n  const podSecurityCtx = pod.spec?.securityContext || ({} as V1PodSecurityContext);\n\n  if (\n    podSecurityCtx.runAsUser === 1337 ||\n    podSecurityCtx.runAsGroup === 1337 ||\n    podSecurityCtx.fsGroup === 1337 ||\n    podSecurityCtx.supplementalGroups?.includes(1337)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function findContainerUsingIstioUserID(podContainers: V1Container[]): string | undefined {\n  // Check container security contexts\n  for (const container of podContainers) {\n    // Check if this is an Istio proxy container\n    const isIstioProxy = isIstioProxyContainer(container);\n\n    // Only check UID/GID 1337 if this is not an Istio proxy container\n    if (!isIstioProxy) {\n      const containerCtx = container.securityContext || {};\n      if (containerCtx.runAsUser === 1337 || containerCtx.runAsGroup === 1337) {\n        return container.name;\n      }\n    }\n  }\n  return undefined;\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { KubernetesObject, V1Container, V1SecurityContext } from \"@kubernetes/client-node\";\nimport { Capability, PeprMutateRequest, PeprValidateRequest, a, sdk } from \"pepr\";\nimport { Component, setupLogger } from \"../logger\";\nimport { Policy } from \"../operator/crd\";\n\nconst { containers } = sdk;\nexport type Ctx = {\n  name?: string;\n  ctx: V1SecurityContext;\n};\n\nexport const policies = new Capability({\n  name: \"uds-core-policies\",\n  description:\n    \"Collection of core validation policies for Pods, ConfigMaps, and other Kubernetes resources.\",\n});\n\nexport const { When } = policies;\n\nconst log = setupLogger(Component.POLICIES);\n\n// The default shouldn't be used, but is the default zarf registry in case our env doesn't get set as expected\nconst zarfRegistry = process.env.ZARF_REGISTRY_ADDRESS || \"127.0.0.1:31999\";\n\n// Map of flavor to its expected registry and repository for Istio proxy image\nconst ISTIO_IMAGE_FLAVOR_CONFIGS = {\n  upstream: {\n    registry: \"docker.io\",\n    repository: \"istio/proxyv2\",\n  },\n  registry1: {\n    registry: \"registry1.dso.mil\",\n    repository: \"ironbank/tetrate/istio/proxyv2\",\n  },\n  unicorn: {\n    registry: \"quay.io\",\n    repository: \"rfcurated/istio/proxyv2\",\n  },\n} as const;\n\n/**\n * Parse an image reference into its registry and repository components\n */\nexport function parseImageRef(imageRef: string): { registry: string; repository: string } | null {\n  if (!imageRef) return null;\n\n  try {\n    const trimmed = imageRef.trim();\n    if (trimmed === \"\") return null;\n\n    // Remove any tag or digest\n    const imageWithoutTag = trimmed.replace(/[@:][^/]+$/, \"\");\n\n    // Split on / - the repository section always starts with /\n    const parts = imageWithoutTag.split(\"/\");\n\n    const firstPart = parts[0];\n    // A registry must contain either `.`, `:`, or be `localhost`. Otherwise it is assumed this is `docker.io`.\n    const isRegistry =\n      firstPart.includes(\".\") || firstPart.includes(\":\") || firstPart === \"localhost\";\n\n    let registry: string;\n    let repository: string;\n\n    if (isRegistry) {\n      registry = firstPart;\n      repository = parts.slice(1).join(\"/\");\n\n      // If there's no repository, this image is unparsable\n      if (!repository) {\n        return null;\n      }\n    } else {\n      // No registry specified, use default `docker.io`\n      registry = \"docker.io\";\n      repository = imageWithoutTag;\n    }\n\n    return { registry, repository };\n  } catch (error) {\n    log.error(`Error parsing image reference '${imageRef}':`, error);\n    return null;\n  }\n}\n\n/**\n * Validate if an image is an allowed Istio proxy image\n */\nexport function validateIstioImage(imageString: string): boolean {\n  try {\n    const parsed = parseImageRef(imageString);\n    if (!parsed) return false;\n\n    const { registry, repository } = parsed;\n\n    // Find matching flavor by repository\n    for (const config of Object.values(ISTIO_IMAGE_FLAVOR_CONFIGS)) {\n      if (config.repository === repository) {\n        // Check if registry matches either the flavor's registry (connected environment) or the zarf registry\n        return registry === config.registry || registry === zarfRegistry;\n      }\n    }\n\n    return false;\n  } catch (error) {\n    log.error(`Error validating image ${imageString}:`, error);\n    return false;\n  }\n}\n\n// Returns all volumes in the pod\nexport function volumes(request: PeprValidateRequest<a.Pod>) {\n  return request.Raw.spec?.volumes || [];\n}\n\n/**\n * Returns all containers in the pod that have a securityContext\n *\n * @param request\n * @returns Map of container name to securityContext\n */\nexport function securityContextContainers(\n  request: PeprValidateRequest<a.Pod>,\n  excludeIstioInit = false,\n) {\n  return containers(request)\n    .filter(c => c.securityContext)\n    .filter(c => !excludeIstioInit || !isIstioInitContainer(request, c)) // conditionally filter out istio init containers\n    .map(c => ({ name: c.name, ctx: c.securityContext! }) as Ctx);\n}\n\nexport function securityContextMessage(\n  msg: string,\n  authorized: (string | undefined)[],\n  ctx: Ctx[],\n) {\n  const violations = ctx.map(c => JSON.stringify(c)).join(\" | \");\n  const authMsg = authorized.filter(a => a).join(\" | \");\n\n  return `${msg}. Authorized: [${authMsg}] Found: ${violations}`;\n}\n\n/**\n * Returns true if the container looks like an istio-init container\n *\n * @param request the request to check\n * @param container the container to check\n * @returns boolean\n */\nexport function isIstioInitContainer(\n  request: PeprValidateRequest<a.Pod> | PeprMutateRequest<a.Pod>,\n  container: V1Container,\n) {\n  // Check for the sidecar.istio.io/status annotation\n  if (!request.HasAnnotation(\"sidecar.istio.io/status\")) {\n    return false;\n  }\n\n  // Check for an istio-proxy in initContainers (native sidecar)\n  const hasSidecar = request.Raw.spec?.initContainers?.some(c => isIstioProxyContainer(c));\n\n  // Exit if no istio-proxy is found in initContainers\n  if (!hasSidecar) {\n    return false;\n  }\n\n  // If the container doesn't have an image, we can't validate\n  if (!container.image) {\n    return false;\n  }\n\n  // Check if the provided container looks like an istio-init container\n  const initContainer =\n    container.name === \"istio-init\" &&\n    container.args?.[0] === \"istio-iptables\" &&\n    container.command === undefined &&\n    validateIstioImage(container.image);\n\n  return initContainer;\n}\n\n/**\n * Check if a container is an Istio proxy container\n * @param container the container to check\n * @returns boolean\n */\nexport function isIstioProxyContainer(container: V1Container): boolean {\n  // If the container doesn't have an image, we can't validate\n  if (!container.image) {\n    return false;\n  }\n\n  // Check if the provided container looks like an istio-proxy container\n  const isProxyContainer =\n    container?.name === \"istio-proxy\" &&\n    container.ports?.some(p => p.name === \"http-envoy-prom\") &&\n    container.args?.[0] === \"proxy\" &&\n    container.command === undefined;\n\n  if (!isProxyContainer) {\n    return false;\n  }\n\n  return validateIstioImage(container.image);\n}\n\nfunction transform(policy: Policy) {\n  return policy\n    .split(/(?=[A-Z])/)\n    .join(\"-\")\n    .toLowerCase();\n}\n\nexport function annotateMutation<T extends KubernetesObject>(\n  request: PeprMutateRequest<T>,\n  policy: Policy,\n) {\n  const key = \"uds-core.pepr.dev/mutated\";\n  const annotations = request.Raw.metadata?.annotations ?? {};\n  const valStr = annotations[key];\n  const arr = JSON.parse(valStr || \"[]\");\n  const safePolicyName = transform(policy);\n  if (!arr.includes(safePolicyName)) {\n    arr.push(safePolicyName);\n  }\n  request.SetAnnotation(key, JSON.stringify(arr));\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { KubernetesObject } from \"kubernetes-fluent-client\";\nimport { PeprMutateRequest, PeprValidateRequest } from \"pepr\";\nimport { Component, setupLogger } from \"../../logger\";\nimport { ExemptionStore } from \"../../operator/controllers/exemptions/exemption-store\";\nimport { Policy } from \"../../operator/crd\";\n\n// configure subproject logger\nconst log = setupLogger(Component.POLICIES_EXEMPTIONS);\n\n/**\n * Check a resource against an exemption list for use by the validation action.\n *\n * @param policy Policy to get exemptions for\n * @param request The request to check.\n * @returns True if exempt and false otherwise\n */\nexport function isExempt<T extends KubernetesObject>(\n  request: PeprValidateRequest<T> | PeprMutateRequest<T>,\n  policy: Policy,\n) {\n  const exemptList = ExemptionStore.getByPolicy(policy);\n  const resourceName = request.Raw.metadata?.name || request.Raw.metadata?.generateName;\n  const resourceNamespace = request.Raw.metadata?.namespace;\n\n  if (exemptList.length !== 0) {\n    // Debug log to provide current exemptions for policy\n    log.debug(\n      `Checking ${resourceName} against ${policy} exemptions: ${JSON.stringify(exemptList)}`,\n    );\n    for (const exempt of exemptList) {\n      // If the exempt namespace is specified, check it\n      if (exempt.namespace !== resourceNamespace) {\n        continue;\n      }\n\n      // If the exempt name is specified, check it\n      if (!resourceName?.match(exempt.name)) {\n        continue;\n      }\n\n      // If we get here, the request is exempt\n      log.info(`${resourceName} is exempt from ${policy}`);\n      return true;\n    }\n  }\n\n  // No exemptions matched\n  return false;\n}\n\nexport const exemptionAnnotationPrefix = \"uds-core.pepr.dev/uds-core-policies\";\n\n/**\n *\n * @param policy\n * @returns Function that takes PeprMutateRequest and evaluates if request isExempt()\n */\nexport function markExemption<T extends KubernetesObject>(policy: Policy) {\n  return (request: PeprMutateRequest<T>) => {\n    if (isExempt(request, policy)) {\n      request.SetAnnotation(`${exemptionAnnotationPrefix}.${policy}`, \"exempted\");\n      return;\n    }\n  };\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { V1Container, V1PodSpec, V1ServiceSpec } from \"@kubernetes/client-node\";\nimport { a, sdk } from \"pepr\";\n\nimport { Policy } from \"../operator/crd\";\nimport { When } from \"./common\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\nconst { containers } = sdk;\n/**\n * This policy prevents pods from sharing the host namespaces.\n *\n * Host namespaces (Process ID namespace, Inter-Process Communication namespace, and network namespace)\n * allow access to shared information and can be used to elevate privileges. Pods should not be allowed\n * access to host namespaces. This policy ensures fields which make use of these host namespaces are\n * set to `false`.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-host-namespaces.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowHostNamespaces))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowHostNamespaces)) {\n      return request.Approve();\n    }\n\n    const podSpec = request.Raw.spec!;\n    const isValid = checkNoHostNamespaces(podSpec);\n\n    if (isValid) {\n      return request.Approve();\n    } else {\n      return request.Deny(\n        \"Sharing the host namespaces is disallowed. The fields spec.hostNetwork, spec.hostIPC, and spec.hostPID must not be set to true.\",\n      );\n    }\n  });\n\n/**\n * Checks if a pod spec is using host namespaces\n */\nexport function checkNoHostNamespaces(pod: V1PodSpec): boolean {\n  // If the pod is using the host network, IPC, or PID namespaces, it's invalid\n  if (pod.hostNetwork || pod.hostIPC || pod.hostPID) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * This policy restricts the use of host ports in Pods.\n *\n * Access to host ports can allow potential snooping of network traffic and should be\n * restricted to a known list. This policy ensures only approved ports\n * are defined in container's `hostPort` field.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-host-ports.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictHostPorts))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictHostPorts)) {\n      return request.Approve();\n    }\n\n    const containerList = containers(request);\n    const isValid = checkNoHostPorts(containerList);\n\n    if (isValid) {\n      return request.Approve();\n    } else {\n      return request.Deny(`Host ports are not allowed.`);\n    }\n  });\n\n/**\n * Checks if any containers in the pod are using host ports\n */\nexport function checkNoHostPorts(containerList: V1Container[]): boolean {\n  // Check if any container has a host port\n  const hasHostPort = containerList.flatMap(c => c.ports || []).find(p => p.hostPort);\n\n  // If a container has a host port, it's invalid\n  return !hasHostPort;\n}\n\n/**\n * This policy restricts the use of external names in services to mitigate the risk of MITM attacks.\n *\n * Service external names can be exploited by attackers to redirect traffic to malicious locations.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-external-names.yaml\n */\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictExternalNames))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictExternalNames)) {\n      return request.Approve();\n    }\n\n    const isValid = checkNotExternalNameService(request.Raw.spec);\n\n    if (isValid) {\n      return request.Approve();\n    } else {\n      return request.Deny(\"ExternalName services are not allowed.\");\n    }\n  });\n\n/**\n * Checks if a service is using ExternalName type\n */\nexport function checkNotExternalNameService(serviceSpec: V1ServiceSpec | undefined): boolean {\n  return serviceSpec?.type !== \"ExternalName\";\n}\n\n/**\n * This policy prevents the use of NodePort services in Kubernetes.\n *\n * NodePort services can pose security risks as they use a host port to receive traffic,\n * which cannot be controlled by a NetworkPolicy. This policy ensures that Services\n * do not use the NodePort type for enhanced security.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-nodeport-services.yaml\n */\nWhen(a.Service)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowNodePortServices))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowNodePortServices)) {\n      return request.Approve();\n    }\n\n    const isValid = checkNotNodePortService(request.Raw.spec);\n\n    if (isValid) {\n      return request.Approve();\n    } else {\n      return request.Deny(\"NodePort services are not allowed.\");\n    }\n  });\n\n/**\n * Checks if a service is using NodePort type\n */\nexport function checkNotNodePortService(serviceSpec: V1ServiceSpec | undefined): boolean {\n  return serviceSpec?.type !== \"NodePort\";\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { a, sdk } from \"pepr\";\n\nimport {\n  V1Container,\n  V1ObjectMeta,\n  V1PodSecurityContext,\n  V1PodSpec,\n} from \"@kubernetes/client-node\";\nimport { Policy } from \"../operator/crd\";\nimport {\n  Ctx,\n  When,\n  annotateMutation,\n  securityContextContainers,\n  securityContextMessage,\n} from \"./common\";\nimport { exemptionAnnotationPrefix, isExempt, markExemption } from \"./exemptions\";\n\nconst { containers } = sdk;\n\n// @lulaStart ede53ec3-fdb5-4cd5-a2b1-abcbe338b285\n/**\n * This policy ensures that Pods do not allow privilege escalation.\n *\n * The `allowPrivilegeEscalation` field in a container's security context should either be undefined\n * or set to `false` to prevent potential security vulnerabilities.\n *\n * Running containers in privileged mode disables many security mechanisms and grants extensive\n * access to host resources, which can lead to security breaches.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-privilege-escalation.yaml\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-privileged-containers.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(request => {\n    markExemption(Policy.DisallowPrivileged)(request);\n    if (request.HasAnnotation(`${exemptionAnnotationPrefix}.${Policy.DisallowPrivileged}`)) {\n      return;\n    }\n\n    if (setPrivilegeEscalation(containers(request))) {\n      annotateMutation(request, Policy.DisallowPrivileged);\n    }\n  })\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowPrivileged)) {\n      return request.Approve();\n    }\n\n    const violations = validatePrivilegeEscalation(securityContextContainers(request));\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Privilege escalation is disallowed\",\n          [\"allowPrivilegeEscalation = false\", \"privileged = false\"],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Sets allowPrivilegeEscalation to false for containers that meet the criteria:\n * - allowPrivilegeEscalation is undefined\n * - privileged is not true\n * - capabilities.add does not include CAP_SYS_ADMIN\n */\nexport function setPrivilegeEscalation(containers: V1Container[]): boolean {\n  let wasMutated = false;\n\n  for (const container of containers) {\n    container.securityContext = container.securityContext || {};\n    const shouldSetPrivilegeEscalation = [\n      container.securityContext.allowPrivilegeEscalation === undefined,\n      !container.securityContext.privileged,\n      !container.securityContext.capabilities?.add?.includes(\"CAP_SYS_ADMIN\"),\n    ].every(Boolean);\n\n    if (shouldSetPrivilegeEscalation) {\n      container.securityContext.allowPrivilegeEscalation = false;\n      wasMutated = true;\n    }\n  }\n\n  return wasMutated;\n}\n\n/**\n * Validates that containers do not allow privilege escalation\n */\nexport function validatePrivilegeEscalation(containers: Ctx[]): Ctx[] {\n  // Checking if allowPrivilegeEscalation is undefined. If yes, fallback to true as the default behavior in k8s is to allow if undefined.\n  // Checks the three different ways a container could escalate to admin privs\n  return containers.filter(c => (c.ctx.allowPrivilegeEscalation ?? true) || c.ctx.privileged);\n}\n\n/**\n * Require Non-root User for Pods\n *\n * Following the least privilege principle, containers should not be run as root. This policy ensures\n * containers either have `runAsNonRoot` set to `true` or `runAsUser` > 0. It applies to security contexts\n * defined at both the Pod level and individual container levels (including initContainers and ephemeralContainers).\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/require-non-root-user.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(request => {\n    markExemption(Policy.RequireNonRootUser)(request);\n    if (request.HasAnnotation(`${exemptionAnnotationPrefix}.${Policy.RequireNonRootUser}`)) {\n      return;\n    }\n\n    setNonRootUserSettings(request.Raw.spec!, request.Raw.metadata!);\n    annotateMutation(request, Policy.RequireNonRootUser);\n  })\n  .Validate(request => {\n    if (isExempt(request, Policy.RequireNonRootUser)) {\n      return request.Approve();\n    }\n\n    // Check pod securityContext\n    const podCtx = request.Raw.spec?.securityContext || {};\n    if (isRootSecurityContext(podCtx)) {\n      return request.Deny(\"Pod level securityContext does not meet the non-root user requirement.\");\n    }\n\n    // Check container securityContext, filter out istio-init containers\n    const violations = securityContextContainers(request, true).filter(c =>\n      isRootSecurityContext(c.ctx),\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container securityContext. Containers must not run as root or have root-level supplemental groups\",\n          [\"runAsNonRoot = true\", \"runAsUser > 0\", \"supplementalGroups must not include 0\"],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Configures the pod security context to ensure it runs as a non-root user\n */\nexport function setNonRootUserSettings(pod: V1PodSpec, metadata: V1ObjectMeta) {\n  // Ensure the securityContext field is defined\n  pod.securityContext = pod.securityContext || {};\n\n  // Set the runAsUser field if it is defined in a label\n  const runAsUser = metadata.labels?.[\"uds/user\"];\n  if (runAsUser) {\n    pod.securityContext.runAsUser = parseInt(runAsUser);\n  }\n\n  // Set the runAsGroup field if it is defined in a label\n  const runAsGroup = metadata.labels?.[\"uds/group\"];\n  if (runAsGroup) {\n    pod.securityContext.runAsGroup = parseInt(runAsGroup);\n  }\n\n  // Set the fsGroup field if it is defined in a label\n  const fsGroup = metadata.labels?.[\"uds/fsgroup\"];\n  if (fsGroup) {\n    pod.securityContext.fsGroup = parseInt(fsGroup);\n  }\n\n  // Set the runAsNonRoot field to true if it is undefined\n  if (pod.securityContext.runAsNonRoot === undefined) {\n    pod.securityContext.runAsNonRoot = true;\n  }\n\n  // Set the runAsUser field to 1000 if it is undefined\n  if (pod.securityContext.runAsUser === undefined) {\n    pod.securityContext.runAsUser = 1000;\n  }\n\n  // Set the runAsGroup field to 1000 if it is undefined\n  if (pod.securityContext.runAsGroup === undefined) {\n    pod.securityContext.runAsGroup = 1000;\n  }\n}\n\n/**\n * Checks if a security context represents a root user\n */\nexport function isRootSecurityContext(ctx: Partial<V1PodSecurityContext>): boolean {\n  const isRunAsRoot = ctx.runAsNonRoot === false;\n  const isRunAsRootUser = ctx.runAsUser === 0;\n  const hasRootSupplementalGroups = Boolean(ctx.supplementalGroups?.includes(0));\n\n  return isRunAsRoot || isRunAsRootUser || hasRootSupplementalGroups;\n}\n// @lulaEnd ede53ec3-fdb5-4cd5-a2b1-abcbe338b285\n\n/**\n * Restrict Proc Mount in Pods\n *\n * The default /proc masks are set up to reduce the attack surface. This policy\n * ensures nothing but the specified procMount can be used. By default only \"Default\"\n * is allowed. Applies to all containers, initContainers, and ephemeralContainers in a Pod.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-proc-mount.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictProcMount))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictProcMount)) {\n      return request.Approve();\n    }\n\n    const authorized = [undefined, \"Default\"];\n    const { violations } = validateProcMount(securityContextContainers(request), authorized);\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\"Unauthorized procMount type\", authorized, violations),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Validates that procMount types are within the allowed set\n */\nexport function validateProcMount(\n  containers: Ctx[],\n  allowedTypes: (string | undefined)[],\n): { violations: Ctx[]; isPodViolation: boolean } {\n  // Check container level security contexts\n  const containerViolations = containers.filter(\n    c => c.ctx.procMount && !allowedTypes.includes(c.ctx.procMount),\n  );\n\n  return {\n    violations: containerViolations,\n    isPodViolation: false, // Always false since procMount is container-level only\n  };\n}\n\n/**\n * Restrict Seccomp in Pods\n *\n * The SecComp profile should not be explicitly set to Unconfined. This policy ensures\n * that the `seccompProfile.Type` is undefined or restricted to `RuntimeDefault` or\n * `Localhost`. Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-seccomp.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictSeccomp))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictSeccomp)) {\n      return request.Approve();\n    }\n\n    const authorized = [undefined, \"RuntimeDefault\", \"Localhost\"];\n    const { violations, isPodViolation } = validateSeccompProfile(\n      request.Raw.spec?.securityContext,\n      securityContextContainers(request),\n      authorized,\n    );\n\n    if (violations.length) {\n      const message = isPodViolation\n        ? \"Unauthorized pod seccomp profile type\"\n        : \"Unauthorized container seccomp profile type\";\n\n      return request.Deny(securityContextMessage(message, authorized, violations));\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Validates that seccomp profile types are within the allowed set\n */\nexport function validateSeccompProfile(\n  podSecurityContext: V1PodSecurityContext | undefined,\n  containers: Ctx[],\n  allowedTypes: (string | undefined)[],\n): { violations: Ctx[]; isPodViolation: boolean } {\n  // Check pod level security context first\n  const podSeccompType = podSecurityContext?.seccompProfile?.type;\n  if (!allowedTypes.includes(podSeccompType)) {\n    return {\n      violations: [\n        {\n          name: \"pod\",\n          ctx: podSecurityContext || {},\n        },\n      ],\n      isPodViolation: true,\n    };\n  }\n\n  // Check container level security contexts\n  const containerViolations = containers.filter(\n    c => !allowedTypes.includes(c.ctx.seccompProfile?.type),\n  );\n\n  return {\n    violations: containerViolations,\n    isPodViolation: false,\n  };\n}\n\n/**\n * Disallow SELinux Options in Pods\n *\n * SELinux options can be used to escalate privileges. This policy ensures that the\n * `seLinuxOptions` user and role fields are set to undefined.\n * Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/disallow-selinux-options.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.DisallowSELinuxOptions))\n  .Validate(request => {\n    if (isExempt(request, Policy.DisallowSELinuxOptions)) {\n      return request.Approve();\n    }\n\n    const authorized = [\"user: undefined\", \"role: undefined\"];\n    const { violations, isPodViolation } = validateSELinuxOptions(\n      request.Raw.spec?.securityContext,\n      securityContextContainers(request),\n    );\n\n    if (violations.length) {\n      const message = isPodViolation\n        ? \"Unauthorized pod SELinux Options\"\n        : \"Unauthorized container SELinux Options\";\n\n      return request.Deny(securityContextMessage(message, authorized, violations));\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Validates that SELinux user and role options are not set\n */\nexport function validateSELinuxOptions(\n  podSecurityContext: V1PodSecurityContext | undefined,\n  containers: Ctx[],\n): { violations: Ctx[]; isPodViolation: boolean } {\n  // Check pod level security context\n  const seLinuxOptions = podSecurityContext?.seLinuxOptions;\n  if (seLinuxOptions?.user || seLinuxOptions?.role) {\n    return {\n      violations: [\n        {\n          name: \"pod\",\n          ctx: podSecurityContext || {},\n        },\n      ],\n      isPodViolation: true,\n    };\n  }\n\n  // Check container level security context\n  const containerViolations = containers.filter(\n    c => c.ctx.seLinuxOptions?.user || c.ctx.seLinuxOptions?.role,\n  );\n\n  return {\n    violations: containerViolations,\n    isPodViolation: false,\n  };\n}\n\n/**\n * Restrict SELinux Type in Pods\n *\n * SELinux options can be used to escalate privileges. This policy ensures that the\n * `seLinuxOptions` type field is set to either `container_t`, `container_init_t`, or\n * `container_kvm_t`. Applies to Pods and all types of containers within them.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-selinux-type.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictSELinuxType))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictSELinuxType)) {\n      return request.Approve();\n    }\n\n    const authorized = [undefined, \"container_t\", \"container_init_t\", \"container_kvm_t\"];\n    const { violations, isPodViolation } = validateSELinuxTypes(\n      request.Raw.spec?.securityContext,\n      securityContextContainers(request),\n      authorized,\n    );\n\n    if (violations.length) {\n      const message = isPodViolation\n        ? \"Unauthorized pod SELinux type\"\n        : \"Unauthorized container SELinux type\";\n\n      return request.Deny(securityContextMessage(message, authorized, violations));\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Validates that SELinux types are within the allowed set\n */\nexport function validateSELinuxTypes(\n  podSecurityContext: V1PodSecurityContext | undefined,\n  containers: Ctx[],\n  authorizedTypes: (string | undefined)[],\n): { violations: Ctx[]; isPodViolation: boolean } {\n  // Check pod level security context first\n  const podSeLinuxType = podSecurityContext?.seLinuxOptions?.type;\n  if (!authorizedTypes.includes(podSeLinuxType)) {\n    return {\n      violations: [\n        {\n          name: \"pod\",\n          ctx: podSecurityContext || {},\n        },\n      ],\n      isPodViolation: true,\n    };\n  }\n\n  // Only check containers if pod level passes\n  const containerViolations = containers.filter(\n    c => !authorizedTypes.includes(c.ctx.seLinuxOptions?.type),\n  );\n\n  return {\n    violations: containerViolations,\n    isPodViolation: false,\n  };\n}\n\n/**\n * Drop All Capabilities in Pods\n *\n * This policy ensures that all containers, initContainers, and ephemeralContainers in a Pod\n * explicitly specify `drop: [\"ALL\"]` in their securityContext capabilities. Capabilities permit\n * privileged actions without giving full root access. Dropping all capabilities and only adding\n * back those that are required increases the security posture of the Pod.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/require-drop-all-capabilities.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(request => {\n    markExemption(Policy.DropAllCapabilities)(request);\n    if (request.HasAnnotation(`${exemptionAnnotationPrefix}.${Policy.DropAllCapabilities}`)) {\n      return;\n    }\n\n    setAllContainersDropAllCapabilities(containers(request));\n    annotateMutation(request, Policy.DropAllCapabilities);\n  })\n  .Validate(request => {\n    if (isExempt(request, Policy.DropAllCapabilities)) {\n      return request.Approve();\n    }\n    const authorized = \"ALL\";\n    const violations = findContainersWithoutDropAllCapability(\n      securityContextContainers(request),\n      authorized,\n    );\n\n    if (violations.length) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container DROP capabilities in securityContext.capabilities.drop\",\n          [authorized],\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Sets the drop capabilities to [\"ALL\"] for all containers in the provided list\n */\nexport function setAllContainersDropAllCapabilities(containers: V1Container[]) {\n  // Always set drop: [\"ALL\"] for all containers\n  for (const container of containers) {\n    container.securityContext = container.securityContext || {};\n    container.securityContext.capabilities = container.securityContext.capabilities || {};\n    container.securityContext.capabilities.drop = [\"ALL\"];\n  }\n}\n\n/**\n * Finds containers that don't have the specified capability in their drop list\n */\nexport function findContainersWithoutDropAllCapability(\n  containers: Ctx[],\n  requiredCapability: string,\n) {\n  return containers.filter(c => {\n    // Match the original behavior: returns true if capabilities?.drop?.includes() is falsy\n    return !c.ctx.capabilities?.drop?.includes(requiredCapability);\n  });\n}\n\n/**\n * Restrict Capabilities in Pods\n *\n * This policy ensures that users cannot add additional capabilities beyond the allowed list to a Pod.\n * The allowed capability in this policy is 'NET_BIND_SERVICE'. The policy checks that the `add` field\n * in the `capabilities` of the `securityContext` for all containers, initContainers, and ephemeralContainers\n * contains only the allowed capability. This helps in preventing the escalation of privileges by restricting\n * the capabilities that can be added to a container.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-capabilities.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictCapabilities))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictCapabilities)) {\n      return request.Approve();\n    }\n\n    const authorized = [\"NET_BIND_SERVICE\"];\n    // Check container securityContext, filter out istio-init containers\n    const containers = securityContextContainers(request, true);\n    const violations = validateContainerCapabilities(containers, authorized);\n\n    if (violations.length > 0) {\n      return request.Deny(\n        securityContextMessage(\n          \"Unauthorized container capabilities in securityContext.capabilities.add\",\n          authorized,\n          violations,\n        ),\n      );\n    }\n\n    return request.Approve();\n  });\n\n/**\n * Validates container capabilities against an allowlist\n */\nexport function validateContainerCapabilities(\n  containers: Ctx[],\n  allowedCapabilities: string[],\n): Ctx[] {\n  return containers\n    .filter(\n      (c): c is Ctx & { ctx: { capabilities: { add: string[] } } } =>\n        !!c.ctx?.capabilities?.add?.length,\n    )\n    .filter(c => !c.ctx.capabilities.add.every(cap => allowedCapabilities.includes(cap)))\n    .map(c => ({\n      name: c.name || \"unnamed\",\n      ctx: {\n        capabilities: {\n          add: c.ctx.capabilities.add,\n        },\n      },\n    }));\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { a, sdk } from \"pepr\";\n\nimport { V1Container, V1Volume } from \"@kubernetes/client-node\";\nimport { Policy } from \"../operator/crd\";\nimport { When, volumes } from \"./common\";\nimport { isExempt, markExemption } from \"./exemptions\";\n\nconst { containers } = sdk;\n/**\n * Restrict Volume Types for Pods\n *\n * Volume types, beyond the core set, should be restricted to limit exposure to potential vulnerabilities\n * in Container Storage Interface (CSI) drivers.  In addition, HostPath volumes should not be allowed\n * because host directories could be exploited to access shared data or escalate privileges.  This policy\n * restricts use of volume types to the allowed list.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-volume-types.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictVolumeTypes))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictVolumeTypes)) {\n      return request.Approve();\n    }\n\n    const [isValid, invalidVolume] = validateVolumeTypes(volumes(request));\n\n    if (!isValid && invalidVolume) {\n      return request.Deny(\n        `Volume ${invalidVolume.name} has a disallowed volume type of '${invalidVolume.type}'.`,\n      );\n    }\n\n    // All volumes are allowed, so approve the request\n    return request.Approve();\n  });\n\n/**\n * Validates that all volumes in a pod use allowed volume types\n */\nexport function validateVolumeTypes(\n  volumes: V1Volume[],\n): [boolean, { name: string; type: string } | null] {\n  // List of allowed volume types\n  const allowedVolumeTypes = [\n    \"configMap\",\n    \"csi\",\n    \"downwardAPI\",\n    \"emptyDir\",\n    \"ephemeral\",\n    \"persistentVolumeClaim\",\n    \"projected\",\n    \"secret\",\n  ];\n\n  // Check all volumes in the pod spec, if any\n  for (const volume of volumes) {\n    // Get the volume type, which will be the only key in the volume object other than \"name\"\n    const volumeType = Object.keys(volume).find(key => key !== \"name\") || \"unknown\";\n\n    // If the volume type is not in the allowed list, deny the request\n    if (!allowedVolumeTypes.includes(volumeType)) {\n      return [\n        false,\n        {\n          name: volume.name,\n          type: volumeType,\n        },\n      ];\n    }\n  }\n\n  // All volumes are allowed\n  return [true, null];\n}\n\n/**\n * Restrict hostPath Volume Writable Paths for Pods\n *\n * hostPath volumes consume the underlying node's file system. If hostPath volumes are not universally disabled,\n * they should be required to be read-only. Pods which are allowed to mount hostPath volumes in read/write mode\n * pose a security risk even if confined to a \"safe\" file system on the host and may escape those confines\n * (see https://blog.aquasec.com/kubernetes-security-pod-escape-log-mounts). This policy checks containers for\n * hostPath volumes and validates they are explicitly mounted in readOnly mode.  It is strongly recommended to\n * pair this policy with another to restrict the path of hostPath volumes to a known list.\n *\n * @related https://repo1.dso.mil/big-bang/product/packages/kyverno-policies/-/blob/main/chart/templates/restrict-host-path-write.yaml\n */\nWhen(a.Pod)\n  .IsCreatedOrUpdated()\n  .Mutate(markExemption(Policy.RestrictHostPathWrite))\n  .Validate(request => {\n    if (isExempt(request, Policy.RestrictHostPathWrite)) {\n      return request.Approve();\n    }\n\n    const [isValid, invalidVolume] = validateHostPathVolumes(volumes(request), containers(request));\n\n    if (!isValid && invalidVolume) {\n      return request.Deny(`hostPath volume '${invalidVolume.name}' must be mounted as readOnly.`);\n    }\n\n    // All volumes are allowed, so approve the request\n    return request.Approve();\n  });\n\n/**\n * Validates that all hostPath volumes are mounted as read-only\n */\nexport function validateHostPathVolumes(\n  volumes: V1Volume[],\n  containers: V1Container[],\n): [boolean, { name: string } | null] {\n  for (const volume of volumes) {\n    // If the volume is a hostPath\n    if (volume.hostPath) {\n      // Check all mounts in any container for this volume and verify they are readOnly\n      const hasRWMount = containers\n        .flatMap(c => c.volumeMounts || [])\n        .filter(mount => mount.name === volume.name)\n        .some(mount => !mount.readOnly);\n\n      // If any mount is not readOnly, deny the request\n      if (hasRWMount) {\n        return [false, { name: volume.name }];\n      }\n    }\n  }\n\n  // All volumes are allowed\n  return [true, null];\n}\n", "/**\n * Copyright 2024 Defense Unicorns\n * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial\n */\n\nimport { Capability } from \"pepr\";\nimport { Component, setupLogger } from \"../logger\";\nimport { PrometheusPodMonitor, PrometheusServiceMonitor } from \"../operator/crd\";\nimport { FallbackScrapeProtocol } from \"../operator/crd/generated/prometheus/servicemonitor-v1\";\n\nconst log = setupLogger(Component.PROMETHEUS);\n\nexport const prometheus = new Capability({\n  name: \"prometheus\",\n  description: \"UDS Core Capability for the Prometheus stack.\",\n});\n\nconst { When } = prometheus;\n\n/**\n * Mutate a ServiceMonitor resource to add a fallbackScrapeProtocol of PrometheusText0.0.4\n * This maintains backwards compatibility with Prometheus 2.x to support UDS Packages.\n *\n * @param sm The ServiceMonitor to mutate\n */\nexport async function mutateServiceMonitor(sm: PrometheusServiceMonitor): Promise<void> {\n  // Always set fallbackScrapeProtocol if missing.\n  if (!sm.Raw.spec!.fallbackScrapeProtocol) {\n    sm.Raw.spec!.fallbackScrapeProtocol = FallbackScrapeProtocol.PrometheusText004;\n    log.info(`Set fallbackScrapeProtocol for ServiceMonitor ${sm.Raw.metadata?.name}`);\n  }\n}\n\nWhen(PrometheusServiceMonitor)\n  .IsCreatedOrUpdated()\n  .Mutate(async sm => await mutateServiceMonitor(sm));\n\n/**\n * Mutate a PodMonitor resource to add a fallbackScrapeProtocol of PrometheusText0.0.4\n * This maintains backwards compatibility with Prometheus 2.x to support UDS Packages.\n *\n * @param pm The PodMonitor to mutate\n */\nexport async function mutatePodMonitor(pm: PrometheusPodMonitor): Promise<void> {\n  if (!pm.Raw.spec!.fallbackScrapeProtocol) {\n    pm.Raw.spec!.fallbackScrapeProtocol = FallbackScrapeProtocol.PrometheusText004;\n    log.info(`Set fallbackScrapeProtocol for PodMonitor ${pm.Raw.metadata?.name}`);\n  }\n}\n\nWhen(PrometheusPodMonitor)\n  .IsCreatedOrUpdated()\n  .Mutate(async pm => await mutatePodMonitor(pm));\n"],
  "mappings": "8FAKA,IAAAA,GAA2B,gBCL3B,IAAAC,GAAA,CACE,KAAQ,WACR,QAAW,QACX,YAAe,4CACf,SAAY,CACV,OACA,MACA,gBACA,cACA,UACF,EACA,QAAW,CACT,KAAQ,UACV,EACA,KAAQ,CACN,KAAQ,WACR,KAAQ,WACR,QAAW,SACX,SAAY,OACZ,aAAgB,CACd,WAAc,CAAC,CACjB,EACA,UAAa,CACX,aAAgB,CACd,WAAc,CACZ,MACF,CACF,CACF,EACA,MAAS,CACP,aAAgB,CACd,WAAc,CACZ,MACF,CACF,CACF,EACA,mBAAsB,CACpB,CACE,cAAiB,SACjB,UAAa,cACf,CACF,CACF,EACA,QAAW,CACT,YAAa,0FACb,YAAa,sBACf,EACA,aAAgB,CACd,gBAAiB,UACjB,KAAQ,kBACV,EACA,gBAAmB,CACjB,kBAAmB,SACnB,kCAAmC,SACnC,mBAAoB,SACpB,aAAc,UACd,YAAa,UACb,sBAAuB,SACvB,QAAW,UACX,MAAS,QACT,cAAe,SACf,OAAU,QACZ,CACF,EC1DA,IAAAC,GAAoB,gBA0Bb,SAASC,EAAYC,EAAsB,CAChD,IAAMD,EAAc,OAAI,MAAM,CAAE,UAAAC,CAAU,CAAC,EAGvCC,EAAW,QAAQ,IAAI,cAC3B,OAAI,CAACA,GAAYA,IAAa,kCAC5BA,EAAW,SAGbF,EAAY,MAAQE,EAEbF,CACT,CAZgBG,EAAAH,EAAA,eCzBhB,IAAAI,EAAkB,gBCDlB,IAAAC,GAA2B,gBAEdC,GAAW,IAAI,cAAW,CACrC,KAAM,oBACN,YAAa,6EACf,CAAC,EAEY,CAAE,MAAAC,GAAO,KAAAC,CAAK,EAAIF,GCN/B,IAAAG,EAA6B,gBCA7B,IAAAC,GAA0C,oCACnC,IAAMC,GAAN,cAAsB,cAAY,CAPzC,MAOyC,CAAAC,EAAA,gBACvC,KACA,MACF,KA82BA,iBAAaC,GAAS,CACpB,MAAO,UACP,QAAS,WACT,KAAM,UACN,OAAQ,UACV,CAAC,ECv3BD,IAAAC,GAA0C,oCACnC,IAAMC,GAAN,cAAwB,cAAY,CAP3C,MAO2C,CAAAC,EAAA,kBACzC,IACF,EA0CO,IAAKC,QACVA,EAAA,uBAAyB,yBACzBA,EAAA,yBAA2B,2BAC3BA,EAAA,mBAAqB,qBACrBA,EAAA,uBAAyB,yBACzBA,EAAA,oBAAsB,sBACtBA,EAAA,mBAAqB,qBACrBA,EAAA,qBAAuB,uBACvBA,EAAA,sBAAwB,wBACxBA,EAAA,sBAAwB,wBACxBA,EAAA,kBAAoB,oBACpBA,EAAA,8BAAgC,gCAChCA,EAAA,8BAAgC,gCAChCA,EAAA,8BAAgC,gCAChCA,EAAA,kBAAoB,oBACpBA,EAAA,kBAAoB,oBACpBA,EAAA,oBAAsB,sBACtBA,EAAA,gBAAkB,kBAClBA,EAAA,oBAAsB,sBAlBZA,QAAA,OAqBZ,iBAAaC,GAAW,CACtB,MAAO,UACP,QAAS,WACT,KAAM,YACN,OAAQ,YACV,CAAC,ECvED,IAAAC,GAA0C,oCAEnC,IAAMC,GAAN,cAA4B,cAAY,CAR/C,MAQ+C,CAAAC,EAAA,sBAE7C,KACA,MACF,KA0FA,iBAAaC,GAAe,CAC1B,MAAO,UACP,QAAS,WACT,KAAM,gBACN,OAAQ,eACV,CAAC,ECpGD,IAAAC,GAA0C,oCAEnC,IAAMC,GAAN,cAA6B,cAAY,CAThD,MASgD,CAAAC,EAAA,uBAK9C,KACA,MACF,KAyxBA,iBAAaC,GAAgB,CAC3B,MAAO,sBACP,QAAS,UACT,KAAM,gBACR,CAAC,ECtyBD,IAAAC,GAA0C,oCAEnC,IAAMC,GAAN,cAA2B,cAAY,CAT9C,MAS8C,CAAAC,EAAA,qBAK5C,KAEA,MACF,KA6HA,iBAAaC,GAAc,CACzB,MAAO,sBACP,QAAS,UACT,KAAM,eACN,OAAQ,gBACV,CAAC,EC7ID,IAAAC,GAA0C,oCAanC,IAAMC,GAAN,cAAyB,cAAY,CAnB5C,MAmB4C,CAAAC,EAAA,mBAuB1C,IACF,KAgwCA,iBAAaC,GAAY,CACvB,MAAO,wBACP,QAAS,KACT,KAAM,aACN,OAAQ,aACV,CAAC,EC1yCD,IAAAC,GAA0C,oCAanC,IAAMC,GAAN,cAA6B,cAAY,CAnBhD,MAmBgD,CAAAC,EAAA,uBAwB9C,KAUA,MACF,KAg4CA,iBAAaC,GAAgB,CAC3B,MAAO,wBACP,QAAS,KACT,KAAM,iBACN,OAAQ,iBACV,CAAC,ECr7CD,IAAAC,GAA0C,oCACnC,IAAMC,EAAN,cAAkC,cAAY,CAPrD,MAOqD,CAAAC,EAAA,4BAKnD,KACA,MACF,KA8NA,iBAAaC,EAAqB,CAChC,MAAO,oBACP,QAAS,UACT,KAAM,sBACN,OAAQ,uBACV,CAAC,EC1OD,IAAAC,GAA0C,oCAEnC,IAAMC,GAAN,cAAoC,cAAY,CATvD,MASuD,CAAAC,EAAA,8BAKrD,KACA,MACF,KA0HA,iBAAaD,GAAuB,CAClC,MAAO,oBACP,QAAS,KACT,KAAM,uBACR,CAAC,ECxID,IAAAE,GAA0C,oCACnC,IAAMC,GAAN,cAA8B,cAAY,CAPjD,MAOiD,CAAAC,EAAA,wBAK/C,KACA,MACF,KAyoDA,iBAAaC,GAAiB,CAC5B,MAAO,sBACP,QAAS,KACT,KAAM,kBACN,OAAQ,kBACV,CAAC,ECtpDD,IAAAC,GAA0C,oCACnC,IAAMC,GAAN,cAAsB,cAAY,CAPzC,MAOyC,CAAAC,EAAA,gBAKvC,KACA,MACF,KAmPA,iBAAaC,GAAS,CACpB,MAAO,sBACP,QAAS,KACT,KAAM,UACN,OAAQ,UACV,CAAC,EChQD,IAAAC,GAA0C,oCACnC,IAAMC,GAAN,cAAsB,cAAY,CAPzC,MAOyC,CAAAC,EAAA,gBAKvC,KACA,MACF,KAklBA,iBAAaC,GAAS,CACpB,MAAO,sBACP,QAAS,KACT,KAAM,UACN,OAAQ,UACV,CAAC,EC9lBD,IAAAC,GAA0C,oCAKnC,IAAMC,GAAN,cAAyB,cAAY,CAZ5C,MAY4C,CAAAC,EAAA,mBAwB1C,KAIA,MACF,KAw6BA,iBAAaC,GAAY,CACvB,MAAO,4BACP,QAAS,KACT,KAAM,UACN,OAAQ,UACV,CAAC,ECl8BM,IAAKC,QACVA,EAAA,OAAS,SACTA,EAAA,MAAQ,QACRA,EAAA,YAAc,cAHJA,QAAA,ICfZ,IAAAC,GAA2B,6DAC3BC,GAA0B,gBCA1B,IAAAC,GAAgC,kBCAhC,IAAAC,GAAgE,oCAEhEC,GAA0B,gBAKnB,IAAMC,GACX,kEAMWC,GAAqB,CAChC,iBAAkB,QAAQ,IAAI,wBAC1B,SAAS,QAAQ,IAAI,wBAAyB,EAAE,EAChD,EACJ,eAAgB,QAAQ,IAAI,0BACxB,SAAS,QAAQ,IAAI,0BAA2B,EAAE,EAClD,EACJ,qBAAsB,QAAQ,IAAI,6BAC9B,SAAS,QAAQ,IAAI,6BAA8B,EAAE,EACrD,IACJ,kBAAmB,QAAQ,IAAI,6BAC3B,SAAS,QAAQ,IAAI,6BAA8B,EAAE,EACrD,GACN,EAEO,SAASC,GACdC,EACAC,EACAC,EACA,CACA,IAAMC,EAEF,CACF,CAAC,cAAW,OAAO,EAAGC,GAAO,CAE3BH,EAAI,MACF,sBAAsBC,CAAS,4DAA4DE,EAAI,OAAO,EACxG,EACA,QAAQ,KAAK,CAAC,CAChB,EACA,CAAC,cAAW,UAAU,EAAGA,GAAOH,EAAI,KAAK,yBAAyBC,CAAS,MAAME,EAAI,OAAO,EAAE,EAC9F,CAAC,cAAW,SAAS,EAAGC,GACtBJ,EAAI,MACF,yBAAyBC,CAAS,+BAA+BG,CAAU,WAAWA,IAAe,EAAI,GAAK,GAAG,EACnH,EACF,CAAC,cAAW,KAAK,EAAGD,GAAOH,EAAI,KAAK,qBAAqBC,CAAS,MAAME,EAAI,OAAO,EAAE,EACrF,CAAC,cAAW,aAAa,EAAGA,GAC1BH,EAAI,KAAK,4BAA4BC,CAAS,MAAME,EAAI,OAAO,EAAE,EACnE,CAAC,cAAW,UAAU,EAAGA,GAAOH,EAAI,KAAK,yBAAyBC,CAAS,MAAME,EAAI,OAAO,EAAE,CAChG,EACA,OAAO,QAAQD,CAAa,EAAE,QAAQ,CAAC,CAACG,EAAOC,CAAO,IAAM,CAC1DP,EAAQ,OAAO,GAAGM,EAAOC,CAAO,CAClC,CAAC,CACH,CA5BgBC,EAAAT,GAAA,8BAoCT,SAASU,EAAqBC,EAAc,CACjD,OACEA,EAEG,YAAY,EAEZ,QAAQ,cAAe,GAAG,EAE1B,MAAM,EAAG,GAAG,EAEZ,QAAQ,qBAAsB,EAAE,CAEvC,CAZgBF,EAAAC,EAAA,wBAmBT,SAASE,EAAYC,EAAqC,CAC/D,GAAM,CAAE,KAAAF,EAAM,IAAAG,CAAI,EAAID,EAAG,SAEzB,MAAO,CACL,CACE,WAAYA,EAAG,WACf,KAAMA,EAAG,KACT,IAAKC,EACL,KAAMH,CACR,CACF,CACF,CAXgBF,EAAAG,EAAA,eAyBhB,eAAsBG,EACpBC,EACAC,EACAC,EACAC,EACAjB,EACAkB,EACA,CACA,IAAIC,KAAQ,QAAIF,CAAI,EAAE,YAAYF,CAAS,EAAE,UAAU,cAAeC,CAAO,EAE7E,GAAIE,EACF,OAAW,CAACE,EAAKC,CAAK,IAAK,OAAO,QAAQH,CAAgB,EACxDC,EAAQA,EAAM,UAAUC,EAAKC,CAAK,EAItC,IAAMC,EAAY,MAAMH,EAAM,IAAI,EAElC,QAAWI,KAAYD,EAAU,MAC3BC,EAAS,UAAU,SAAS,gBAAgB,IAAMT,IACpDd,EAAI,MAAM,CAAE,SAAAuB,CAAS,EAAG,qBAAqBA,EAAS,IAAK,IAAIA,EAAS,SAAU,IAAI,EAAE,EACxF,QAAM,QAAIN,CAAI,EAAE,OAAOM,CAAQ,EAGrC,CAxBsBhB,EAAAM,EAAA,gBAoCtB,eAAsBW,EACpBC,EACAzB,EACA0B,EAAU,EACVC,EAAU,IACE,CACZ,IAAIC,EAAU,EACd,KAAOA,EAAUF,GACf,GAAI,CACF,OAAO,MAAMD,EAAG,CAClB,OAAStB,EAAK,CAEZ,GADAyB,IACIA,GAAWF,EACb,MAAMvB,EAGR,IAAI0B,EAAQ,gBACR1B,IACF0B,EAAQ,GAAG,KAAK,UAAU1B,CAAG,CAAC,GAE1BA,EAAI,MAAM,QACZ0B,EAAQ1B,EAAI,KAAK,QAERA,EAAI,UACb0B,EAAQ1B,EAAI,UAGhBH,EAAI,KACF,CAAE,MAAA6B,CAAM,EACR,WAAWD,CAAO,OAAOH,EAAG,MAAQ,oBAAoB,wBAAwBE,CAAO,KACzF,EACA,MAAM,IAAI,QAAQG,GAAW,WAAWA,EAASH,CAAO,CAAC,CAC3D,CAIF,MAAM,IAAI,MAAM,mDAAmD,CACrE,CArCsBpB,EAAAiB,EAAA,kBA6Cf,SAASO,GAASC,EAAa,CACpC,GAAI,CACF,OAAO,OAAO,KAAKA,EAAK,QAAQ,EAAE,SAAS,QAAQ,IAAMA,CAC3D,MAAQ,CACN,MAAO,EACT,CACF,CANgBzB,EAAAwB,GAAA,YAehB,eAAsBE,GACpBV,EACAlB,EAAiC,CAAC,EAClCL,EACe,CACf,IAAMS,EAAOc,EAAS,UAAU,KAC1BR,EAAYQ,EAAS,UAAU,UAC/BW,EAAeX,EAAS,KAE9B,GAAI,CAACd,GAAQ,CAACM,GAAa,CAACmB,EAAc,CACxC,IAAML,EAAQ,IAAI,MAAM,gEAAgE,EACxF,MAAA7B,EAAI,MAAM6B,EAAM,OAAO,EACjBA,CACR,CAGA,QAAM,QAAI,QAAK,SAAS,EAAE,OAAO,CAE/B,KAAM,SACN,OAAQ,SAER,GAAGxB,EAEH,SAAU,CACR,UAAAU,EACA,aAAcN,CAChB,EACA,eAAgB,CACd,WAAYc,EAAS,WACrB,KAAMW,EACN,KAAAzB,EACA,UAAAM,EACA,IAAKQ,EAAS,UAAU,GAC1B,EACA,eAAgB,IAAI,KACpB,mBAAoB,mBACpB,kBAAmB,QAAQ,IAAI,QACjC,CAAC,CACH,CAtCsBhB,EAAA0B,GAAA,eAyCtB,eAAsBE,GACpBpB,EACAqB,EACgC,CAChC,GAAI,CACF,OAAO,QAAM,QAAI,QAAK,SAAS,EAAE,IAAIrB,CAAS,CAChD,OAASsB,EAAG,CACV,GAAIA,GAAG,QAAU,IAAK,CACpB,GAAID,EACF,OAAO,KAEP,MAAMC,CAEV,KACE,OAAMA,CAEV,CACF,CAjBsB9B,EAAA4B,GAAA,qBAuBf,SAASG,GAAsBC,EAAiB,CAErD,OADaA,EAAI,MAAM,KAAO,CAAC,GACnB,OAAOC,GAAOA,GAAK,2BAA6B,IAAI,CAClE,CAHgBjC,EAAA+B,GAAA,yBDzQhB,eAAsBG,GAAkBC,EAAyC,CAC/E,GAAI,CACFC,GAAYD,EAAI,GAAG,CACrB,OAASE,EAAG,CACV,OAAOF,EAAI,KAAK,sBAAsBE,EAAE,OAAO,EAAE,CACnD,CACA,OAAOF,EAAI,QAAQ,CACrB,CAPsBG,EAAAJ,GAAA,qBASf,SAASE,GAAYG,EAAoB,CAE9C,GACEA,EAAI,MAAM,UAAU,OACpBA,EAAI,KAAK,SAAS,QAAU,kCAC5BA,EAAI,KAAK,SAAS,QAAU,yBAC5B,CACA,GAAI,CAACC,GAASD,EAAI,KAAK,SAAS,KAAK,EACnC,MAAM,IAAI,MAAM,2EAA2E,EAK7F,IAAME,EADe,OAAO,KAAKF,EAAI,KAAK,SAAS,MAAO,QAAQ,EAAE,SAAS,MAAM,EACnD,MAC9B,+DACF,EAEA,GAAI,CAACE,GAAcA,EAAW,SAAW,EACvC,MAAM,IAAI,MAAM,sDAAsD,EAIxEA,EAAW,QAAQ,CAACC,EAASC,IAAU,CACrC,GAAI,CACF,IAAI,mBAAgBD,CAAO,CAC7B,OAASL,EAAG,CACV,MAAM,IAAI,MACR,+CAA+CM,CAAK,KAAKN,aAAa,MAAQA,EAAE,QAAU,OAAOA,CAAC,CAAC,EACrG,CACF,CACF,CAAC,CACH,CACF,CAhCgBC,EAAAF,GAAA,eEdhB,IAAAQ,GAA0B,gBAMnB,IAAMC,GAA4B,gBACnCC,GAAyB,mBACzBC,GAAwB,gBAExBC,GAAMC,sBAAwC,EAWpD,eAAsBC,GAAkBC,EAAiBC,EAAkC,CACzF,IAAMC,EAAUF,EAAI,SAAU,KACxBG,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDI,EAAYC,EAAYL,CAAG,EAG3BM,EAAgBN,EAAI,MAAM,UAAU,WAAW,MAAQL,GACvDY,EAAeP,EAAI,MAAM,UAAU,WAAW,KAAOJ,GACrDY,EAAkBR,EAAI,MAAM,UAAU,WAAW,QAAU,CAAC,EAC5DS,EAAuBT,EAAI,MAAM,UAAU,WAAW,aAAe,CAAC,EAE5E,GAAI,CACFH,GAAI,MAAM,uCAAuCK,CAAO,EAAE,EAG1D,IAAMQ,EAAkBC,GAAqB,EAG7C,GAAI,CAACD,GAAmBA,EAAgB,KAAK,IAAM,GAAI,CACrDb,GAAI,MAAM,wEAAwEK,CAAO,EAAE,EAG3F,GAAI,CACF,QAAM,QAAI,QAAK,SAAS,EACrB,YAAYD,CAAS,EACrB,UAAU,cAAeC,CAAO,EAChC,UAAUR,GAA2B,MAAM,EAC3C,OAAO,EACVG,GAAI,MAAM,6CAA6CK,CAAO,iBAAiBD,CAAS,EAAE,CAC5F,MAAQ,CAER,CAEA,MACF,CAGA,IAAMW,EAAoC,CACxC,WAAY,KACZ,KAAM,YACN,SAAU,CACR,KAAMN,EACN,UAAWL,EACX,OAAQ,CACN,cAAeC,EACf,iBAAkBC,EAClB,CAACT,EAAyB,EAAG,OAC7B,GAAGc,CACL,EACA,YAAa,CACX,GAAGC,CACL,EAEA,gBAAiBL,CACnB,EACA,KAAM,CACJ,CAACG,CAAY,EAAGG,CAClB,CACF,EAGA,QAAM,QAAI,QAAK,SAAS,EAAE,MAAME,EAAmB,CAAE,MAAO,EAAK,CAAC,EAGlE,MAAMC,EAAaV,EAAYF,EAAWC,EAAS,QAAK,UAAWL,GAAK,CACtE,CAACH,EAAyB,EAAG,MAC/B,CAAC,CACH,OAASoB,EAAK,CACZ,MAAM,IAAI,MACR,6CAA6CZ,CAAO,YAAY,KAAK,UAAUY,CAAG,CAAC,EACrF,CACF,CACF,CAxEsBC,EAAAhB,GAAA,qBAkFtB,SAASY,IAA+B,CACtC,IAAMK,EAAkB,CAAC,EAGzB,GAAIC,EAAU,SAAS,MAAO,CAC5B,IAAMC,EAAY,KAAKD,EAAU,SAAS,KAAK,EAC3CC,GACFF,EAAM,KAAKE,CAAS,CAExB,CAGA,GAAID,EAAU,SAAS,iBAAmBA,EAAU,SAAS,SAAU,CACrE,IAAME,EAAW,KAAKF,EAAU,SAAS,QAAQ,EAC7CE,GACFH,EAAM,KAAKG,CAAQ,CAEvB,CAGA,GAAIF,EAAU,SAAS,oBAAsBA,EAAU,SAAS,YAAa,CAC3E,IAAMG,EAAc,KAAKH,EAAU,SAAS,WAAW,EACnDG,GACFJ,EAAM,KAAKI,CAAW,CAE1B,CAGA,OAAOJ,EACJ,OAAOK,GAAQA,EAAK,KAAK,CAAC,EAC1B,KAAK;AAAA;AAAA,CAAM,EACX,KAAK,CACV,CAhCSN,EAAAJ,GAAA,wBA0CT,eAAsBW,IAA6C,CACjE,GAAI,CACFzB,GAAI,MAAM,2DAA2D,EAGrE,IAAM0B,EAAW,QAAM,QAAIC,EAAU,EAAE,IAAI,EAE3C,GAAI,CAACD,EAAS,OAASA,EAAS,MAAM,SAAW,EAAG,CAClD1B,GAAI,MAAM,0DAA0D,EACpE,MACF,CAEAA,GAAI,MAAM,SAAS0B,EAAS,MAAM,MAAM,gDAAgD,EAGxF,QAAWvB,KAAOuB,EAAS,MAAO,CAChC,GAAI,CAACvB,EAAI,UAAU,MAAQ,CAACA,EAAI,UAAU,UAExC,SAGF,IAAME,EAAUF,EAAI,SAAS,KACvBC,EAAYD,EAAI,SAAS,UAE/B,GAAI,CACFH,GAAI,MACF,8CAA8CK,CAAO,iBAAiBD,CAAS,EACjF,EACA,MAAMF,GAAkBC,EAAKC,CAAS,CACxC,OAASa,EAAK,CAEZjB,GAAI,MACF,qDAAqDK,CAAO,iBAAiBD,CAAS,GACtFa,CACF,CAEF,CACF,CAEAjB,GAAI,MAAM,4DAA4D,CACxE,OAASiB,EAAK,CACZ,MAAAjB,GAAI,MAAM,yDAA0DiB,CAAG,EACjE,IAAI,MAAM,yDAA0D,CAAE,MAAOA,CAAI,CAAC,CAC1F,CACF,CA5CsBC,EAAAO,GAAA,+BCjJtB,IAAAG,GAAkB,gBCAlB,IAAAC,EAA6B,gBCQ7B,IAAMC,GAAMC,qBAAuC,EAI/CC,GACAC,GAQJ,SAASC,IAAa,CACpBF,GAAsB,IAAI,IAC1BC,GAAW,IAAI,GACjB,CAHSE,EAAAD,GAAA,QAeT,SAASE,GAAIC,EAAiBC,EAAkB,GAAY,CAC1D,GAAI,CAACD,EAAI,UAAU,WAAa,CAACA,EAAI,SAAS,KAC5C,MAAM,IAAI,MAAM,uDAAuD,EAEzE,IAAME,EAAYF,EAAI,SAAS,UACzBG,EAAOH,EAAI,SAAS,KAGrBL,GAAoB,IAAIO,CAAS,GACpCP,GAAoB,IAAIO,EAAW,IAAI,GAAK,EAG9C,IAAME,EAAeT,GAAoB,IAAIO,CAAS,EAChDG,EAAWD,EAAa,IAAID,CAAI,EAGtCC,EAAa,IAAID,EAAMH,CAAG,EAG1B,IAAMM,EAAUN,EAAI,MAAM,IACtBM,GACFA,EAAQ,QAAQC,GAAU,CACxB,IAAMC,EAAWD,EAAO,SACnBX,GAAS,IAAIY,CAAQ,GACxBZ,GAAS,IAAIY,EAAU,IAAI,GAAK,EAGlCZ,GAAS,IAAIY,CAAQ,EAAG,IAAIN,CAAS,CACvC,CAAC,EAGCD,IACEI,EACFZ,GAAI,MAAM,qCAAqCU,CAAI,iBAAiBD,CAAS,GAAG,EAEhFT,GAAI,MAAM,kBAAkBS,CAAS,IAAIC,CAAI,iBAAiB,EAGpE,CAtCSL,EAAAC,GAAA,OAkDT,SAASU,GAAOT,EAAiBC,EAAkB,GAAY,CAC7D,GAAI,CAACD,EAAI,UAAU,WAAa,CAACA,EAAI,SAAS,KAC5C,MAAM,IAAI,MAAM,uDAAuD,EAGzE,IAAME,EAAYF,EAAI,SAAS,UACzBG,EAAOH,EAAI,SAAS,KAEpBI,EAAeT,GAAoB,IAAIO,CAAS,EACtD,GAAI,CAACE,EAEH,OAIFA,EAAa,OAAOD,CAAI,EAGpBC,EAAa,OAAS,GACxBT,GAAoB,OAAOO,CAAS,EAItC,IAAMI,EAAUN,EAAI,MAAM,IACtBM,GACFA,EAAQ,QAAQC,GAAU,CACxB,IAAMC,EAAWD,EAAO,SAClBG,EAAQd,GAAS,IAAIY,CAAQ,EAC9BE,IACLA,EAAM,OAAOR,CAAS,EAClBQ,EAAM,OAAS,GACjBd,GAAS,OAAOY,CAAQ,EAE5B,CAAC,EAGCP,GACFR,GAAI,MAAM,oBAAoBS,CAAS,IAAIC,CAAI,mBAAmB,CAEtE,CAvCSL,EAAAW,GAAA,UAmDT,SAASE,GAAOT,EAA4B,CAC1C,OAAOP,GAAoB,IAAIO,CAAS,CAC1C,CAFSJ,EAAAa,GAAA,UAcT,SAASC,GAAWV,EAAkC,CACpD,IAAME,EAAeT,GAAoB,IAAIO,CAAS,EACtD,MAAI,CAACE,GAAgBA,EAAa,OAAS,EAClC,KAIF,MAAM,KAAKA,EAAa,KAAK,CAAC,EAAE,CAAC,CAC1C,CARSN,EAAAc,GAAA,cAgBT,SAASC,GAA4BL,EAA+B,CAClE,OAAOZ,GAAS,IAAIY,CAAQ,GAAK,IAAI,GACvC,CAFSV,EAAAe,GAAA,+BAQT,SAASC,IAAmC,CAC1C,IAAMC,EAAuB,CAAC,EAC9B,QAAWX,KAAgBT,GAAoB,OAAO,EACpD,QAAWK,KAAOI,EAAa,OAAO,EAChCJ,EAAI,MAAM,SAAS,aAAa,OAAS,WAC3Ce,EAAO,KAAKf,CAAG,EAIrB,OAAOe,CACT,CAVSjB,EAAAgB,GAAA,sBAiBT,SAASE,GAAsBd,EAA2C,CACxE,IAAME,EAAeT,GAAoB,IAAIO,CAAS,EACtD,GAAI,GAACE,GAAgBA,EAAa,OAAS,GAG3C,OAAO,MAAM,KAAKA,EAAa,OAAO,CAAC,EAAE,CAAC,CAC5C,CANSN,EAAAkB,GAAA,yBAQF,IAAMC,GAAe,CAC1B,KAAApB,GACA,IAAAE,GACA,OAAAU,GACA,OAAAE,GACA,WAAAC,GACA,4BAAAC,GACA,mBAAAC,GACA,sBAAAE,EACF,ECjNA,IAAAE,GAAoB,gBCKb,SAASC,GACdC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,IAAMC,EAASD,EACX,CAAE,WAAY,CAAC,oBAAoBJ,CAAS,OAAOI,CAAc,EAAE,CAAE,EACrE,CAAE,WAAY,CAAC,GAAGJ,CAAS,EAAE,CAAE,EAkCnC,MAhC6C,CAC3C,SAAU,CACR,KAAMM,GAA6CR,EAAMM,CAAc,EACvE,UAAAJ,EACA,OAAQ,CACN,cAAeD,EACf,iBAAkBE,EAClB,UAAW,QACb,EAEA,gBAAiBC,CACnB,EACA,KAAM,CACJ,eACA,MAAO,CACL,CACE,KAAM,CACJ,CACE,OAAAG,CACF,CACF,CACF,CACF,EAEA,UAAW,CACT,MAAO,sBACP,KAAM,eACN,KAAMF,CACR,CACF,CACF,CAGF,CA9CgBI,EAAAV,GAAA,4CAgDT,SAASS,GACdR,EACAM,EACA,CACA,OAAOA,EACHI,EAAqB,GAAGV,CAAI,IAAIM,CAAc,SAAS,EACvDI,EAAqB,GAAGV,CAAI,SAAS,CAC3C,CAPgBS,EAAAD,GAAA,gDCrDhB,IAAAG,GAA0B,gBCA1B,IAAAC,GAAoB,gBCApB,IAAAC,GAAoB,gBC6Bb,SAASC,GACdC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,GAAM,CAAE,QAAAC,WAA0B,KAAAC,CAAK,EAAIN,EAErCO,EAAOC,GAAeN,EAASF,CAAM,EAGrCS,EAASJ,IAAY,QAAgBK,EAAU,YAAcA,EAAU,OAGzEC,EAAO,GACPL,IAAS,IACXK,EAAOF,EAEPE,EAAO,GAAGL,CAAI,IAAIG,CAAM,GAG1B,IAAMG,EAA8B,CAClC,KAAM,QACN,OAAQ,IACR,SAAU,OACZ,EAEMC,EAAsC,CAE1C,QAAS,GAAGR,CAAO,yBAAyBA,CAAO,4BACrD,EAuBA,MArBmC,CACjC,SAAU,CACR,KAAAE,EACA,UAAAN,EACA,OAAQ,CACN,cAAeC,EACf,iBAAkBC,CACpB,EAEA,gBAAiBC,CACnB,EACA,KAAM,CAEJ,MAAO,CAACO,CAAI,EACZ,yBACA,iBACA,MAAO,CAACC,CAAgB,EACxB,UAAW,CAACC,CAAoB,CAClC,CACF,CAGF,CAvDgBC,EAAAf,GAAA,+BAyDT,SAASS,GAAeN,EAAiBF,EAAgB,CAC9D,GAAM,CAAE,QAAAK,WAA0B,KAAAC,CAAK,EAAIN,EAM3C,OAFae,EAAqB,GAAGb,CAAO,IAAIG,CAAO,IADjCC,IAAS,IAAM,cAAgBA,CACmB,EAAE,CAG5E,CARgBQ,EAAAN,GAAA,kBAoBT,SAASQ,GACdV,EACAW,EACAf,EACAD,EACAE,EACAC,EACAc,EACA,CACA,GAAM,CAAE,aAAAC,CAAa,EAAIF,EAEnBV,EAAOa,GAA0BlB,EAASiB,EAAcb,CAAI,EAG5De,EAAqBF,EAAa,IAAIG,IAAO,CACjD,KAAM,GAAGA,EAAG,SAAS,YAAY,CAAC,IAAIA,EAAG,KAAK,SAAS,CAAC,GACxD,OAAQA,EAAG,KACX,SAAUA,EAAG,QACf,EAAE,EAEIC,EAAkC,CACtC,SAAU,CACR,KAAAhB,EACA,UAAAN,EACA,OAAQ,CACN,cAAeC,EACf,iBAAkBC,CACpB,EAEA,gBAAiBC,CACnB,EACA,KAAM,CACJ,MAAO,CAACE,CAAI,EACZ,yBACA,iBACA,MAAAe,EACA,SAAU,CAAC,GAAG,CAChB,CACF,EAGA,OAAIH,IAAc,YAChBK,EAAa,SAAU,OAAQ,uBAAuB,EAAIC,GAC1DD,EAAa,SAAU,OAAQ,iCAAiC,EAAIE,IAG/DF,CACT,CA/CgBT,EAAAE,GAAA,mCAiDT,SAASU,GACdpB,EACAqB,EACAxB,EACA,CACA,IAAMI,EAAOqB,GAA2BtB,CAAI,EAGtCuB,EAAsC,CAAC,EAC7C,QAAWC,KAASH,EAAS,SAC3BE,EAAY,GAAGE,GAAuBD,CAAK,CAAC,EAAE,EAAI,OAIpD,IAAMT,EAAQM,EAAS,cAAc,IAAIL,IAAO,CAC9C,KAAM,GAAGA,EAAG,SAAS,YAAY,CAAC,IAAIA,EAAG,KAAK,SAAS,CAAC,GACxD,OAAQA,EAAG,KACX,SAAUA,EAAG,QACf,EAAE,EAqBF,MAnBwC,CACtC,SAAU,CACR,KAAAf,EACA,UAAWyB,EACX,YAAAH,EACA,OAAQ,CACN,cAAeI,GACf,iBAAkB9B,EAAW,SAAS,CACxC,CACF,EACA,KAAM,CACJ,MAAO,CAACG,CAAI,EACZ,yBACA,iBACA,MAAAe,EACA,SAAU,CAAC,GAAG,CAChB,CACF,CAGF,CAxCgBP,EAAAY,GAAA,8BA0CT,SAASN,GACdlB,EACAiB,EACAb,EACA,CACA,IAAM4B,EAAWf,EACd,IAAIG,GAAM,GAAGA,EAAG,KAAK,SAAS,CAAC,IAAIA,EAAG,SAAS,YAAY,CAAC,EAAE,EAC9D,KAAK,GAAG,EACX,OAAOP,EAAqB,GAAGb,CAAO,WAAWI,CAAI,IAAI4B,CAAQ,EAAE,CACrE,CATgBpB,EAAAM,GAAA,6BAWhB,SAASQ,GAA2BtB,EAAc,CAChD,OAAOS,EAAqB,iBAAiBT,CAAI,EAAE,CACrD,CAFSQ,EAAAc,GAAA,8BC9MT,IAAAO,GAAoB,gBAsBb,SAASC,GACdC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,GAAM,CAAE,QAAAC,WAA0B,KAAAC,EAAM,KAAAC,EAAM,QAAAC,EAAS,aAAAC,EAAe,CAAC,CAAE,EAAIT,EAEvEU,EAAOC,GAAeT,EAASF,CAAM,EAGvCY,EAASC,EAAU,OACnBb,EAAO,OACTY,EAASZ,EAAO,QACPK,IAAY,SAAiBA,EAAQ,SAAS,OAAO,KAC9DO,EAASC,EAAU,aAIrB,IAAIC,EAAO,GACPR,IAAS,IACXQ,EAAOF,EAEPE,EAAO,GAAGR,CAAI,IAAIM,CAAM,GAG1B,IAAMG,EAAkB,CAAE,GAAGN,CAAa,EAGpCO,EAA0B,CAC9B,CACE,YAAa,CAEX,KAAM,GAAGR,CAAO,IAAIP,CAAS,qBAE7B,KAAM,CAAE,OAAQM,CAAK,CACvB,CACF,CACF,EAEI,CAACE,EAAa,gBAAkB,CAACA,EAAa,WAEhDM,EAAK,MAAQC,GAGf,IAAMC,EAA+B,CACnC,SAAU,CACR,KAAAP,EACA,UAAAT,EACA,OAAQ,CACN,cAAeC,EACf,iBAAkBC,CACpB,EAEA,gBAAiBC,CACnB,EACA,KAAM,CAEJ,MAAO,CAACU,CAAI,EAEZ,SAAU,CAAC,SAAST,CAAO,YAAYA,CAAO,UAAU,EAExD,KAAM,CAACU,CAAI,CACb,CACF,EAGA,OAAIV,IAAY,eAAuBA,EAAQ,SAAS,aAAa,KACnEY,EAAQ,KAAM,IAAM,CAClB,CACE,MAAO,CAAC,CAAE,KAAM,IAAK,SAAU,CAACH,CAAI,CAAE,CAAC,EACvC,MAAAE,CACF,CACF,GAEKC,CACT,CA7EgBC,EAAAnB,GAAA,iCA+ET,SAASY,GAAeT,EAAiBF,EAAgB,CAC9D,GAAM,CAAE,QAAAK,WAA0B,KAAAC,EAAM,KAAAC,EAAM,QAAAC,EAAS,YAAAW,EAAa,aAAAV,CAAa,EAAIT,EAG/EoB,EAAYX,GAAc,OAAO,QAAQ,GAAK,EAAE,IAAI,EAAE,KAAK,GAAG,GAAK,GAEnEY,EAAaF,GAAe,GADZb,IAAS,IAAM,cAAgBA,CACH,IAAIC,CAAI,IAAIC,CAAO,IAAIY,CAAS,GAGlF,OAFaE,EAAqB,GAAGpB,CAAO,IAAIG,CAAO,IAAIgB,CAAU,EAAE,CAGzE,CAVgBH,EAAAP,GAAA,kBAmBT,SAASY,GACdjB,EACAkB,EACArB,EACA,CACA,IAAMO,EAAOe,GAAqBnB,CAAI,EAGhCoB,EAAsC,CAAC,EAC7C,QAAWC,KAASH,EAAS,SAC3BE,EAAY,GAAGE,GAAuBD,CAAK,CAAC,EAAE,EAAI,OAIpD,IAAME,EAA0B,CAAC,EAC3BC,EAAwB,CAAC,EAC/B,QAAWC,KAAgBP,EAAS,cAAe,CACjD,IAAMjB,EAAOwB,EAAa,KACpBC,EAAWD,EAAa,SACxBf,EAAQiB,GAA6B3B,EAAMC,EAAMyB,CAAQ,EAC3DA,GAAY,MACdF,EAAU,KAAK,GAAId,CAAoB,EAC9BgB,GAAY,QACrBH,EAAW,KAAK,GAAIb,CAAqB,CAE7C,CAqBA,MAlBgC,CAC9B,SAAU,CACR,KAAAN,EACA,UAAAwB,EACA,YAAAR,EACA,OAAQ,CACN,iBAAkBvB,EAAW,SAAS,EACtC,cAAegC,EACjB,CACF,EACA,KAAM,CACJ,MAAO,CAAC7B,CAAI,EACZ,SAAU,CAAC,OAAQ,GAAG8B,GAAoB9B,CAAI,CAAC,EAAE,EACjD,GAAIwB,EAAU,OAAS,GAAK,CAAE,IAAKA,CAAU,EAC7C,GAAID,EAAW,OAAS,GAAK,CAAE,KAAMA,CAAW,CAClD,CACF,CAGF,CA/CgBX,EAAAK,GAAA,gCAkDhB,SAASU,GAA6B3B,EAAcC,EAAcyB,EAAkB,CAClF,IAAMK,EAAY,CAChB,SAAU,CAAC,MAAM,EACjB,KAAA9B,EACA,GAAIyB,GAAY,OAAS,CAAE,SAAU,CAAC1B,CAAI,CAAE,CAC9C,EAEMgC,EAAe,CACnB,SAAU,CAAC,GAAGF,GAAoB9B,CAAI,CAAC,EAAE,EACzC,KAAAC,EACA,GAAIyB,GAAY,OAAS,CAAE,SAAU,CAAC1B,CAAI,CAAE,CAC9C,EAEA,MAAO,CACL,CACE,MAAO,CAAC+B,CAAS,EACjB,MAAO,CACL,CACE,YAAa,CACX,KAAM,iBAAiBH,CAAS,qBAChC,KAAM,CAAE,OAAQ3B,CAAK,CACvB,CACF,CACF,CACF,EACA,CACE,MAAO,CAAC+B,CAAY,EACpB,MAAO,CACL,CACE,YAAa,CACX,KAAAhC,EACA,KAAM,CAAE,OAAQC,CAAK,CACvB,CACF,CACF,CACF,CACF,CACF,CArCSW,EAAAe,GAAA,gCA2CT,eAAsBM,GAAoCjC,EAAc,CACtE,IAAMkC,EAAkB,QAAM,QAAIC,EAAmB,EAAE,IAAI,EACrD/B,EAAOe,GAAqBnB,CAAI,EAGtC,QAAWoC,KAAMF,EAAgB,MAC/B,GAAI,EAAAE,EAAG,UAAU,OAAShC,GAAQgC,EAAG,UAAU,YAAcR,IAIzDQ,EAAG,MAAQA,EAAG,KAAK,OACrB,QAAWC,KAAUD,EAAG,KAAK,MAC3B,GAAIC,IAAWrC,EAAM,CACnB,IAAMsC,EAAU,kCAAkCF,EAAG,UAAU,IAAI,IAAIA,EAAG,UAAU,SAAS,2GAC7F,MAAAG,EAAI,MAAMD,CAAO,EACX,IAAI,MAAMA,CAAO,CACzB,EAIR,CApBsB1B,EAAAqB,GAAA,uCAsBf,SAASd,GAAqBnB,EAAc,CACjD,OAAOgB,EAAqB,aAAahB,CAAI,EAAE,CACjD,CAFgBY,EAAAO,GAAA,wBFrNT,IAAMqB,EAAMC,kBAAoC,EASvD,eAAsBC,GAAeC,EAAiBC,EAAmB,CACvE,IAAMC,EAAUF,EAAI,SAAU,KACxBG,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDI,EAAYC,EAAYL,CAAG,EAG3BM,EAAaN,EAAI,MAAM,SAAS,QAAU,CAAC,EAG3CO,EAAQ,IAAI,IAGZC,EAA0C,IAAI,IAGpD,QAAWC,KAAUH,EAAY,CAE/B,IAAMI,EAAYC,GAChBF,EACAR,EACAC,EACAC,EACAC,CACF,EAEAP,EAAI,MAAMa,EAAW,2BAA2BA,EAAU,UAAU,IAAI,EAAE,EAG1E,QAAM,QAAIE,EAAmB,EAAE,MAAMF,EAAW,CAAE,MAAO,EAAK,CAAC,EAE/DA,EAAU,KAAM,MAAO,QAAQG,GAAKN,EAAM,IAAIM,CAAC,CAAC,EAGhD,IAAMC,EAAYC,GAChBN,EACAR,EACAC,EACAC,EACAC,CACF,EAGII,EAAkB,IAAIM,EAAU,SAAU,IAAK,IAInDjB,EAAI,MAAMiB,EAAW,yBAAyBA,EAAU,UAAU,IAAI,EAAE,EAGxE,QAAM,QAAIE,EAAiB,EAAE,MAAMF,EAAW,CAAE,MAAO,EAAK,CAAC,EAE7DN,EAAkB,IAAIM,EAAU,SAAU,KAAO,EAAI,EACvD,CAGA,aAAMG,GAAqBjB,EAAKC,CAAS,EAGzC,MAAMiB,EAAaf,EAAYF,EAAWC,EAASU,GAAqBf,CAAG,EAC3E,MAAMqB,EAAaf,EAAYF,EAAWC,EAASc,GAAmBnB,CAAG,EACzE,MAAMqB,EAAaf,EAAYF,EAAWC,EAASiB,GAActB,CAAG,EACpE,MAAMqB,EAAaf,EAAYF,EAAWC,EAASkB,EAA0BvB,EAAK,CAChF,UAAW,QACb,CAAC,EAGM,CAAC,GAAGU,CAAK,CAClB,CAnEsBc,EAAAtB,GAAA,kBA4EtB,eAAsBkB,GAAqBjB,EAAiBC,EAAmB,CAE7E,IAAMqB,EAAYtB,EAAI,MAAM,SAAS,aAAa,MAAQ,UACpDuB,EAAQC,GAAaxB,CAAG,EACxBE,EAAUF,EAAI,SAAU,KACxBG,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDI,EAAYC,EAAYL,CAAG,EAG3ByB,EAAkBC,GAAsB1B,CAAG,EAG3C2B,EAAYC,GAA2B5B,EAAI,MAAM,SAAS,OAAS,CAAC,CAAC,EAG3E,GAAIyB,EACF,GAAIH,IAAc,UAAc,CAE9B,GAAI,CACF,MAAMO,GAAkBC,EAAsB,CAChD,OAASC,EAAG,CACV,IAAIC,EAAU,+CAA+CF,EAAsB,IACnF,MAAIC,GAAG,QAAU,MACfC,EAAU,QAAQF,EAAsB,qGAE1CjC,EAAI,MAAMmC,CAAO,EACX,IAAI,MAAMA,CAAO,CACzB,CAGA,MAAMC,GACJR,EACAE,EACAzB,EACAD,EACAE,EACAC,CACF,CACF,MAEE,MAAM8B,GAAsBT,CAAe,EAG3C,MAAMU,GACJV,EACAE,EACAzB,EACAD,EACAE,EACAC,CACF,EAKJ,GAAI,CACF,MAAMgC,GACJX,EACAF,uBAEAD,CACF,CACF,OAASS,EAAG,CACV,MAAAlC,EAAI,MAAM,2DAA2D0B,CAAK,GAAIQ,CAAC,EACzEA,CACR,CACF,CAlEsBV,EAAAJ,GAAA,wBAqEf,SAASoB,GAAuBd,EAAe,CACpD,MAAO,gBAAgBA,CAAK,EAC9B,CAFgBF,EAAAgB,GAAA,0BAKT,SAASb,GAAaxB,EAAiB,CAC5C,MAAO,GAAGA,EAAI,UAAU,IAAI,IAAIA,EAAI,UAAU,SAAS,EACzD,CAFgBqB,EAAAG,GAAA,gBDzKT,SAASc,GAAsBC,EAAcC,EAA0BC,EAAoB,CAChG,IAAMC,EAAOC,GAAoBJ,CAAI,EAG/BK,EAAsC,CAAC,EAC7C,QAAWC,KAASL,EAAS,SAC3BI,EAAY,GAAGE,GAAuBD,CAAK,CAAC,EAAE,EAAI,OAIpD,IAAME,EAAyB,CAAC,EAChC,QAAWC,KAAgBR,EAAS,cAAe,CACjD,IAAMS,EAAOD,EAAa,KACpBE,EAAWF,EAAa,SACxBG,EAASC,GAAsBb,EAAMW,EAAUD,CAAI,EACzDF,EAAQ,KAAKI,CAAM,CACrB,CAqBA,MAlB8B,CAC5B,SAAU,CACR,KAAAT,EACA,UAAAW,EACA,YAAAT,EACA,OAAQ,CACN,iBAAkBH,EAAW,SAAS,EACtC,cAAea,EACjB,CACF,EACA,KAAM,CACJ,SAAU,CACR,IAAK,eACP,EACA,QAAAP,CACF,CACF,CAGF,CAtCgBQ,EAAAjB,GAAA,yBAyChB,SAASc,GAAsBb,EAAcW,EAA0BD,EAAc,CACnF,MAAO,CACL,MAAO,CAACV,CAAI,EACZ,KAAM,CACJ,KAAM,GAAGW,EAAS,YAAY,CAAC,IAAID,EAAK,SAAS,CAAC,GAClD,OAAQA,EACR,SAAUC,CACZ,EACA,IAAK,CACH,kBACF,CACF,CACF,CAZSK,EAAAH,GAAA,yBAkBT,eAAsBI,GAA6BjB,EAAc,CAC/D,IAAMkB,EAAW,QAAM,QAAIC,EAAY,EAAE,IAAI,EACvChB,EAAOC,GAAoBJ,CAAI,EAGrC,QAAWoB,KAAMF,EAAS,MACxB,GAAI,EAAAE,EAAG,UAAU,OAASjB,GAAQiB,EAAG,UAAU,YAAcN,IAIzDM,EAAG,MAAQA,EAAG,KAAK,SACrB,QAAWC,KAAOD,EAAG,KAAK,QACxB,QAAWE,KAAWD,EAAI,MACxB,GAAIC,IAAYtB,EAAM,CACpB,IAAMuB,EAAU,0BAA0BH,EAAG,UAAU,IAAI,IAAIA,EAAG,UAAU,SAAS,mGACrF,MAAAI,EAAI,MAAMD,CAAO,EACX,IAAI,MAAMA,CAAO,CACzB,EAKV,CAtBsBP,EAAAC,GAAA,gCAyBf,SAASb,GAAoBJ,EAAc,CAChD,OAAOyB,EAAqB,WAAWzB,CAAI,EAAE,CAC/C,CAFgBgB,EAAAZ,GAAA,uBIpFT,SAASsB,GACdC,EACAC,EACAC,EACAC,EACAC,EACA,CAoBA,MAjB8B,CAC5B,SAAU,CACR,KAJSC,GAAoBJ,EAASD,CAAQ,EAK9C,UAAAE,EACA,OAAQ,CACN,cAAeD,EACf,iBAAkBE,CACpB,EAEA,gBAAiBC,CACnB,EACA,KAAM,CACJ,sBAAuB,CAAE,oBAAkD,EAC3E,GAAIJ,GAAY,CAAE,iBAAkB,CAAE,OAAQA,CAAS,CAAE,CAC3D,CACF,CAGF,CA3BgBM,EAAAP,GAAA,yBA4BhB,SAASM,GAAoBJ,EAAiBD,EAA8C,CAC1F,IAAMO,EAAiBP,EACnB,OAAO,QAAQA,CAAQ,EACpB,IAAI,CAAC,CAACQ,EAAKC,CAAK,IAAM,GAAGD,CAAG,IAAIC,CAAK,EAAE,EACvC,KAAK,GAAG,EACX,UACJ,OAAOC,EAAqB,GAAGT,CAAO,WAAWM,CAAc,EAAE,CACnE,CAPSD,EAAAD,GAAA,uBLrBF,IAAMM,EAAyB,uBACzBC,GAAoB,yBAGjC,eAAsBC,GACpBC,EACAC,EACA,CAEA,IAAMC,EAAkBC,GAAqBH,CAAa,EAGpDI,EAAiC,CAAC,EAExC,QAAWC,KAAQH,EAAiB,CAClC,IAAMI,EAAWJ,EAAgBG,CAAI,EAG/BE,EAAcC,GAAmBH,EAAMC,EAAUL,CAAU,EACjEG,EAAc,KAAKG,CAAW,CAChC,CAGA,MAAM,QAAQ,IAAIH,CAAa,CACjC,CApBsBK,EAAAV,GAAA,+BAuBtB,eAAsBW,GAA4BT,EAAoB,CACpE,GAAI,CACF,MAAMU,EAAaV,EAAYJ,EAAwBC,GAAmBc,GAAcC,CAAG,EAC3F,MAAMF,EACJV,EACAJ,EACAC,GACAgB,GACAD,CACF,EACA,MAAMF,EACJV,EACAJ,EACAC,GACAiB,GACAF,CACF,CACF,OAASG,EAAG,CACV,IAAMC,EAAU,oDAChB,MAAAJ,EAAI,MAAM,oDAAqDG,CAAC,EAC1DC,CACR,CACF,CAtBsBR,EAAAC,GAAA,+BAyBf,SAASP,GAAqBH,EAA+B,CAClE,IAAME,EAAqC,CAAC,EAC5C,QAAWgB,KAASlB,EAAe,CACjC,IAAMmB,EAAkBnB,EAAckB,CAAK,EAC3C,QAAWb,KAAQc,EAAiB,CAClC,IAAMC,EAAgBD,EAAgBd,CAAI,EAAE,aAE5CH,EAAgBG,CAAI,IAAM,CACxB,SAAU,CAAC,EACX,cAAe,CAAC,CAClB,EAEKH,EAAgBG,CAAI,EAAE,SAAS,SAASa,CAAK,GAChDhB,EAAgBG,CAAI,EAAE,SAAS,KAAKa,CAAK,EAG3C,QAAWG,KAAgBD,EACIlB,EAAgBG,CAAI,EAAE,cAAc,KAC/DiB,GAAMA,EAAG,OAASD,EAAa,MAAQC,EAAG,WAAaD,EAAa,QACtE,GAGEnB,EAAgBG,CAAI,EAAE,cAAc,KAAKgB,CAAY,CAG3D,CACF,CAEA,OAAOnB,CACT,CA7BgBO,EAAAN,GAAA,wBAgChB,eAAeK,GAAmBH,EAAcC,EAA0BL,EAAoB,CAC5F,GAAI,CAEF,MAAMsB,GAA6BlB,CAAI,EACvC,MAAMmB,GAAoCnB,CAAI,EAG9C,IAAMoB,EAAoC,CAAC,EAGrCC,GAAkB,SAAY,CAClC,GAAI,CACF,IAAMC,EAAUC,GAAsBvB,EAAMC,EAAUL,CAAU,EAChEY,EAAI,MAAMc,EAAS,2BAA2BA,EAAQ,UAAU,IAAI,EAAE,EACtE,QAAM,QAAIf,EAAY,EAAE,MAAMe,EAAS,CAAE,MAAO,EAAK,CAAC,CACxD,OAASX,EAAG,CACV,IAAMC,EAAU,oCAAoCZ,CAAI,GACxD,MAAAQ,EAAI,MAAMI,EAASD,CAAC,EACd,IAAI,MAAMC,CAAO,CACzB,CACF,GAAG,EACHQ,EAAiB,KAAKC,CAAc,EAGpC,IAAMG,GAAyB,SAAY,CACzC,GAAI,CACF,IAAMC,EAAiBC,GAA6B1B,EAAMC,EAAUL,CAAU,EAC9EY,EAAI,MACFiB,EACA,mCAAmCA,EAAe,UAAU,IAAI,EAClE,EACA,QAAM,QAAIhB,EAAmB,EAAE,MAAMgB,EAAgB,CAAE,MAAO,EAAK,CAAC,CACtE,OAASd,EAAG,CACV,IAAMC,EAAU,4CAA4CZ,CAAI,GAChE,MAAAQ,EAAI,MAAMI,EAASD,CAAC,EACd,IAAI,MAAMC,CAAO,CACzB,CACF,GAAG,EACHQ,EAAiB,KAAKI,CAAqB,EAG3C,IAAMG,GAAuB,SAAY,CACvC,GAAI,CACF,IAAMC,EAAeC,GAA2B7B,EAAMC,EAAUL,CAAU,EAC1EY,EAAI,MAAMoB,EAAc,0BAA0BA,EAAa,UAAU,IAAI,EAAE,EAC/E,QAAM,QAAIlB,EAAiB,EAAE,MAAMkB,EAAc,CAAE,MAAO,EAAK,CAAC,CAClE,OAASjB,EAAG,CACV,IAAMC,EAAU,0CAA0CZ,CAAI,GAC9D,MAAAQ,EAAI,MAAMI,EAASD,CAAC,EACd,IAAI,MAAMC,CAAO,CACzB,CACF,GAAG,EACHQ,EAAiB,KAAKO,CAAmB,EAGzC,MAAM,QAAQ,IAAIP,CAAgB,CACpC,OAAST,EAAG,CACV,MAAAH,EAAI,MAAM,6CAA6CR,CAAI,kBAAkBJ,CAAU,GAAIe,CAAC,EACtFA,CACR,CACF,CA5DeP,EAAAD,GAAA,sBA+Df,eAAsB2B,GAAsBhB,EAAkC,CAE5E,GAAI,CACF,MAAMiB,GAAkBvC,CAAsB,CAChD,OAASmB,EAAG,CACV,IAAIC,EAAU,8CAA8CpB,CAAsB,IAClF,MAAImB,GAAG,QAAU,MACfC,EAAU,6FAEZJ,EAAI,MAAMI,CAAO,EACX,IAAI,MAAMA,CAAO,CACzB,CAKA,IAAMoB,GAFU,QAAM,QAAI,QAAK,OAAO,EAAE,YAAYxC,CAAsB,EAAE,IAAI,eAAe,GAEzE,MAAM,OAAS,CAAC,EACtC,QAAWQ,KAAQc,EACjB,QAAWE,KAAgBF,EAAgBd,CAAI,EAAE,aAE/C,GAAI,CADSgC,EAAM,KAAKC,GAAKA,EAAE,OAASjB,EAAa,IAAI,EAC9C,CACT,IAAMJ,EAAU,uCAAuCI,EAAa,IAAI,aAAahB,CAAI,kEACzF,MAAAQ,EAAI,MAAMI,CAAO,EACX,IAAI,MAAMA,CAAO,CACzB,CAGN,CA3BsBR,EAAA0B,GAAA,yBA8BtB,eAAsBI,GACpBpB,EACAqB,EACAC,EACAC,EACAzC,EACA0C,EACA,CAEA,QAAWtC,KAAQ,OAAO,KAAKc,CAAe,EAAG,CAE/C,IAAMc,EAAeW,GACnBvC,EACAc,EAAgBd,CAAI,EACpBoC,EACAC,EACAzC,EACA0C,WAEF,EAEA9B,EAAI,MAAMoB,EAAc,0BAA0BA,EAAa,UAAU,IAAI,EAAE,EAG/E,QAAM,QAAIlB,EAAiB,EAAE,MAAMkB,EAAc,CAAE,MAAO,EAAK,CAAC,CAClE,CAGA,IAAMY,EAAoB,IAAI,IAAIL,EAAgB,IAAIM,GAASA,EAAM,UAAY,MAAS,CAAC,EACrFC,EAAkB,IAAI,IAG5B,QAAWC,KAAYH,EAAmB,CAExC,GAAIE,EAAgB,IAAI,KAAK,UAAUC,CAAQ,CAAC,EAC9C,SAEFD,EAAgB,IAAI,KAAK,UAAUC,CAAQ,CAAC,EAG5C,IAAMC,EAAUC,GAAsBF,EAAUP,EAASC,EAAWzC,EAAY0C,CAAS,EAEzF9B,EAAI,MAAMoC,EAAS,oBAAoBA,EAAQ,UAAU,IAAI,EAAE,EAG/D,QAAM,QAAIE,EAAY,EAAE,MAAMF,EAAS,CAAE,MAAO,EAAK,CAAC,CACxD,CACF,CA/CsBxC,EAAA8B,GAAA,wCMtLf,IAAMa,GAAqC,CAAC,EAG/CC,GAAc,GAEdC,GAAmC,CAAC,EAG3BC,GAA4C,CAAC,EACtDC,GAAc,GAEdC,GAAmC,CAAC,EAGpCC,GAA4C,KAGrCC,GAA0C,IAAI,IAGrDC,GAAoB,EACpBC,GAAoB,EAIxB,eAAsBC,GACpBC,EACAC,EACAC,EACAC,EACA,CAEA,OAAIA,IAAc,WAEhB,MAAMC,GAAyBJ,EAAiBC,iBAA2B,EAG3E,MAAMI,GAAgCL,EAAiBC,EAAOC,CAAM,IAGpE,MAAME,GAAyBJ,EAAiBC,EAAOC,CAAM,EAG7D,MAAMG,GAAgCL,EAAiBC,iBAA2B,GAK7E,MAAMK,GAAqCL,CAAK,CACzD,CAxBsBM,EAAAR,GAAA,kCA2BtB,eAAsBO,GAAqCL,EAA8B,CAEvF,GAAIN,GACF,GAAI,CAGF,GAFA,MAAMA,GAEFC,GAA2B,IAAIK,CAAK,EACtC,MAEJ,MAAQ,CAGNN,GAAsB,IACxB,CAIFA,GAAsBa,GAA4B,EAElD,GAAI,CACF,MAAMb,EACR,OAASc,EAAG,CAEV,MAAAC,EAAI,MAAM,+BAAgCD,CAAC,EACrCA,CACR,QAAE,CAEAd,GAAsB,IACxB,CACF,CA7BsBY,EAAAD,GAAA,wCAgCtB,eAAsBE,IAA8B,CAElDG,GAAiC,EAGjC,IAAMC,EAAkB,CAAC,EAGzB,GAAI,CAC6B,MAAMC,GAAkBC,EAAwB,EAAI,IAEjFjB,KAGA,MAAMkB,GAA4B1B,GAAoBQ,EAAiB,EAGvE,MAAMmB,GAA4BnB,GAAkB,SAAS,CAAC,EAElE,OAASY,EAAG,CACV,IAAMQ,EAAU,+CAChBP,EAAI,MAAMO,EAASR,CAAC,EACpBG,EAAO,KAAK,IAAI,MAAMK,CAAO,CAAC,CAChC,CAGA,GAAI,CAEF,GAD+B,MAAMJ,GAAkBK,GAAwB,EAAI,EACvD,CAC1BpB,KAGA,IAAMqB,EAAa,IAAI,IAAI,OAAO,KAAK3B,EAAyB,CAAC,EACjE,MAAM4B,GAA4BD,EAAYrB,EAAiB,EAG/D,MAAMuB,GAA4BvB,GAAkB,SAAS,CAAC,CAChE,CACF,OAASW,EAAG,CACV,IAAMQ,EAAU,+CAChBP,EAAI,MAAMO,EAASR,CAAC,EACpBG,EAAO,KAAK,IAAI,MAAMK,CAAO,CAAC,CAChC,CAGA,GAAIL,EAAO,OAAS,EAAG,CACrB,IAAMU,EAAoBV,EAAO,IAAIW,GAAOA,EAAI,OAAO,EAAE,KAAK,IAAI,EAClE,MAAM,IAAI,MAAM,iCAAiCD,CAAiB,EAAE,CACtE,CACF,CAjDsBf,EAAAC,GAAA,+BAoDtB,eAAsBJ,GACpBJ,EACAC,EACAC,EACA,CAEIZ,IACF,MAAM,IAAI,QAAckC,GAAW,CACjCjC,GAAiB,KAAKiC,CAAO,CAC/B,CAAC,EAGH,GAAI,CACFd,EAAI,MAAM,uCAAuC,EACjDpB,GAAc,GAEVY,GAAU,qBACRF,GAEFyB,GAA0BpC,GAAoBW,EAAiBC,CAAK,EAEpEZ,GAAmBY,CAAK,EAAID,GAE5B0B,GAAmBrC,GAAoBY,CAAK,EAErCC,GAAU,iBACnBwB,GAAmBrC,GAAoBY,CAAK,CAEhD,OAASQ,EAAG,CACV,MAAAC,EAAI,MAAM,CAAE,OAAAR,EAAQ,EAAAO,CAAE,EAAG,yDAAyD,EAC5EA,CACR,QAAE,CAEAC,EAAI,MAAM,yCAAyC,EACnDpB,GAAc,GACd,IAAMqC,EAAcpC,GAAiB,MAAM,EACvCoC,GACFA,EAAY,CAEhB,CACF,CAxCsBpB,EAAAH,GAAA,4BA2CtB,eAAsBC,GACpBL,EACAC,EACAC,EACA,CAEIT,IACF,MAAM,IAAI,QAAc+B,GAAW,CACjC9B,GAAiB,KAAK8B,CAAO,CAC/B,CAAC,EAGH,GAAI,CAIF,GAHAd,EAAI,MAAM,wCAAwC,EAClDjB,GAAc,GAEVS,GAAU,qBACZ,GAAIF,EAAiB,CAEnB,IAAM4B,EAAgBC,GACpBrC,GACAQ,EACAC,CACF,EAGAT,GAA0BS,CAAK,EAAI2B,CACrC,MACEF,GAAmBlC,GAA2BS,CAAK,OAE5CC,GAAU,iBACnBwB,GAAmBlC,GAA2BS,CAAK,CAEvD,OAASQ,EAAG,CACV,MAAAC,EAAI,MAAM,CAAE,OAAAR,EAAQ,EAAAO,CAAE,EAAG,0DAA0D,EAC7EA,CACR,QAAE,CAEAC,EAAI,MAAM,0CAA0C,EACpDjB,GAAc,GACd,IAAMkC,EAAcjC,GAAiB,MAAM,EACvCiC,GACFA,EAAY,CAEhB,CACF,CA7CsBpB,EAAAF,GAAA,mCAgDf,SAASM,IAAmC,CACjD,OAAAf,GAA6B,IAAI,IAAI,CACnC,GAAG,OAAO,KAAKP,EAAkB,EACjC,GAAG,OAAO,KAAKG,EAAyB,CAC1C,CAAC,EACMI,EACT,CANgBW,EAAAI,GAAA,oCAST,SAASc,GACdK,EACAC,EACAC,EACM,CAEN,IAAMC,EACJ,CAAC,EAEH,OAAW,CAAChC,EAAOD,CAAe,IAAK,OAAO,QAAQ8B,CAAiB,EAErE,GAAI7B,IAAU+B,EAId,OAAW,CAACE,EAAMC,CAAY,IAAK,OAAO,QAAQnC,CAAe,EAC/D,QAAWoC,KAAgBD,EAAa,aAAc,CACpD,IAAME,EAAM,GAAGH,CAAI,IAAIE,EAAa,IAAI,GACxCH,EAA0BI,CAAG,EAAI,CAC/B,SAAUD,EAAa,SACvB,UAAWnC,CACb,CACF,CAKJ,OAAW,CAACiC,EAAMC,CAAY,IAAK,OAAO,QAAQJ,CAAkB,EAClE,QAAWK,KAAgBD,EAAa,aAAc,CACpD,IAAME,EAAM,GAAGH,CAAI,IAAIE,EAAa,IAAI,GAClCE,EAAWL,EAA0BI,CAAG,EAE9C,GAAIC,GAAYA,EAAS,WAAaF,EAAa,SAAU,CAC3D,IAAMG,EACJ,kCAAkCL,CAAI,IAAIE,EAAa,IAAI,cAC/CJ,CAAQ,kBAAkBI,EAAa,QAAQ,iBAAiBE,EAAS,SAAS,sBAC1EA,EAAS,QAAQ,2CACvC,MAAA5B,EAAI,MAAM6B,CAAQ,EACZ,IAAI,MAAMA,CAAQ,CAC1B,CACF,CAEJ,CA1CgBhC,EAAAkB,GAAA,6BA6CT,SAASI,GACdC,EACAC,EACAC,EACiB,CAEjB,IAAMQ,EAAuBT,EAE7B,OAAW,CAAC9B,EAAOD,CAAe,IAAK,OAAO,QAAQ8B,CAAiB,EAErE,GAAI7B,IAAU+B,EAId,OAAW,CAACE,EAAMC,CAAY,IAAK,OAAO,QAAQnC,CAAe,EAAG,CAClE,IAAMyC,EAAmBN,EAAa,aAAa,IAAIO,GAAM,GAAGA,EAAG,IAAI,IAAIA,EAAG,QAAQ,EAAE,EACxF,OAAW,CAACC,EAASC,CAAe,IAAK,OAAO,QAAQb,CAAkB,EACxE,GAAIG,IAASS,EAAS,CAOpB,GAAI,CALwBC,EAAgB,aAAa,IACvDF,GAAM,GAAGA,EAAG,IAAI,IAAIA,EAAG,QAAQ,EACjC,EAGyB,MAAMA,GAAMD,EAAiB,SAASC,CAAE,CAAC,EAAG,CACnE,IAAMH,EACJ,uCAAuCL,CAAI,cAC/BjC,CAAK,oEACnB,MAAAS,EAAI,MAAM6B,CAAQ,EACZ,IAAI,MAAMA,CAAQ,CAC1B,CAGAC,EAAqBG,CAAO,EAAE,aAAeR,EAAa,YAC5D,CAEJ,CAGF,OAAOK,CACT,CAxCgBjC,EAAAsB,GAAA,iCA2CT,SAASgB,GAAsBC,EAAiB,CACrD,IAAM9C,EAAmC,CAAC,EAE1C,QAAW+C,KAASD,EAAI,MAAM,SAAS,OAAS,CAAC,EAAG,CAClD,IAAME,EAAoBC,GAAqBF,CAAK,EAEpD,GAAIC,EAAmB,CAEhBhD,EAAgBgD,EAAkB,IAAI,IACzChD,EAAgBgD,EAAkB,IAAI,EAAI,CACxC,aAAc,CAAC,CACjB,GAIF,QAAWE,KAAQF,EAAkB,MAENhD,EAAgBgD,EAAkB,IAAI,EAAE,aAAa,KAChFN,GAAMA,EAAG,OAASQ,GAAQR,EAAG,WAAaM,EAAkB,QAC9D,GAIEhD,EAAgBgD,EAAkB,IAAI,EAAE,aAAa,KAAK,CACxD,KAAME,EACN,SAAUF,EAAkB,QAC9B,CAAC,CAGP,CACF,CAEA,GAAI,OAAO,KAAKhD,CAAe,EAAE,OAAS,EACxC,OAAOA,CAGX,CApCgBO,EAAAsC,GAAA,yBAuCT,SAASI,GAAqBF,EAAc,CACjD,IAAIC,EAEEd,EAAOa,EAAM,WACbI,EAAWJ,EAAM,gBAAkB,MAGrCK,EAAQ,CAAC,EACb,OAAIL,EAAM,MACRK,EAAQL,EAAM,MACLA,EAAM,KACfK,EAAQ,CAACL,EAAM,IAAI,EAEnBK,EAAQ,CAAC,GAAG,EAGVlB,IACFc,EAAoB,CAClB,KAAAd,EACA,MAAAkB,EACA,SAAAD,CACF,GAEKH,CACT,CAxBgBzC,EAAA0C,GAAA,wBA2BT,SAASvB,GAAmB2B,EAA4BpD,EAAe,CACxEoD,EAAWpD,CAAK,EAClB,OAAOoD,EAAWpD,CAAK,EAEvBS,EAAI,MAAM,CAAE,MAAAT,CAAM,EAAG,gCAAgC,CAEzD,CANgBM,EAAAmB,GAAA,sBAST,SAAS4B,GAA2BC,EAAoB,CAC7D,OAAOA,EAAU,OAAOR,GACfA,EAAM,UACd,CACH,CAJgBxC,EAAA+C,GAAA,8BRpZT,IAAME,GAAyB,uBACzBC,GAAoB,iCAGjC,eAAsBC,GAA4BC,EAA0BC,EAAoB,CAE9F,GAAID,EAAY,OAAS,EACvB,OAIF,IAAME,EAAWC,GAA4BH,EAAaC,CAAU,EAC9DG,EAAeF,EAAS,UAAU,MAAQ,YAGhDG,EAAI,MAAMH,EAAU,qBAAqBE,CAAY,EAAE,EAGvD,QAAM,QAAIE,EAAU,EAAE,MAAMJ,EAAU,CAAE,MAAO,EAAK,CAAC,EAGrD,MAAMK,GAA0BV,GAAwBO,CAAY,CACtE,CAlBsBI,EAAAT,GAAA,+BAqBtB,eAAsBU,GAA4BR,EAAoB,CACpE,GAAI,CACF,MAAMS,EAAaT,EAAYJ,GAAwBC,GAAmBQ,GAAYD,CAAG,CAC3F,OAASM,EAAG,CACV,IAAMC,EAAU,oDAChB,MAAAP,EAAI,MAAM,oDAAqDM,CAAC,EAC1DC,CACR,CACF,CARsBJ,EAAAC,GAAA,+BAWtB,eAAsBI,GACpBC,EACAC,EACAC,EACAC,EACAhB,EACAiB,EACA,CAEA,QAAWC,KAAQ,OAAO,KAAKL,CAAe,EAAG,CAE/C,IAAMM,EAAeC,GACnBF,EACAL,EAAgBK,CAAI,EACpBH,EACAC,EACAhB,EACAiB,WAEF,EAEAb,EAAI,MAAMe,EAAc,0BAA0BA,EAAa,UAAU,IAAI,EAAE,EAG/E,QAAM,QAAIE,EAAiB,EAAE,MAAMF,EAAc,CAAE,MAAO,EAAK,CAAC,CAClE,CAGA,QAAWG,KAASR,EAAiB,CACnC,IAAMS,EAAoBC,GAAqBF,CAAK,EACpD,GAAI,CAACC,EACH,SAEF,GAAM,CAAE,KAAAL,EAAM,MAAAO,EAAO,SAAAC,CAAS,EAAIH,EAC5BI,EAAgBF,EAAM,IAAIG,IAAS,CAAE,KAAAA,EAAM,SAAAF,CAAS,EAAE,EAGtDG,EAAaC,GACjBZ,EACAH,EACAC,EACAhB,EACAiB,EACAc,GAA0BhB,EAASY,EAAeT,CAAI,EACtDI,EAAM,cACR,EAEAlB,EAAI,MAAMyB,EAAY,iCAAiCA,EAAW,UAAU,IAAI,EAAE,EAGlF,QAAM,QAAIG,CAAwB,EAAE,MAAMH,EAAY,CAAE,MAAO,EAAK,CAAC,CACvE,CACF,CApDsBtB,EAAAK,GAAA,wCS1CtB,IAAMqB,GAAkB,YAKXC,GAA2BC,EAACC,GAChCA,EAAI,MAAM,SAAS,aAAa,OAAS,WAAgBC,GAAkBD,CAAG,EAD/C,4BAO3BC,GAAoBF,EAACC,GAChCA,EAAI,MAAM,KAAK,KAAKE,GAAKA,EAAE,4BAA8B,MAAS,GAAK,GADxC,qBAMpBC,EAAkBJ,EAACK,GAAuB,CAErD,GAAI,CAACA,GAAMA,EAAG,KAAK,IAAM,GACvB,MAAM,IAAI,MAAM,6BAA6B,EAI/C,IAAIC,EAAeD,EAGnB,OAAKC,EAAa,SAASR,EAAe,IACxCQ,EAAe,GAAGA,CAAY,GAAGR,EAAe,IAG3CQ,CACT,EAf+B,mBAoBxB,SAASC,GACdN,EACAO,EACAF,EACwB,CACxB,OAAIP,GAAyBE,CAAG,EACvB,CAAE,wBAAyBK,CAAa,EAE1CE,CACT,CATgBR,EAAAO,GAAA,kBAcT,SAASE,GACdC,EACAF,EACS,CACT,IAAMG,EAAcD,EAAI,MAAM,UAAY,CAAC,EAC3C,OAAO,OAAO,QAAQF,CAAQ,EAAE,MAAM,CAAC,CAACI,EAAGC,CAAC,IAAMF,EAAYC,CAAC,IAAMC,CAAC,CACxE,CANgBb,EAAAS,GAAA,0BAWT,SAASK,GACdC,EACAP,EACS,CACT,OAAO,OAAO,QAAQA,CAAQ,EAAE,MAAM,CAAC,CAACI,EAAGC,CAAC,IAAME,EAAOH,CAAC,IAAMC,CAAC,CACnE,CALgBb,EAAAc,GAAA,iBX3DT,IAAME,GAAqB,kBAG5BC,GAAuB,wBACvBC,GAAoB,iBAGpBC,GAAc,CAClB,WAAY,IACZ,UAAW,GACb,EAKA,eAAsBC,GAAqBC,EAAiBC,EAA4B,CACtF,GAAM,CAAE,UAAAC,EAAW,KAAAC,CAAK,EAAIH,EAAI,UAAY,CAAC,EAC7C,GAAI,CAACE,GAAa,CAACC,EAAM,CACvB,IAAMC,EAAQ,gDACd,MAAAC,EAAI,MAAM,CAAE,IAAAL,CAAI,EAAGI,CAAK,EAClB,IAAI,MAAMA,CAAK,CACvB,CAEAC,EAAI,KAAK,+CAA+CF,CAAI,OAAOD,CAAS,EAAE,EAE9E,IAAMI,EAAaL,EAAO,SACpBM,EAAeC,EAAgBF,CAAU,EAE/C,GAAI,CACF,MAAMG,GAAsBT,EAAKO,CAAY,EAC7C,MAAMG,GAA0BR,EAAWK,CAAY,EACvD,MAAMI,GAA2BX,EAAKC,EAAQM,CAAY,CAC5D,OAASH,EAAO,CACd,IAAMQ,EAAeR,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1E,MAAAC,EAAI,MACF,CAAE,aAAAO,CAAa,EACf,gDAAgDL,CAAY,OAAOL,CAAS,EAC9E,EACME,CACR,CACF,CAzBsBS,EAAAd,GAAA,wBA8BtB,eAAsBU,GAAsBT,EAAiBO,EAAsB,CACjF,GAAM,CAAE,UAAAL,EAAW,KAAAC,CAAK,EAAIH,EAAI,UAAY,CAAC,EAC7C,GAAI,CAACE,GAAa,CAACC,EAAM,MAAM,IAAI,MAAM,+CAA+C,EAExFE,EAAI,KAAK,0CAA0CH,CAAS,IAAIC,CAAI,EAAE,EAEtE,GAAI,CACF,IAAMW,EAAU,IAAIC,GAEpBD,EAAQ,SAAW,CACjB,KAAMP,EACN,UAAAL,EACA,OAAQ,CACN,CAACL,EAAiB,EAAG,eACrB,8BAA+B,mBAC/B,wBAAyB,MACzB,wBAAyBU,EACzB,kBAAmBP,EAAI,UAAU,YAAc,GAAG,SAAS,EAC3D,cAAeA,EAAI,UAAU,MAAQ,SACvC,EACA,gBAAiBgB,EAAYhB,CAAG,CAClC,EAEAc,EAAQ,KAAO,CACb,iBAAkB,iBAClB,UAAW,CAAC,CAAE,KAAM,OAAQ,KAAM,MAAO,SAAU,OAAQ,CAAC,CAC9D,EAGAT,EAAI,KACF,CACE,UAAAH,EACA,KAAMK,EACN,iBAAkBO,EAAQ,KAAK,iBAC/B,gBAAiB,KAAK,UAAUA,EAAQ,SAAS,eAAe,CAClE,EACA,2BACF,EAEA,GAAI,CACF,eAAM,OAAIC,EAAU,EAAE,MAAMD,CAAO,EACnCT,EAAI,KAAK,CAAE,UAAAH,EAAW,aAAAK,CAAa,EAAG,uCAAuC,EACtEA,CACT,OAASU,EAAY,CAEnB,MAAAZ,EAAI,MACF,CAAE,UAAAH,EAAW,aAAAK,EAAc,UAAW,OAAOU,EAAY,aAAcA,CAAW,EAClF,iCACF,EAEM,IAAI,MACR,sCAAsCA,aAAsB,MAAQA,EAAW,QAAU,OAAOA,CAAU,CAAC,EAC7G,CACF,CACF,OAASb,EAAO,CAEd,MAAAC,EAAI,MACF,CAAE,UAAAH,EAAW,aAAAK,EAAc,aAAcH,CAAM,EAC/C,mCACF,EAEM,IAAI,MACR,sCAAsCA,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAAC,EAC9F,CACF,CACF,CAjEsBS,EAAAJ,GAAA,yBAsEtB,eAAsBS,GACpBhB,EACAK,EACkB,CAClB,GAAI,CAMF,OALa,QAAM,OAAI,IAAE,GAAG,EACzB,YAAYL,CAAS,EACrB,UAAU,yBAAyBK,CAAY,EAAE,EACjD,IAAI,GAGA,OAAO,KACVY,GACEA,EAAI,QAAQ,QAAU,WAAaA,EAAI,QAAQ,mBAAmB,MAAMC,GAAMA,EAAG,KAAK,CAC1F,GAAK,EAET,OAAShB,EAAO,CACd,OAAAC,EAAI,KAAK,0CAA0CE,CAAY,OAAOL,CAAS,IAAKE,CAAK,EAClF,EACT,CACF,CApBsBS,EAAAK,GAAA,wBAyBtB,eAAsBR,GACpBR,EACAK,EACe,CACf,IAAMc,EAAQ,KAAK,IAAI,EACjB,CAAE,WAAAC,EAAY,UAAAC,CAAU,EAAIzB,GAC9B0B,EAAW,EAEf,OAAa,CACXA,IACA,IAAMC,EAAU,KAAK,IAAI,EAAIJ,EAE7B,GAAII,GAAWF,EACb,MAAM,IAAI,MACR,oCAAoChB,CAAY,OAAOL,CAAS,UAAUuB,CAAO,IACnF,EAIF,GADkB,MAAMP,GAAqBhB,EAAWK,CAAY,EACrD,CACbF,EAAI,MACF,gBAAgBE,CAAY,OAAOL,CAAS,qBAAqBsB,CAAQ,iBAAiBC,CAAO,IACnG,EACA,MACF,CAEA,MAAM,IAAI,QAAQC,GAAW,WAAWA,EAASJ,CAAU,CAAC,CAC9D,CACF,CA5BsBT,EAAAH,GAAA,6BAiCtB,eAAsBiB,GAAiBC,EAA+B,CACpE,IAAM1B,EAAY0B,EAAI,UAAU,UAehC,GAdI,CAAC1B,IAKA0B,EAAI,WACPA,EAAI,SAAW,CAAC,GAGbA,EAAI,SAAS,SAChBA,EAAI,SAAS,OAAS,CAAC,GAKvBA,EAAI,UAAU,SAAS,6BAA6B,IAAM,oBAC1DA,EAAI,UAAU,SAAS,wCAAwC,GAAG,SAAS,UAAU,GAErF,OAGF,IAAM5B,EAAM6B,GAAa,sBAAsB3B,CAAS,EACxD,GACE,CAACF,GACDA,EAAI,UAAU,mBACdA,EAAI,MAAM,SAAS,aAAa,OAAS,UAEzC,OAKF,IAAM8B,EADcC,GAAsB/B,CAAG,EACb,KAAKgC,GACnCC,GAAuBL,EAAKI,EAAI,yBAA0B,CAC5D,EAEA,GAAI,CAACF,GAAa,SAAU,OAE5B,IAAMvB,EAAeC,EAAgBsB,EAAY,QAAQ,EAEzDF,EAAI,SAAS,OAAS,CACpB,GAAGA,EAAI,SAAS,OAChB,CAAChC,EAAoB,EAAGW,EACxB,gCAAiC,MACnC,EAEAF,EAAI,KACF,CAAE,UAAAH,EAAW,aAAAK,EAAc,SAAUuB,EAAY,SAAU,OAAQF,EAAI,SAAS,MAAO,EACvF,oCAAoCA,EAAI,UAAU,IAAI,EACxD,CACF,CApDsBf,EAAAc,GAAA,oBAyDtB,eAAsBO,GAAaf,EAA2B,CAC5D,IAAMjB,EAAYiB,EAAI,UAAU,UAehC,GAdI,CAACjB,IAKAiB,EAAI,WACPA,EAAI,SAAW,CAAC,GAGbA,EAAI,SAAS,SAChBA,EAAI,SAAS,OAAS,CAAC,GAKvBA,EAAI,UAAU,SAAS,6BAA6B,IAAM,oBAC1DA,EAAI,UAAU,SAAS,wCAAwC,GAAG,SAAS,UAAU,GAErF,OAGF,IAAMnB,EAAM6B,GAAa,sBAAsB3B,CAAS,EACxD,GACE,CAACF,GACDA,EAAI,UAAU,mBACdA,EAAI,MAAM,SAAS,aAAa,OAAS,UAEzC,OAKF,IAAM8B,EADcC,GAAsB/B,CAAG,EACb,KAAKgC,GACnCG,GAAchB,EAAI,UAAU,QAAU,CAAC,EAAGa,EAAI,yBAA0B,CAC1E,EAEA,GAAI,CAACF,GAAa,SAAU,OAE5B,IAAMvB,EAAeC,EAAgBsB,EAAY,QAAQ,EAEzDX,EAAI,SAAS,OAAS,CACpB,GAAGA,EAAI,SAAS,OAChB,CAACvB,EAAoB,EAAGW,CAC1B,EAEA,IAAM6B,EAAiBjB,EAAI,UAAU,MAAQA,EAAI,UAAU,cAAgB,iBAE3Ed,EAAI,KACF,CACE,UAAAH,EACA,aAAAK,EACA,SAAUuB,EAAY,QACxB,EACA,gCAAgCM,CAAc,EAChD,CACF,CAzDsBvB,EAAAqB,GAAA,gBA8DtB,eAAsBG,GACpBnC,EACAK,EACe,CACfF,EAAI,KAAK,kDAAkDH,CAAS,cAAcK,CAAY,EAAE,EAEhG,GAAI,CAEF,MAAM+B,GAA6BpC,EAAWK,CAAY,EAG1D,MAAMgC,GAAiCrC,EAAWK,CAAY,CAChE,OAASH,EAAO,CACd,IAAMQ,EAAeR,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1EC,EAAI,MACF,CACE,UAAAH,EACA,aAAAK,EACA,MAAOK,CACT,EACA,oCACF,CAEF,CACF,CAxBsBC,EAAAwB,GAAA,yBA6BtB,eAAeC,GACbpC,EACAK,EACe,CACf,IAAMiC,EAAO,QAAM,OAAI,IAAE,GAAG,EACzB,YAAYtC,CAAS,EACrB,UAAUN,GAAsBW,CAAY,EAC5C,IAAI,EAEP,MAAM,QAAQ,IACZiC,EAAK,MAAM,IAAI,MAAMrB,GAAO,CAC1B,IAAMsB,EAAUtB,EAAI,UAAU,KAC9B,GAAKsB,EAGL,IAAItB,EAAI,UAAU,kBAAmB,CACnCd,EAAI,MAAM,CAAE,UAAAH,EAAW,QAAAuC,CAAQ,EAAG,mCAAmC,EACrE,MACF,CAEA,GAAI,CACF,QAAM,OAAI,OAAK,IAAK,CAClB,KAAMA,EACN,UAAAvC,CACF,CAAC,EAAE,MAAM,CACP,CACE,GAAI,SACJ,KAAM,yCACR,CACF,CAAC,EACDG,EAAI,KAAK,CAAE,UAAAH,EAAW,QAAAuC,EAAS,aAAAlC,CAAa,EAAG,iCAAiC,CAClF,OAASH,EAAO,CACdC,EAAI,MACF,CACE,UAAAH,EACA,QAAAuC,EACA,aAAAlC,EACA,MAAOH,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAC9D,EACA,0CACF,CACF,EACF,CAAC,CACH,CACF,CA5CeS,EAAAyB,GAAA,gCAiDf,eAAeC,GACbrC,EACAK,EACe,CACf,IAAMmC,EAAW,QAAM,OAAI,IAAE,OAAO,EACjC,YAAYxC,CAAS,EACrB,UAAUN,GAAsBW,CAAY,EAC5C,IAAI,EAEP,MAAM,QAAQ,IACZmC,EAAS,MAAM,IAAI,MAAMd,GAAO,CAC9B,IAAMe,EAAUf,EAAI,UAAU,KAC9B,GAAKe,EAGL,IAAIf,EAAI,UAAU,kBAAmB,CACnCvB,EAAI,MAAM,CAAE,UAAAH,EAAW,QAAAyC,CAAQ,EAAG,uCAAuC,EACzE,MACF,CAEA,GAAI,CACF,QAAM,OAAI,OAAK,QAAS,CACtB,KAAMA,EACN,UAAAzC,CACF,CAAC,EAAE,MAAM,CACP,CACE,GAAI,SACJ,KAAM,iDACR,EACA,CACE,GAAI,SACJ,KAAM,yCACR,CACF,CAAC,EACDG,EAAI,KAAK,CAAE,UAAAH,EAAW,QAAAyC,EAAS,aAAApC,CAAa,EAAG,sCAAsC,CACvF,OAASH,EAAO,CACdC,EAAI,MACF,CACE,UAAAH,EACA,QAAAyC,EACA,aAAApC,EACA,MAAOH,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,CAC9D,EACA,+CACF,CACF,EACF,CAAC,CACH,CACF,CAhDeS,EAAA0B,GAAA,oCAkDf,eAAsB5B,GACpBX,EACA4C,EACArC,EACe,CACf,IAAML,EAAYF,EAAI,UAAU,UAChC,GAAI,CAACE,EAAW,CACdG,EAAI,KAAK,CAAE,IAAAL,CAAI,EAAG,wCAAwC,EAC1D,MACF,CAEAK,EAAI,KAAK,oDAAoDH,CAAS,QAAQK,CAAY,EAAE,EAE5F,GAAI,CACF,GAAM,CAACmC,EAAUF,CAAI,EAAI,MAAM,QAAQ,IAAI,IACzC,OAAI,OAAK,OAAO,EAAE,YAAYtC,CAAS,EAAE,IAAI,KAC7C,OAAI,OAAK,GAAG,EAAE,YAAYA,CAAS,EAAE,IAAI,CAC3C,CAAC,EAEK2C,EAAmBH,EAAS,MAAM,OAAOd,GAC7CK,GAAuBL,EAAKgB,EAAU,yBAA0B,CAClE,EAEME,EAAeN,EAAK,MAAM,OAAOrB,GACrBgB,GACdhB,EAAI,UAAU,QAAU,CAAC,EACzByB,EAAU,yBACZ,CAED,EAEDvC,EAAI,MAAM,oDAAoDH,CAAS,EAAE,EAGzE,QAAW0B,KAAOiB,EAChB,GAAI,CACF,QAAM,OAAI,OAAK,QAAS,CACtB,KAAMjB,EAAI,SAAU,KACpB,UAAW1B,CACb,CAAC,EAAE,MAAM,CACP,CACE,GAAI,MACJ,KAAM,kDACN,MAAO,MACT,EACA,CACE,GAAI,MACJ,KAAM,oBAAoBN,GAAqB,QAAQ,MAAO,IAAI,CAAC,GACnE,MAAOW,CACT,CACF,CAAC,CACH,OAASH,EAAO,CACd,IAAMQ,EAAeR,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1EC,EAAI,MAAM,CAAE,aAAAO,CAAa,EAAG,qCAAqCV,CAAS,EAAE,CAC9E,CAIF,QAAWiB,KAAO2B,EAChB,GAAI,CACF,QAAM,OAAI,OAAK,IAAK,CAClB,KAAM3B,EAAI,SAAU,KACpB,UAAWjB,CACb,CAAC,EAAE,MAAM,CACP,CACE,GAAI,MACJ,KAAM,oBAAoBN,GAAqB,QAAQ,MAAO,IAAI,CAAC,GACnE,MAAOW,CACT,CACF,CAAC,CACH,OAASH,EAAO,CACd,IAAMQ,EAAeR,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1EC,EAAI,KAAK,CAAE,aAAAO,CAAa,EAAG,iCAAiCV,CAAS,EAAE,CACzE,CAEJ,OAASE,EAAO,CACd,IAAMQ,EAAeR,aAAiB,MAAQA,EAAM,QAAU,OAAOA,CAAK,EAC1E,MAAAC,EAAI,MAAM,CAAE,aAAAO,CAAa,EAAG,uCAAuC,EAG7DR,CACR,CACF,CAlFsBS,EAAAF,GAAA,8BAqFf,SAASoC,GAA4BC,EAAmBC,EAAoB,CAEjF,IAAMC,EAAsC,CAAC,EAC7C,QAAWC,KAASH,EAClBE,EAAY,GAAGE,GAAuBD,CAAK,CAAC,EAAE,EAAI,OA6CpD,MAzC6B,CAC3B,SAAU,CACR,KAAMxD,GACN,UAAW0D,GACX,YAAAH,EACA,OAAQ,CACN,cAAeI,GACf,iBAAkBL,EAAW,SAAS,EACtC,wBAAyBtD,EAC3B,CACF,EACA,KAAM,CACJ,iBAAkB,iBAClB,UAAW,CACT,CACE,KAAM,OACN,KAAM,MACN,SAAU,QACV,cAAe,CACb,WAAY,CACV,UACF,EACA,MAAO,CACL,CACE,MAAO,sBACP,KAAM,cACR,CACF,CACF,CACF,CACF,EACA,eAAgB,CACd,cAAe,CACb,MAAO,GACP,KAAM,YACN,KAAM,wBACR,CACF,CACF,CACF,CAGF,CAlDgBkB,EAAAkC,GAAA,+BYlgBhB,IAAAQ,GAAoB,gBAepB,IAAMC,GAGF,CACD,UAA8B,QAC9B,aAAiC,QACpC,EAOA,SAASC,GACPC,EACAC,EACAC,EACAC,EACA,CACIF,GAAaC,GACfF,EAAK,UAAY,CACf,MAAO,4BACP,KAAM,UACN,KAAME,CACR,EACA,OAAOF,EAAK,WAEZA,EAAK,SAAW,CAAE,YAAaG,CAAc,EAC7C,OAAOH,EAAK,UAEhB,CAjBSI,EAAAL,GAAA,mBA2BT,SAASM,GACPC,EACsF,CACtF,IAAMC,EAED,CAAC,EAGAC,EAAc,IAAI,IACxB,QAAWC,KAAMH,EAAmB,CAClC,GAAI,CAACG,EAAG,KAAM,SACd,IAAMC,EAAQF,EAAY,IAAIC,EAAG,IAAI,GAAK,IAAI,IAC1CA,EAAG,MAAMC,EAAM,IAAID,EAAG,IAAI,EAC9BD,EAAY,IAAIC,EAAG,KAAMC,CAAK,CAChC,CAGA,OAAW,CAACC,EAAMD,CAAK,IAAKF,EAAY,QAAQ,EAAG,CACjD,IAAMI,EAAW,MAAM,KAAKF,CAAK,EAC7BE,EAAS,OAAS,EACpBL,EAAQ,KAAK,CAAE,UAAW,CAAE,MAAO,CAACI,CAAI,EAAG,SAAUC,CAAS,CAAE,CAAC,EAGjEL,EAAQ,KAAK,CAAE,UAAW,CAAE,MAAO,CAACI,CAAI,EAAG,SAAU,CAAC,UAAU,CAAE,CAAE,CAAC,CAEzE,CAGA,IAAME,EAAe,MAAM,KAAKL,EAAY,KAAK,CAAC,EAClD,OAAIK,EAAa,OAAS,GACxBN,EAAQ,KAAK,CAAE,UAAW,CAAE,SAAUM,CAAa,CAAE,CAAC,EAGjDN,CACT,CAlCSH,EAAAC,GAAA,6BAuCT,SAASS,GACPR,EAC8D,CAC9D,IAAMC,EAAwE,CAAC,EAEzEC,EAAc,IAAI,IACxB,QAAWC,KAAMH,EAAmB,CAClC,GAAI,CAACG,EAAG,KAAM,SACd,IAAMC,EAAQF,EAAY,IAAIC,EAAG,IAAI,GAAK,IAAI,IAC1CA,EAAG,MAAMC,EAAM,IAAID,EAAG,IAAI,EAC9BD,EAAY,IAAIC,EAAG,KAAMC,CAAK,CAChC,CAEA,OAAW,CAACC,EAAMD,CAAK,IAAKF,EAAY,QAAQ,EAAG,CACjD,IAAMI,EAAW,MAAM,KAAKF,CAAK,EAC7BE,EAAS,OAAS,EACpBL,EAAQ,KAAK,CAAE,UAAW,CAAE,MAAO,CAACI,CAAI,EAAG,MAAOC,CAAS,CAAE,CAAC,EAG9DL,EAAQ,KAAK,CAAE,UAAW,CAAE,MAAO,CAACI,CAAI,EAAG,MAAO,CAAC,UAAU,CAAE,CAAE,CAAC,CAEtE,CAEA,OAAOJ,CACT,CAxBSH,EAAAU,GAAA,0BA0BT,SAASC,GACPZ,EACAa,EACAC,EACAhB,EAAY,GACZC,EACAI,EAAwC,CAAC,EACf,CAC1B,IAAMY,EAAgBb,GAA0BC,CAAiB,EAC3Da,EAAsB,CAC1B,CACE,IAAK,iCACL,UAAW,CAAC,GAAG,CACjB,CACF,EACMC,EAAgE,CAAC,EAC1CF,EAAc,OAAS,EAUlDE,EAAM,KAAK,CACT,GAAIF,EACJ,KAAMC,CACR,CAAC,EATDC,EAAM,KAAK,CACT,KAAMD,CACR,CAAC,EAUH,IAAME,EACJ,CACE,KAAM,sBACN,SAAU,CACR,KAAMC,EAAqB,GAAGN,CAAI,cAAc,EAChD,UAAAC,CACF,EACA,KAAM,CACJ,gBACA,SAAU,CACR,KAAM,aACR,EACA,MAAAG,CACF,CACF,EAEF,OAAArB,GAAgBsB,EAAO,KAAMpB,EAAWC,EAAcC,CAAa,EAC5DkB,CACT,CAlDSjB,EAAAW,GAAA,kCAoDT,SAASQ,GACPpB,EACAa,EACAC,EACAhB,EAAY,GACZC,EACAI,EAAwC,CAAC,EACf,CAE1B,IAAMkB,EAAaV,GAAuBR,CAAiB,EACrDY,EAAgBb,GAA0BC,CAAiB,EAE3Dc,EAAgE,CAAC,EAEjEK,EAAe,CACnB,qBAAsB,CAAC,eAAeC,EAAU,MAAM,eAAe,CACvE,EAEMC,EAA2B,CAC/B,GAAGF,EACH,cAAe,CAACG,EAAoB,CACtC,EAE6BJ,EAAW,OAAS,GAa/CJ,EAAM,KAAK,CACT,KAAM,CACJ,CACE,OAAQO,CACV,CACF,EACA,GAAIH,CACN,CAAC,EAGDJ,EAAM,KAAK,CACT,KAAM,CACJ,CACE,OAAQK,CACV,CACF,EACA,GAAIP,CACN,CAAC,GA1BDE,EAAM,KAAK,CACT,KAAM,CACJ,CACE,OAAQK,CACV,CACF,CACF,CAAC,EAuBH,IAAMJ,EAAmC,CACvC,KAAM,sBACN,SAAU,CACR,KAAMC,EAAqB,GAAGN,CAAI,YAAY,EAC9C,UAAAC,CACF,EACA,KAAM,CACJ,cACA,MAAAG,CACF,CACF,EAEA,OAAArB,GAAgBsB,EAAO,KAAOpB,EAAWC,EAAcC,CAAa,EAC7DkB,CACT,CAtESjB,EAAAmB,GAAA,+BAwET,SAASM,GACP1B,EACAa,EACAC,EACAhB,EAAY,GACZC,EAC4B,CAE5B,IAAMmB,EAEF,CACF,KAAM,wBACN,SAAU,CACR,KAAMC,EAAqB,GAAGN,CAAI,YAAY,EAC9C,UAAAC,CACF,EACA,KAAM,CACJ,SAAU,CACR,CACE,UAAW,CAACD,CAAI,EAChB,qBAAsB,GACtB,OAAQ,eAAeU,EAAU,MAAM,cACvC,QAAS,eAAeA,EAAU,MAAM,2CAC1C,CACF,CACF,CACF,EAEA,OAAA3B,GAAgBsB,EAAO,KAAOpB,EAAWC,EAAcC,CAAa,EAC7DkB,CACT,CA9BSjB,EAAAyB,GAAA,8BAgCT,eAAeC,GACbC,EACA5B,EACA6B,EACA/B,EACAC,EACA,CAEA,IAAM+B,EAAYnC,GAAaiC,EAAM,MAAM,EACrCd,EAAYe,EAAI,SAAU,UAC1BE,GAAcF,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDG,EAAkBC,EAAYJ,CAAG,EAGjC1B,EAAoB+B,GAAyBL,EAAK7B,CAAa,EAChEF,GAEHK,EAAkB,KAAK,CAAE,KAAM,QAAS,KAAM,mBAAoB,CAAC,EAGrE,IAAMgC,EAAiBlC,EAACmC,IACtBA,EAAU,SAAU,gBAAkBJ,EACtCI,EAAU,SAAU,OAAS,CAC3B,cAAeP,EAAI,SAAU,KAC7B,iBAAkBE,CACpB,EACOK,GANc,kBASvB,GAAI,CAEF,QAAM,QAAIC,CAAwB,EAAEP,CAAS,EAC3CK,EACEvB,GACEZ,EACA4B,EAAM,KACNd,EACAhB,EACAC,EACAI,CACF,CACF,EACA,CAAE,MAAO,EAAK,CAChB,EAGA,QAAM,QAAImC,EAA0B,EAAER,CAAS,EAC7CK,EACET,GAA2B1B,EAAe4B,EAAM,KAAMd,EAAWhB,EAAWC,CAAY,CAC1F,EACA,CAAE,MAAO,EAAK,CAChB,EAGA,QAAM,QAAIsC,CAAwB,EAAEP,CAAS,EAC3CK,EACEf,GACEpB,EACA4B,EAAM,KACNd,EACAhB,EACAC,EACAI,CACF,CACF,EACA,CAAE,MAAO,EAAK,CAChB,CACF,OAASoC,EAAG,CACV,IAAMC,EAAM,oCAAoCZ,EAAM,IAAI,OAAOd,CAAS,KAAKyB,CAAC,GAChF,MAAAE,EAAI,MAAMF,EAAGC,CAAG,EACV,IAAI,MAAMA,EAAK,CACnB,MAAOD,CACT,CAAC,CACH,CAEA,GAAI,CACF,MAAMG,GAAoBX,EAAYjB,EAAWe,EAAI,SAAU,IAAK,CACtE,OAASU,EAAG,CACVE,EAAI,MAAMF,EAAG,wCAAwCX,EAAM,IAAI,OAAOd,CAAS,KAAKyB,CAAC,EAAE,CACzF,CACF,CAhFetC,EAAA0B,GAAA,gBAkFf,eAAee,GAAoBX,EAAoBjB,EAAmB6B,EAAiB,CACzF,QAAWC,IAAQ,CAACP,EAA0BC,EAA0B,EACtE,MAAMO,EAAad,EAAYjB,EAAW6B,EAASC,EAAMH,CAAG,CAEhE,CAJexC,EAAAyC,GAAA,uBAoBf,SAASI,GACPC,EACAC,EACoB,CACpB,IAAMC,EAAsBF,EAAI,MAAM,SAAW,CAAC,EAC5CG,EAA0B,CAAC,EAEjC,QAAWC,KAAKF,EAAU,CACxB,IAAMG,EAA8BD,EAAE,aAAeA,EAAE,UAG1B,OAAO,KAAKH,CAAa,EAAE,SAAW,GACvCK,GAAcD,EAAKJ,CAAa,IAC1DE,EAAI,KAAK,CAAE,KAAM,OAAOC,EAAE,UAAU,EAAG,KAAMA,EAAE,MAAQ,UAAW,CAAC,CAEvE,CAEA,OAAOD,CACT,CAlBSI,EAAAR,GAAA,4BC1XT,IAAAS,GAA2B,kBAC3BC,GAA0B,gBAO1B,IAAIC,GAAwD,KAGxDC,GAA2C,KAGzCC,GAGF,IAAI,IAGJC,GAAiD,KAGjDC,GAAuC,KAGrCC,GAAoB,SAAS,QAAQ,IAAI,mBAAqB,OAAQ,EAAE,EAEnEC,EAAyC,CAAC,EAE9C,SAASC,IAA2B,CACzCD,EAAiB,CACf,UAAW,cACX,WAAY,kBACZ,WAAY,eAAeE,EAAU,MAAM,GAC3C,MAAO,KACT,EAEAC,EAAI,KAAKH,EAAgB,yCAAyC,CACpE,CATgBI,EAAAH,GAAA,4BAehB,eAAsBI,IAAyB,CAC7C,GAAI,QAAQ,IAAI,kBAAoB,QAAU,QAAQ,IAAI,YAAc,MAAO,CAC7EJ,GAAyB,EAEzBE,EAAI,KAAK,4CAA4C,EAErD,QAAM,QAAI,QAAK,SAAS,EAAE,MAAM,CAC9B,SAAU,CACR,KAAMH,EAAe,SACvB,CACF,CAAC,EAGD,GAAI,CACF,IAAMM,EAAS,QAAM,QAAI,QAAK,MAAM,EACjC,YAAYN,EAAe,SAAS,EACpC,IAAIA,EAAe,UAAU,EAChCG,EAAI,KAAK,kDAAkDG,EAAO,UAAU,IAAI,EAAE,CACpF,MAAQ,CACNH,EAAI,KAAK,oDAAoD,EAC7D,GAAI,CAEF,MAAMI,GAAwBC,GAAmB,EAAG,EAAK,CAC3D,OAASC,EAAK,CACZ,MAAAN,EAAI,MAAMM,EAAK,kDAAkD,EAC3D,IAAI,MAAM,mDAAoD,CAAE,MAAOA,CAAI,CAAC,CACpF,CACF,CACF,CACF,CA7BsBL,EAAAC,GAAA,0BAqCf,SAASG,IAAwC,CACtD,IAAME,EAA4B,CAChC,yBAA0B,GAC1B,eAAgB,UAChB,YAAa,QACb,UAAW,OACX,oBAAqB,CACnB,sBAAuB,GACvB,kBAAmB,eAAeR,EAAU,MAAM,WAAWF,EAAe,KAAK,gCACjF,UAAW,eAAeE,EAAU,MAAM,WAAWF,EAAe,KAAK,iCACzE,aAAc,CACZ,SAAU,eAAeE,EAAU,MAAM,WAAWF,EAAe,KAAK,iCACxE,4BAA6B,EAC/B,EACA,UAAW,YACX,cAAe,gBACf,SAAU,CACR,SAAU,SACV,OAAQ,eACV,EACA,8BAA+B,GAAG,KAAKE,EAAU,SAAS,KAAK,CAAC,GAChE,OAAQ,CACN,KAAM,gBACN,aAAc,eAAeA,EAAU,MAAM,WAAWF,EAAe,KAAK,uCAC9E,EACA,yBAA0B,IAC1B,qBAAsB,IACtB,OAAQ,CAAC,CACX,EACA,QAAS,EACT,OAAQ,CACNW,GAAW,CACT,KAAM,cACN,mBACA,OAAQ,CACN,SAAU,cACV,OAAQ,cACR,aAAc,CAAC,yBAAyB,CAC1C,CACF,CAAC,CACH,CACF,EAGA,OAAIT,EAAU,sBACZQ,EAAO,oBAAoB,2BAA6B,CACtD,WAAYR,EAAU,mBACxB,GAGKQ,CACT,CAnDgBN,EAAAI,GAAA,sBA0DT,SAASI,GAAqBF,EAA2B,CAC9Df,GAAiBe,CACnB,CAFgBN,EAAAQ,GAAA,wBAUhB,eAAsBC,IAAmD,CACvE,OAAIlB,IACFQ,EAAI,KAAK,wCAAwC,EAC1C,QAAQ,QAAQR,EAAc,IAKnCD,KAAuB,OACzBA,MAAqB,QAAI,QAAK,MAAM,EACjC,YAAYM,EAAe,SAAS,EACpC,IAAIA,EAAe,UAAU,EAC7B,KAAKM,GAAU,CACd,IAAMI,EAAS,KAAK,MAAM,KAAKJ,EAAO,KAAM,aAAa,CAAC,CAAC,EAE3D,OAAAX,GAAiBe,EACjBb,GAAuBa,EAChBA,CACT,CAAC,EACA,QAAQ,IAAM,CACbhB,GAAqB,IACvB,CAAC,GAGEA,GACT,CAzBsBU,EAAAS,GAAA,wBAmCtB,eAAsBN,GACpBO,EACAC,EAAW,GACI,CACf,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CAEtCrB,GAAgB,IAAIkB,EAAmB,CAAE,QAAAE,EAAS,OAAAC,CAAO,CAAC,EAGtDnB,IACF,aAAaA,EAAa,EAI5BA,GAAgB,WAAW,SAAY,CACrC,GAAI,CACFK,EAAI,KACF,kDACE,MAAM,KAAKP,GAAgB,KAAK,CAAC,EAAE,MACrC,mBACF,EAGA,GAAM,CAAE,oBAAAsB,EAAqB,KAAAC,CAAK,EAAIC,GAAaN,CAAkB,EAGrEjB,GAAuB,MAAMwB,GAAYH,CAAmB,EAE5Df,EAAI,KAAK,mEAAmE,EAGxEY,IACFZ,EAAI,KAAK,sDAAsD,EAC/D,MAAMmB,GAAmBH,CAAI,GAI/BvB,GAAgB,QAAQ2B,GAAK,CAC3BA,EAAE,QAAQ,CACZ,CAAC,CACH,OAASC,EAAG,CACVrB,EAAI,MAAMqB,EAAG,oCAAoC,EAGjD7B,GAAiBE,GACjBM,EAAI,KAAK,2CAA2C,EAGpDP,GAAgB,QAAQ2B,GAAK,CAC3BA,EAAE,OAAO,IAAI,MAAM,gDAAiD,CAAE,MAAOC,CAAE,CAAC,CAAC,CACnF,CAAC,CACH,QAAE,CAEA5B,GAAgB,MAAM,EAGtBE,GAAgB,IAClB,CACF,EAAGC,EAAiB,CACtB,CAAC,CACH,CA5DsBK,EAAAG,GAAA,2BAmEtB,eAAee,GAAmBP,EAAkB,CAClD,GAAI,CACF,QAAM,QAAI,QAAK,WAAY,CAAE,KAAM,cAAe,UAAWf,EAAe,SAAU,CAAC,EAAE,MAAM,CAC7F,CACE,GAAI,MACJ,KAAM,yDACN,MAAOe,CACT,CACF,CAAC,EAEDZ,EAAI,KAAK,kDAAkD,CAC7D,OAASqB,EAAG,CACV,MAAArB,EAAI,MAAMqB,EAAG,6CAA6C,EACpD,IAAI,MAAM,8CAA+C,CAAE,MAAOA,CAAE,CAAC,CAC7E,CACF,CAfepB,EAAAkB,GAAA,sBAsBf,eAAeD,GAAYH,EAA6B,CACtD,GAAI,CACF,OAAO,QAAM,QAAI,QAAK,MAAM,EACzB,MACC,CACE,SAAU,CACR,UAAWlB,EAAe,UAC1B,KAAMA,EAAe,UACvB,EACA,KAAM,CACJ,cAAekB,CACjB,CACF,EACA,CAAE,MAAO,EAAK,CAChB,EACC,KAAKZ,GAAU,KAAK,MAAM,KAAKA,EAAO,KAAM,aAAa,CAAC,CAAC,CAAsB,CACtF,OAASkB,EAAG,CACV,MAAArB,EAAI,MAAMqB,EAAG,+CAA+C,EACtD,IAAI,MAAM,yCAA0C,CAAE,MAAOA,CAAE,CAAC,CACxE,CACF,CApBepB,EAAAiB,GAAA,eA4Bf,SAASD,GAAaK,EAAqE,CACzF,IAAMf,EAAS,KAAK,KAAK,UAAUe,CAAC,CAAC,EAC/BN,KAAO,eAAW,QAAQ,EAAE,OAAOT,CAAM,EAAE,OAAO,KAAK,EAE7D,MAAO,CAAE,oBAAqBA,EAAQ,KAAAS,CAAK,CAC7C,CALSf,EAAAgB,GAAA,gBdtRF,IAAMM,EAAMC,wBAA0C,EACzDC,GAAO,GAEX,eAAsBC,GACpBC,EACAC,EAC8B,CAC9B,GAAI,CAACD,EAAI,UAAU,WAAa,CAACA,EAAI,UAAU,KAC7C,MAAM,IAAI,MAAM,6CAA6C,EAI/D,IAAME,EAAYF,EAAI,MAAM,SAAS,aAAa,MAAQ,UACpDG,EAAmBH,EAAI,QAAQ,UAAY,UAC3CI,EAAYF,IAAc,UAG1BG,EAAqBC,GAAsBN,CAAG,EAG9CO,EAAwBF,EAAmB,IAAIG,IAAQ,CAC3D,SAAUA,EAAI,SACd,SAAUA,EAAI,2BAA6B,CAAC,CAC9C,EAAE,EAGF,QAAWA,KAAOH,EAAoB,CAChCD,GACF,MAAMK,GAAqBT,EAAKQ,CAAG,EAGrC,IAAME,EAAST,EAAQ,IAAIO,EAAI,QAAQ,EACvC,GAAI,CAACE,EACH,MAAM,IAAI,MAAM,wBAAwBF,EAAI,QAAQ,EAAE,EAIxD,IAAMG,EAAmBC,EAAgBJ,EAAI,QAAQ,EAErD,MAAMK,GACJ,CAAE,KAAML,EAAI,SAAU,mBAA0B,OAAAE,CAAO,EACvDF,EAAI,0BACJJ,EACAJ,EACAW,CACF,CACF,CAGA,aAAMG,GAAwBd,EAAKO,EAAuBJ,EAAkBD,CAAS,EAGrF,MAAMa,GACHf,EAAI,UAAU,YAAc,GAAG,SAAS,EACzCA,EAAI,SAAS,UACbA,EAAI,SAAS,KACbgB,GACApB,CACF,EAGOW,CACT,CA3DsBU,EAAAlB,GAAA,eA6DtB,eAAsBe,GACpBd,EACAO,EAA6C,CAAC,EAC9CJ,EACAe,EACe,CACf,IAAMC,EAAcnB,EAAI,QAAQ,oBAAsB,CAAC,EAGjDoB,EAAkBjB,IAAqBe,EAGvCG,EAAiBF,EAAY,OACjCG,GAAa,CAACf,EAAsB,KAAKgB,GAAKA,EAAE,WAAaD,EAAU,QAAQ,CACjF,EAGA,MAAM,QAAQ,IACZD,EAAe,IAAI,MAAMX,GAAU,CACjC,IAAMC,EAAmBC,EAAgBF,EAAO,QAAQ,EACxDd,EAAI,KAAK,+BAA+Bc,EAAO,QAAQ,EAAE,EAEzD,MAAMG,GACJ,CAAE,KAAMH,EAAO,SAAU,qBAA4B,EACrD,CAAC,EACD,GACAV,EACAW,CACF,EAEIX,EAAI,UAAU,WAChB,MAAMwB,GAAsBxB,EAAI,SAAS,UAAWW,CAAgB,CAExE,CAAC,CACH,EAGA,IAAMc,EAAyBL,EAC3BD,EACAA,EAAY,OAAOG,GAAa,CAC9B,IAAMI,EAAYnB,EAAsB,KAAKgB,GAAKA,EAAE,WAAaD,EAAU,QAAQ,EACnF,OAAKI,EACE,KAAK,UAAUJ,EAAU,QAAQ,IAAM,KAAK,UAAUI,EAAU,QAAQ,EADxD,EAEzB,CAAC,EAGL,QAAWhB,KAAUe,EAAwB,CAC3C,IAAMC,EAAYnB,EAAsB,KAAKgB,GAAKA,EAAE,WAAab,EAAO,QAAQ,EAC1EC,EAAmBC,EAAgBF,EAAO,QAAQ,EACnDgB,IAEL9B,EAAI,KACF,CACE,OAAQwB,EAAkB,mBAAqB,kBACjD,EACA,+BAA+BV,EAAO,QAAQ,EAChD,EAEIV,EAAI,UAAU,WAChB,MAAMwB,GAAsBxB,EAAI,SAAS,UAAWW,CAAgB,EAExE,CACF,CA9DsBM,EAAAH,GAAA,2BAgEtB,SAASa,GAAyBC,EAA0D,CAC1F,OAAOA,EAAM,SAAW,aAAoBA,EAAM,SAAW,cAC/D,CAFSX,EAAAU,GAAA,4BAIT,eAAsBd,GACpBe,EACAC,EAA2C,CAAC,EAC5CzB,EACAJ,EACA8B,EACA,CAEA,GADA,MAAMC,GAAaH,CAAK,EACpBD,GAAyBC,CAAK,EAAG,CACnC,GAAI,CAAC5B,EACH,MAAM,IAAI,MAAM,+DAA+D,EAEjF,MAAMgC,GAAaJ,EAAOC,EAAe7B,EAAKI,EAAW0B,CAAY,CACvE,CACF,CAdsBb,EAAAJ,GAAA,wBAiBtB,eAAsBkB,GAAaH,EAAyB,CAE1D,GAAI9B,GAAM,CACRF,EAAI,MAAM,4CAA4C,EACtD,WAAW,IAAMmC,GAAaH,CAAK,EAAG,CAAC,EACvC,MACF,CAEA,IAAIK,EAEJ,GAAI,CACFrC,EAAI,MAAM,2BAA2B,EACrCE,GAAO,GAGPmC,EAAS,MAAMC,GAAqB,EAAE,KAAKD,GAClCE,GAAYF,EAAQL,CAAK,CACjC,EAGDQ,GAAqBH,CAAM,CAC7B,OAASI,EAAG,CACV,MAAAzC,EAAI,MAAM,CAAE,MAAAgC,EAAO,EAAAS,CAAE,EAAG,wDAAwD,EAC1EA,CACR,QAAE,CAEAzC,EAAI,MAAM,6BAA6B,EACvCE,GAAO,EACT,CAGAF,EAAI,MAAM,6BAA6B,EACvC,MAAM0C,GAAwBL,CAAM,CACtC,CAjCsBhB,EAAAc,GAAA,gBAmCf,SAASI,GAAYF,EAA2BL,EAAyB,CAC9E,IAAIW,EAEJ,GAAIX,EAAM,SAAW,YAEnBW,EAASN,EAAO,OAAO,OAAOO,GAASA,EAAM,OAASZ,EAAM,IAAI,EAChEW,EAASA,EAAO,OAAOE,GAAWb,CAAK,CAAC,EAIxCW,EADmB,KAAE,OAAO,KAAE,KAAK,MAAM,CAAC,EACtBA,CAAM,UACjBX,EAAM,SAAW,eAG1BW,EAASN,EAAO,OAAO,OAAOO,GAASA,EAAM,OAASZ,EAAM,IAAI,UAEvDA,EAAM,SAAW,qBACrBA,EAAM,SAKTK,EAAO,oBAAoB,2BAA6B,CACtD,WAAYL,EAAM,QACpB,EALA,OAAOK,EAAO,oBAAoB,2BAO/BL,EAAM,UAKTK,EAAO,oBAAoB,8BAAgCL,EAAM,UAHjE,OAAOK,EAAO,oBAAoB,8BAKpCM,EAASN,EAAO,WAEhB,OAAM,IAAI,MAAM,qBAAqBL,EAAM,MAAsB,EAAE,EAIrE,MAAO,CAAE,GAAGK,EAAQ,OAAAM,CAAO,CAC7B,CAxCgBtB,EAAAkB,GAAA,eA0CT,SAASM,GAAWC,EAA0B,CAInD,IAAMC,EAAW,IAAI,IAAID,EAAO,OAAQ,aAAa,CAAC,CAAC,EAAE,SA0BzD,MAxBqB,CACnB,KAAMA,EAAO,KACb,MAAO,CACL,OAAQ,aACR,OAAQC,CACV,EACA,QAAS,CACP,CACE,cAAe,CACb,kBAAmB,eAAeC,EAAU,MAAM,WAAWC,EAAe,KAAK,gCACjF,UAAW,eAAeD,EAAU,MAAM,WAAWC,EAAe,KAAK,iCACzE,aAAcH,EAAO,OAAQ,aAAa,CAAC,EAC3C,UAAWA,EAAO,OAAQ,SAC1B,cAAeA,EAAO,OAAQ,OAC9B,OAAQ,CAAC,EACT,OAAQ,CACN,KAAM,UACN,aAAc,eAAeE,EAAU,MAAM,WAAWC,EAAe,KAAK,iCAC9E,EACA,mBAAoBH,EAAO,OAAQ,QACrC,CACF,CACF,CACF,CAEF,CA/BgBzB,EAAAwB,GAAA,cezPhB,IAAAK,EAA6B,gBCCtB,IAAMC,GAAU,qBAgBVC,GAAuC,CAClD,CACE,QAAS,CAAE,KAAMD,EAAQ,CAC3B,CACF,EClBO,IAAME,GAAgC,CAC3C,QAAS,CACP,KAAM,YACN,OAAQ,CAACC,EAAO,CAClB,CACF,EAMaC,GAAyC,CACpD,kBAAmB,CAAC,CACtB,EFPA,IAAMC,GAAMC,uBAAyC,EAG/CC,GAAU,IAAI,IAGdC,GAAkB,IAAI,IAGxBC,GAA4B,GAMhC,eAAsBC,IAAqB,CACzC,GAAI,QAAQ,IAAI,kBAAoB,QAAU,QAAQ,IAAI,YAAc,MAAO,CAE7E,GAAIC,EAAU,cAAc,OAAS,EAAG,CACtC,QAAWC,KAAYD,EAAU,cAC/BJ,GAAQ,IAAIK,CAAQ,EAEtB,MAAMC,GAA+B,EACrC,MAAMC,GAAqC,EAC3C,MACF,CAEA,GAAI,CACF,IAAMC,EAAQ,MAAMC,EAAeC,GAAsBZ,EAAG,EAC5DE,GAAQ,MAAM,EAEd,QAAWW,KAAQH,EAAM,MAAO,CAC9B,IAAMI,EAAKC,GAAkBF,CAAI,EAC3BG,EAAWH,EAAK,SAAU,KAE5BC,IACFZ,GAAQ,IAAIY,CAAE,EACdX,GAAgB,IAAIa,EAAUF,CAAE,EAEpC,CACA,MAAMN,GAA+B,EACrC,MAAMC,GAAqC,CAC7C,OAASQ,EAAK,CACZjB,GAAI,MAAM,2BAA4BiB,CAAG,CAC3C,CACF,CACF,CA/BsBC,EAAAb,GAAA,sBAqCf,SAASc,IAAmC,CACjD,IAAMC,EAAWC,GAAkB,CAAC,GAAGnB,EAAO,CAAC,EAC/C,OAAIkB,EAAS,OAAS,EAAUA,GAEhCpB,GAAI,KAAK,mDAAmD,EACrD,CAACsB,EAAQ,EAClB,CANgBJ,EAAAC,GAAA,aAYhB,eAAsBI,GAAgCV,EAAiB,CACrE,IAAMC,EAAKC,GAAkBF,CAAI,EAC3BG,EAAWH,EAAK,SAAU,KAEhC,GAAIC,EAAI,CACN,IAAMU,EAAQrB,GAAgB,IAAIa,CAAQ,EAE1Cd,GAAQ,IAAIY,CAAE,EACdX,GAAgB,IAAIa,EAAUF,CAAE,EAG5BU,GAASA,IAAUV,GACrBZ,GAAQ,OAAOsB,CAAK,CAExB,CAEA,MAAMhB,GAA+B,EACrC,MAAMC,GAAqC,CAC7C,CAlBsBS,EAAAK,GAAA,mCAwBtB,eAAsBE,GAA0BZ,EAAiB,CAC/D,IAAMC,EAAKC,GAAkBF,CAAI,EAC3BG,EAAWH,EAAK,SAAU,KAC5BC,IACFZ,GAAQ,OAAOY,CAAE,EACjBX,GAAgB,OAAOa,CAAQ,GAGjC,MAAMR,GAA+B,EACrC,MAAMC,GAAqC,CAC7C,CAVsBS,EAAAO,GAAA,6BAetB,eAAeb,IAAiE,CAC9E,SAAO,OAAI,OAAK,IAAI,EAAE,IAAI,CAC5B,CAFeM,EAAAN,GAAA,wBAQf,eAAsBJ,IAAiC,CACrD,IAAMkB,EAAWL,GAAkB,CAAC,GAAGnB,EAAO,CAAC,EACzCyB,EAAU,QAAM,OAAI,OAAK,aAAa,EACzC,UAAU,2BAA0C,EACpD,IAAI,EAEP,QAAWC,KAAUD,EAAQ,MAAO,CAClC,GAAI,CAACC,EAAO,KAAM,CAChB5B,GAAI,KACF,2BAA2B4B,EAAO,UAAU,SAAS,IAAIA,EAAO,UAAU,IAAI,mBAChF,EACA,QACF,CAEA,IAAIC,EAAiB,GACrB,GAAID,EAAO,KAAK,OAAQ,CACtBA,EAAO,KAAK,OAAO,CAAC,EAAIA,EAAO,KAAK,OAAO,CAAC,GAAK,CAAE,GAAI,CAAC,CAAE,EAC1D,IAAME,EAAWF,EAAO,KAAK,OAAO,CAAC,EAAE,GAClC,IAAE,OAAOE,EAAUJ,CAAQ,IAC9BG,EAAiB,GACjBD,EAAO,KAAK,OAAO,CAAC,EAAE,GAAKF,EAE/B,SAAWE,EAAO,KAAK,QAAS,CAC9BA,EAAO,KAAK,QAAQ,CAAC,EAAIA,EAAO,KAAK,QAAQ,CAAC,GAAK,CAAE,KAAM,CAAC,CAAE,EAC9D,IAAME,EAAWF,EAAO,KAAK,QAAQ,CAAC,EAAE,KACnC,IAAE,OAAOE,EAAUJ,CAAQ,IAC9BG,EAAiB,GACjBD,EAAO,KAAK,QAAQ,CAAC,EAAE,KAAOF,EAElC,CAGA,GAAIG,EAAgB,CACdD,EAAO,WAETA,EAAO,SAAS,cAAgB,QAGlC5B,GAAI,MACF,oCAAoC4B,EAAO,UAAU,SAAS,IAAIA,EAAO,UAAU,IAAI,kBACzF,EAEA,GAAI,CACF,QAAM,OAAI,OAAK,aAAa,EAAE,MAAMA,EAAQ,CAAE,MAAO,EAAK,CAAC,CAC7D,OAASX,EAAK,CACZ,IAAIc,EAAUd,EAAI,MAAM,SAAW,yDACnC,MAAIX,EAAU,cAAc,OAAS,IACnCyB,GACE,qFAEE,IAAI,MAAMA,CAAO,CACzB,CACF,CACF,CACF,CAtDsBb,EAAAV,GAAA,kCAoEtB,eAAsBC,IAAsD,CAI1E,IAAMuB,EAFWX,GAAkB,CAAC,GAAGnB,EAAO,CAAC,EAG5C,IAAI+B,GAAQA,EAAK,SAAS,IAAI,EAC9B,OAAQC,GAAyB,OAAOA,GAAS,QAAQ,EAG5D,GAAI,CAAC9B,GACH,GAAI,CACF,QAAM,OAAI,OAAK,wBAAwB,EAAE,IAAI,yCAAyC,EACtFA,GAA4B,EAC9B,MAAQ,CACNJ,GAAI,KACF,uGACF,EACA,MACF,CAGF,IAAMmC,EAAW,QAAM,OAAIC,CAAmB,EAC3C,UAAU,2BAA0C,EACpD,IAAI,EAEP,GAAID,EAAS,MAAM,OAAS,EAAG,CAC7B,IAAME,EAAUF,EAAS,MACtB,IAAIG,GAAO,SAASA,EAAI,UAAU,IAAI,gBAAgBA,EAAI,UAAU,SAAS,EAAE,EAC/E,KAAK,KAAK,EACbtC,GAAI,MAAM,WAAWmC,EAAS,MAAM,MAAM,2BAA2BE,CAAO,EAAE,CAChF,CAEA,QAAWC,KAAOH,EAAS,MAAO,CAEhC,GAAI,CAACG,EAAI,MAAQ,CAACA,EAAI,KAAK,OAASA,EAAI,KAAK,MAAM,SAAW,EAAG,CAC/DtC,GAAI,KACF,uBAAuBsC,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,oBACtE,EACA,QACF,CAEA,IAAIT,EAAiB,GACfU,EAAOD,EAAI,KAAK,MAAM,CAAC,EAG7B,GAAIC,EAAK,MAAQA,EAAK,KAAK,OAAS,GAAKA,EAAK,KAAK,CAAC,EAAE,QAAQ,SAAU,CACtE,IAAMC,EAAcD,EAAK,KAAK,CAAC,EAAE,OAAO,SACnC,IAAE,OAAOC,EAAaR,CAAW,IACpCO,EAAK,KAAK,CAAC,EAAE,OAAO,SAAWP,EAC/BH,EAAiB,GAErB,MAEEU,EAAK,KAAO,CAAC,CAAE,OAAQ,CAAE,SAAUP,CAAY,CAAE,CAAC,EAClDH,EAAiB,GAGnB,GAAIA,EAAgB,CAEdS,EAAI,WACNA,EAAI,SAAS,cAAgB,QAE/B,GAAI,CACF,QAAM,OAAIF,CAAmB,EAAE,MAAME,EAAK,CAAE,MAAO,EAAK,CAAC,EACzDtC,GAAI,MACF,yCAAyCsC,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,EACxF,CACF,OAASrB,EAAK,CACZjB,GAAI,MACFiB,EACA,wCAAwCqB,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,EACvF,CACF,CACF,CACF,CACF,CA3EsBpB,EAAAT,GAAA,wCAgFtB,SAASY,GAAkBoB,EAA0C,CACnE,OAAOA,EAAQ,IAAI3B,IAAO,CACxB,QAAS,CACP,KAAM4B,GAAa5B,CAAE,CACvB,CACF,EAAE,CACJ,CANSI,EAAAG,GAAA,qBAWT,SAASqB,GAAa5B,EAAoB,CAExC,OAAIA,EAAG,SAAS,GAAG,EACVA,EAGF,GAAGA,CAAE,KACd,CAPSI,EAAAwB,GAAA,gBAYT,SAAS3B,GAAkBF,EAAqC,CAC9D,OAAOA,EAAK,QAAQ,WAAW,KAAM8B,GAAwBA,EAAK,OAAS,YAAY,GAAG,OAC5F,CAFSzB,EAAAH,GAAA,qBnBvRF,IAAM6B,EAAYC,mBAAqC,EAGjDC,EAAoB,CAC/B,OAAQ,GACR,YAAa,GACb,SAAU,CACR,MAAO,GACP,gBAAiB,GACjB,mBAAoB,GACpB,SAAU,GACV,YAAa,EACf,EACA,oBAAqB,GACrB,qBAAsB,GACtB,YAAa,GACb,cAAe,CAAC,EAChB,mBAAoB,EACtB,EAoBO,SAASC,GACdC,EACAC,EACAC,EACQ,CACR,IAAMC,EAASH,IAAW,EAK1B,MAAO,GAHLC,IAAS,EAAoBE,EAAS,UAAY,WAAcA,EAAS,SAAW,SAGxE,oBAAoBD,CAAY,GAF/BC,EAAS,GAAK,SAE0B,EACzD,CAXgBC,EAAAL,GAAA,uBAsBT,SAASM,GAA6BL,EAA+B,CAC1E,OACEA,IAAW,IACV,QAAQ,IAAI,kBAAoB,QAAU,QAAQ,IAAI,YAAc,MAEzE,CALgBI,EAAAC,GAAA,gCAiBT,SAASC,GAAWC,EAAmB,CAC5C,IAAMC,EAAYD,EAAG,QAAQ,QAAU,UACjCE,EAAsBF,EAAG,UAAU,aAAeA,EAAG,QAAQ,mBAGnE,OAAIC,GACFE,EAAU,MAAMH,EAAI,8BAA8B,EAC3C,IAGLE,GACFC,EAAU,MAAMH,EAAI,wDAAwD,EACrE,KAGTG,EAAU,MAAMH,EAAI,oDAAoD,EAEjE,GACT,CAlBgBH,EAAAE,GAAA,cA0BT,SAASK,GAAaC,EAAqB,CAEhD,IAAMC,EAAyC,CAAC,EAChD,QAAWC,KAAOF,EAAO,KACvB,GAAI,CACF,IAAMG,EAAe,KAAKH,EAAO,KAAKE,CAAG,CAAC,EACtCC,EACFF,EAAYC,CAAG,EAAIC,EAEnBF,EAAYC,CAAG,EAAI,EAEvB,OAASE,EAAG,CACVN,EAAU,MAAM,gCAAgCI,CAAG,YAAYE,EAAE,OAAO,EAAE,CAC5E,CAGF,OAAOH,CACT,CAjBgBT,EAAAO,GAAA,gBAyBhB,eAAsBM,GAAgBC,EAAkBlB,EAAsB,CAC5E,IAAME,EAAe,6BACrBQ,EAAU,KAAKX,GAAoBC,EAAQ,EAAkBE,CAAY,CAAC,EAG1E,IAAMiB,EAAyBd,GAA6BL,CAAM,EAE5DoB,EAAiBT,GAAaO,CAAG,EAGlC,OAAO,KAAKE,CAAc,EAAE,SAAS,uBAAuB,IAC/DA,EAAe,sBAAwB,IAIrCA,EAAe,wBAA0B,yCAC3CA,EAAe,sBAAwB,IAIrCC,EAAU,sBAAwBD,EAAe,wBACnDC,EAAU,oBAAsBD,EAAe,sBAE3CD,GACF,MAAMG,GAAyB,qBAAqB,GAIxDZ,EAAU,KAAKX,GAAoBC,EAAQ,EAAmBE,CAAY,CAAC,CAC7E,CA7BsBE,EAAAa,GAAA,mBAuCtB,SAASM,GACPC,EACAC,EACAC,EACS,CAwBT,MAtBI,GAAAL,EAAU,SAAS,QAAUG,EAAS,OAKtCH,EAAU,SAAS,mBAAqBG,EAAS,kBAAoB,KAKrEH,EAAU,SAAS,sBAAwBG,EAAS,qBAAuB,KAK3EA,EAAS,iBACPH,EAAU,SAAS,WAAaI,GAMlCD,EAAS,oBACPH,EAAU,SAAS,cAAgBK,EAM3C,CAnCStB,EAAAmB,GAAA,kCA2CT,eAAeI,GAAqBH,EAA0BL,EAAkC,CAEzFK,EAAS,QACZA,EAAS,MAAQ,KAIfA,EAAS,QAAU,kCAEZA,EAAS,QAAU,4BAC5BA,EAAS,MAAQ,IAInB,IAAII,EACAH,EAAW,GACXC,EAAc,GAElB,GAAI,CACFE,EAAmB,QAAM,QAAI,QAAK,SAAS,EAAE,YAAY,aAAa,EAAE,IAAI,cAAc,EAEtFA,EAAiB,OACnBH,EAAWG,EAAiB,KAAK,YAAiB,GAClDF,EAAcE,EAAiB,KAAK,eAAoB,GAE5D,OAASZ,EAAG,CAEV,GAAIA,GAAG,SAAW,IAChBN,EAAU,KAAK,2EAA2E,MAG1F,OAAAA,EAAU,MAAM,0DAA2DM,CAAC,EACtEA,CAEV,CAGA,IAAMa,EAA+BN,GACnCC,EACAC,EACAC,CACF,EAEIL,EAAU,SAAS,QAAUG,EAAS,QACxCH,EAAU,SAAS,MAAQG,EAAS,OAAS,GAGzCL,GACF,MAAMG,GAAyB,mBAAmB,GAItDD,EAAU,SAAS,gBAAkBG,EAAS,kBAAoB,GAClEH,EAAU,SAAS,mBAAqBG,EAAS,qBAAuB,GACxEH,EAAU,SAAS,SAAWI,EAC9BJ,EAAU,SAAS,YAAcK,EAG7BG,GAAgCV,GAClC,MAAMW,GAA4B,CAEtC,CA7De1B,EAAAuB,GAAA,wBAyEf,eAAsBI,GAAUb,EAAoBlB,EAAsB,CAGxE,GAAI,EAAAA,IAAW,GAAqBM,GAAWY,CAAG,GAIlD,GAAI,CAEF,QAAM,QAAIc,EAAa,EAAE,YAAY,CACnC,SAAU,CACR,KAAMd,EAAI,SAAU,IACtB,EACA,OAAQ,CACN,eACF,CACF,CAAC,EAED,IAAMhB,EAAe,oCACrBQ,EAAU,KAAKX,GAAoBC,EAAQ,EAAkBE,CAAY,CAAC,EAG1E,IAAMiB,EAAyBd,GAA6BL,CAAM,EAE5D,CAAE,OAAAiC,EAAQ,OAAAC,EAAQ,WAAAC,EAAY,SAAAX,CAAS,EAAIN,EAAI,KAGrD,MAAMS,GAAqBH,GAAY,CAAC,EAAGL,CAAsB,EAG7DgB,GAAY,cAAgBd,EAAU,cACxCA,EAAU,YAAcc,GAAY,aAAe,GAC/ChB,IAEFT,EAAU,MAAM,kEAAkE,EAClF,MAAM0B,GAAkB,IAIvBC,GAAsBF,GAAY,cAAed,EAAU,aAAa,IAC3EA,EAAU,cAAgBc,GAAY,eAAiB,CAAC,EACpDhB,IAEFT,EAAU,MAAM,sEAAsE,EACtF,MAAM4B,GAAmB,KAIzBL,EAAO,SAAWZ,EAAU,QAAUY,EAAO,cAAgBZ,EAAU,eACrEY,EAAO,QAAUA,EAAO,SAAW,wBACrCZ,EAAU,OAASY,EAAO,OAE1BZ,EAAU,OAAS,UAEjBY,EAAO,aAAeA,EAAO,cAAgB,8BAC/CZ,EAAU,YAAcY,EAAO,YAE/BZ,EAAU,YAAc,SAASA,EAAU,MAAM,IAMrDA,EAAU,qBAAuBa,EAAO,uBAAyB,GAEjExB,EAAU,KAAKX,GAAoBC,EAAQ,EAAmBE,CAAY,CAAC,EAG3E,QAAM,QAAI8B,EAAa,EAAE,YAAY,CACnC,SAAU,CACR,KAAMd,EAAI,SAAU,IACtB,EACA,OAAQ,CACN,cACA,mBAAoBA,EAAI,SAAU,UACpC,CACF,CAAC,CACH,OAASF,EAAG,CACV,MAAAN,EAAU,MAAM,iCAAkCM,CAAC,EAGnD,QAAM,QAAIgB,EAAa,EAAE,YAAY,CACnC,SAAU,CACR,KAAMd,EAAI,SAAU,IACtB,EACA,OAAQ,CACN,eACA,mBAAoBA,EAAI,SAAU,UACpC,CACF,CAAC,EAEKF,CACR,CACF,CA7FsBZ,EAAA2B,GAAA,aAuGtB,eAAsBQ,IAAgB,CAEpC,GAAI,QAAQ,IAAI,iBAAmB,QAAQ,IAAI,YAAc,MAAO,CAClE,IAAIrB,EAAqB,CAAC,EACtBsB,EAAyB,CAAC,EAE9B,GAAI,CAGF,GAFAtB,EAAM,QAAM,QAAIc,EAAa,EAAE,IAAI,oBAAoB,EAEnD,CAACd,EACH,MAAM,IAAI,MAAM,gCAAgC,CAEpD,OAASF,EAAG,CACV,MAAAN,EAAU,MAAM,sCAAuCM,CAAC,EAClD,IAAI,MAAM,sCAAuC,CAAE,MAAOA,CAAE,CAAC,CACrE,CAEA,GAAI,CAGF,GAFAwB,EAAY,QAAM,QAAI,QAAK,MAAM,EAAE,YAAY,aAAa,EAAE,IAAI,qBAAqB,EAEnF,CAACA,EACH,MAAM,IAAI,MAAM,iCAAiC,CAErD,OAASxB,EAAG,CACV,MAAAN,EAAU,MAAM,8CAA+CM,CAAC,EAC1D,IAAI,MAAM,8CAA+C,CAAE,MAAOA,CAAE,CAAC,CAC7E,CAEA,GAAI,CACFyB,GAAYvB,CAAG,EACf,MAAMa,GAAUb,EAAK,CAAiB,EACtC,MAAMD,GAAgBuB,EAAW,CAAiB,EAClD9B,EAAU,KAAKgC,GAAa,EAAG,mBAAmB,CACpD,OAAS1B,EAAG,CACV,MAAAN,EAAU,MAAMM,CAAC,EACXA,CACR,CACF,CACF,CAtCsBZ,EAAAmC,GAAA,iBA6CtB,SAASG,IAAe,CACtB,IAAMC,EAAsBtB,EAAU,oBAAsB,OAAS,GAC/DI,EAAWJ,EAAU,SAAS,SAAW,OAAS,GAClDK,EAAcL,EAAU,SAAS,YAAc,OAAS,GACxDuB,EAAQvB,EAAU,SAAS,MAAQ,OAAS,GAC5CG,EAAW,CAAE,GAAGH,EAAU,SAAU,SAAAI,EAAU,YAAAC,EAAa,MAAAkB,CAAM,EACvE,MAAO,CAAE,GAAGvB,EAAW,oBAAAsB,EAAqB,SAAAnB,CAAS,CACvD,CAPSpB,EAAAsC,GAAA,gBAUT,SAASL,GAAsBQ,EAAqB,CAAC,EAAGC,EAAyB,CAAC,EAAY,CAC5F,GAAID,EAAS,SAAWC,EAAa,OACnC,MAAO,GAET,IAAMC,EAAiB,CAAC,GAAGF,CAAQ,EAAE,KAAK,EACpCG,EAAqB,CAAC,GAAGF,CAAY,EAAE,KAAK,EAClD,OAAOC,EAAe,MAAM,CAACE,EAAMC,IAAUD,IAASD,EAAmBE,CAAK,CAAC,CACjF,CAPS9C,EAAAiC,GAAA,yBAcT,eAAef,GAAyB6B,EAAgB,CACtD,IAAMC,EAAsC,CAC1C,KAAM,uBACN,4BAEA,UAAW,KAAK/B,EAAU,SAAS,KAAK,EACxC,SAAUA,EAAU,mBACtB,EACAX,EAAU,MAAM,yCAAyCyC,CAAM,EAAE,EACjE,MAAME,GAAqBD,CAAiB,CAC9C,CAVehD,EAAAkB,GAAA,4BAkBf,eAAsBgC,GAAgCC,EAA0C,CAC9F,GAAI,CACF7C,EAAU,MAAM,0CAA0C,EAG1D,IAAMe,EAAW8B,EAAU,MAAO,YAAiB,GAC7C7B,EAAc6B,EAAU,MAAO,eAAoB,GAGnDC,EAAkC,CACtC,MAAOnC,EAAU,SAAS,MAC1B,gBAAiBA,EAAU,SAAS,gBACpC,mBAAoBA,EAAU,SAAS,kBACzC,EAKA,GAAI,CAFgBE,GAA+BiC,EAAiB/B,EAAUC,CAAW,EAEvE,CAChBhB,EAAU,MAAM,uCAAuC,EACvD,MACF,CAGAW,EAAU,SAAS,SAAWI,EAC9BJ,EAAU,SAAS,YAAcK,EACjChB,EAAU,MAAM,oDAAoD,EAGpE,MAAMoB,GAA4B,EAClCpB,EAAU,MAAM,+CAA+C,CACjE,OAAS+C,EAAO,CACd,MAAA/C,EAAU,MAAM+C,EAAO,iDAAiD,EAClEA,CACR,CACF,CAnCsBrD,EAAAkD,GAAA,mCA4CtB,eAAsBI,IAAmB,CAEvC,GAAI,QAAQ,IAAI,kBAAoB,SAAW,QAAQ,IAAI,YAAc,MAAO,CAC9E,IAAMC,KAAU,QAAI3B,EAAa,EAAE,MAAM,MAAOd,EAAoB0C,IAAsB,CAGxF,GAFAlD,EAAU,MAAM,2CAA2CkD,CAAK,EAAE,EAE9D1C,EAAI,UAAU,OAAS,qBAK3B,OAAQ0C,EAAO,CACb,KAAK,cAAW,MAChB,KAAK,cAAW,SACd,GAAI,CACF,MAAM7B,GAAUb,EAAK,CAAmB,CAC1C,OAASF,EAAG,CACVN,EAAU,MAAMM,EAAG,+CAA+C,CACpE,CACA,KAEJ,CACF,EAAG6C,EAAQ,EAEXnD,EAAU,MAAM,kCAAkC,EAClDoD,GAA2BH,EAASjD,EAAW,eAAe,EAC9D,MAAMiD,EAAQ,MAAM,CACtB,CACF,CA5BsBvD,EAAAsD,GAAA,oBfvgBtB,IAAMK,EAAMC,uBAAyC,EAGjDC,GAGAC,GAA4B,GAShC,eAAsBC,IAAoB,CACxC,GAAI,QAAQ,IAAI,kBAAoB,QAAU,QAAQ,IAAI,YAAc,MACtE,GAAI,CACF,IAAMC,EAAM,MAAMC,EAAeC,GAAwBP,CAAG,EAG5D,GAAIQ,EAAU,YACZR,EAAI,KACF,gBAAgBQ,EAAU,WAAW,0DACvC,EACA,MAAMC,GAAoBJ,EAAKG,EAAU,WAAW,MAC/C,CACL,IAAME,EAAQ,MAAMJ,EAAeK,GAA8BX,CAAG,EACpE,MAAMS,GAAoBJ,EAAKK,CAAK,CACtC,CACF,OAASE,EAAO,CACdZ,EAAI,MACF,CACE,IAAK,KAAK,UAAUY,CAAK,CAC3B,EACA,6EACF,CACF,CAEJ,CAxBsBC,EAAAT,GAAA,qBA+Bf,SAASU,IAAiC,CAE/C,OAAIZ,KAKJF,EAAI,KAAK,wDAAwD,EAC1D,CAACe,EAAQ,EAClB,CATgBF,EAAAC,GAAA,WAgBhB,eAAsBE,GAAqCN,EAA2B,CACpF,GAAI,CACFV,EAAI,MACF,wFACF,EACA,IAAMK,EAAM,MAAMC,EAAeC,GAAwBP,CAAG,EAC5D,MAAMS,GAAoBJ,EAAKK,CAAK,CACtC,OAASO,EAAK,CAEZjB,EAAI,MAAM,CAAE,IAAAiB,CAAI,EADJ,6DACU,CACxB,CACF,CAXsBJ,EAAAG,GAAA,wCAoBtB,eAAsBE,GAA+Bb,EAAmB,CACtE,GAAI,CACF,GAAIG,EAAU,YACZR,EAAI,MAAM,4EAA4E,EACtF,MAAMS,GAAoBJ,EAAKG,EAAU,WAAW,MAC/C,CACLR,EAAI,MACF,yFACF,EACA,IAAMU,EAAQ,MAAMJ,EAAeK,GAA8BX,CAAG,EACpE,MAAMS,GAAoBJ,EAAKK,CAAK,CACtC,CACF,OAASO,EAAK,CAEZjB,EAAI,MAAM,CAAE,IAAAiB,CAAI,EADJ,0DACU,CACxB,CACF,CAhBsBJ,EAAAK,GAAA,kCAwBtB,eAAsBT,GAAoBJ,EAAmBK,EAAoC,CAC/F,IAAMS,EAAWd,EAAI,MAAM,UAEvBe,EAAkB,CAAC,EAGvB,GAAI,OAAOV,GAAU,SACnBU,EAAM,KAAKV,CAAK,MACX,CACL,GAAM,CAAE,UAAAW,CAAU,EAAIX,EACtBU,EAAQ,MAAM,QAAQC,CAAS,EAC3BA,EAAU,QAAQC,GACZ,CAAC,MAAM,QAAQA,GAAG,SAAS,GAAKA,EAAE,UAAU,SAAW,EAClD,CAAC,EAEHA,EAAE,UAAU,IAAIC,GAAQ,GAAGA,CAAI,KAAK,CAC5C,EACD,CAAC,CACP,CAGIJ,GACFC,EAAM,KAAK,GAAGD,CAAQ,KAAK,EAIzBC,EAAM,QACRlB,GAAiBkB,EAAM,QAAQI,IAAS,CACtC,QAAS,CACP,KAAMA,CACR,CACF,EAAE,EAGF,MAAMC,GAA6BvB,EAAc,EAGjD,MAAMwB,GAAmCxB,EAAc,GAEvDF,EAAI,KAAK,gDAAgD,CAE7D,CAzCsBa,EAAAJ,GAAA,uBAgDtB,eAAsBgB,GAA6BE,EAAiC,CAClF,IAAMC,EAAU,QAAM,OAAI,OAAK,aAAa,EACzC,UAAU,yBAAwC,EAClD,IAAI,EAEP,QAAWC,KAAUD,EAAQ,MAAO,CAElC,GAAI,CAACC,EAAO,KAAM,CAChB7B,EAAI,KACF,yBAAyB6B,EAAO,SAAU,SAAS,IACjDA,EAAO,SAAU,IACnB,mBACF,EACA,QACF,CAEA,IAAIC,EAAiB,GAErB,GAAID,EAAO,KAAK,OAAQ,CACjBA,EAAO,KAAK,OAAO,CAAC,IACvBA,EAAO,KAAK,OAAO,CAAC,EAAI,CAAE,GAAI,CAAC,CAAE,GAEnC,IAAME,EAAWF,EAAO,KAAK,OAAO,CAAC,EAAE,GAClC,IAAE,OAAOE,EAAUJ,CAAQ,IAC9BG,EAAiB,GACjBD,EAAO,KAAK,OAAO,CAAC,EAAE,GAAKF,EAG/B,SAAWE,EAAO,KAAK,QAAS,CACzBA,EAAO,KAAK,QAAQ,CAAC,IACxBA,EAAO,KAAK,QAAQ,CAAC,EAAI,CAAE,KAAM,CAAC,CAAE,GAEtC,IAAME,EAAWF,EAAO,KAAK,QAAQ,CAAC,EAAE,KACnC,IAAE,OAAOE,EAAUJ,CAAQ,IAC9BG,EAAiB,GACjBD,EAAO,KAAK,QAAQ,CAAC,EAAE,KAAOF,EAElC,CAGA,GAAIG,EAAgB,CACdD,EAAO,WAETA,EAAO,SAAS,cAAgB,QAGlC7B,EAAI,MACF,kCAAkC6B,EAAO,SAAU,SAAS,IAC1DA,EAAO,SAAU,IACnB,kBACF,EACA,GAAI,CACF,QAAM,OAAI,OAAK,aAAa,EAAE,MAAMA,EAAQ,CAAE,MAAO,EAAK,CAAC,CAC7D,OAASZ,EAAK,CACZ,IAAIe,EAAUf,EAAI,MAAM,SAAW,wDACnC,MAAIT,EAAU,cACZwB,GACE,mFAEE,IAAI,MAAMA,CAAO,CACzB,CACF,CACF,CACF,CA/DsBnB,EAAAY,GAAA,gCA8EtB,eAAsBC,GACpBC,EACe,CAEf,IAAMM,EAAcN,EACjB,IAAIO,GAAQA,EAAK,SAAS,IAAI,EAC9B,OAAQV,GAAyB,OAAOA,GAAS,QAAQ,EAG5D,GAAI,CAACrB,GACH,GAAI,CACF,QAAM,OAAI,OAAK,wBAAwB,EAAE,IAAI,yCAAyC,EACtFA,GAA4B,EAC9B,MAAQ,CACNH,EAAI,KACF,qGACF,EACA,MACF,CAIF,IAAMmC,EAAW,QAAM,OAAIC,CAAmB,EAC3C,UAAU,yBAAwC,EAClD,IAAI,EAEP,GAAID,EAAS,MAAM,OAAS,EAAG,CAC7B,IAAME,EAAUF,EAAS,MACtB,IAAIG,GAAO,SAASA,EAAI,UAAU,IAAI,gBAAgBA,EAAI,UAAU,SAAS,EAAE,EAC/E,KAAK,KAAK,EACbtC,EAAI,MAAM,WAAWmC,EAAS,MAAM,MAAM,2BAA2BE,CAAO,EAAE,CAChF,CAEA,QAAWC,KAAOH,EAAS,MAAO,CAEhC,GAAI,CAACG,EAAI,MAAQ,CAACA,EAAI,KAAK,OAASA,EAAI,KAAK,MAAM,SAAW,EAAG,CAC/DtC,EAAI,KACF,uBAAuBsC,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,oBACtE,EACA,QACF,CAEA,IAAIR,EAAiB,GACfS,EAAOD,EAAI,KAAK,MAAM,CAAC,EAE7B,GAAIC,EAAK,MAAQA,EAAK,KAAK,OAAS,GAAKA,EAAK,KAAK,CAAC,EAAE,QAAQ,SAAU,CACtE,IAAMC,EAAcD,EAAK,KAAK,CAAC,EAAE,OAAO,SACnC,IAAE,OAAOC,EAAaP,CAAW,IACpCM,EAAK,KAAK,CAAC,EAAE,OAAO,SAAWN,EAC/BH,EAAiB,GAErB,MAEES,EAAK,KAAO,CAAC,CAAE,OAAQ,CAAE,SAAUN,CAAY,CAAE,CAAC,EAClDH,EAAiB,GAGnB,GAAIA,EAAgB,CAEdQ,EAAI,WACNA,EAAI,SAAS,cAAgB,QAE/B,GAAI,CACF,QAAM,OAAIF,CAAmB,EAAE,MAAME,EAAK,CAAE,MAAO,EAAK,CAAC,EACzDtC,EAAI,MACF,uCAAuCsC,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,EACtF,CACF,OAASrB,EAAK,CACZjB,EAAI,MACFiB,EACA,wCAAwCqB,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,EACvF,CACF,CACF,CACF,CACF,CA3EsBzB,EAAAa,GAAA,sCAkFtB,eAAenB,IAAgD,CAC7D,SAAO,OAAI,OAAK,OAAO,EAAE,YAAY,SAAS,EAAE,IAAI,YAAY,CAClE,CAFeM,EAAAN,GAAA,0BASf,eAAeI,IAA4D,CACzE,SAAO,OAAI,OAAK,aAAa,EAAE,YAAY,SAAS,EAAE,IAAI,YAAY,CACxE,CAFeE,EAAAF,GAAA,gCqC9Uf,IAAA8B,GAA2B,kBAC3BC,GAA0B,gBCC1B,IAAAC,EAA0B,gBAmB1B,eAAsBC,GACpBC,EACAC,EACAC,EACAC,EACAC,EACA,CACA,GAAIH,EAAK,SAAW,EAAG,CACrBE,EAAI,KAAK,8CAA8CH,CAAS,EAAE,EAClE,MACF,CAEAG,EAAI,KAAK,cAAcF,EAAK,MAAM,2CAA2CD,CAAS,EAAE,EAGxF,IAAMK,EAA8C,CAAC,EAC/CC,EAAoC,CAAC,EAG3C,QAAWC,KAAON,EAAM,CAEtB,IAAMO,EAAQD,EAAI,QAAQ,MAC1B,GAAIC,IAAU,aAAeA,IAAU,SAAU,CAC/CL,EAAI,MAAM,gBAAgBH,CAAS,IAAIO,EAAI,UAAU,IAAI,YAAYC,CAAK,GAAG,EAC7E,QACF,CAEA,GAAID,EAAI,UAAU,kBAAmB,CACnCJ,EAAI,MAAM,gBAAgBH,CAAS,IAAIO,EAAI,UAAU,IAAI,yBAAyB,EAClF,QACF,CAGA,IAAME,GADYF,EAAI,UAAU,iBAAmB,CAAC,GACpB,KAAKG,GAAOA,EAAI,aAAe,EAAI,EAEnE,GAAI,CAACD,EAAe,CAElBH,EAAsB,KAAKC,CAAG,EAC9B,QACF,CAGA,IAAMI,EAAgB,GAAGF,EAAc,IAAI,IAAIA,EAAc,IAAI,GACjE,GAAI,CAAAJ,EAAmBM,CAAa,EAKpC,GAAI,CACF,GAAIF,EAAc,OAAS,aAEzB,MAAMG,GAAsBZ,EAAWS,EAAc,KAAMP,EAASC,EAAKC,CAAM,UACtEK,EAAc,OAAS,aAEhC,MAAMI,GACJb,EACA,OAAK,WACLS,EAAc,KACdP,EACAC,EACAC,CACF,UACSK,EAAc,OAAS,cAEhC,MAAMI,GACJb,EACA,OAAK,YACLS,EAAc,KACdP,EACAC,EACAC,CACF,UACSK,EAAc,OAAS,YAEhC,MAAMI,GACJb,EACA,OAAK,UACLS,EAAc,KACdP,EACAC,EACAC,CACF,MACK,CAELE,EAAsB,KAAKC,CAAG,EAC9B,QACF,CAGAF,EAAmBM,CAAa,EAAI,EACtC,OAASG,EAAO,CACdX,EAAI,MACF,CACE,IAAKI,EAAI,UAAU,KACnB,UAAAP,EACA,WAAYS,EAAc,KAC1B,eAAgBA,EAAc,KAC9B,MAAAK,CACF,EACA,wCAAwCZ,CAAO,EACjD,CACF,CACF,CAGII,EAAsB,OAAS,GACjC,MAAMS,GAAoBf,EAAWM,EAAuBJ,EAASC,CAAG,CAE5E,CA5GsBa,EAAAjB,GAAA,cAiHtB,eAAea,GACbZ,EACAiB,EACAf,EACAC,EACAC,EACe,CACf,GAAI,CAEF,eAAec,GAAgB,CAC7B,SAAO,OAAI,OAAK,UAAU,EAAE,YAAYlB,CAAS,EAAE,IAAIiB,CAAc,CACvE,CAFeD,EAAAE,EAAA,iBAMf,IAAMC,GAHK,MAAMC,EAAeF,EAAef,CAAG,GAGvB,UAAU,iBAAiB,KAAKO,GAAOA,EAAI,OAAS,YAAY,EAEvFS,GAAiB,KAEnB,MAAMN,GACJb,EACA,OAAK,WACLmB,EAAgB,KAChBjB,EACAC,EACAC,CACF,EAGA,MAAMS,GAAkBb,EAAW,OAAK,WAAYiB,EAAgBf,EAASC,EAAKC,CAAM,CAE5F,OAASU,EAAO,CACd,MAAAX,EAAI,MACF,CAAE,WAAYc,EAAgB,UAAAjB,EAAW,MAAAc,CAAM,EAC/C,sCAAsCZ,CAAO,EAC/C,EACMY,CACR,CACF,CAtCeE,EAAAJ,GAAA,yBA2Cf,eAAsBC,GACpBb,EACAqB,EACAC,EACApB,EACAC,EACAC,EACe,CAEf,IAAMmB,EAAqBF,GAAgB,MAAQ,OAAOA,CAAc,EASxE,GAAI,CANiB,CAAC,OAAK,WAAY,OAAK,YAAa,OAAK,UAAW,OAAK,UAAU,EAIrD,KAAKG,GAAKA,IAAMH,CAAc,EAG/D,MAAM,IAAI,MAAM,gCAAgCE,CAAkB,EAAE,EAItE,eAAeE,GAAgB,CAC7B,SAAO,OAAIJ,CAAc,EAAE,YAAYrB,CAAS,EAAE,IAAIsB,CAAI,CAC5D,CAFeN,EAAAS,EAAA,iBAGf,IAAMC,EAAa,MAAMN,EAAeK,EAAetB,CAAG,EAE1D,GAAI,CAEGuB,EAAW,OAAMA,EAAW,KAAO,CAAC,GACpCA,EAAW,KAAK,WAAUA,EAAW,KAAK,SAAW,CAAC,GACtDA,EAAW,KAAK,SAAS,WAAUA,EAAW,KAAK,SAAS,SAAW,CAAC,GACxEA,EAAW,KAAK,SAAS,SAAS,cACrCA,EAAW,KAAK,SAAS,SAAS,YAAc,CAAC,GACnDA,EAAW,KAAK,SAAS,SAAS,YAAY,qBAAqB,EAAI,IAAI,KAAK,EAAE,YAAY,EAE9F,OAAOA,EAAW,UAAU,cAG5B,eAAeC,GAA4B,CACzC,SAAO,OAAIN,EAAgB,CAAE,KAAAC,EAAM,UAAAtB,CAAU,CAAC,EAAE,MAAM0B,CAAU,CAClE,CAFeV,EAAAW,EAAA,6BAGf,MAAMP,EAAeO,EAA2BxB,CAAG,CACrD,OAASW,EAAO,CACd,MAAAX,EAAI,MACF,CAAE,WAAYoB,EAAoB,KAAAD,EAAM,UAAAtB,EAAW,MAAAc,CAAM,EACzD,mBAAmBS,CAAkB,uBAAuBrB,CAAO,EACrE,EACMY,CACR,CAEA,GAAI,CAEF,eAAec,GAAwB,CACrC,OAAOC,GACLH,EACA,CACE,KAAM,SACN,OAAQ,GAAGtB,CAAM,GACjB,QAAS,qBAAqBF,CAAO,EACvC,EACAC,CACF,CACF,CAVea,EAAAY,EAAA,yBAWf,MAAMR,EAAeQ,EAAuBzB,CAAG,CACjD,OAASW,EAAO,CACdX,EAAI,KACF,CAAE,WAAYoB,EAAoB,KAAAD,EAAM,UAAAtB,EAAW,MAAAc,CAAM,EACzD,cAAcS,CAAkB,IAAID,CAAI,yDAC1C,CAEF,CAGAnB,EAAI,KAAK,0BAA0BoB,CAAkB,IAAIvB,CAAS,IAAIsB,CAAI,KAAKpB,CAAO,EAAE,CAC1F,CA5EsBc,EAAAH,GAAA,qBAiFtB,eAAsBE,GACpBf,EACAC,EACAG,EACAD,EACA,CACA,GAAIF,EAAK,SAAW,EAAG,OAEvBE,EAAI,KAAK,qBAAqBF,EAAK,MAAM,iCAAiCD,CAAS,EAAE,EAGrF,IAAM8B,EAAqC,CAAC,EAE5C,QAAWvB,KAAON,EAAM,CAEtB,IAAM8B,EACJxB,EAAI,UAAU,iBAAiB,KAAMG,GAA0BA,EAAI,UAAU,GAAG,KAChF,QACFoB,EAAOC,CAAY,EAAID,EAAOC,CAAY,GAAK,CAAC,EAChDD,EAAOC,CAAY,EAAE,KAAKxB,CAAG,CAC/B,CAGA,QAAWyB,KAAS,OAAO,OAAOF,CAAM,EACtC,QAAWvB,KAAOyB,EAAO,CACvB7B,EAAI,KAAK,gBAAgBH,CAAS,IAAIO,EAAI,UAAU,IAAI,WAAWH,CAAM,EAAE,EAE3E,GAAI,CAEF,eAAe6B,GAAW,CACxB,SAAO,OAAI,OAAK,GAAG,EAAE,YAAYjC,CAAS,EAAE,MAAMO,EAAI,SAAU,IAAK,CACvE,CAFeS,EAAAiB,EAAA,YAGf,MAAMb,EAAea,EAAU9B,CAAG,EAClCA,EAAI,KAAK,4BAA4BH,CAAS,IAAIO,EAAI,UAAU,IAAI,EAAE,CACxE,OAAS2B,EAAK,CAEZ/B,EAAI,KACF,uBAAuBH,CAAS,IAAIO,EAAI,UAAU,IAAI,6CAA6C2B,EAAI,OAAO,EAChH,EACA,GAAI,CACF,eAAeC,GAAY,CACzB,SAAO,OAAI,OAAK,GAAG,EAAE,OAAO5B,CAAG,CACjC,CAFeS,EAAAmB,EAAA,aAGf,MAAMf,EAAee,EAAWhC,CAAG,EACnCA,EAAI,KACF,mDAAmDH,CAAS,IAAIO,EAAI,UAAU,IAAI,EACpF,CACF,OAAS6B,EAAW,CAClBjC,EAAI,MACF,wBAAwBH,CAAS,IAAIO,EAAI,UAAU,IAAI,KAAK6B,EAAU,OAAO,EAC/E,CACF,CACF,CACF,CAEJ,CAvDsBpB,EAAAD,GAAA,uBD5PtB,IAAMsB,GAAMC,oBAAsC,EAOrCC,GAAsB,IAAI,IAC1BC,GAAyB,IAAI,IAQnC,SAASC,GAAwBC,EAAsC,CAE5E,IAAMC,EAAa,OAAO,KAAKD,CAAI,EAAE,KAAK,EACpCE,KAAO,eAAW,QAAQ,EAGhC,QAAWC,KAAOF,EAChBC,EAAK,OAAO,GAAGC,CAAG,IAAIH,EAAKG,CAAG,CAAC,EAAE,EAGnC,OAAOD,EAAK,OAAO,KAAK,CAC1B,CAXgBE,EAAAL,GAAA,2BAoBhB,eAAsBM,GAAwBC,EAAmBC,EAAoB,CAKnF,OAHa,QAAM,QAAI,QAAK,GAAG,EAAE,YAAYD,CAAS,EAAE,IAAI,GAGhD,MAAM,OAAOE,GAClBA,EAAI,KAGgBA,EAAI,KAAK,SAAS,KACzCC,GAAUA,EAAO,QAAUA,EAAO,OAAO,aAAeF,CAC1D,GAIkCC,EAAI,KAAK,SAAS,KAAKC,GACvDA,EAAO,WAAW,SAAS,KAAKC,GAAUA,EAAO,QAAQ,OAASH,CAAU,CAC9E,EACsC,GAGnB,CAAC,GAAIC,EAAI,KAAK,YAAc,CAAC,EAAI,GAAIA,EAAI,KAAK,gBAAkB,CAAC,CAAE,EACrD,KAC/BG,GACEA,EAAU,KAAK,KAAKC,GAAOA,EAAI,WAAW,cAAc,OAASL,CAAU,GAC3EI,EAAU,SAAS,KAAKE,GAAWA,EAAQ,WAAW,OAASN,CAAU,CAC7E,EApBsB,EAuBvB,CACH,CA9BsBH,EAAAC,GAAA,2BAqCf,SAASS,GAAoBC,EAA8C,CAChF,GAAI,CAEF,IAAMC,EAAiC,CAAC,EAGlCC,EAAQF,EAAM,MAAM,GAAG,EAE7B,QAAWG,KAAQD,EAAO,CACxB,GAAM,CAACd,EAAKgB,CAAG,EAAID,EAAK,KAAK,EAAE,MAAM,GAAG,EACxC,GAAIf,GAAOgB,EACTH,EAAOb,EAAI,KAAK,CAAC,EAAIgB,EAAI,KAAK,MAG9B,QAAO,IAEX,CAEA,OAAO,OAAO,KAAKH,CAAM,EAAE,OAAS,EAAIA,EAAS,IACnD,MAAQ,CACN,OAAO,IACT,CACF,CAtBgBZ,EAAAU,GAAA,uBA+BhB,eAAsBM,GAA2Bd,EAAmBe,EAAuB,CAKzF,OAHa,QAAM,QAAI,QAAK,GAAG,EAAE,YAAYf,CAAS,EAAE,IAAI,GAGhD,MAAM,OAAOE,GAClBA,EAAI,KAGmBA,EAAI,KAAK,SAAS,KAC5CC,GAAUA,EAAO,WAAaA,EAAO,UAAU,OAASY,CAC1D,GAIqCb,EAAI,KAAK,SAAS,KAAKC,GAC1DA,EAAO,WAAW,SAAS,KAAKC,GAAUA,EAAO,WAAW,OAASW,CAAa,CACpF,EACyC,GAGtB,CAAC,GAAIb,EAAI,KAAK,YAAc,CAAC,EAAI,GAAIA,EAAI,KAAK,gBAAkB,CAAC,CAAE,EAClD,KAClCG,GACEA,EAAU,KAAK,KAAKC,GAAOA,EAAI,WAAW,iBAAiB,OAASS,CAAa,GACjFV,EAAU,SAAS,KAAKE,GAAWA,EAAQ,cAAc,OAASQ,CAAa,CACnF,EApBsB,EAuBvB,CACH,CA9BsBjB,EAAAgB,GAAA,8BAwCtB,eAAsBE,GACpBC,EACAC,EACAC,EACAC,EACA,CACA,GAAI,CAACH,EAAS,UAAU,MAAQ,CAACA,EAAS,UAAU,UAClD,OAGF,GAAM,CAAE,KAAAI,EAAM,UAAArB,CAAU,EAAIiB,EAAS,SAC/BK,EAAW,GAAGtB,CAAS,IAAIqB,CAAI,GAG/B3B,EAAOuB,EAAS,MAAQ,CAAC,EAGzBM,EAAkB9B,GAAwBC,CAAI,EAG9C8B,EAAmBN,EAAc,IAAII,CAAQ,EAMnD,GAHAJ,EAAc,IAAII,EAAUC,CAAe,EAGvC,CAACC,GAAoBA,IAAqBD,EAC5C,OAGFlC,GAAI,KACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,KAAMoB,CAAa,EAChD,GAAGA,CAAY,sCACjB,EAGA,IAAIK,EAA2B,CAAC,EAG1BC,EAAcT,EAAS,UAAU,cAAc,6BAA6B,EAElF,GAAIS,EAAa,CACf,IAAMC,EAAWnB,GAAoBkB,CAAW,EAChD,GAAI,CAACC,EAAU,CACb,IAAMC,EAAW,yEAAyER,EAAa,YAAY,CAAC,IAAIpB,CAAS,IAAIqB,CAAI,KAAKK,CAAW,6CACzJrC,GAAI,MAAM,CAAE,SAAUgC,EAAM,UAAArB,EAAW,SAAU0B,EAAa,KAAMN,CAAa,EAAGQ,CAAQ,EAC5F,MACF,CAEAvC,GAAI,MACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,SAAA2B,EAAU,KAAMP,CAAa,EAC1D,oCAAoCA,EAAa,YAAY,CAAC,wBAChE,EAGA,IAAIS,KAAW,QAAI,QAAK,GAAG,EAAE,YAAY7B,CAAS,EAClD,OAAW,CAACH,EAAKY,CAAK,IAAK,OAAO,QAAQkB,CAAQ,EAChDE,EAAWA,EAAS,UAAUhC,EAAKY,CAAK,EAG1C,GAAI,CACF,eAAeqB,GAAsB,CACnC,OAAOD,EAAS,IAAI,CACtB,CAFe/B,EAAAgC,EAAA,uBAKfL,GADa,MAAMM,EAAeD,EAAqBzC,EAAG,GACtC,KACtB,OAAS2C,EAAO,CACd3C,GAAI,MACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,SAAA2B,EAAU,MAAAK,EAAO,KAAMZ,CAAa,EACjE,0CAA0CA,EAAa,YAAY,CAAC,aACtE,EACA,MACF,CACF,KAAO,CAEL/B,GAAI,MACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,KAAMoB,CAAa,EAChD,oBAAoBA,EAAa,YAAY,CAAC,YAChD,EACA,GAAI,CACF,eAAea,GAAuB,CACpC,OAAOd,EAA0BnB,EAAWqB,CAAI,CAClD,CAFevB,EAAAmC,EAAA,wBAGfR,EAAe,MAAMM,EAAeE,EAAsB5C,EAAG,CAC/D,OAAS2C,EAAO,CACd3C,GAAI,MACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,MAAAgC,EAAO,KAAMZ,CAAa,EACvD,sBAAsBA,EAAa,YAAY,CAAC,YAClD,EACA,MACF,CACF,CAGA,GAAIK,EAAa,SAAW,EAAG,CAC7BpC,GAAI,KACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,KAAMoB,CAAa,EAChD,+BAA+BA,EAAa,YAAY,CAAC,SAC3D,EACA,MACF,CAGA/B,GAAI,KACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,SAAUyB,EAAa,OAAQ,KAAML,CAAa,EAC/E,aAAaK,EAAa,MAAM,gBAAgBL,EAAa,YAAY,CAAC,SAC5E,EAEA,GAAI,CACF,MAAMc,GACJlC,EACAyB,EACA,GAAGL,CAAY,IAAIC,CAAI,UACvBhC,GACA,GAAG+B,CAAY,SACjB,CACF,OAASY,EAAO,CACd3C,GAAI,MACF,CAAE,SAAUgC,EAAM,UAAArB,EAAW,SAAUyB,EAAa,OAAQ,MAAAO,EAAO,KAAMZ,CAAa,EACtF,+BAA+BA,EAAa,YAAY,CAAC,SAC3D,EACA,MACF,CACF,CA5HsBtB,EAAAkB,GAAA,wBAoIf,SAASmB,GACdlB,EACAC,EACA,CACA,GAAI,CAACD,EAAS,UAAU,MAAQ,CAACA,EAAS,UAAU,UAClD,OAGF,GAAM,CAAE,KAAAI,EAAM,UAAArB,CAAU,EAAIiB,EAAS,SAC/BK,EAAW,GAAGtB,CAAS,IAAIqB,CAAI,GAGrCH,EAAc,OAAOI,CAAQ,CAC/B,CAbgBxB,EAAAqC,GAAA,wBAoBhB,eAAsBC,GAAmBC,EAAqB,CAC5D,MAAMrB,GAAqBqB,EAAQ9C,GAAqBQ,GAAyB,QAAQ,CAC3F,CAFsBD,EAAAsC,GAAA,sBASf,SAASE,GAAmBD,EAAqB,CACtDF,GAAqBE,EAAQ9C,EAAmB,CAClD,CAFgBO,EAAAwC,GAAA,sBAShB,eAAsBC,GAAsBC,EAA2B,CACrE,MAAMxB,GACJwB,EACAhD,GACAsB,GACA,WACF,CACF,CAPsBhB,EAAAyC,GAAA,yBAcf,SAASE,GAAsBD,EAA2B,CAC/DL,GAAqBK,EAAWhD,EAAsB,CACxD,CAFgBM,EAAA2C,GAAA,yBE3UT,SAASC,GAAoBC,EAAiBC,EAAkB,CACrE,GAAM,CAAE,SAAAC,EAAU,SAAAC,EAAU,YAAAC,CAAY,EAAIH,EAGtCI,EAAaD,GAAe,GAAG,OAAO,OAAOF,CAAQ,CAAC,IAAIC,CAAQ,GAGxE,OAFaG,EAAqB,GAAGN,CAAO,IAAIK,CAAU,EAAE,CAG9D,CARgBE,EAAAR,GAAA,uBCAT,IAAMS,GAAsC,CACjD,YAAa,CACX,YAAa,CAAC,CAChB,CACF,ECJO,SAASC,GAAWC,EAAmC,CAC5D,MAAO,CACL,QAAS,CACP,KAAAA,CACF,CACF,CACF,CANgBC,EAAAF,GAAA,cCET,IAAMG,GAAqC,CAChD,kBAAmB,CACjB,YAAa,CACX,8BAA+BC,CACjC,CACF,EACA,YAAa,CACX,YAAa,CACX,IAAK,eACP,CACF,CACF,EAGaC,GAAsC,CACjD,kBAAmB,CACjB,YAAa,CACX,8BAA+BC,EACjC,CACF,EACA,YAAa,CACX,YAAa,CACX,yCAA0C,iBAC5C,CACF,CACF,ECjBA,SAASC,GAAoBC,EAAmB,CAC9C,OAAOA,IAAc,IAAMA,IAAc,GAC3C,CAFSC,EAAAF,GAAA,uBAIT,SAASG,GAASC,EAAeC,EAAoD,CACnF,IAAIC,EAA+B,CAAC,EAEpC,GAAIF,EAAO,gBACT,OAAQA,EAAO,gBAAiB,CAC9B,cACEE,EAAQC,GAAQ,EAChB,MAEF,gBACED,EAAQE,GAAU,EAClB,MAEF,oBACEF,EAAQG,GACR,MAEF,qBACEH,EAAQ,CAACI,EAAc,EACvB,MAEF,eACEJ,EAAQ,CAACK,GAAUC,EAAiB,EACpC,KACJ,SACSR,EAAO,kBAAoB,QAAaA,EAAO,iBAAmB,OAAW,CACtF,IAAMS,EAA4B,CAAC,EAE/BT,EAAO,kBAAoB,SACzBJ,GAAoBI,EAAO,eAAe,EAC5CS,EAAK,kBAAoB,CAAC,EAE1BA,EAAK,kBAAoB,CACvB,YAAa,CAAE,8BAA+BT,EAAO,eAAgB,CACvE,GAIAA,EAAO,iBAAmB,SAC5BS,EAAK,YAAc,CACjB,YAAaT,EAAO,cACtB,GAGFE,EAAM,KAAKO,CAAI,CACjB,MAAWT,EAAO,aAAe,OAC/BE,EAAQ,CAACQ,GAAWV,EAAO,UAAU,CAAC,EAC7BA,EAAO,aACZC,IAAc,UAChBC,EAAQ,CAACS,EAAc,EAEvBT,EAAQ,CAACU,EAAa,GAI1B,OAAOV,CACT,CAxDSJ,EAAAC,GAAA,YA0DF,SAASc,EAAShB,EAAmBG,EAAeC,EAAsC,CAK/F,IAAMa,EAAgC,CACpC,WAAY,uBACZ,KAAM,gBACN,SAAU,CACR,KAPSC,GAAaf,CAAM,EAQ5B,UAAAH,EACA,OAAQ,CAAE,GAAGG,EAAO,MAAO,CAC7B,EACA,KAAM,CACJ,YAAa,CAACA,EAAO,SAAS,EAC9B,YAAa,CACX,YAAaA,EAAO,QACtB,CACF,CACF,EAGIA,EAAO,cACTc,EAAU,SAAU,YAAc,CAChC,kBAAmBd,EAAO,WAC5B,GAIEA,EAAO,kBACTc,EAAU,SAAU,OAAQ,eAAe,EAAId,EAAO,iBAIxD,IAAME,EAA+BH,GAASC,EAAQC,CAAS,EAGzDe,GAAgChB,EAAO,OAAS,CAAC,GAAG,IAAIiB,IAAS,CAAE,KAAAA,CAAK,EAAE,EAUhF,OAPIjB,EAAO,MACTgB,EAAM,KAAK,CACT,KAAMhB,EAAO,IACf,CAAC,EAIKA,EAAO,UAAW,CACxB,IAAK,UACHc,EAAU,KAAM,QAAU,CAAC,CAAE,KAAMZ,EAAO,MAAAc,CAAM,CAAC,EACjD,MAEF,IAAK,SACHF,EAAU,KAAM,OAAS,CAAC,CAAE,GAAIZ,EAAO,MAAAc,CAAM,CAAC,EAC9C,KACJ,CAEA,OAAOF,CACT,CA1DgBhB,EAAAe,EAAA,YAmET,SAASE,GAAaf,EAAe,CAC1C,IAAMkB,EAEJlB,EAAO,aAEP,CACE,OAAO,OAAOA,EAAO,UAAY,CAAC,UAAU,CAAC,EAC7CA,EAAO,iBAAmB,CACxBA,EAAO,gBACP,OAAO,OAAOA,EAAO,gBAAkB,CAAC,UAAU,CAAC,CACrD,CACF,EAEG,KAAK,CAAC,EACN,KAAK,GAAG,EAEb,MAAO,GAAGA,EAAO,SAAS,IAAIkB,CAAI,EACpC,CAjBgBpB,EAAAiB,GAAA,gBCrIT,SAASI,GAAQC,EAAiB,CACvC,IAAMC,EAAaD,EAAI,MAAM,SAAS,QAAU,CAAC,EAEjD,QAAWE,KAAUD,EAEfC,EAAO,QACTA,EAAO,aAAeA,EAAO,cAAgB,CAAC,EAC9CA,EAAO,aAAa,MAAQA,EAAO,MACnC,OAAOA,EAAO,OAIlB,IAAMC,EAAYH,EAAI,MAAM,SAAS,OAAS,CAAC,EAE/C,QAAWI,KAASD,EAEdC,EAAM,YACRA,EAAM,SAAWA,EAAM,UACvB,OAAOA,EAAM,WAIXA,EAAM,kBACRA,EAAM,eAAiBA,EAAM,gBAC7B,OAAOA,EAAM,iBAKjB,OAAAC,GAAcL,CAAG,EAEVA,CACT,CAhCgBM,EAAAP,GAAA,WAwCT,SAASQ,GAA+BP,EAAkD,CAC/F,IAAMQ,EAAMR,EAAI,QAAQ,mBACxB,GAAI,CAAC,MAAM,QAAQQ,CAAG,GAAKA,EAAI,SAAW,EAAG,OAE7C,IAAMC,EAASD,EAAkB,CAAC,EAElC,GAAI,OAAOC,GAAU,SACnB,OAAOD,EAIT,GAAI,OAAOC,GAAU,SAAU,CAC7B,IAAMC,EAAWV,EAAI,MAAM,KAA6B,CAAC,EACzD,OAAQQ,EAAiB,IAAIG,GAAM,CACjC,IAAMC,EAAQF,EAAQ,KAAKG,GAAKA,EAAE,WAAaF,CAAE,EACjD,MAAO,CACL,SAAUA,EACV,SAAUC,GAAO,2BAA6B,CAAC,CACjD,CACF,CAAC,CACH,CAGF,CAvBgBN,EAAAC,GAAA,kCA4BT,SAASO,GAAyBd,EAAiB,CACxD,IAAMe,EAAWR,GAA+BP,CAAG,EACnD,GAAI,CAACe,EAAU,OAEf,IAAMC,EAAsBhB,EAAI,QAAyB,CAAC,EAC1DA,EAAI,OAAS,CAAE,GAAGgB,EAAS,mBAAoBD,CAAS,CAC1D,CANgBT,EAAAQ,GAAA,4BAWT,SAAST,GAAcL,EAAiB,CAC7Cc,GAAyBd,CAAG,CAC9B,CAFgBM,EAAAD,GAAA,iBC7EhB,IAAMY,GAAoB,CAAC,cAAe,cAAe,YAAa,aAAa,EAEnF,eAAsBC,GAAUC,EAAsC,CACpE,IAAMC,EAAMC,GAAQF,EAAI,GAAG,EAErBG,EAAUF,EAAI,UAAU,MAAQ,YAChCG,EAAKH,EAAI,UAAU,WAAa,YAChCI,EAAoBJ,EAAI,UAAU,mBAAqB,KACvDK,EAAYL,EAAI,MAAM,SAAS,aAAa,MAAQ,UAE1D,GAAIH,GAAkB,SAASM,CAAE,EAC/B,OAAOJ,EAAI,KAAK,mBAAmB,EAIrC,GAAIO,GAAa,OAAOH,CAAE,GAAK,CAACC,EAAmB,CACjD,IAAMG,EAAkBD,GAAa,WAAWH,CAAE,EAElD,GAAII,IAAoBL,EACtB,OAAOH,EAAI,KACT,4BAA4BQ,CAAe,sCAAsCJ,CAAE,+CACrF,CAEJ,CAGA,IAAMK,EAAoBC,EAACC,GACxB,OAAO,OAAOC,EAAO,EAAe,SAASD,CAAC,EADvB,qBAGpBE,EAAaZ,EAAI,MAAM,SAAS,QAAU,CAAC,EAG3Ca,EAAsB,IAAI,IAEhC,QAAWC,KAAUF,EAAY,CAE/B,GAAIE,EAAO,SAAW,CAACN,EAAkBM,EAAO,OAAO,GAE/BC,EAAqBD,EAAO,OAAO,IACnCA,EAAO,QAC3B,OAAOf,EAAI,KACT,iBAAiBe,EAAO,OAAO,kHACjC,EAGJ,GAAIA,EAAO,SAAWN,EAAkBM,EAAO,OAAO,GAAKA,EAAO,OAChE,OAAOf,EAAI,KACT,gFACF,EAGF,IAAIe,EAAO,UAAY,eAAuBA,EAAO,SAAS,SAAS,aAAa,IAC9EA,EAAO,aACT,OAAOf,EAAI,KAAK,wDAAwD,EAK5E,GACEe,EAAO,cAAc,iBACpBA,EAAO,SAAWA,EAAO,UAAYA,EAAO,MAAQA,EAAO,YAE5D,OAAOf,EAAI,KAAK,4EAA4E,EAI9F,IAAMiB,EAAOC,GAAef,EAASY,CAAM,EAC3C,GAAID,EAAoB,IAAIG,CAAI,EAC9B,OAAOjB,EAAI,KACT,mOAEwCiB,CAAI,IAC9C,EAIFH,EAAoB,IAAIG,CAAI,CAC9B,CAEA,IAAME,EAAgBlB,EAAI,MAAM,SAAS,OAAS,CAAC,EAG7CmB,EAAqB,IAAI,IAE/B,QAAWC,KAAUF,EAAe,CAElC,GACEE,EAAO,kBACNA,EAAO,iBACNA,EAAO,gBACPA,EAAO,YACPA,EAAO,YACPA,EAAO,gBAET,OAAOrB,EAAI,KACT,oHACF,EAIF,IACGqB,EAAO,iBAAmBA,EAAO,kBACjCA,EAAO,iBAAmBA,EAAO,YAAcA,EAAO,YAAcA,EAAO,gBAE5E,OAAOrB,EAAI,KACT,uHACF,EAIF,GACEqB,EAAO,aACNA,EAAO,iBACNA,EAAO,iBACPA,EAAO,gBACPA,EAAO,YACPA,EAAO,gBAET,OAAOrB,EAAI,KACT,oHACF,EAIF,GACEqB,EAAO,aACNA,EAAO,iBACNA,EAAO,iBACPA,EAAO,gBACPA,EAAO,YAET,OAAOrB,EAAI,KACT,oGACF,EAIF,GACEqB,EAAO,iBACNA,EAAO,iBACNA,EAAO,iBACPA,EAAO,gBACPA,EAAO,YACP,CAACA,EAAO,YAEV,OAAOrB,EAAI,KACT,iIACF,EAIF,IAAKqB,EAAO,YAAcA,EAAO,iBAAmBA,EAAO,WAAa,UACtE,OAAOrB,EAAI,KAAK,8DAA8D,EAIhF,GAAIqB,EAAO,YAAcA,EAAO,WAAW,SAAS,GAAG,EACrD,OAAOrB,EAAI,KAAK,8CAA8C,EAIhE,GAAIqB,EAAO,gBAAkB,EAAEA,EAAO,YAAcf,IAAc,WAChE,OAAON,EAAI,KAAK,qEAAqE,EAIvF,IAAMiB,EAAOD,EAAqB,SAASf,EAAI,UAAU,IAAI,IAAIqB,GAAaD,CAAM,CAAC,EAAE,EACvF,GAAID,EAAmB,IAAIH,CAAI,EAC7B,OAAOjB,EAAI,KACT,6OAEwCiB,CAAI,IAC9C,EAGFG,EAAmB,IAAIH,CAAI,CAC7B,CAEA,IAAMM,EAAatB,EAAI,MAAM,KAAO,CAAC,EAG/BuB,EAAY,IAAI,IAEhBC,EAA0B,IAAI,IAAI,CACtC,0BACA,sCACA,2CACA,4BACA,4CACA,6BACA,8BACA,8BACA,wBACA,2BACA,wBACA,mCACA,uCACA,sCACA,0CACA,kCACA,qBACA,eACA,sBACA,0BACF,CAAC,EAED,QAAWC,KAAUH,EAAY,CAE/B,GAAIC,EAAU,IAAIE,EAAO,QAAQ,EAC/B,OAAO1B,EAAI,KAAK,kBAAkB0B,EAAO,QAAQ,qCAAqC,EAExFF,EAAU,IAAIE,EAAO,QAAQ,EAG7B,IAAMC,EAAyBpB,GAAa,4BAA4BmB,EAAO,QAAQ,EAGvF,GAAIC,EAAuB,KAAO,GAI5B,CAH4BA,EAAuB,IAAIvB,CAAE,EAI3D,OAAOJ,EAAI,KAAK,kBAAkB0B,EAAO,QAAQ,yCAAyC,EAI9F,GAAIA,EAAO,YAAcA,EAAO,aAAeV,EAAqBU,EAAO,UAAU,EACnF,OAAO1B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,iCAAiCA,EAAO,UAAU,EACrF,EAGF,GAAIA,EAAO,sBAAwB,IAAS,CAACA,EAAO,aAClD,OAAO1B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,4FACnC,EAGF,GAAIA,EAAO,wBAA0BA,EAAO,oBAC1C,OAAO1B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,iEACnC,EAGF,GACEA,EAAO,eACNA,EAAO,sBAAwB,IAC9BA,EAAO,wBACPA,EAAO,SAAW,QAClBA,EAAO,aAAe,QACtBA,EAAO,iBAAmB,QAC1BA,EAAO,4BAA8B,QACrCA,EAAO,WAAa,QACpBA,EAAO,aAAa,2CAA2C,IAAM,QAEvE,OAAO1B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,+CACnC,EAGF,GAAIA,EAAO,YACT,QAAWE,MAAQ,OAAO,KAAKF,EAAO,UAAU,EAC9C,GAAI,CAACD,EAAwB,IAAIG,EAAI,EACnC,OAAO5B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,wCAAwCE,EAAI,GAC/E,EAKN,GAAIF,EAAO,2BAA6BA,EAAO,SAAS,SAAS,GAAG,EAClE,OAAO1B,EAAI,KACT,kBAAkB0B,EAAO,QAAQ,wGACnC,CAEJ,CAEA,IAAMG,EAAW5B,EAAI,MAAM,SAAW,CAAC,EAGjC6B,EAAkB,IAAI,IACtBC,EAAkB,IAAI,IAE5B,QAAWC,KAAWH,EAAU,CAC9B,IAAMI,EAAcC,GAAoB/B,EAAS6B,CAAO,EACxD,GAAIA,EAAQ,OAAS,aAAiB,CACpC,GAAIF,EAAgB,IAAIG,CAAW,EACjC,OAAOjC,EAAI,KACT,mOAEwCiC,CAAW,IACrD,EAEFH,EAAgB,IAAIG,CAAW,CACjC,KAAO,CACL,GAAIF,EAAgB,IAAIE,CAAW,EACjC,OAAOjC,EAAI,KACT,uOAEwCiC,CAAW,IACrD,EAEFF,EAAgB,IAAIE,CAAW,CACjC,CACF,CAEA,OAAOjC,EAAI,QAAQ,CACrB,CAjTsBU,EAAAX,GAAA,aChBtB,SAASoC,GAAUC,EAAS,CAC1B,OAAQ,OAAOA,EAAY,KAAiBA,IAAY,IAC1D,CAFSC,EAAAF,GAAA,aAKT,SAASG,GAASF,EAAS,CACzB,OAAQ,OAAOA,GAAY,UAAcA,IAAY,IACvD,CAFSC,EAAAC,GAAA,YAKT,SAASC,GAAQC,EAAU,CACzB,OAAI,MAAM,QAAQA,CAAQ,EAAUA,EAC3BL,GAAUK,CAAQ,EAAU,CAAC,EAE/B,CAAEA,CAAS,CACpB,CALSH,EAAAE,GAAA,WAQT,SAASE,GAAOC,EAAQC,EAAQ,CAC9B,IAAIC,EAAOC,EAAQC,EAAKC,EAExB,GAAIJ,EAGF,IAFAI,EAAa,OAAO,KAAKJ,CAAM,EAE1BC,EAAQ,EAAGC,EAASE,EAAW,OAAQH,EAAQC,EAAQD,GAAS,EACnEE,EAAMC,EAAWH,CAAK,EACtBF,EAAOI,CAAG,EAAIH,EAAOG,CAAG,EAI5B,OAAOJ,CACT,CAbSL,EAAAI,GAAA,UAgBT,SAASO,GAAOC,EAAQC,EAAO,CAC7B,IAAIC,EAAS,GAAIC,EAEjB,IAAKA,EAAQ,EAAGA,EAAQF,EAAOE,GAAS,EACtCD,GAAUF,EAGZ,OAAOE,CACT,CARSd,EAAAW,GAAA,UAWT,SAASK,GAAeC,EAAQ,CAC9B,OAAQA,IAAW,GAAO,OAAO,oBAAsB,EAAIA,CAC7D,CAFSjB,EAAAgB,GAAA,kBAKT,IAAIE,GAAmBpB,GACnBqB,GAAmBlB,GACnBmB,GAAmBlB,GACnBmB,GAAmBV,GACnBW,GAAmBN,GACnBO,GAAmBnB,GAEnBoB,EAAS,CACZ,UAAWN,GACX,SAAUC,GACV,QAASC,GACT,OAAQC,GACR,eAAgBC,GAChB,OAAQC,EACT,EAKA,SAASE,GAAYC,EAAWC,EAAS,CACvC,IAAIC,EAAQ,GAAIC,EAAUH,EAAU,QAAU,mBAE9C,OAAKA,EAAU,MAEXA,EAAU,KAAK,OACjBE,GAAS,OAASF,EAAU,KAAK,KAAO,MAG1CE,GAAS,KAAOF,EAAU,KAAK,KAAO,GAAK,KAAOA,EAAU,KAAK,OAAS,GAAK,IAE3E,CAACC,GAAWD,EAAU,KAAK,UAC7BE,GAAS;AAAA;AAAA,EAASF,EAAU,KAAK,SAG5BG,EAAU,IAAMD,GAZKC,CAa9B,CAhBS7B,EAAAyB,GAAA,eAmBT,SAASK,GAAgBC,EAAQC,EAAM,CAErC,MAAM,KAAK,IAAI,EAEf,KAAK,KAAO,gBACZ,KAAK,OAASD,EACd,KAAK,KAAOC,EACZ,KAAK,QAAUP,GAAY,KAAM,EAAK,EAGlC,MAAM,kBAER,MAAM,kBAAkB,KAAM,KAAK,WAAW,EAG9C,KAAK,MAAS,IAAI,MAAM,EAAG,OAAS,EAExC,CAjBSzB,EAAA8B,GAAA,mBAqBTA,GAAgB,UAAY,OAAO,OAAO,MAAM,SAAS,EACzDA,GAAgB,UAAU,YAAcA,GAGxCA,GAAgB,UAAU,SAAW9B,EAAA,SAAkB2B,EAAS,CAC9D,OAAO,KAAK,KAAO,KAAOF,GAAY,KAAME,CAAO,CACrD,EAFqC,YAKrC,IAAID,EAAYI,GAGhB,SAASG,GAAQC,EAAQC,EAAWC,EAASC,EAAUC,EAAe,CACpE,IAAIC,EAAO,GACPC,EAAO,GACPC,EAAgB,KAAK,MAAMH,EAAgB,CAAC,EAAI,EAEpD,OAAID,EAAWF,EAAYM,IACzBF,EAAO,QACPJ,EAAYE,EAAWI,EAAgBF,EAAK,QAG1CH,EAAUC,EAAWI,IACvBD,EAAO,OACPJ,EAAUC,EAAWI,EAAgBD,EAAK,QAGrC,CACL,IAAKD,EAAOL,EAAO,MAAMC,EAAWC,CAAO,EAAE,QAAQ,MAAO,QAAG,EAAII,EACnE,IAAKH,EAAWF,EAAYI,EAAK,MACnC,CACF,CAnBSvC,EAAAiC,GAAA,WAsBT,SAASS,GAAS9B,EAAQ+B,EAAK,CAC7B,OAAOnB,EAAO,OAAO,IAAKmB,EAAM/B,EAAO,MAAM,EAAIA,CACnD,CAFSZ,EAAA0C,GAAA,YAKT,SAASE,GAAYZ,EAAMa,EAAS,CAGlC,GAFAA,EAAU,OAAO,OAAOA,GAAW,IAAI,EAEnC,CAACb,EAAK,OAAQ,OAAO,KAEpBa,EAAQ,YAAWA,EAAQ,UAAY,IACxC,OAAOA,EAAQ,QAAgB,WAAUA,EAAQ,OAAc,GAC/D,OAAOA,EAAQ,aAAgB,WAAUA,EAAQ,YAAc,GAC/D,OAAOA,EAAQ,YAAgB,WAAUA,EAAQ,WAAc,GAQnE,QANIC,EAAK,eACLC,EAAa,CAAE,CAAE,EACjBC,EAAW,CAAC,EACZC,EACAC,EAAc,GAEVD,EAAQH,EAAG,KAAKd,EAAK,MAAM,GACjCgB,EAAS,KAAKC,EAAM,KAAK,EACzBF,EAAW,KAAKE,EAAM,MAAQA,EAAM,CAAC,EAAE,MAAM,EAEzCjB,EAAK,UAAYiB,EAAM,OAASC,EAAc,IAChDA,EAAcH,EAAW,OAAS,GAIlCG,EAAc,IAAGA,EAAcH,EAAW,OAAS,GAEvD,IAAIjC,EAAS,GAAIqC,EAAGC,EAChBC,EAAe,KAAK,IAAIrB,EAAK,KAAOa,EAAQ,WAAYG,EAAS,MAAM,EAAE,SAAS,EAAE,OACpFV,EAAgBO,EAAQ,WAAaA,EAAQ,OAASQ,EAAe,GAEzE,IAAKF,EAAI,EAAGA,GAAKN,EAAQ,aACnB,EAAAK,EAAcC,EAAI,GADcA,IAEpCC,EAAOnB,GACLD,EAAK,OACLe,EAAWG,EAAcC,CAAC,EAC1BH,EAASE,EAAcC,CAAC,EACxBnB,EAAK,UAAYe,EAAWG,CAAW,EAAIH,EAAWG,EAAcC,CAAC,GACrEb,CACF,EACAxB,EAASU,EAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAOmB,EAAI,GAAG,SAAS,EAAGE,CAAY,EACjG,MAAQD,EAAK,IAAM;AAAA,EAAOtC,EAQ9B,IALAsC,EAAOnB,GAAQD,EAAK,OAAQe,EAAWG,CAAW,EAAGF,EAASE,CAAW,EAAGlB,EAAK,SAAUM,CAAa,EACxGxB,GAAUU,EAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAO,GAAG,SAAS,EAAGqB,CAAY,EAC9F,MAAQD,EAAK,IAAM;AAAA,EACrBtC,GAAUU,EAAO,OAAO,IAAKqB,EAAQ,OAASQ,EAAe,EAAID,EAAK,GAAG,EAAI;AAAA,EAExED,EAAI,EAAGA,GAAKN,EAAQ,YACnB,EAAAK,EAAcC,GAAKH,EAAS,QADGG,IAEnCC,EAAOnB,GACLD,EAAK,OACLe,EAAWG,EAAcC,CAAC,EAC1BH,EAASE,EAAcC,CAAC,EACxBnB,EAAK,UAAYe,EAAWG,CAAW,EAAIH,EAAWG,EAAcC,CAAC,GACrEb,CACF,EACAxB,GAAUU,EAAO,OAAO,IAAKqB,EAAQ,MAAM,EAAIH,IAAUV,EAAK,KAAOmB,EAAI,GAAG,SAAS,EAAGE,CAAY,EAClG,MAAQD,EAAK,IAAM;AAAA,EAGvB,OAAOtC,EAAO,QAAQ,MAAO,EAAE,CACjC,CA/DSd,EAAA4C,GAAA,eAkET,IAAIU,GAAUV,GAEVW,GAA2B,CAC7B,OACA,QACA,UACA,YACA,aACA,YACA,YACA,gBACA,eACA,cACF,EAEIC,GAAkB,CACpB,SACA,WACA,SACF,EAEA,SAASC,GAAoBC,EAAK,CAChC,IAAI5C,EAAS,CAAC,EAEd,OAAI4C,IAAQ,MACV,OAAO,KAAKA,CAAG,EAAE,QAAQ,SAAUC,EAAO,CACxCD,EAAIC,CAAK,EAAE,QAAQ,SAAUC,EAAO,CAClC9C,EAAO,OAAO8C,CAAK,CAAC,EAAID,CAC1B,CAAC,CACH,CAAC,EAGI7C,CACT,CAZSd,EAAAyD,GAAA,uBAcT,SAASI,GAAOC,EAAKjB,EAAS,CAuB5B,GAtBAA,EAAUA,GAAW,CAAC,EAEtB,OAAO,KAAKA,CAAO,EAAE,QAAQ,SAAUkB,EAAM,CAC3C,GAAIR,GAAyB,QAAQQ,CAAI,IAAM,GAC7C,MAAM,IAAIrC,EAAU,mBAAqBqC,EAAO,8BAAgCD,EAAM,cAAc,CAExG,CAAC,EAGD,KAAK,QAAgBjB,EACrB,KAAK,IAAgBiB,EACrB,KAAK,KAAgBjB,EAAQ,MAAoB,KACjD,KAAK,QAAgBA,EAAQ,SAAoB,UAAY,CAAE,MAAO,EAAM,EAC5E,KAAK,UAAgBA,EAAQ,WAAoB,SAAUmB,EAAM,CAAE,OAAOA,CAAM,EAChF,KAAK,WAAgBnB,EAAQ,YAAoB,KACjD,KAAK,UAAgBA,EAAQ,WAAoB,KACjD,KAAK,UAAgBA,EAAQ,WAAoB,KACjD,KAAK,cAAgBA,EAAQ,eAAoB,KACjD,KAAK,aAAgBA,EAAQ,cAAoB,KACjD,KAAK,MAAgBA,EAAQ,OAAoB,GACjD,KAAK,aAAgBY,GAAoBZ,EAAQ,cAAmB,IAAI,EAEpEW,GAAgB,QAAQ,KAAK,IAAI,IAAM,GACzC,MAAM,IAAI9B,EAAU,iBAAmB,KAAK,KAAO,uBAAyBoC,EAAM,cAAc,CAEpG,CA1BS9D,EAAA6D,GAAA,UA4BT,IAAII,EAAOJ,GAQX,SAASK,GAAYC,EAAQJ,EAAM,CACjC,IAAIjD,EAAS,CAAC,EAEd,OAAAqD,EAAOJ,CAAI,EAAE,QAAQ,SAAUK,EAAa,CAC1C,IAAIC,EAAWvD,EAAO,OAEtBA,EAAO,QAAQ,SAAUwD,EAAcC,EAAe,CAChDD,EAAa,MAAQF,EAAY,KACjCE,EAAa,OAASF,EAAY,MAClCE,EAAa,QAAUF,EAAY,QAErCC,EAAWE,EAEf,CAAC,EAEDzD,EAAOuD,CAAQ,EAAID,CACrB,CAAC,EAEMtD,CACT,CAnBSd,EAAAkE,GAAA,eAsBT,SAASM,IAA2B,CAClC,IAAI1D,EAAS,CACP,OAAQ,CAAC,EACT,SAAU,CAAC,EACX,QAAS,CAAC,EACV,SAAU,CAAC,EACX,MAAO,CACL,OAAQ,CAAC,EACT,SAAU,CAAC,EACX,QAAS,CAAC,EACV,SAAU,CAAC,CACb,CACF,EAAGP,EAAOC,EAEd,SAASiE,EAAYR,EAAM,CACrBA,EAAK,OACPnD,EAAO,MAAMmD,EAAK,IAAI,EAAE,KAAKA,CAAI,EACjCnD,EAAO,MAAM,SAAY,KAAKmD,CAAI,GAElCnD,EAAOmD,EAAK,IAAI,EAAEA,EAAK,GAAG,EAAInD,EAAO,SAAYmD,EAAK,GAAG,EAAIA,CAEjE,CAEA,IATSjE,EAAAyE,EAAA,eASJlE,EAAQ,EAAGC,EAAS,UAAU,OAAQD,EAAQC,EAAQD,GAAS,EAClE,UAAUA,CAAK,EAAE,QAAQkE,CAAW,EAEtC,OAAO3D,CACT,CA3BSd,EAAAwE,GAAA,cA8BT,SAASE,GAASC,EAAY,CAC5B,OAAO,KAAK,OAAOA,CAAU,CAC/B,CAFS3E,EAAA0E,GAAA,YAKTA,GAAS,UAAU,OAAS1E,EAAA,SAAgB2E,EAAY,CACtD,IAAIC,EAAW,CAAC,EACZC,EAAW,CAAC,EAEhB,GAAIF,aAAsBV,EAExBY,EAAS,KAAKF,CAAU,UAEf,MAAM,QAAQA,CAAU,EAEjCE,EAAWA,EAAS,OAAOF,CAAU,UAE5BA,IAAe,MAAM,QAAQA,EAAW,QAAQ,GAAK,MAAM,QAAQA,EAAW,QAAQ,GAE3FA,EAAW,WAAUC,EAAWA,EAAS,OAAOD,EAAW,QAAQ,GACnEA,EAAW,WAAUE,EAAWA,EAAS,OAAOF,EAAW,QAAQ,OAGvE,OAAM,IAAIjD,EAAU,kHAC6C,EAGnEkD,EAAS,QAAQ,SAAUE,EAAQ,CACjC,GAAI,EAAEA,aAAkBb,GACtB,MAAM,IAAIvC,EAAU,oFAAoF,EAG1G,GAAIoD,EAAO,UAAYA,EAAO,WAAa,SACzC,MAAM,IAAIpD,EAAU,iHAAiH,EAGvI,GAAIoD,EAAO,MACT,MAAM,IAAIpD,EAAU,oGAAoG,CAE5H,CAAC,EAEDmD,EAAS,QAAQ,SAAUC,EAAQ,CACjC,GAAI,EAAEA,aAAkBb,GACtB,MAAM,IAAIvC,EAAU,oFAAoF,CAE5G,CAAC,EAED,IAAIZ,EAAS,OAAO,OAAO4D,GAAS,SAAS,EAE7C,OAAA5D,EAAO,UAAY,KAAK,UAAY,CAAC,GAAG,OAAO8D,CAAQ,EACvD9D,EAAO,UAAY,KAAK,UAAY,CAAC,GAAG,OAAO+D,CAAQ,EAEvD/D,EAAO,iBAAmBoD,GAAYpD,EAAQ,UAAU,EACxDA,EAAO,iBAAmBoD,GAAYpD,EAAQ,UAAU,EACxDA,EAAO,gBAAmB0D,GAAW1D,EAAO,iBAAkBA,EAAO,gBAAgB,EAE9EA,CACT,EApD4B,UAuD5B,IAAIqD,GAASO,GAETK,GAAM,IAAId,EAAK,wBAAyB,CAC1C,KAAM,SACN,UAAWjE,EAAA,SAAUgE,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,EAAI,EAApD,YACb,CAAC,EAEGgB,GAAM,IAAIf,EAAK,wBAAyB,CAC1C,KAAM,WACN,UAAWjE,EAAA,SAAUgE,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,CAAC,CAAG,EAApD,YACb,CAAC,EAEGN,GAAM,IAAIO,EAAK,wBAAyB,CAC1C,KAAM,UACN,UAAWjE,EAAA,SAAUgE,EAAM,CAAE,OAAOA,IAAS,KAAOA,EAAO,CAAC,CAAG,EAApD,YACb,CAAC,EAEGiB,GAAW,IAAId,GAAO,CACxB,SAAU,CACRY,GACAC,GACAtB,EACF,CACF,CAAC,EAED,SAASwB,GAAgBlB,EAAM,CAC7B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OAEf,OAAQrB,IAAQ,GAAKqB,IAAS,KACtBrB,IAAQ,IAAMqB,IAAS,QAAUA,IAAS,QAAUA,IAAS,OACvE,CAPShE,EAAAkF,GAAA,mBAST,SAASC,IAAoB,CAC3B,OAAO,IACT,CAFSnF,EAAAmF,GAAA,qBAIT,SAASC,GAAOC,EAAQ,CACtB,OAAOA,IAAW,IACpB,CAFSrF,EAAAoF,GAAA,UAIT,IAAIE,GAAQ,IAAIrB,EAAK,yBAA0B,CAC7C,KAAM,SACN,QAASiB,GACT,UAAWC,GACX,UAAWC,GACX,UAAW,CACT,UAAWpF,EAAA,UAAY,CAAE,MAAO,GAAQ,EAA7B,aACX,UAAWA,EAAA,UAAY,CAAE,MAAO,MAAQ,EAA7B,aACX,UAAWA,EAAA,UAAY,CAAE,MAAO,MAAQ,EAA7B,aACX,UAAWA,EAAA,UAAY,CAAE,MAAO,MAAQ,EAA7B,aACX,MAAWA,EAAA,UAAY,CAAE,MAAO,EAAQ,EAA7B,QACb,EACA,aAAc,WAChB,CAAC,EAED,SAASuF,GAAmBvB,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OAEf,OAAQrB,IAAQ,IAAMqB,IAAS,QAAUA,IAAS,QAAUA,IAAS,SAC7DrB,IAAQ,IAAMqB,IAAS,SAAWA,IAAS,SAAWA,IAAS,QACzE,CAPShE,EAAAuF,GAAA,sBAST,SAASC,GAAqBxB,EAAM,CAClC,OAAOA,IAAS,QACTA,IAAS,QACTA,IAAS,MAClB,CAJShE,EAAAwF,GAAA,wBAMT,SAASC,GAAUJ,EAAQ,CACzB,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,kBACpD,CAFSrF,EAAAyF,GAAA,aAIT,IAAIC,GAAO,IAAIzB,EAAK,yBAA0B,CAC5C,KAAM,SACN,QAASsB,GACT,UAAWC,GACX,UAAWC,GACX,UAAW,CACT,UAAWzF,EAAA,SAAUqF,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,EAAtD,aACX,UAAWrF,EAAA,SAAUqF,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,EAAtD,aACX,UAAWrF,EAAA,SAAUqF,EAAQ,CAAE,OAAOA,EAAS,OAAS,OAAS,EAAtD,YACb,EACA,aAAc,WAChB,CAAC,EAED,SAASM,GAAUC,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,IAC3B,IAAeA,GAAOA,GAAK,IAC3B,IAAeA,GAAOA,GAAK,GACtC,CAJS5F,EAAA2F,GAAA,aAMT,SAASE,GAAUD,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,EACtC,CAFS5F,EAAA6F,GAAA,aAIT,SAASC,GAAUF,EAAG,CACpB,MAAS,KAAeA,GAAOA,GAAK,EACtC,CAFS5F,EAAA8F,GAAA,aAIT,SAASC,GAAmB/B,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIrB,EAAMqB,EAAK,OACXzD,EAAQ,EACRyF,EAAY,GACZC,EAEJ,GAAI,CAACtD,EAAK,MAAO,GASjB,GAPAsD,EAAKjC,EAAKzD,CAAK,GAGX0F,IAAO,KAAOA,IAAO,OACvBA,EAAKjC,EAAK,EAAEzD,CAAK,GAGf0F,IAAO,IAAK,CAEd,GAAI1F,EAAQ,IAAMoC,EAAK,MAAO,GAK9B,GAJAsD,EAAKjC,EAAK,EAAEzD,CAAK,EAIb0F,IAAO,IAAK,CAId,IAFA1F,IAEOA,EAAQoC,EAAKpC,IAElB,GADA0F,EAAKjC,EAAKzD,CAAK,EACX0F,IAAO,IACX,IAAIA,IAAO,KAAOA,IAAO,IAAK,MAAO,GACrCD,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CAGA,GAAIA,IAAO,IAAK,CAId,IAFA1F,IAEOA,EAAQoC,EAAKpC,IAElB,GADA0F,EAAKjC,EAAKzD,CAAK,EACX0F,IAAO,IACX,IAAI,CAACN,GAAU3B,EAAK,WAAWzD,CAAK,CAAC,EAAG,MAAO,GAC/CyF,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CAGA,GAAIA,IAAO,IAAK,CAId,IAFA1F,IAEOA,EAAQoC,EAAKpC,IAElB,GADA0F,EAAKjC,EAAKzD,CAAK,EACX0F,IAAO,IACX,IAAI,CAACJ,GAAU7B,EAAK,WAAWzD,CAAK,CAAC,EAAG,MAAO,GAC/CyF,EAAY,GAEd,OAAOA,GAAaC,IAAO,GAC7B,CACF,CAKA,GAAIA,IAAO,IAAK,MAAO,GAEvB,KAAO1F,EAAQoC,EAAKpC,IAElB,GADA0F,EAAKjC,EAAKzD,CAAK,EACX0F,IAAO,IACX,IAAI,CAACH,GAAU9B,EAAK,WAAWzD,CAAK,CAAC,EACnC,MAAO,GAETyF,EAAY,GAId,MAAI,GAACA,GAAaC,IAAO,IAG3B,CApFSjG,EAAA+F,GAAA,sBAsFT,SAASG,GAAqBlC,EAAM,CAClC,IAAImC,EAAQnC,EAAMoC,EAAO,EAAGH,EAc5B,GAZIE,EAAM,QAAQ,GAAG,IAAM,KACzBA,EAAQA,EAAM,QAAQ,KAAM,EAAE,GAGhCF,EAAKE,EAAM,CAAC,GAERF,IAAO,KAAOA,IAAO,OACnBA,IAAO,MAAKG,EAAO,IACvBD,EAAQA,EAAM,MAAM,CAAC,EACrBF,EAAKE,EAAM,CAAC,GAGVA,IAAU,IAAK,MAAO,GAE1B,GAAIF,IAAO,IAAK,CACd,GAAIE,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,CAAC,EAC9D,GAAIA,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,EAAE,EAC/D,GAAIA,EAAM,CAAC,IAAM,IAAK,OAAOC,EAAO,SAASD,EAAM,MAAM,CAAC,EAAG,CAAC,CAChE,CAEA,OAAOC,EAAO,SAASD,EAAO,EAAE,CAClC,CAxBSnG,EAAAkG,GAAA,wBA0BT,SAASG,GAAUhB,EAAQ,CACzB,OAAQ,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAO,mBAC5CA,EAAS,IAAM,GAAK,CAAC7D,EAAO,eAAe6D,CAAM,CAC3D,CAHSrF,EAAAqG,GAAA,aAKT,IAAIC,GAAM,IAAIrC,EAAK,wBAAyB,CAC1C,KAAM,SACN,QAAS8B,GACT,UAAWG,GACX,UAAWG,GACX,UAAW,CACT,OAAarG,EAAA,SAAUuG,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAOA,EAAI,SAAS,CAAC,EAAI,MAAQA,EAAI,SAAS,CAAC,EAAE,MAAM,CAAC,CAAG,EAA9F,UACb,MAAavG,EAAA,SAAUuG,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAQA,EAAI,SAAS,CAAC,EAAI,MAASA,EAAI,SAAS,CAAC,EAAE,MAAM,CAAC,CAAG,EAAhG,SACb,QAAavG,EAAA,SAAUuG,EAAK,CAAE,OAAOA,EAAI,SAAS,EAAE,CAAG,EAA1C,WAEb,YAAavG,EAAA,SAAUuG,EAAK,CAAE,OAAOA,GAAO,EAAI,KAAOA,EAAI,SAAS,EAAE,EAAE,YAAY,EAAK,MAAQA,EAAI,SAAS,EAAE,EAAE,YAAY,EAAE,MAAM,CAAC,CAAG,EAA7H,cACf,EACA,aAAc,UACd,aAAc,CACZ,OAAa,CAAE,EAAI,KAAM,EACzB,MAAa,CAAE,EAAI,KAAM,EACzB,QAAa,CAAE,GAAI,KAAM,EACzB,YAAa,CAAE,GAAI,KAAM,CAC3B,CACF,CAAC,EAEGC,GAAqB,IAAI,OAE3B,0IAOuB,EAEzB,SAASC,GAAiBzC,EAAM,CAG9B,MAFI,EAAAA,IAAS,MAET,CAACwC,GAAmB,KAAKxC,CAAI,GAG7BA,EAAKA,EAAK,OAAS,CAAC,IAAM,IAKhC,CAXShE,EAAAyG,GAAA,oBAaT,SAASC,GAAmB1C,EAAM,CAChC,IAAImC,EAAOC,EASX,OAPAD,EAASnC,EAAK,QAAQ,KAAM,EAAE,EAAE,YAAY,EAC5CoC,EAASD,EAAM,CAAC,IAAM,IAAM,GAAK,EAE7B,KAAK,QAAQA,EAAM,CAAC,CAAC,GAAK,IAC5BA,EAAQA,EAAM,MAAM,CAAC,GAGnBA,IAAU,OACJC,IAAS,EAAK,OAAO,kBAAoB,OAAO,kBAE/CD,IAAU,OACZ,IAEFC,EAAO,WAAWD,EAAO,EAAE,CACpC,CAjBSnG,EAAA0G,GAAA,sBAoBT,IAAIC,GAAyB,gBAE7B,SAASC,GAAmBvB,EAAQ1B,EAAO,CACzC,IAAIkD,EAEJ,GAAI,MAAMxB,CAAM,EACd,OAAQ1B,EAAO,CACb,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,MAC3B,SACS,OAAO,oBAAsB0B,EACtC,OAAQ1B,EAAO,CACb,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,OACzB,IAAK,YAAa,MAAO,MAC3B,SACS,OAAO,oBAAsB0B,EACtC,OAAQ1B,EAAO,CACb,IAAK,YAAa,MAAO,QACzB,IAAK,YAAa,MAAO,QACzB,IAAK,YAAa,MAAO,OAC3B,SACSnC,EAAO,eAAe6D,CAAM,EACrC,MAAO,OAGT,OAAAwB,EAAMxB,EAAO,SAAS,EAAE,EAKjBsB,GAAuB,KAAKE,CAAG,EAAIA,EAAI,QAAQ,IAAK,IAAI,EAAIA,CACrE,CA/BS7G,EAAA4G,GAAA,sBAiCT,SAASE,GAAQzB,EAAQ,CACvB,OAAQ,OAAO,UAAU,SAAS,KAAKA,CAAM,IAAM,oBAC3CA,EAAS,IAAM,GAAK7D,EAAO,eAAe6D,CAAM,EAC1D,CAHSrF,EAAA8G,GAAA,WAKT,IAAIC,GAAQ,IAAI9C,EAAK,0BAA2B,CAC9C,KAAM,SACN,QAASwC,GACT,UAAWC,GACX,UAAWI,GACX,UAAWF,GACX,aAAc,WAChB,CAAC,EAEGI,GAAO/B,GAAS,OAAO,CACzB,SAAU,CACRK,GACAI,GACAY,GACAS,EACF,CACF,CAAC,EAEGE,GAAOD,GAEPE,GAAmB,IAAI,OACzB,oDAEgB,EAEdC,GAAwB,IAAI,OAC9B,kLASwB,EAE1B,SAASC,GAAqBpD,EAAM,CAClC,OAAIA,IAAS,KAAa,GACtBkD,GAAiB,KAAKlD,CAAI,IAAM,MAChCmD,GAAsB,KAAKnD,CAAI,IAAM,IAE3C,CALShE,EAAAoH,GAAA,wBAOT,SAASC,GAAuBrD,EAAM,CACpC,IAAIf,EAAOqE,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,EAAW,EAC1DC,EAAQ,KAAMC,EAASC,EAAWC,EAKtC,GAHA/E,EAAQiE,GAAiB,KAAKlD,CAAI,EAC9Bf,IAAU,OAAMA,EAAQkE,GAAsB,KAAKnD,CAAI,GAEvDf,IAAU,KAAM,MAAM,IAAI,MAAM,oBAAoB,EAQxD,GAJAqE,EAAO,CAAErE,EAAM,CAAC,EAChBsE,EAAQ,CAAEtE,EAAM,CAAC,EAAK,EACtBuE,EAAM,CAAEvE,EAAM,CAAC,EAEX,CAACA,EAAM,CAAC,EACV,OAAO,IAAI,KAAK,KAAK,IAAIqE,EAAMC,EAAOC,CAAG,CAAC,EAS5C,GAJAC,EAAO,CAAExE,EAAM,CAAC,EAChByE,EAAS,CAAEzE,EAAM,CAAC,EAClB0E,EAAS,CAAE1E,EAAM,CAAC,EAEdA,EAAM,CAAC,EAAG,CAEZ,IADA2E,EAAW3E,EAAM,CAAC,EAAE,MAAM,EAAG,CAAC,EACvB2E,EAAS,OAAS,GACvBA,GAAY,IAEdA,EAAW,CAACA,CACd,CAIA,OAAI3E,EAAM,CAAC,IACT6E,EAAU,CAAE7E,EAAM,EAAE,EACpB8E,EAAY,EAAE9E,EAAM,EAAE,GAAK,GAC3B4E,GAASC,EAAU,GAAKC,GAAa,IACjC9E,EAAM,CAAC,IAAM,MAAK4E,EAAQ,CAACA,IAGjCG,EAAO,IAAI,KAAK,KAAK,IAAIV,EAAMC,EAAOC,EAAKC,EAAMC,EAAQC,EAAQC,CAAQ,CAAC,EAEtEC,GAAOG,EAAK,QAAQA,EAAK,QAAQ,EAAIH,CAAK,EAEvCG,CACT,CA/CShI,EAAAqH,GAAA,0BAiDT,SAASY,GAAuB5C,EAAoB,CAClD,OAAOA,EAAO,YAAY,CAC5B,CAFSrF,EAAAiI,GAAA,0BAIT,IAAIC,GAAY,IAAIjE,EAAK,8BAA+B,CACtD,KAAM,SACN,QAASmD,GACT,UAAWC,GACX,WAAY,KACZ,UAAWY,EACb,CAAC,EAED,SAASE,GAAiBnE,EAAM,CAC9B,OAAOA,IAAS,MAAQA,IAAS,IACnC,CAFShE,EAAAmI,GAAA,oBAIT,IAAIC,GAAQ,IAAInE,EAAK,0BAA2B,CAC9C,KAAM,SACN,QAASkE,EACX,CAAC,EASGE,GAAa;AAAA,IAGjB,SAASC,GAAkBtE,EAAM,CAC/B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIuE,EAAMC,EAAKC,EAAS,EAAG9F,EAAMqB,EAAK,OAAQN,EAAM2E,GAGpD,IAAKG,EAAM,EAAGA,EAAM7F,EAAK6F,IAIvB,GAHAD,EAAO7E,EAAI,QAAQM,EAAK,OAAOwE,CAAG,CAAC,EAG/B,EAAAD,EAAO,IAGX,IAAIA,EAAO,EAAG,MAAO,GAErBE,GAAU,EAIZ,OAAQA,EAAS,IAAO,CAC1B,CApBSzI,EAAAsI,GAAA,qBAsBT,SAASI,GAAoB1E,EAAM,CACjC,IAAIwE,EAAKG,EACLC,EAAQ5E,EAAK,QAAQ,WAAY,EAAE,EACnCrB,EAAMiG,EAAM,OACZlF,EAAM2E,GACNQ,EAAO,EACP/H,EAAS,CAAC,EAId,IAAK0H,EAAM,EAAGA,EAAM7F,EAAK6F,IAClBA,EAAM,IAAM,GAAMA,IACrB1H,EAAO,KAAM+H,GAAQ,GAAM,GAAI,EAC/B/H,EAAO,KAAM+H,GAAQ,EAAK,GAAI,EAC9B/H,EAAO,KAAK+H,EAAO,GAAI,GAGzBA,EAAQA,GAAQ,EAAKnF,EAAI,QAAQkF,EAAM,OAAOJ,CAAG,CAAC,EAKpD,OAAAG,EAAYhG,EAAM,EAAK,EAEnBgG,IAAa,GACf7H,EAAO,KAAM+H,GAAQ,GAAM,GAAI,EAC/B/H,EAAO,KAAM+H,GAAQ,EAAK,GAAI,EAC9B/H,EAAO,KAAK+H,EAAO,GAAI,GACdF,IAAa,IACtB7H,EAAO,KAAM+H,GAAQ,GAAM,GAAI,EAC/B/H,EAAO,KAAM+H,GAAQ,EAAK,GAAI,GACrBF,IAAa,IACtB7H,EAAO,KAAM+H,GAAQ,EAAK,GAAI,EAGzB,IAAI,WAAW/H,CAAM,CAC9B,CApCSd,EAAA0I,GAAA,uBAsCT,SAASI,GAAoBzD,EAAoB,CAC/C,IAAIvE,EAAS,GAAI+H,EAAO,EAAGL,EAAKhG,EAC5BG,EAAM0C,EAAO,OACb3B,EAAM2E,GAIV,IAAKG,EAAM,EAAGA,EAAM7F,EAAK6F,IAClBA,EAAM,IAAM,GAAMA,IACrB1H,GAAU4C,EAAKmF,GAAQ,GAAM,EAAI,EACjC/H,GAAU4C,EAAKmF,GAAQ,GAAM,EAAI,EACjC/H,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAImF,EAAO,EAAI,GAG3BA,GAAQA,GAAQ,GAAKxD,EAAOmD,CAAG,EAKjC,OAAAhG,EAAOG,EAAM,EAETH,IAAS,GACX1B,GAAU4C,EAAKmF,GAAQ,GAAM,EAAI,EACjC/H,GAAU4C,EAAKmF,GAAQ,GAAM,EAAI,EACjC/H,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAImF,EAAO,EAAI,GAChBrG,IAAS,GAClB1B,GAAU4C,EAAKmF,GAAQ,GAAM,EAAI,EACjC/H,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAI,EAAE,GACPlB,IAAS,IAClB1B,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAKmF,GAAQ,EAAK,EAAI,EAChC/H,GAAU4C,EAAI,EAAE,EAChB5C,GAAU4C,EAAI,EAAE,GAGX5C,CACT,CAxCSd,EAAA8I,GAAA,uBA0CT,SAASC,GAASxC,EAAK,CACrB,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAG,IAAO,qBAClD,CAFSvG,EAAA+I,GAAA,YAIT,IAAIC,GAAS,IAAI/E,EAAK,2BAA4B,CAChD,KAAM,SACN,QAASqE,GACT,UAAWI,GACX,UAAWK,GACX,UAAWD,EACb,CAAC,EAEGG,GAAoB,OAAO,UAAU,eACrCC,GAAoB,OAAO,UAAU,SAEzC,SAASC,GAAgBnF,EAAM,CAC7B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIoF,EAAa,CAAC,EAAG7I,EAAOC,EAAQ6I,EAAMC,EAASC,EAC/ClE,EAASrB,EAEb,IAAKzD,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAAG,CAIlE,GAHA8I,EAAOhE,EAAO9E,CAAK,EACnBgJ,EAAa,GAETL,GAAY,KAAKG,CAAI,IAAM,kBAAmB,MAAO,GAEzD,IAAKC,KAAWD,EACd,GAAIJ,GAAkB,KAAKI,EAAMC,CAAO,EACtC,GAAI,CAACC,EAAYA,EAAa,OACzB,OAAO,GAIhB,GAAI,CAACA,EAAY,MAAO,GAExB,GAAIH,EAAW,QAAQE,CAAO,IAAM,GAAIF,EAAW,KAAKE,CAAO,MAC1D,OAAO,EACd,CAEA,MAAO,EACT,CA1BStJ,EAAAmJ,GAAA,mBA4BT,SAASK,GAAkBxF,EAAM,CAC/B,OAAOA,IAAS,KAAOA,EAAO,CAAC,CACjC,CAFShE,EAAAwJ,GAAA,qBAIT,IAAIC,GAAO,IAAIxF,EAAK,yBAA0B,CAC5C,KAAM,WACN,QAASkF,GACT,UAAWK,EACb,CAAC,EAEGE,GAAc,OAAO,UAAU,SAEnC,SAASC,GAAiB3F,EAAM,CAC9B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIzD,EAAOC,EAAQ6I,EAAMO,EAAM9I,EAC3BuE,EAASrB,EAIb,IAFAlD,EAAS,IAAI,MAAMuE,EAAO,MAAM,EAE3B9E,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAAG,CAOlE,GANA8I,EAAOhE,EAAO9E,CAAK,EAEfmJ,GAAY,KAAKL,CAAI,IAAM,oBAE/BO,EAAO,OAAO,KAAKP,CAAI,EAEnBO,EAAK,SAAW,GAAG,MAAO,GAE9B9I,EAAOP,CAAK,EAAI,CAAEqJ,EAAK,CAAC,EAAGP,EAAKO,EAAK,CAAC,CAAC,CAAE,CAC3C,CAEA,MAAO,EACT,CArBS5J,EAAA2J,GAAA,oBAuBT,SAASE,GAAmB7F,EAAM,CAChC,GAAIA,IAAS,KAAM,MAAO,CAAC,EAE3B,IAAIzD,EAAOC,EAAQ6I,EAAMO,EAAM9I,EAC3BuE,EAASrB,EAIb,IAFAlD,EAAS,IAAI,MAAMuE,EAAO,MAAM,EAE3B9E,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAC/D8I,EAAOhE,EAAO9E,CAAK,EAEnBqJ,EAAO,OAAO,KAAKP,CAAI,EAEvBvI,EAAOP,CAAK,EAAI,CAAEqJ,EAAK,CAAC,EAAGP,EAAKO,EAAK,CAAC,CAAC,CAAE,EAG3C,OAAO9I,CACT,CAjBSd,EAAA6J,GAAA,sBAmBT,IAAIC,GAAQ,IAAI7F,EAAK,0BAA2B,CAC9C,KAAM,WACN,QAAS0F,GACT,UAAWE,EACb,CAAC,EAEGE,GAAoB,OAAO,UAAU,eAEzC,SAASC,GAAehG,EAAM,CAC5B,GAAIA,IAAS,KAAM,MAAO,GAE1B,IAAIvD,EAAK4E,EAASrB,EAElB,IAAKvD,KAAO4E,EACV,GAAI0E,GAAkB,KAAK1E,EAAQ5E,CAAG,GAChC4E,EAAO5E,CAAG,IAAM,KAAM,MAAO,GAIrC,MAAO,EACT,CAZST,EAAAgK,GAAA,kBAcT,SAASC,GAAiBjG,EAAM,CAC9B,OAAOA,IAAS,KAAOA,EAAO,CAAC,CACjC,CAFShE,EAAAiK,GAAA,oBAIT,IAAIC,GAAM,IAAIjG,EAAK,wBAAyB,CAC1C,KAAM,UACN,QAAS+F,GACT,UAAWC,EACb,CAAC,EAEGE,GAAWlD,GAAK,OAAO,CACzB,SAAU,CACRiB,GACAE,EACF,EACA,SAAU,CACRY,GACAS,GACAK,GACAI,EACF,CACF,CAAC,EAUGE,GAAoB,OAAO,UAAU,eAGrCC,GAAoB,EACpBC,GAAoB,EACpBC,GAAoB,EACpBC,GAAoB,EAGpBC,GAAiB,EACjBC,GAAiB,EACjBC,GAAiB,EAGjBC,GAAgC,sIAChCC,GAAgC,qBAChCC,GAAgC,cAChCC,GAAgC,yBAChCC,GAAgC,mFAGpC,SAASC,GAAO1E,EAAK,CAAE,OAAO,OAAO,UAAU,SAAS,KAAKA,CAAG,CAAG,CAA1DvG,EAAAiL,GAAA,UAET,SAASC,GAAOtF,EAAG,CACjB,OAAQA,IAAM,IAAkBA,IAAM,EACxC,CAFS5F,EAAAkL,GAAA,UAIT,SAASC,GAAevF,EAAG,CACzB,OAAQA,IAAM,GAAmBA,IAAM,EACzC,CAFS5F,EAAAmL,GAAA,kBAIT,SAASC,GAAaxF,EAAG,CACvB,OAAQA,IAAM,GACNA,IAAM,IACNA,IAAM,IACNA,IAAM,EAChB,CALS5F,EAAAoL,GAAA,gBAOT,SAASC,GAAkBzF,EAAG,CAC5B,OAAOA,IAAM,IACNA,IAAM,IACNA,IAAM,IACNA,IAAM,KACNA,IAAM,GACf,CANS5F,EAAAqL,GAAA,qBAQT,SAASC,GAAY1F,EAAG,CACtB,IAAI2F,EAEJ,MAAK,KAAe3F,GAAOA,GAAK,GACvBA,EAAI,IAIb2F,EAAK3F,EAAI,GAEJ,IAAe2F,GAAQA,GAAM,IACzBA,EAAK,GAAO,GAGd,GACT,CAfSvL,EAAAsL,GAAA,eAiBT,SAASE,GAAc5F,EAAG,CACxB,OAAIA,IAAM,IAAsB,EAC5BA,IAAM,IAAsB,EAC5BA,IAAM,GAAsB,EACzB,CACT,CALS5F,EAAAwL,GAAA,iBAOT,SAASC,GAAgB7F,EAAG,CAC1B,MAAK,KAAeA,GAAOA,GAAK,GACvBA,EAAI,GAGN,EACT,CANS5F,EAAAyL,GAAA,mBAQT,SAASC,GAAqB9F,EAAG,CAE/B,OAAQA,IAAM,GAAe,KACtBA,IAAM,GAAe,OACrBA,IAAM,GAAe,KACrBA,IAAM,KACNA,IAAM,EADe,IAErBA,IAAM,IAAe;AAAA,EACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,KACrBA,IAAM,IAAe,OACrBA,IAAM,GAAmB,IACzBA,IAAM,GAAe,IACrBA,IAAM,GAAe,IACrBA,IAAM,GAAe,KACrBA,IAAM,GAAe,OACrBA,IAAM,GAAe,OACrBA,IAAM,GAAe,SACrBA,IAAM,GAAe,SAAW,EACzC,CApBS5F,EAAA0L,GAAA,wBAsBT,SAASC,GAAkB/F,EAAG,CAC5B,OAAIA,GAAK,MACA,OAAO,aAAaA,CAAC,EAIvB,OAAO,cACVA,EAAI,OAAa,IAAM,OACvBA,EAAI,MAAY,MAAU,KAC9B,CACF,CAVS5F,EAAA2L,GAAA,qBAcT,SAASC,GAAYvG,EAAQ5E,EAAK0F,EAAO,CAEnC1F,IAAQ,YACV,OAAO,eAAe4E,EAAQ5E,EAAK,CACjC,aAAc,GACd,WAAY,GACZ,SAAU,GACV,MAAO0F,CACT,CAAC,EAEDd,EAAO5E,CAAG,EAAI0F,CAElB,CAZSnG,EAAA4L,GAAA,eAcT,IAAIC,GAAoB,IAAI,MAAM,GAAG,EACjCC,GAAkB,IAAI,MAAM,GAAG,EACnC,IAAS3I,GAAI,EAAGA,GAAI,IAAKA,KACvB0I,GAAkB1I,EAAC,EAAIuI,GAAqBvI,EAAC,EAAI,EAAI,EACrD2I,GAAgB3I,EAAC,EAAIuI,GAAqBvI,EAAC,EAFpC,IAAAA,GAMT,SAAS4I,GAAQnD,EAAO/F,EAAS,CAC/B,KAAK,MAAQ+F,EAEb,KAAK,SAAY/F,EAAQ,UAAgB,KACzC,KAAK,OAAYA,EAAQ,QAAgBsH,GACzC,KAAK,UAAYtH,EAAQ,WAAgB,KAGzC,KAAK,OAAYA,EAAQ,QAAgB,GAEzC,KAAK,KAAYA,EAAQ,MAAgB,GACzC,KAAK,SAAYA,EAAQ,UAAgB,KAEzC,KAAK,cAAgB,KAAK,OAAO,iBACjC,KAAK,QAAgB,KAAK,OAAO,gBAEjC,KAAK,OAAa+F,EAAM,OACxB,KAAK,SAAa,EAClB,KAAK,KAAa,EAClB,KAAK,UAAa,EAClB,KAAK,WAAa,EAIlB,KAAK,eAAiB,GAEtB,KAAK,UAAY,CAAC,CAYpB,CAtCS5I,EAAA+L,GAAA,WAyCT,SAASC,GAAcC,EAAOpK,EAAS,CACrC,IAAIG,EAAO,CACT,KAAUiK,EAAM,SAChB,OAAUA,EAAM,MAAM,MAAM,EAAG,EAAE,EACjC,SAAUA,EAAM,SAChB,KAAUA,EAAM,KAChB,OAAUA,EAAM,SAAWA,EAAM,SACnC,EAEA,OAAAjK,EAAK,QAAUsB,GAAQtB,CAAI,EAEpB,IAAIN,EAAUG,EAASG,CAAI,CACpC,CAZShC,EAAAgM,GAAA,iBAcT,SAASE,EAAWD,EAAOpK,EAAS,CAClC,MAAMmK,GAAcC,EAAOpK,CAAO,CACpC,CAFS7B,EAAAkM,EAAA,cAIT,SAASC,GAAaF,EAAOpK,EAAS,CAChCoK,EAAM,WACRA,EAAM,UAAU,KAAK,KAAMD,GAAcC,EAAOpK,CAAO,CAAC,CAE5D,CAJS7B,EAAAmM,GAAA,gBAOT,IAAIC,GAAoB,CAEtB,KAAMpM,EAAA,SAA6BiM,EAAOlI,EAAMsI,EAAM,CAEpD,IAAIpJ,EAAOqJ,EAAOC,EAEdN,EAAM,UAAY,MACpBC,EAAWD,EAAO,gCAAgC,EAGhDI,EAAK,SAAW,GAClBH,EAAWD,EAAO,6CAA6C,EAGjEhJ,EAAQ,uBAAuB,KAAKoJ,EAAK,CAAC,CAAC,EAEvCpJ,IAAU,MACZiJ,EAAWD,EAAO,2CAA2C,EAG/DK,EAAQ,SAASrJ,EAAM,CAAC,EAAG,EAAE,EAC7BsJ,EAAQ,SAAStJ,EAAM,CAAC,EAAG,EAAE,EAEzBqJ,IAAU,GACZJ,EAAWD,EAAO,2CAA2C,EAG/DA,EAAM,QAAUI,EAAK,CAAC,EACtBJ,EAAM,gBAAmBM,EAAQ,EAE7BA,IAAU,GAAKA,IAAU,GAC3BJ,GAAaF,EAAO,0CAA0C,CAElE,EA/BM,uBAiCN,IAAKjM,EAAA,SAA4BiM,EAAOlI,EAAMsI,EAAM,CAElD,IAAIG,EAAQC,EAERJ,EAAK,SAAW,GAClBH,EAAWD,EAAO,6CAA6C,EAGjEO,EAASH,EAAK,CAAC,EACfI,EAASJ,EAAK,CAAC,EAEVtB,GAAmB,KAAKyB,CAAM,GACjCN,EAAWD,EAAO,6DAA6D,EAG7E7B,GAAkB,KAAK6B,EAAM,OAAQO,CAAM,GAC7CN,EAAWD,EAAO,8CAAgDO,EAAS,cAAc,EAGtFxB,GAAgB,KAAKyB,CAAM,GAC9BP,EAAWD,EAAO,8DAA8D,EAGlF,GAAI,CACFQ,EAAS,mBAAmBA,CAAM,CACpC,MAAc,CACZP,EAAWD,EAAO,4BAA8BQ,CAAM,CACxD,CAEAR,EAAM,OAAOO,CAAM,EAAIC,CACzB,EA9BK,qBA+BP,EAGA,SAASC,GAAeT,EAAOU,EAAOC,EAAKC,EAAW,CACpD,IAAIC,EAAWC,EAASC,EAAYC,EAEpC,GAAIN,EAAQC,EAAK,CAGf,GAFAK,EAAUhB,EAAM,MAAM,MAAMU,EAAOC,CAAG,EAElCC,EACF,IAAKC,EAAY,EAAGC,EAAUE,EAAQ,OAAQH,EAAYC,EAASD,GAAa,EAC9EE,EAAaC,EAAQ,WAAWH,CAAS,EACnCE,IAAe,GACd,IAAQA,GAAcA,GAAc,SACzCd,EAAWD,EAAO,+BAA+B,OAG5CrB,GAAsB,KAAKqC,CAAO,GAC3Cf,EAAWD,EAAO,8CAA8C,EAGlEA,EAAM,QAAUgB,CAClB,CACF,CApBSjN,EAAA0M,GAAA,kBAsBT,SAASQ,GAAcjB,EAAOkB,EAAa7M,EAAQ8M,EAAiB,CAClE,IAAI1M,EAAYD,EAAKF,EAAO8M,EAQ5B,IANK7L,EAAO,SAASlB,CAAM,GACzB4L,EAAWD,EAAO,mEAAmE,EAGvFvL,EAAa,OAAO,KAAKJ,CAAM,EAE1BC,EAAQ,EAAG8M,EAAW3M,EAAW,OAAQH,EAAQ8M,EAAU9M,GAAS,EACvEE,EAAMC,EAAWH,CAAK,EAEjB6J,GAAkB,KAAK+C,EAAa1M,CAAG,IAC1CmL,GAAYuB,EAAa1M,EAAKH,EAAOG,CAAG,CAAC,EACzC2M,EAAgB3M,CAAG,EAAI,GAG7B,CAjBST,EAAAkN,GAAA,iBAmBT,SAASI,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAC1EC,EAAWC,EAAgBC,EAAU,CAErC,IAAIrN,EAAO8M,EAKX,GAAI,MAAM,QAAQG,CAAO,EAGvB,IAFAA,EAAU,MAAM,UAAU,MAAM,KAAKA,CAAO,EAEvCjN,EAAQ,EAAG8M,EAAWG,EAAQ,OAAQjN,EAAQ8M,EAAU9M,GAAS,EAChE,MAAM,QAAQiN,EAAQjN,CAAK,CAAC,GAC9B2L,EAAWD,EAAO,6CAA6C,EAG7D,OAAOuB,GAAY,UAAYvC,GAAOuC,EAAQjN,CAAK,CAAC,IAAM,oBAC5DiN,EAAQjN,CAAK,EAAI,mBAmBvB,GAXI,OAAOiN,GAAY,UAAYvC,GAAOuC,CAAO,IAAM,oBACrDA,EAAU,mBAIZA,EAAU,OAAOA,CAAO,EAEpBP,IAAY,OACdA,EAAU,CAAC,GAGTM,IAAW,0BACb,GAAI,MAAM,QAAQE,CAAS,EACzB,IAAKlN,EAAQ,EAAG8M,EAAWI,EAAU,OAAQlN,EAAQ8M,EAAU9M,GAAS,EACtE2M,GAAcjB,EAAOgB,EAASQ,EAAUlN,CAAK,EAAG6M,CAAe,OAGjEF,GAAcjB,EAAOgB,EAASQ,EAAWL,CAAe,MAGtD,CAACnB,EAAM,MACP,CAAC7B,GAAkB,KAAKgD,EAAiBI,CAAO,GAChDpD,GAAkB,KAAK6C,EAASO,CAAO,IACzCvB,EAAM,KAAOyB,GAAazB,EAAM,KAChCA,EAAM,UAAY0B,GAAkB1B,EAAM,UAC1CA,EAAM,SAAW2B,GAAY3B,EAAM,SACnCC,EAAWD,EAAO,wBAAwB,GAG5CL,GAAYqB,EAASO,EAASC,CAAS,EACvC,OAAOL,EAAgBI,CAAO,EAGhC,OAAOP,CACT,CA3DSjN,EAAAsN,GAAA,oBA6DT,SAASO,GAAc5B,EAAO,CAC5B,IAAIhG,EAEJA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACTgG,EAAM,WACGhG,IAAO,IAChBgG,EAAM,WACFA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,IAC7CA,EAAM,YAGRC,EAAWD,EAAO,0BAA0B,EAG9CA,EAAM,MAAQ,EACdA,EAAM,UAAYA,EAAM,SACxBA,EAAM,eAAiB,EACzB,CAnBSjM,EAAA6N,GAAA,iBAqBT,SAASC,EAAoB7B,EAAO8B,EAAeC,EAAa,CAI9D,QAHIC,EAAa,EACbhI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEvChG,IAAO,GAAG,CACf,KAAOkF,GAAelF,CAAE,GAClBA,IAAO,GAAiBgG,EAAM,iBAAmB,KACnDA,EAAM,eAAiBA,EAAM,UAE/BhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAI8B,GAAiB9H,IAAO,GAC1B,GACEA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QACrChG,IAAO,IAAgBA,IAAO,IAAgBA,IAAO,GAGhE,GAAIiF,GAAOjF,CAAE,EAOX,IANA4H,GAAc5B,CAAK,EAEnBhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1CgC,IACAhC,EAAM,WAAa,EAEZhG,IAAO,IACZgG,EAAM,aACNhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,MAG9C,MAEJ,CAEA,OAAI+B,IAAgB,IAAMC,IAAe,GAAKhC,EAAM,WAAa+B,GAC/D7B,GAAaF,EAAO,uBAAuB,EAGtCgC,CACT,CAvCSjO,EAAA8N,EAAA,uBAyCT,SAASI,GAAsBjC,EAAO,CACpC,IAAIa,EAAYb,EAAM,SAClBhG,EAMJ,OAJAA,EAAKgG,EAAM,MAAM,WAAWa,CAAS,EAIhC,IAAA7G,IAAO,IAAeA,IAAO,KAC9BA,IAAOgG,EAAM,MAAM,WAAWa,EAAY,CAAC,GAC3C7G,IAAOgG,EAAM,MAAM,WAAWa,EAAY,CAAC,IAE7CA,GAAa,EAEb7G,EAAKgG,EAAM,MAAM,WAAWa,CAAS,EAEjC7G,IAAO,GAAKmF,GAAanF,CAAE,GAMnC,CAtBSjG,EAAAkO,GAAA,yBAwBT,SAASC,GAAiBlC,EAAOpL,EAAO,CAClCA,IAAU,EACZoL,EAAM,QAAU,IACPpL,EAAQ,IACjBoL,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAMX,EAAQ,CAAC,EAEjD,CANSb,EAAAmO,GAAA,oBAST,SAASC,GAAgBnC,EAAOoC,EAAYC,EAAsB,CAChE,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAQ9C,EAAM,KACdgB,EAAUhB,EAAM,OAChBhG,EAoBJ,GAlBAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtCb,GAAanF,CAAE,GACfoF,GAAkBpF,CAAE,GACpBA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,KACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,IACPA,IAAO,KAIPA,IAAO,IAAeA,IAAO,MAC/BuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,GACtBF,GAAwBjD,GAAkBmD,CAAS,GACrD,MAAO,GASX,IALAvC,EAAM,KAAO,SACbA,EAAM,OAAS,GACfwC,EAAeC,EAAazC,EAAM,SAClC0C,EAAoB,GAEb1I,IAAO,GAAG,CACf,GAAIA,IAAO,IAGT,GAFAuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,GACtBF,GAAwBjD,GAAkBmD,CAAS,EACrD,cAGOvI,IAAO,IAGhB,GAFAsI,EAAYtC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAamD,CAAS,EACxB,UAGG,IAAKtC,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,GAClEqC,GAAwBjD,GAAkBpF,CAAE,EACrD,MAEK,GAAIiF,GAAOjF,CAAE,EAMlB,GALA2I,EAAQ3C,EAAM,KACd4C,EAAa5C,EAAM,UACnB6C,EAAc7C,EAAM,WACpB6B,EAAoB7B,EAAO,GAAO,EAAE,EAEhCA,EAAM,YAAcoC,EAAY,CAClCM,EAAoB,GACpB1I,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1C,QACF,KAAO,CACLA,EAAM,SAAWyC,EACjBzC,EAAM,KAAO2C,EACb3C,EAAM,UAAY4C,EAClB5C,EAAM,WAAa6C,EACnB,KACF,EAGEH,IACFjC,GAAeT,EAAOwC,EAAcC,EAAY,EAAK,EACrDP,GAAiBlC,EAAOA,EAAM,KAAO2C,CAAK,EAC1CH,EAAeC,EAAazC,EAAM,SAClC0C,EAAoB,IAGjBxD,GAAelF,CAAE,IACpByI,EAAazC,EAAM,SAAW,GAGhChG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,CAC9C,CAIA,OAFAS,GAAeT,EAAOwC,EAAcC,EAAY,EAAK,EAEjDzC,EAAM,OACD,IAGTA,EAAM,KAAO8C,EACb9C,EAAM,OAASgB,EACR,GACT,CA3GSjN,EAAAoO,GAAA,mBA6GT,SAASY,GAAuB/C,EAAOoC,EAAY,CACjD,IAAIpI,EACAwI,EAAcC,EAIlB,GAFAzI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACT,MAAO,GAQT,IALAgG,EAAM,KAAO,SACbA,EAAM,OAAS,GACfA,EAAM,WACNwC,EAAeC,EAAazC,EAAM,UAE1BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,GACvD,GAAIhG,IAAO,GAIT,GAHAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,GACTwI,EAAexC,EAAM,SACrBA,EAAM,WACNyC,EAAazC,EAAM,aAEnB,OAAO,QAGAf,GAAOjF,CAAE,GAClByG,GAAeT,EAAOwC,EAAcC,EAAY,EAAI,EACpDP,GAAiBlC,EAAO6B,EAAoB7B,EAAO,GAAOoC,CAAU,CAAC,EACrEI,EAAeC,EAAazC,EAAM,UAEzBA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAC1EC,EAAWD,EAAO,8DAA8D,GAGhFA,EAAM,WACNyC,EAAazC,EAAM,UAIvBC,EAAWD,EAAO,4DAA4D,CAChF,CA3CSjM,EAAAgP,GAAA,0BA6CT,SAASC,GAAuBhD,EAAOoC,EAAY,CACjD,IAAII,EACAC,EACAQ,EACAC,EACAC,EACAnJ,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACT,MAAO,GAQT,IALAgG,EAAM,KAAO,SACbA,EAAM,OAAS,GACfA,EAAM,WACNwC,EAAeC,EAAazC,EAAM,UAE1BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,GAAG,CAC1D,GAAIhG,IAAO,GACT,OAAAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDA,EAAM,WACC,GAEF,GAAIhG,IAAO,GAAa,CAI7B,GAHAyG,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAI,EACxDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExCf,GAAOjF,CAAE,EACX6H,EAAoB7B,EAAO,GAAOoC,CAAU,UAGnCpI,EAAK,KAAO4F,GAAkB5F,CAAE,EACzCgG,EAAM,QAAUH,GAAgB7F,CAAE,EAClCgG,EAAM,oBAEImD,EAAM5D,GAAcvF,CAAE,GAAK,EAAG,CAIxC,IAHAiJ,EAAYE,EACZD,EAAY,EAELD,EAAY,EAAGA,IACpBjJ,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAEvCmD,EAAM9D,GAAYrF,CAAE,IAAM,EAC7BkJ,GAAaA,GAAa,GAAKC,EAG/BlD,EAAWD,EAAO,gCAAgC,EAItDA,EAAM,QAAUN,GAAkBwD,CAAS,EAE3ClD,EAAM,UAER,MACEC,EAAWD,EAAO,yBAAyB,EAG7CwC,EAAeC,EAAazC,EAAM,QAEpC,MAAWf,GAAOjF,CAAE,GAClByG,GAAeT,EAAOwC,EAAcC,EAAY,EAAI,EACpDP,GAAiBlC,EAAO6B,EAAoB7B,EAAO,GAAOoC,CAAU,CAAC,EACrEI,EAAeC,EAAazC,EAAM,UAEzBA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAC1EC,EAAWD,EAAO,8DAA8D,GAGhFA,EAAM,WACNyC,EAAazC,EAAM,SAEvB,CAEAC,EAAWD,EAAO,4DAA4D,CAChF,CA7ESjM,EAAAiP,GAAA,0BA+ET,SAASI,GAAmBpD,EAAOoC,EAAY,CAC7C,IAAIiB,EAAW,GACXV,EACAC,EACAU,EACAC,EAAWvD,EAAM,IACjBgB,EACAwC,EAAWxD,EAAM,OACjBuC,EACAkB,EACAC,EACAC,EACAC,EACAzC,EAAkB,OAAO,OAAO,IAAI,EACpCI,EACAD,EACAE,EACAxH,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GACTyJ,EAAa,GACbG,EAAY,GACZ5C,EAAU,CAAC,UACFhH,IAAO,IAChByJ,EAAa,IACbG,EAAY,GACZ5C,EAAU,CAAC,MAEX,OAAO,GAST,IANIhB,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAErChG,IAAO,GAAG,CAKf,GAJA6H,EAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAOyJ,EACT,OAAAzD,EAAM,WACNA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO4D,EAAY,UAAY,WACrC5D,EAAM,OAASgB,EACR,GACGqC,EAEDrJ,IAAO,IAEhBiG,EAAWD,EAAO,0CAA0C,EAH5DC,EAAWD,EAAO,8CAA8C,EAMlEsB,EAASC,EAAUC,EAAY,KAC/BkC,EAASC,EAAiB,GAEtB3J,IAAO,KACTuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjDb,GAAaoD,CAAS,IACxBmB,EAASC,EAAiB,GAC1B3D,EAAM,WACN6B,EAAoB7B,EAAO,GAAMoC,CAAU,IAI/CO,EAAQ3C,EAAM,KACd4C,EAAa5C,EAAM,UACnBsD,EAAOtD,EAAM,SACb6D,GAAY7D,EAAOoC,EAAYhE,GAAiB,GAAO,EAAI,EAC3DkD,EAAStB,EAAM,IACfuB,EAAUvB,EAAM,OAChB6B,EAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAErC2D,GAAkB3D,EAAM,OAAS2C,IAAU3I,IAAO,KACrD0J,EAAS,GACT1J,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5C6B,EAAoB7B,EAAO,GAAMoC,CAAU,EAC3CyB,GAAY7D,EAAOoC,EAAYhE,GAAiB,GAAO,EAAI,EAC3DoD,EAAYxB,EAAM,QAGhB4D,EACFvC,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAAWmB,EAAOC,EAAYU,CAAI,EAC5FI,EACT1C,EAAQ,KAAKK,GAAiBrB,EAAO,KAAMmB,EAAiBG,EAAQC,EAASC,EAAWmB,EAAOC,EAAYU,CAAI,CAAC,EAEhHtC,EAAQ,KAAKO,CAAO,EAGtBM,EAAoB7B,EAAO,GAAMoC,CAAU,EAE3CpI,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,IACTqJ,EAAW,GACXrJ,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAE5CqD,EAAW,EAEf,CAEApD,EAAWD,EAAO,uDAAuD,CAC3E,CA9GSjM,EAAAqP,GAAA,sBAgHT,SAASU,GAAgB9D,EAAOoC,EAAY,CAC1C,IAAII,EACAuB,EACAC,EAAiBxF,GACjByF,EAAiB,GACjBC,EAAiB,GACjBC,EAAiB/B,EACjBgC,EAAiB,EACjBC,EAAiB,GACjBlB,EACAnJ,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,IACT+J,EAAU,WACD/J,IAAO,GAChB+J,EAAU,OAEV,OAAO,GAMT,IAHA/D,EAAM,KAAO,SACbA,EAAM,OAAS,GAERhG,IAAO,GAGZ,GAFAA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,IAAeA,IAAO,GAC3BwE,KAAkBwF,EACpBA,EAAYhK,IAAO,GAAe0E,GAAgBD,GAElDwB,EAAWD,EAAO,sCAAsC,WAGhDmD,EAAM3D,GAAgBxF,CAAE,IAAM,EACpCmJ,IAAQ,EACVlD,EAAWD,EAAO,8EAA8E,EACtFkE,EAIVjE,EAAWD,EAAO,2CAA2C,GAH7DmE,EAAa/B,EAAae,EAAM,EAChCe,EAAiB,QAMnB,OAIJ,GAAIhF,GAAelF,CAAE,EAAG,CACtB,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1Cd,GAAelF,CAAE,GAExB,GAAIA,IAAO,GACT,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1C,CAACf,GAAOjF,CAAE,GAAMA,IAAO,EAElC,CAEA,KAAOA,IAAO,GAAG,CAMf,IALA4H,GAAc5B,CAAK,EACnBA,EAAM,WAAa,EAEnBhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAElC,CAACkE,GAAkBlE,EAAM,WAAamE,IACtCnK,IAAO,IACbgG,EAAM,aACNhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAO9C,GAJI,CAACkE,GAAkBlE,EAAM,WAAamE,IACxCA,EAAanE,EAAM,YAGjBf,GAAOjF,CAAE,EAAG,CACdoK,IACA,QACF,CAGA,GAAIpE,EAAM,WAAamE,EAAY,CAG7BH,IAAatF,GACfsB,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAM0O,EAAiB,EAAIG,EAAaA,CAAU,EACvEJ,IAAaxF,IAClByF,IACFjE,EAAM,QAAU;AAAA,GAKpB,KACF,CAsCA,IAnCI+D,EAGE7E,GAAelF,CAAE,GACnBqK,EAAiB,GAEjBrE,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAM0O,EAAiB,EAAIG,EAAaA,CAAU,GAGvEC,GACTA,EAAiB,GACjBrE,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAM6O,EAAa,CAAC,GAGzCA,IAAe,EACpBH,IACFjE,EAAM,QAAU,KAKlBA,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAM6O,CAAU,EAMhDpE,EAAM,QAAUzK,EAAO,OAAO;AAAA,EAAM0O,EAAiB,EAAIG,EAAaA,CAAU,EAGlFH,EAAiB,GACjBC,EAAiB,GACjBE,EAAa,EACb5B,EAAexC,EAAM,SAEd,CAACf,GAAOjF,CAAE,GAAMA,IAAO,GAC5BA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CS,GAAeT,EAAOwC,EAAcxC,EAAM,SAAU,EAAK,CAC3D,CAEA,MAAO,EACT,CA7ISjM,EAAA+P,GAAA,mBA+IT,SAASQ,GAAkBtE,EAAOoC,EAAY,CAC5C,IAAIO,EACAY,EAAYvD,EAAM,IAClBwD,EAAYxD,EAAM,OAClBgB,EAAY,CAAC,EACbuB,EACAgC,EAAY,GACZvK,EAIJ,GAAIgG,EAAM,iBAAmB,GAAI,MAAO,GAQxC,IANIA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnChG,IAAO,IACRgG,EAAM,iBAAmB,KAC3BA,EAAM,SAAWA,EAAM,eACvBC,EAAWD,EAAO,gDAAgD,GAGhE,EAAAhG,IAAO,KAIXuI,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EAEjD,CAACb,GAAaoD,CAAS,MAZZ,CAmBf,GAHAgC,EAAW,GACXvE,EAAM,WAEF6B,EAAoB7B,EAAO,GAAM,EAAE,GACjCA,EAAM,YAAcoC,EAAY,CAClCpB,EAAQ,KAAK,IAAI,EACjBhH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAC1C,QACF,CAUF,GAPA2C,EAAQ3C,EAAM,KACd6D,GAAY7D,EAAOoC,EAAY9D,GAAkB,GAAO,EAAI,EAC5D0C,EAAQ,KAAKhB,EAAM,MAAM,EACzB6B,EAAoB7B,EAAO,GAAM,EAAE,EAEnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,GAErCA,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,IAAgBpI,IAAO,EACrEiG,EAAWD,EAAO,qCAAqC,UAC9CA,EAAM,WAAaoC,EAC5B,KAEJ,CAEA,OAAImC,GACFvE,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO,WACbA,EAAM,OAASgB,EACR,IAEF,EACT,CApESjN,EAAAuQ,GAAA,qBAsET,SAASE,GAAiBxE,EAAOoC,EAAYqC,EAAY,CACvD,IAAIlC,EACAmC,EACA/B,EACAgC,EACAC,EACAC,EACAtB,EAAgBvD,EAAM,IACtBwD,EAAgBxD,EAAM,OACtBgB,EAAgB,CAAC,EACjBG,EAAkB,OAAO,OAAO,IAAI,EACpCG,EAAgB,KAChBC,EAAgB,KAChBC,EAAgB,KAChBsD,EAAgB,GAChBP,EAAgB,GAChBvK,EAIJ,GAAIgG,EAAM,iBAAmB,GAAI,MAAO,GAQxC,IANIA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIgB,GAGlChH,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnChG,IAAO,GAAG,CAaf,GAZI,CAAC8K,GAAiB9E,EAAM,iBAAmB,KAC7CA,EAAM,SAAWA,EAAM,eACvBC,EAAWD,EAAO,gDAAgD,GAGpEuC,EAAYvC,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,EACrD2C,EAAQ3C,EAAM,MAMThG,IAAO,IAAeA,IAAO,KAAgBmF,GAAaoD,CAAS,EAElEvI,IAAO,IACL8K,IACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EACzGvD,EAASC,EAAUC,EAAY,MAGjC+C,EAAW,GACXO,EAAgB,GAChBJ,EAAe,IAENI,GAETA,EAAgB,GAChBJ,EAAe,IAGfzE,EAAWD,EAAO,mGAAmG,EAGvHA,EAAM,UAAY,EAClBhG,EAAKuI,MAKA,CAKL,GAJAoC,EAAW3E,EAAM,KACjB4E,EAAgB5E,EAAM,UACtB6E,EAAU7E,EAAM,SAEZ,CAAC6D,GAAY7D,EAAOyE,EAAYpG,GAAkB,GAAO,EAAI,EAG/D,MAGF,GAAI2B,EAAM,OAAS2C,EAAO,CAGxB,IAFA3I,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEnCd,GAAelF,CAAE,GACtBA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAIhG,IAAO,GACTA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAEvCb,GAAanF,CAAE,GAClBiG,EAAWD,EAAO,yFAAyF,EAGzG8E,IACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EACzGvD,EAASC,EAAUC,EAAY,MAGjC+C,EAAW,GACXO,EAAgB,GAChBJ,EAAe,GACfpD,EAAStB,EAAM,IACfuB,EAAUvB,EAAM,eAEPuE,EACTtE,EAAWD,EAAO,0DAA0D,MAG5E,QAAAA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACR,EAGX,SAAWe,EACTtE,EAAWD,EAAO,gFAAgF,MAGlG,QAAAA,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACR,EAEX,CA6BA,IAxBIxD,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,KACzC0C,IACFH,EAAW3E,EAAM,KACjB4E,EAAgB5E,EAAM,UACtB6E,EAAU7E,EAAM,UAGd6D,GAAY7D,EAAOoC,EAAY7D,GAAmB,GAAMmG,CAAY,IAClEI,EACFvD,EAAUvB,EAAM,OAEhBwB,EAAYxB,EAAM,QAIjB8E,IACHzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAASC,EAAWmD,EAAUC,EAAeC,CAAO,EAC9GvD,EAASC,EAAUC,EAAY,MAGjCK,EAAoB7B,EAAO,GAAM,EAAE,EACnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAGvCA,EAAM,OAAS2C,GAAS3C,EAAM,WAAaoC,IAAgBpI,IAAO,EACrEiG,EAAWD,EAAO,oCAAoC,UAC7CA,EAAM,WAAaoC,EAC5B,KAEJ,CAOA,OAAI0C,GACFzD,GAAiBrB,EAAOgB,EAASG,EAAiBG,EAAQC,EAAS,KAAMoD,EAAUC,EAAeC,CAAO,EAIvGN,IACFvE,EAAM,IAAMuD,EACZvD,EAAM,OAASwD,EACfxD,EAAM,KAAO,UACbA,EAAM,OAASgB,GAGVuD,CACT,CA/KSxQ,EAAAyQ,GAAA,oBAiLT,SAASO,GAAgB/E,EAAO,CAC9B,IAAIa,EACAmE,EAAa,GACbC,EAAa,GACbC,EACAC,EACAnL,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAuB/B,GArBIgG,EAAM,MAAQ,MAChBC,EAAWD,EAAO,+BAA+B,EAGnDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAExChG,IAAO,IACTgL,EAAa,GACbhL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAEnChG,IAAO,IAChBiL,EAAU,GACVC,EAAY,KACZlL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAG5CkF,EAAY,IAGdrE,EAAYb,EAAM,SAEdgF,EAAY,CACd,GAAKhL,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1ChG,IAAO,GAAKA,IAAO,IAEtBgG,EAAM,SAAWA,EAAM,QACzBmF,EAAUnF,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EACrDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,GAE5CC,EAAWD,EAAO,oDAAoD,CAE1E,KAAO,CACL,KAAOhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAE7BA,IAAO,KACJiL,EAUHhF,EAAWD,EAAO,6CAA6C,GAT/DkF,EAAYlF,EAAM,MAAM,MAAMa,EAAY,EAAGb,EAAM,SAAW,CAAC,EAE1DlB,GAAmB,KAAKoG,CAAS,GACpCjF,EAAWD,EAAO,iDAAiD,EAGrEiF,EAAU,GACVpE,EAAYb,EAAM,SAAW,IAMjChG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CmF,EAAUnF,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAEjDnB,GAAwB,KAAKsG,CAAO,GACtClF,EAAWD,EAAO,qDAAqD,CAE3E,CAEImF,GAAW,CAACpG,GAAgB,KAAKoG,CAAO,GAC1ClF,EAAWD,EAAO,4CAA8CmF,CAAO,EAGzE,GAAI,CACFA,EAAU,mBAAmBA,CAAO,CACtC,MAAc,CACZlF,EAAWD,EAAO,0BAA4BmF,CAAO,CACvD,CAEA,OAAIH,EACFhF,EAAM,IAAMmF,EAEHhH,GAAkB,KAAK6B,EAAM,OAAQkF,CAAS,EACvDlF,EAAM,IAAMA,EAAM,OAAOkF,CAAS,EAAIC,EAE7BD,IAAc,IACvBlF,EAAM,IAAM,IAAMmF,EAETD,IAAc,KACvBlF,EAAM,IAAM,qBAAuBmF,EAGnClF,EAAWD,EAAO,0BAA4BkF,EAAY,GAAG,EAGxD,EACT,CAlGSnR,EAAAgR,GAAA,mBAoGT,SAASK,GAAmBpF,EAAO,CACjC,IAAIa,EACA7G,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAS/B,IAPIgG,EAAM,SAAW,MACnBC,EAAWD,EAAO,mCAAmC,EAGvDhG,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAAK,CAACoF,GAAkBpF,CAAE,GAC3DA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,OAAIA,EAAM,WAAaa,GACrBZ,EAAWD,EAAO,4DAA4D,EAGhFA,EAAM,OAASA,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EACnD,EACT,CAzBSjM,EAAAqR,GAAA,sBA2BT,SAASC,GAAUrF,EAAO,CACxB,IAAIa,EAAWlJ,EACXqC,EAIJ,GAFAA,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtChG,IAAO,GAAa,MAAO,GAK/B,IAHAA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GAAK,CAACoF,GAAkBpF,CAAE,GAC3DA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,OAAIA,EAAM,WAAaa,GACrBZ,EAAWD,EAAO,2DAA2D,EAG/ErI,EAAQqI,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAE9C7B,GAAkB,KAAK6B,EAAM,UAAWrI,CAAK,GAChDsI,EAAWD,EAAO,uBAAyBrI,EAAQ,GAAG,EAGxDqI,EAAM,OAASA,EAAM,UAAUrI,CAAK,EACpCkK,EAAoB7B,EAAO,GAAM,EAAE,EAC5B,EACT,CA5BSjM,EAAAsR,GAAA,aA8BT,SAASxB,GAAY7D,EAAOsF,EAAcC,EAAaC,EAAad,EAAc,CAChF,IAAIe,EACAC,EACAC,EACAC,EAAe,EACfC,EAAa,GACbC,EAAa,GACbC,EACAC,EACAC,EACAjO,EACAyM,EACAyB,EA6BJ,GA3BIlG,EAAM,WAAa,MACrBA,EAAM,SAAS,OAAQA,CAAK,EAG9BA,EAAM,IAAS,KACfA,EAAM,OAAS,KACfA,EAAM,KAAS,KACfA,EAAM,OAAS,KAEfyF,EAAmBC,EAAoBC,EACrCpH,KAAsBgH,GACtBjH,KAAsBiH,EAEpBC,GACE3D,EAAoB7B,EAAO,GAAM,EAAE,IACrC6F,EAAY,GAER7F,EAAM,WAAasF,EACrBM,EAAe,EACN5F,EAAM,aAAesF,EAC9BM,EAAe,EACN5F,EAAM,WAAasF,IAC5BM,EAAe,KAKjBA,IAAiB,EACnB,KAAOb,GAAgB/E,CAAK,GAAKoF,GAAmBpF,CAAK,GACnD6B,EAAoB7B,EAAO,GAAM,EAAE,GACrC6F,EAAY,GACZF,EAAwBF,EAEpBzF,EAAM,WAAasF,EACrBM,EAAe,EACN5F,EAAM,aAAesF,EAC9BM,EAAe,EACN5F,EAAM,WAAasF,IAC5BM,EAAe,KAGjBD,EAAwB,GAwD9B,GAnDIA,IACFA,EAAwBE,GAAanB,IAGnCkB,IAAiB,GAAKrH,KAAsBgH,KAC1CnH,KAAoBmH,GAAelH,KAAqBkH,EAC1Dd,EAAaa,EAEbb,EAAaa,EAAe,EAG9BY,EAAclG,EAAM,SAAWA,EAAM,UAEjC4F,IAAiB,EACfD,IACCrB,GAAkBtE,EAAOkG,CAAW,GACpC1B,GAAiBxE,EAAOkG,EAAazB,CAAU,IAChDrB,GAAmBpD,EAAOyE,CAAU,EACtCqB,EAAa,IAERJ,GAAqB5B,GAAgB9D,EAAOyE,CAAU,GACvD1B,GAAuB/C,EAAOyE,CAAU,GACxCzB,GAAuBhD,EAAOyE,CAAU,EAC1CqB,EAAa,GAEJT,GAAUrF,CAAK,GACxB8F,EAAa,IAET9F,EAAM,MAAQ,MAAQA,EAAM,SAAW,OACzCC,EAAWD,EAAO,2CAA2C,GAGtDmC,GAAgBnC,EAAOyE,EAAYrG,KAAoBmH,CAAW,IAC3EO,EAAa,GAET9F,EAAM,MAAQ,OAChBA,EAAM,IAAM,MAIZA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,SAGjC4F,IAAiB,IAG1BE,EAAaH,GAAyBrB,GAAkBtE,EAAOkG,CAAW,IAI1ElG,EAAM,MAAQ,KACZA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,gBAG/BA,EAAM,MAAQ,KAWvB,IAJIA,EAAM,SAAW,MAAQA,EAAM,OAAS,UAC1CC,EAAWD,EAAO,oEAAsEA,EAAM,KAAO,GAAG,EAGrG+F,EAAY,EAAGC,EAAehG,EAAM,cAAc,OAAQ+F,EAAYC,EAAcD,GAAa,EAGpG,GAFA/N,EAAOgI,EAAM,cAAc+F,CAAS,EAEhC/N,EAAK,QAAQgI,EAAM,MAAM,EAAG,CAC9BA,EAAM,OAAShI,EAAK,UAAUgI,EAAM,MAAM,EAC1CA,EAAM,IAAMhI,EAAK,IACbgI,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,QAExC,KACF,UAEOA,EAAM,MAAQ,IAAK,CAC5B,GAAI7B,GAAkB,KAAK6B,EAAM,QAAQA,EAAM,MAAQ,UAAU,EAAGA,EAAM,GAAG,EAC3EhI,EAAOgI,EAAM,QAAQA,EAAM,MAAQ,UAAU,EAAEA,EAAM,GAAG,MAMxD,KAHAhI,EAAO,KACPiO,EAAWjG,EAAM,QAAQ,MAAMA,EAAM,MAAQ,UAAU,EAElD+F,EAAY,EAAGC,EAAeC,EAAS,OAAQF,EAAYC,EAAcD,GAAa,EACzF,GAAI/F,EAAM,IAAI,MAAM,EAAGiG,EAASF,CAAS,EAAE,IAAI,MAAM,IAAME,EAASF,CAAS,EAAE,IAAK,CAClF/N,EAAOiO,EAASF,CAAS,EACzB,KACF,CAIC/N,GACHiI,EAAWD,EAAO,iBAAmBA,EAAM,IAAM,GAAG,EAGlDA,EAAM,SAAW,MAAQhI,EAAK,OAASgI,EAAM,MAC/CC,EAAWD,EAAO,gCAAkCA,EAAM,IAAM,wBAA0BhI,EAAK,KAAO,WAAagI,EAAM,KAAO,GAAG,EAGhIhI,EAAK,QAAQgI,EAAM,OAAQA,EAAM,GAAG,GAGvCA,EAAM,OAAShI,EAAK,UAAUgI,EAAM,OAAQA,EAAM,GAAG,EACjDA,EAAM,SAAW,OACnBA,EAAM,UAAUA,EAAM,MAAM,EAAIA,EAAM,SAJxCC,EAAWD,EAAO,gCAAkCA,EAAM,IAAM,gBAAgB,CAOpF,CAEA,OAAIA,EAAM,WAAa,MACrBA,EAAM,SAAS,QAASA,CAAK,EAExBA,EAAM,MAAQ,MAASA,EAAM,SAAW,MAAQ8F,CACzD,CAjLS/R,EAAA8P,GAAA,eAmLT,SAASsC,GAAanG,EAAO,CAC3B,IAAIoG,EAAgBpG,EAAM,SACtBa,EACAwF,EACAC,EACAC,EAAgB,GAChBvM,EAOJ,IALAgG,EAAM,QAAU,KAChBA,EAAM,gBAAkBA,EAAM,OAC9BA,EAAM,OAAS,OAAO,OAAO,IAAI,EACjCA,EAAM,UAAY,OAAO,OAAO,IAAI,GAE5BhG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,KAAO,IACvD6B,EAAoB7B,EAAO,GAAM,EAAE,EAEnChG,EAAKgG,EAAM,MAAM,WAAWA,EAAM,QAAQ,EAEtC,EAAAA,EAAM,WAAa,GAAKhG,IAAO,MALuB,CAa1D,IAJAuM,EAAgB,GAChBvM,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAC5Ca,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GACjCA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAU9C,IAPAqG,EAAgBrG,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,EAC3DsG,EAAgB,CAAC,EAEbD,EAAc,OAAS,GACzBpG,EAAWD,EAAO,8DAA8D,EAG3EhG,IAAO,GAAG,CACf,KAAOkF,GAAelF,CAAE,GACtBA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9C,GAAIhG,IAAO,GAAa,CACtB,GAAKA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,QAC1ChG,IAAO,GAAK,CAACiF,GAAOjF,CAAE,GAC7B,KACF,CAEA,GAAIiF,GAAOjF,CAAE,EAAG,MAIhB,IAFA6G,EAAYb,EAAM,SAEXhG,IAAO,GAAK,CAACmF,GAAanF,CAAE,GACjCA,EAAKgG,EAAM,MAAM,WAAW,EAAEA,EAAM,QAAQ,EAG9CsG,EAAc,KAAKtG,EAAM,MAAM,MAAMa,EAAWb,EAAM,QAAQ,CAAC,CACjE,CAEIhG,IAAO,GAAG4H,GAAc5B,CAAK,EAE7B7B,GAAkB,KAAKgC,GAAmBkG,CAAa,EACzDlG,GAAkBkG,CAAa,EAAErG,EAAOqG,EAAeC,CAAa,EAEpEpG,GAAaF,EAAO,+BAAiCqG,EAAgB,GAAG,CAE5E,CAyBA,GAvBAxE,EAAoB7B,EAAO,GAAM,EAAE,EAE/BA,EAAM,aAAe,GACrBA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAU,IAC/CA,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,IAAM,IAC/CA,EAAM,MAAM,WAAWA,EAAM,SAAW,CAAC,IAAM,IACjDA,EAAM,UAAY,EAClB6B,EAAoB7B,EAAO,GAAM,EAAE,GAE1BuG,GACTtG,EAAWD,EAAO,iCAAiC,EAGrD6D,GAAY7D,EAAOA,EAAM,WAAa,EAAGzB,GAAmB,GAAO,EAAI,EACvEsD,EAAoB7B,EAAO,GAAM,EAAE,EAE/BA,EAAM,iBACNpB,GAA8B,KAAKoB,EAAM,MAAM,MAAMoG,EAAepG,EAAM,QAAQ,CAAC,GACrFE,GAAaF,EAAO,kDAAkD,EAGxEA,EAAM,UAAU,KAAKA,EAAM,MAAM,EAE7BA,EAAM,WAAaA,EAAM,WAAaiC,GAAsBjC,CAAK,EAAG,CAElEA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,KAC7CA,EAAM,UAAY,EAClB6B,EAAoB7B,EAAO,GAAM,EAAE,GAErC,MACF,CAEA,GAAIA,EAAM,SAAYA,EAAM,OAAS,EACnCC,EAAWD,EAAO,uDAAuD,MAEzE,OAEJ,CAzGSjM,EAAAoS,GAAA,gBA4GT,SAASK,GAAc7J,EAAO/F,EAAS,CACrC+F,EAAQ,OAAOA,CAAK,EACpB/F,EAAUA,GAAW,CAAC,EAElB+F,EAAM,SAAW,IAGfA,EAAM,WAAWA,EAAM,OAAS,CAAC,IAAM,IACvCA,EAAM,WAAWA,EAAM,OAAS,CAAC,IAAM,KACzCA,GAAS;AAAA,GAIPA,EAAM,WAAW,CAAC,IAAM,QAC1BA,EAAQA,EAAM,MAAM,CAAC,IAIzB,IAAIqD,EAAQ,IAAIF,GAAQnD,EAAO/F,CAAO,EAElC6P,EAAU9J,EAAM,QAAQ,IAAI,EAUhC,IARI8J,IAAY,KACdzG,EAAM,SAAWyG,EACjBxG,EAAWD,EAAO,mCAAmC,GAIvDA,EAAM,OAAS,KAERA,EAAM,MAAM,WAAWA,EAAM,QAAQ,IAAM,IAChDA,EAAM,YAAc,EACpBA,EAAM,UAAY,EAGpB,KAAOA,EAAM,SAAYA,EAAM,OAAS,GACtCmG,GAAanG,CAAK,EAGpB,OAAOA,EAAM,SACf,CAxCSjM,EAAAyS,GAAA,iBA2CT,SAASE,GAAU/J,EAAOgK,EAAU/P,EAAS,CACvC+P,IAAa,MAAQ,OAAOA,GAAa,UAAY,OAAO/P,EAAY,MAC1EA,EAAU+P,EACVA,EAAW,MAGb,IAAIC,EAAYJ,GAAc7J,EAAO/F,CAAO,EAE5C,GAAI,OAAO+P,GAAa,WACtB,OAAOC,EAGT,QAAStS,EAAQ,EAAGC,EAASqS,EAAU,OAAQtS,EAAQC,EAAQD,GAAS,EACtEqS,EAASC,EAAUtS,CAAK,CAAC,CAE7B,CAfSP,EAAA2S,GAAA,aAkBT,SAASG,GAAOlK,EAAO/F,EAAS,CAC9B,IAAIgQ,EAAYJ,GAAc7J,EAAO/F,CAAO,EAE5C,GAAIgQ,EAAU,SAAW,EAGlB,IAAIA,EAAU,SAAW,EAC9B,OAAOA,EAAU,CAAC,EAEpB,MAAM,IAAInR,EAAU,0DAA0D,EAChF,CAVS1B,EAAA8S,GAAA,UAaT,IAAIC,GAAYJ,GACZK,GAAYF,GAEZG,GAAS,CACZ,QAASF,GACT,KAAMC,EACP,EAQIE,GAAkB,OAAO,UAAU,SACnCC,GAAkB,OAAO,UAAU,eAEnCC,GAA4B,MAC5BC,GAA4B,EAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,GAC5BC,GAA4B,IAC5BC,GAA4B,IAC5BC,GAA4B,IAE5BC,EAAmB,CAAC,EAExBA,EAAiB,CAAI,EAAM,MAC3BA,EAAiB,CAAI,EAAM,MAC3BA,EAAiB,CAAI,EAAM,MAC3BA,EAAiB,CAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,MAC3BA,EAAiB,EAAI,EAAM,OAC3BA,EAAiB,GAAI,EAAM,MAC3BA,EAAiB,GAAI,EAAM,MAC3BA,EAAiB,IAAM,EAAI,MAC3BA,EAAiB,IAAM,EAAI,MAE3B,IAAIC,GAA6B,CAC/B,IAAK,IAAK,MAAO,MAAO,MAAO,KAAM,KAAM,KAC3C,IAAK,IAAK,KAAM,KAAM,KAAM,MAAO,MAAO,KAC5C,EAEIC,GAA2B,4CAE/B,SAASC,GAAgB7Q,EAAQT,EAAK,CACpC,IAAI5C,EAAQ8I,EAAMrJ,EAAOC,EAAQsD,EAAKH,EAAOM,EAE7C,GAAIP,IAAQ,KAAM,MAAO,CAAC,EAK1B,IAHA5C,EAAS,CAAC,EACV8I,EAAO,OAAO,KAAKlG,CAAG,EAEjBnD,EAAQ,EAAGC,EAASoJ,EAAK,OAAQrJ,EAAQC,EAAQD,GAAS,EAC7DuD,EAAM8F,EAAKrJ,CAAK,EAChBoD,EAAQ,OAAOD,EAAII,CAAG,CAAC,EAEnBA,EAAI,MAAM,EAAG,CAAC,IAAM,OACtBA,EAAM,qBAAuBA,EAAI,MAAM,CAAC,GAE1CG,EAAOE,EAAO,gBAAgB,SAAYL,CAAG,EAEzCG,GAAQkP,GAAgB,KAAKlP,EAAK,aAAcN,CAAK,IACvDA,EAAQM,EAAK,aAAaN,CAAK,GAGjC7C,EAAOgD,CAAG,EAAIH,EAGhB,OAAO7C,CACT,CAzBSd,EAAAgV,GAAA,mBA2BT,SAASC,GAAUC,EAAW,CAC5B,IAAItU,EAAQ4L,EAAQhM,EAIpB,GAFAI,EAASsU,EAAU,SAAS,EAAE,EAAE,YAAY,EAExCA,GAAa,IACf1I,EAAS,IACThM,EAAS,UACA0U,GAAa,MACtB1I,EAAS,IACThM,EAAS,UACA0U,GAAa,WACtB1I,EAAS,IACThM,EAAS,MAET,OAAM,IAAIkB,EAAU,+DAA+D,EAGrF,MAAO,KAAO8K,EAAShL,EAAO,OAAO,IAAKhB,EAASI,EAAO,MAAM,EAAIA,CACtE,CAnBSZ,EAAAiV,GAAA,aAsBT,IAAIE,GAAsB,EACtBC,GAAsB,EAE1B,SAASC,GAAMxS,EAAS,CACtB,KAAK,OAAgBA,EAAQ,QAAasH,GAC1C,KAAK,OAAgB,KAAK,IAAI,EAAItH,EAAQ,QAAa,CAAE,EACzD,KAAK,cAAgBA,EAAQ,eAAoB,GACjD,KAAK,YAAgBA,EAAQ,aAAkB,GAC/C,KAAK,UAAiBrB,EAAO,UAAUqB,EAAQ,SAAY,EAAI,GAAKA,EAAQ,UAC5E,KAAK,SAAgBmS,GAAgB,KAAK,OAAQnS,EAAQ,QAAa,IAAI,EAC3E,KAAK,SAAgBA,EAAQ,UAAe,GAC5C,KAAK,UAAgBA,EAAQ,WAAgB,GAC7C,KAAK,OAAgBA,EAAQ,QAAa,GAC1C,KAAK,aAAgBA,EAAQ,cAAmB,GAChD,KAAK,aAAgBA,EAAQ,cAAmB,GAChD,KAAK,YAAgBA,EAAQ,cAAmB,IAAMuS,GAAsBD,GAC5E,KAAK,YAAgBtS,EAAQ,aAAkB,GAC/C,KAAK,SAAgB,OAAOA,EAAQ,UAAgB,WAAaA,EAAQ,SAAc,KAEvF,KAAK,cAAgB,KAAK,OAAO,iBACjC,KAAK,cAAgB,KAAK,OAAO,iBAEjC,KAAK,IAAM,KACX,KAAK,OAAS,GAEd,KAAK,WAAa,CAAC,EACnB,KAAK,eAAiB,IACxB,CAxBS7C,EAAAqV,GAAA,SA2BT,SAASC,GAAa1U,EAAQ2U,EAAQ,CAQpC,QAPIC,EAAMhU,EAAO,OAAO,IAAK+T,CAAM,EAC/BlT,EAAW,EACXoT,EAAO,GACP3U,EAAS,GACTsC,EACA5C,EAASI,EAAO,OAEbyB,EAAW7B,GAChBiV,EAAO7U,EAAO,QAAQ;AAAA,EAAMyB,CAAQ,EAChCoT,IAAS,IACXrS,EAAOxC,EAAO,MAAMyB,CAAQ,EAC5BA,EAAW7B,IAEX4C,EAAOxC,EAAO,MAAMyB,EAAUoT,EAAO,CAAC,EACtCpT,EAAWoT,EAAO,GAGhBrS,EAAK,QAAUA,IAAS;AAAA,IAAMtC,GAAU0U,GAE5C1U,GAAUsC,EAGZ,OAAOtC,CACT,CAxBSd,EAAAsV,GAAA,gBA0BT,SAASI,GAAiBzJ,EAAO0J,EAAO,CACtC,MAAO;AAAA,EAAOnU,EAAO,OAAO,IAAKyK,EAAM,OAAS0J,CAAK,CACvD,CAFS3V,EAAA0V,GAAA,oBAIT,SAASE,GAAsB3J,EAAOlH,EAAK,CACzC,IAAIxE,EAAOC,EAAQyD,EAEnB,IAAK1D,EAAQ,EAAGC,EAASyL,EAAM,cAAc,OAAQ1L,EAAQC,EAAQD,GAAS,EAG5E,GAFA0D,EAAOgI,EAAM,cAAc1L,CAAK,EAE5B0D,EAAK,QAAQc,CAAG,EAClB,MAAO,GAIX,MAAO,EACT,CAZS/E,EAAA4V,GAAA,yBAeT,SAASC,GAAajQ,EAAG,CACvB,OAAOA,IAAM4N,IAAc5N,IAAMyN,EACnC,CAFSrT,EAAA6V,GAAA,gBAQT,SAASC,GAAYlQ,EAAG,CACtB,MAAS,KAAWA,GAAKA,GAAK,KACrB,KAAWA,GAAKA,GAAK,OAAaA,IAAM,MAAUA,IAAM,MACxD,OAAWA,GAAKA,GAAK,OAAaA,IAAMwN,IACxC,OAAWxN,GAAKA,GAAK,OAChC,CALS5F,EAAA8V,GAAA,eAYT,SAASC,GAAqBnQ,EAAG,CAC/B,OAAOkQ,GAAYlQ,CAAC,GACfA,IAAMwN,IAENxN,IAAM2N,IACN3N,IAAM0N,EACb,CANStT,EAAA+V,GAAA,wBAiBT,SAASC,GAAYpQ,EAAGqQ,EAAMC,EAAS,CACrC,IAAIC,EAAwBJ,GAAqBnQ,CAAC,EAC9CwQ,EAAYD,GAAyB,CAACN,GAAajQ,CAAC,EACxD,OAEEsQ,EACEC,EACEA,GAEGvQ,IAAMoO,IACNpO,IAAM2O,IACN3O,IAAM4O,IACN5O,IAAM8O,IACN9O,IAAMgP,KAGVhP,IAAM+N,IACN,EAAEsC,IAAS/B,IAAc,CAACkC,IACzBL,GAAqBE,CAAI,GAAK,CAACJ,GAAaI,CAAI,GAAKrQ,IAAM+N,IAC3DsC,IAAS/B,IAAckC,CAC/B,CApBSpW,EAAAgW,GAAA,eAuBT,SAASK,GAAiBzQ,EAAG,CAI3B,OAAOkQ,GAAYlQ,CAAC,GAAKA,IAAMwN,IAC1B,CAACyC,GAAajQ,CAAC,GAGfA,IAAMqO,IACNrO,IAAMyO,IACNzO,IAAMsO,IACNtO,IAAMoO,IACNpO,IAAM2O,IACN3O,IAAM4O,IACN5O,IAAM8O,IACN9O,IAAMgP,IAENhP,IAAM+N,IACN/N,IAAMiO,IACNjO,IAAMmO,IACNnO,IAAM6N,IACN7N,IAAM+O,IACN/O,IAAMuO,IACNvO,IAAMwO,IACNxO,IAAMkO,IACNlO,IAAM8N,IAEN9N,IAAMgO,IACNhO,IAAM0O,IACN1O,IAAM6O,EACb,CA9BSzU,EAAAqW,GAAA,oBAiCT,SAASC,GAAgB1Q,EAAG,CAE1B,MAAO,CAACiQ,GAAajQ,CAAC,GAAKA,IAAMsO,EACnC,CAHSlU,EAAAsW,GAAA,mBAMT,SAASC,GAAY3V,EAAQ4V,EAAK,CAChC,IAAIC,EAAQ7V,EAAO,WAAW4V,CAAG,EAAG7O,EACpC,OAAI8O,GAAS,OAAUA,GAAS,OAAUD,EAAM,EAAI5V,EAAO,SACzD+G,EAAS/G,EAAO,WAAW4V,EAAM,CAAC,EAC9B7O,GAAU,OAAUA,GAAU,QAExB8O,EAAQ,OAAU,KAAQ9O,EAAS,MAAS,MAGjD8O,CACT,CAVSzW,EAAAuW,GAAA,eAaT,SAASG,GAAoB9V,EAAQ,CACnC,IAAI+V,EAAiB,QACrB,OAAOA,EAAe,KAAK/V,CAAM,CACnC,CAHSZ,EAAA0W,GAAA,uBAKT,IAAIE,GAAgB,EAChBC,GAAgB,EAChBC,GAAgB,EAChBC,GAAgB,EAChBC,GAAgB,EASpB,SAASC,GAAkBrW,EAAQsW,EAAgBC,EAAgBC,EACjEC,EAAmBC,EAAaC,EAAarB,EAAS,CAEtD,IAAI/S,EACAqU,EAAO,EACPC,EAAW,KACXC,EAAe,GACfC,EAAkB,GAClBC,EAAmBR,IAAc,GACjCS,EAAoB,GACpBC,EAAQzB,GAAiBE,GAAY3V,EAAQ,CAAC,CAAC,GACxC0V,GAAgBC,GAAY3V,EAAQA,EAAO,OAAS,CAAC,CAAC,EAEjE,GAAIsW,GAAkBK,EAGpB,IAAKpU,EAAI,EAAGA,EAAIvC,EAAO,OAAQ4W,GAAQ,MAAUrU,GAAK,EAAIA,IAAK,CAE7D,GADAqU,EAAOjB,GAAY3V,EAAQuC,CAAC,EACxB,CAAC2S,GAAY0B,CAAI,EACnB,OAAOR,GAETc,EAAQA,GAAS9B,GAAYwB,EAAMC,EAAUvB,CAAO,EACpDuB,EAAWD,CACb,KACK,CAEL,IAAKrU,EAAI,EAAGA,EAAIvC,EAAO,OAAQ4W,GAAQ,MAAUrU,GAAK,EAAIA,IAAK,CAE7D,GADAqU,EAAOjB,GAAY3V,EAAQuC,CAAC,EACxBqU,IAASlE,GACXoE,EAAe,GAEXE,IACFD,EAAkBA,GAEfxU,EAAI0U,EAAoB,EAAIT,GAC5BxW,EAAOiX,EAAoB,CAAC,IAAM,IACrCA,EAAoB1U,WAEb,CAAC2S,GAAY0B,CAAI,EAC1B,OAAOR,GAETc,EAAQA,GAAS9B,GAAYwB,EAAMC,EAAUvB,CAAO,EACpDuB,EAAWD,CACb,CAEAG,EAAkBA,GAAoBC,GACnCzU,EAAI0U,EAAoB,EAAIT,GAC5BxW,EAAOiX,EAAoB,CAAC,IAAM,GACvC,CAIA,MAAI,CAACH,GAAgB,CAACC,EAGhBG,GAAS,CAACP,GAAe,CAACF,EAAkBzW,CAAM,EAC7CgW,GAEFU,IAAgBlC,GAAsB4B,GAAeH,GAG1DM,EAAiB,GAAKT,GAAoB9V,CAAM,EAC3CoW,GAIJO,EAGED,IAAgBlC,GAAsB4B,GAAeH,GAFnDc,EAAkBZ,GAAeD,EAG5C,CAtES9W,EAAAiX,GAAA,qBA8ET,SAASc,GAAY9L,EAAOrL,EAAQ+U,EAAOqC,EAAO9B,EAAS,CACzDjK,EAAM,MAAQ,UAAY,CACxB,GAAIrL,EAAO,SAAW,EACpB,OAAOqL,EAAM,cAAgBmJ,GAAsB,KAAO,KAE5D,GAAI,CAACnJ,EAAM,eACL6I,GAA2B,QAAQlU,CAAM,IAAM,IAAMmU,GAAyB,KAAKnU,CAAM,GAC3F,OAAOqL,EAAM,cAAgBmJ,GAAuB,IAAMxU,EAAS,IAAQ,IAAMA,EAAS,IAI9F,IAAIqX,EAAShM,EAAM,OAAS,KAAK,IAAI,EAAG0J,CAAK,EAQzCyB,EAAYnL,EAAM,YAAc,GAChC,GAAK,KAAK,IAAI,KAAK,IAAIA,EAAM,UAAW,EAAE,EAAGA,EAAM,UAAYgM,CAAM,EAGrEf,EAAiBc,GAEf/L,EAAM,UAAY,IAAM0J,GAAS1J,EAAM,UAC7C,SAASiM,EAActX,EAAQ,CAC7B,OAAOgV,GAAsB3J,EAAOrL,CAAM,CAC5C,CAEA,OAJSZ,EAAAkY,EAAA,iBAIDjB,GAAkBrW,EAAQsW,EAAgBjL,EAAM,OAAQmL,EAC9Dc,EAAejM,EAAM,YAAaA,EAAM,aAAe,CAAC+L,EAAO9B,CAAO,EAAG,CAEzE,KAAKU,GACH,OAAOhW,EACT,KAAKiW,GACH,MAAO,IAAMjW,EAAO,QAAQ,KAAM,IAAI,EAAI,IAC5C,KAAKkW,GACH,MAAO,IAAMqB,GAAYvX,EAAQqL,EAAM,MAAM,EACzCmM,GAAkB9C,GAAa1U,EAAQqX,CAAM,CAAC,EACpD,KAAKlB,GACH,MAAO,IAAMoB,GAAYvX,EAAQqL,EAAM,MAAM,EACzCmM,GAAkB9C,GAAa+C,GAAWzX,EAAQwW,CAAS,EAAGa,CAAM,CAAC,EAC3E,KAAKjB,GACH,MAAO,IAAMsB,GAAa1X,CAAM,EAAI,IACtC,QACE,MAAM,IAAIc,EAAU,wCAAwC,CAChE,CACF,GAAE,CACJ,CAjDS1B,EAAA+X,GAAA,eAoDT,SAASI,GAAYvX,EAAQuW,EAAgB,CAC3C,IAAIoB,EAAkB7B,GAAoB9V,CAAM,EAAI,OAAOuW,CAAc,EAAI,GAGzEqB,EAAgB5X,EAAOA,EAAO,OAAS,CAAC,IAAM;AAAA,EAC9C6X,EAAOD,IAAS5X,EAAOA,EAAO,OAAS,CAAC,IAAM;AAAA,GAAQA,IAAW;AAAA,GACjE8X,EAAQD,EAAO,IAAOD,EAAO,GAAK,IAEtC,OAAOD,EAAkBG,EAAQ;AAAA,CACnC,CATS1Y,EAAAmY,GAAA,eAYT,SAASC,GAAkBxX,EAAQ,CACjC,OAAOA,EAAOA,EAAO,OAAS,CAAC,IAAM;AAAA,EAAOA,EAAO,MAAM,EAAG,EAAE,EAAIA,CACpE,CAFSZ,EAAAoY,GAAA,qBAMT,SAASC,GAAWzX,EAAQ+X,EAAO,CAoBjC,QAfIC,EAAS,iBAGT9X,GAAU,UAAY,CACxB,IAAI+X,EAASjY,EAAO,QAAQ;AAAA,CAAI,EAChC,OAAAiY,EAASA,IAAW,GAAKA,EAASjY,EAAO,OACzCgY,EAAO,UAAYC,EACZC,GAASlY,EAAO,MAAM,EAAGiY,CAAM,EAAGF,CAAK,CAChD,GAAE,EAEEI,EAAmBnY,EAAO,CAAC,IAAM;AAAA,GAAQA,EAAO,CAAC,IAAM,IACvDoY,EAGA/V,EACIA,EAAQ2V,EAAO,KAAKhY,CAAM,GAAI,CACpC,IAAI6L,EAASxJ,EAAM,CAAC,EAAGG,EAAOH,EAAM,CAAC,EACrC+V,EAAgB5V,EAAK,CAAC,IAAM,IAC5BtC,GAAU2L,GACL,CAACsM,GAAoB,CAACC,GAAgB5V,IAAS,GAC9C;AAAA,EAAO,IACT0V,GAAS1V,EAAMuV,CAAK,EACxBI,EAAmBC,CACrB,CAEA,OAAOlY,CACT,CA/BSd,EAAAqY,GAAA,cAqCT,SAASS,GAAS1V,EAAMuV,EAAO,CAC7B,GAAIvV,IAAS,IAAMA,EAAK,CAAC,IAAM,IAAK,OAAOA,EAa3C,QAVI6V,EAAU,SACVhW,EAEA0J,EAAQ,EAAGC,EAAKsM,EAAO,EAAGzD,EAAO,EACjC3U,EAAS,GAMLmC,EAAQgW,EAAQ,KAAK7V,CAAI,GAC/BqS,EAAOxS,EAAM,MAETwS,EAAO9I,EAAQgM,IACjB/L,EAAOsM,EAAOvM,EAASuM,EAAOzD,EAC9B3U,GAAU;AAAA,EAAOsC,EAAK,MAAMuJ,EAAOC,CAAG,EAEtCD,EAAQC,EAAM,GAEhBsM,EAAOzD,EAKT,OAAA3U,GAAU;AAAA,EAENsC,EAAK,OAASuJ,EAAQgM,GAASO,EAAOvM,EACxC7L,GAAUsC,EAAK,MAAMuJ,EAAOuM,CAAI,EAAI;AAAA,EAAO9V,EAAK,MAAM8V,EAAO,CAAC,EAE9DpY,GAAUsC,EAAK,MAAMuJ,CAAK,EAGrB7L,EAAO,MAAM,CAAC,CACvB,CArCSd,EAAA8Y,GAAA,YAwCT,SAASR,GAAa1X,EAAQ,CAK5B,QAJIE,EAAS,GACT0W,EAAO,EACP2B,EAEKhW,EAAI,EAAGA,EAAIvC,EAAO,OAAQ4W,GAAQ,MAAUrU,GAAK,EAAIA,IAC5DqU,EAAOjB,GAAY3V,EAAQuC,CAAC,EAC5BgW,EAAYtE,EAAiB2C,CAAI,EAE7B,CAAC2B,GAAarD,GAAY0B,CAAI,GAChC1W,GAAUF,EAAOuC,CAAC,EACdqU,GAAQ,QAAS1W,GAAUF,EAAOuC,EAAI,CAAC,IAE3CrC,GAAUqY,GAAalE,GAAUuC,CAAI,EAIzC,OAAO1W,CACT,CAlBSd,EAAAsY,GAAA,gBAoBT,SAASc,GAAkBnN,EAAO0J,EAAOtQ,EAAQ,CAC/C,IAAI4H,EAAU,GACVuC,EAAUvD,EAAM,IAChB1L,EACAC,EACA2F,EAEJ,IAAK5F,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAC/D4F,EAAQd,EAAO9E,CAAK,EAEhB0L,EAAM,WACR9F,EAAQ8F,EAAM,SAAS,KAAK5G,EAAQ,OAAO9E,CAAK,EAAG4F,CAAK,IAItDkT,GAAUpN,EAAO0J,EAAOxP,EAAO,GAAO,EAAK,GAC1C,OAAOA,EAAU,KACjBkT,GAAUpN,EAAO0J,EAAO,KAAM,GAAO,EAAK,KAEzC1I,IAAY,KAAIA,GAAW,KAAQhB,EAAM,aAAqB,GAAN,MAC5DgB,GAAWhB,EAAM,MAIrBA,EAAM,IAAMuD,EACZvD,EAAM,KAAO,IAAMgB,EAAU,GAC/B,CA1BSjN,EAAAoZ,GAAA,qBA4BT,SAASE,GAAmBrN,EAAO0J,EAAOtQ,EAAQ1D,EAAS,CACzD,IAAIsL,EAAU,GACVuC,EAAUvD,EAAM,IAChB1L,EACAC,EACA2F,EAEJ,IAAK5F,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAC/D4F,EAAQd,EAAO9E,CAAK,EAEhB0L,EAAM,WACR9F,EAAQ8F,EAAM,SAAS,KAAK5G,EAAQ,OAAO9E,CAAK,EAAG4F,CAAK,IAItDkT,GAAUpN,EAAO0J,EAAQ,EAAGxP,EAAO,GAAM,GAAM,GAAO,EAAI,GACzD,OAAOA,EAAU,KACjBkT,GAAUpN,EAAO0J,EAAQ,EAAG,KAAM,GAAM,GAAM,GAAO,EAAI,MAExD,CAAChU,GAAWsL,IAAY,MAC1BA,GAAWyI,GAAiBzJ,EAAO0J,CAAK,GAGtC1J,EAAM,MAAQqH,KAAmBrH,EAAM,KAAK,WAAW,CAAC,EAC1DgB,GAAW,IAEXA,GAAW,KAGbA,GAAWhB,EAAM,MAIrBA,EAAM,IAAMuD,EACZvD,EAAM,KAAOgB,GAAW,IAC1B,CAnCSjN,EAAAsZ,GAAA,sBAqCT,SAASC,GAAiBtN,EAAO0J,EAAOtQ,EAAQ,CAC9C,IAAI4H,EAAgB,GAChBuC,EAAgBvD,EAAM,IACtBuN,EAAgB,OAAO,KAAKnU,CAAM,EAClC9E,EACAC,EACAiZ,EACAC,EACAC,EAEJ,IAAKpZ,EAAQ,EAAGC,EAASgZ,EAAc,OAAQjZ,EAAQC,EAAQD,GAAS,EAEtEoZ,EAAa,GACT1M,IAAY,KAAI0M,GAAc,MAE9B1N,EAAM,eAAc0N,GAAc,KAEtCF,EAAYD,EAAcjZ,CAAK,EAC/BmZ,EAAcrU,EAAOoU,CAAS,EAE1BxN,EAAM,WACRyN,EAAczN,EAAM,SAAS,KAAK5G,EAAQoU,EAAWC,CAAW,GAG7DL,GAAUpN,EAAO0J,EAAO8D,EAAW,GAAO,EAAK,IAIhDxN,EAAM,KAAK,OAAS,OAAM0N,GAAc,MAE5CA,GAAc1N,EAAM,MAAQA,EAAM,aAAe,IAAM,IAAM,KAAOA,EAAM,aAAe,GAAK,KAEzFoN,GAAUpN,EAAO0J,EAAO+D,EAAa,GAAO,EAAK,IAItDC,GAAc1N,EAAM,KAGpBgB,GAAW0M,IAGb1N,EAAM,IAAMuD,EACZvD,EAAM,KAAO,IAAMgB,EAAU,GAC/B,CA5CSjN,EAAAuZ,GAAA,oBA8CT,SAASK,GAAkB3N,EAAO0J,EAAOtQ,EAAQ1D,EAAS,CACxD,IAAIsL,EAAgB,GAChBuC,EAAgBvD,EAAM,IACtBuN,EAAgB,OAAO,KAAKnU,CAAM,EAClC9E,EACAC,EACAiZ,EACAC,EACAG,EACAF,EAGJ,GAAI1N,EAAM,WAAa,GAErBuN,EAAc,KAAK,UACV,OAAOvN,EAAM,UAAa,WAEnCuN,EAAc,KAAKvN,EAAM,QAAQ,UACxBA,EAAM,SAEf,MAAM,IAAIvK,EAAU,0CAA0C,EAGhE,IAAKnB,EAAQ,EAAGC,EAASgZ,EAAc,OAAQjZ,EAAQC,EAAQD,GAAS,EACtEoZ,EAAa,IAET,CAAChY,GAAWsL,IAAY,MAC1B0M,GAAcjE,GAAiBzJ,EAAO0J,CAAK,GAG7C8D,EAAYD,EAAcjZ,CAAK,EAC/BmZ,EAAcrU,EAAOoU,CAAS,EAE1BxN,EAAM,WACRyN,EAAczN,EAAM,SAAS,KAAK5G,EAAQoU,EAAWC,CAAW,GAG7DL,GAAUpN,EAAO0J,EAAQ,EAAG8D,EAAW,GAAM,GAAM,EAAI,IAI5DI,EAAgB5N,EAAM,MAAQ,MAAQA,EAAM,MAAQ,KACpCA,EAAM,MAAQA,EAAM,KAAK,OAAS,KAE9C4N,IACE5N,EAAM,MAAQqH,KAAmBrH,EAAM,KAAK,WAAW,CAAC,EAC1D0N,GAAc,IAEdA,GAAc,MAIlBA,GAAc1N,EAAM,KAEhB4N,IACFF,GAAcjE,GAAiBzJ,EAAO0J,CAAK,GAGxC0D,GAAUpN,EAAO0J,EAAQ,EAAG+D,EAAa,GAAMG,CAAY,IAI5D5N,EAAM,MAAQqH,KAAmBrH,EAAM,KAAK,WAAW,CAAC,EAC1D0N,GAAc,IAEdA,GAAc,KAGhBA,GAAc1N,EAAM,KAGpBgB,GAAW0M,IAGb1N,EAAM,IAAMuD,EACZvD,EAAM,KAAOgB,GAAW,IAC1B,CA5ESjN,EAAA4Z,GAAA,qBA8ET,SAASE,GAAW7N,EAAO5G,EAAQR,EAAU,CAC3C,IAAIoI,EAASiF,EAAU3R,EAAOC,EAAQyD,EAAMN,EAI5C,IAFAuO,EAAWrN,EAAWoH,EAAM,cAAgBA,EAAM,cAE7C1L,EAAQ,EAAGC,EAAS0R,EAAS,OAAQ3R,EAAQC,EAAQD,GAAS,EAGjE,GAFA0D,EAAOiO,EAAS3R,CAAK,GAEhB0D,EAAK,YAAeA,EAAK,aACzB,CAACA,EAAK,YAAgB,OAAOoB,GAAW,UAAcA,aAAkBpB,EAAK,cAC7E,CAACA,EAAK,WAAcA,EAAK,UAAUoB,CAAM,GAAI,CAYhD,GAVIR,EACEZ,EAAK,OAASA,EAAK,cACrBgI,EAAM,IAAMhI,EAAK,cAAcoB,CAAM,EAErC4G,EAAM,IAAMhI,EAAK,IAGnBgI,EAAM,IAAM,IAGVhI,EAAK,UAAW,CAGlB,GAFAN,EAAQsI,EAAM,SAAShI,EAAK,GAAG,GAAKA,EAAK,aAErCiP,GAAU,KAAKjP,EAAK,SAAS,IAAM,oBACrCgJ,EAAUhJ,EAAK,UAAUoB,EAAQ1B,CAAK,UAC7BwP,GAAgB,KAAKlP,EAAK,UAAWN,CAAK,EACnDsJ,EAAUhJ,EAAK,UAAUN,CAAK,EAAE0B,EAAQ1B,CAAK,MAE7C,OAAM,IAAIjC,EAAU,KAAOuC,EAAK,IAAM,+BAAiCN,EAAQ,SAAS,EAG1FsI,EAAM,KAAOgB,CACf,CAEA,MAAO,EACT,CAGF,MAAO,EACT,CAzCSjN,EAAA8Z,GAAA,cA8CT,SAAST,GAAUpN,EAAO0J,EAAOtQ,EAAQ0U,EAAOpY,EAASqW,EAAOgC,EAAY,CAC1E/N,EAAM,IAAM,KACZA,EAAM,KAAO5G,EAERyU,GAAW7N,EAAO5G,EAAQ,EAAK,GAClCyU,GAAW7N,EAAO5G,EAAQ,EAAI,EAGhC,IAAIpB,EAAOiP,GAAU,KAAKjH,EAAM,IAAI,EAChCiK,EAAU6D,EACVE,EAEAF,IACFA,EAAS9N,EAAM,UAAY,GAAKA,EAAM,UAAY0J,GAGpD,IAAIuE,EAAgBjW,IAAS,mBAAqBA,IAAS,iBACvDkW,EACAC,EAWJ,GATIF,IACFC,EAAiBlO,EAAM,WAAW,QAAQ5G,CAAM,EAChD+U,EAAYD,IAAmB,KAG5BlO,EAAM,MAAQ,MAAQA,EAAM,MAAQ,KAAQmO,GAAcnO,EAAM,SAAW,GAAK0J,EAAQ,KAC3FhU,EAAU,IAGRyY,GAAanO,EAAM,eAAekO,CAAc,EAClDlO,EAAM,KAAO,QAAUkO,MAClB,CAIL,GAHID,GAAiBE,GAAa,CAACnO,EAAM,eAAekO,CAAc,IACpElO,EAAM,eAAekO,CAAc,EAAI,IAErClW,IAAS,kBACP8V,GAAU,OAAO,KAAK9N,EAAM,IAAI,EAAE,SAAW,GAC/C2N,GAAkB3N,EAAO0J,EAAO1J,EAAM,KAAMtK,CAAO,EAC/CyY,IACFnO,EAAM,KAAO,QAAUkO,EAAiBlO,EAAM,QAGhDsN,GAAiBtN,EAAO0J,EAAO1J,EAAM,IAAI,EACrCmO,IACFnO,EAAM,KAAO,QAAUkO,EAAiB,IAAMlO,EAAM,eAG/ChI,IAAS,iBACd8V,GAAU9N,EAAM,KAAK,SAAW,GAC9BA,EAAM,eAAiB,CAAC+N,GAAcrE,EAAQ,EAChD2D,GAAmBrN,EAAO0J,EAAQ,EAAG1J,EAAM,KAAMtK,CAAO,EAExD2X,GAAmBrN,EAAO0J,EAAO1J,EAAM,KAAMtK,CAAO,EAElDyY,IACFnO,EAAM,KAAO,QAAUkO,EAAiBlO,EAAM,QAGhDmN,GAAkBnN,EAAO0J,EAAO1J,EAAM,IAAI,EACtCmO,IACFnO,EAAM,KAAO,QAAUkO,EAAiB,IAAMlO,EAAM,eAG/ChI,IAAS,kBACdgI,EAAM,MAAQ,KAChB8L,GAAY9L,EAAOA,EAAM,KAAM0J,EAAOqC,EAAO9B,CAAO,MAEjD,IAAIjS,IAAS,qBAClB,MAAO,GAEP,GAAIgI,EAAM,YAAa,MAAO,GAC9B,MAAM,IAAIvK,EAAU,0CAA4CuC,CAAI,EAGlEgI,EAAM,MAAQ,MAAQA,EAAM,MAAQ,MActCgO,EAAS,UACPhO,EAAM,IAAI,CAAC,IAAM,IAAMA,EAAM,IAAI,MAAM,CAAC,EAAIA,EAAM,GACpD,EAAE,QAAQ,KAAM,KAAK,EAEjBA,EAAM,IAAI,CAAC,IAAM,IACnBgO,EAAS,IAAMA,EACNA,EAAO,MAAM,EAAG,EAAE,IAAM,qBACjCA,EAAS,KAAOA,EAAO,MAAM,EAAE,EAE/BA,EAAS,KAAOA,EAAS,IAG3BhO,EAAM,KAAOgO,EAAS,IAAMhO,EAAM,KAEtC,CAEA,MAAO,EACT,CAzGSjM,EAAAqZ,GAAA,aA2GT,SAASgB,GAAuBhV,EAAQ4G,EAAO,CAC7C,IAAIqO,EAAU,CAAC,EACXC,EAAoB,CAAC,EACrBha,EACAC,EAIJ,IAFAga,GAAYnV,EAAQiV,EAASC,CAAiB,EAEzCha,EAAQ,EAAGC,EAAS+Z,EAAkB,OAAQha,EAAQC,EAAQD,GAAS,EAC1E0L,EAAM,WAAW,KAAKqO,EAAQC,EAAkBha,CAAK,CAAC,CAAC,EAEzD0L,EAAM,eAAiB,IAAI,MAAMzL,CAAM,CACzC,CAZSR,EAAAqa,GAAA,0BAcT,SAASG,GAAYnV,EAAQiV,EAASC,EAAmB,CACvD,IAAIf,EACAjZ,EACAC,EAEJ,GAAI6E,IAAW,MAAQ,OAAOA,GAAW,SAEvC,GADA9E,EAAQ+Z,EAAQ,QAAQjV,CAAM,EAC1B9E,IAAU,GACRga,EAAkB,QAAQha,CAAK,IAAM,IACvCga,EAAkB,KAAKha,CAAK,UAG9B+Z,EAAQ,KAAKjV,CAAM,EAEf,MAAM,QAAQA,CAAM,EACtB,IAAK9E,EAAQ,EAAGC,EAAS6E,EAAO,OAAQ9E,EAAQC,EAAQD,GAAS,EAC/Dia,GAAYnV,EAAO9E,CAAK,EAAG+Z,EAASC,CAAiB,MAKvD,KAFAf,EAAgB,OAAO,KAAKnU,CAAM,EAE7B9E,EAAQ,EAAGC,EAASgZ,EAAc,OAAQjZ,EAAQC,EAAQD,GAAS,EACtEia,GAAYnV,EAAOmU,EAAcjZ,CAAK,CAAC,EAAG+Z,EAASC,CAAiB,CAK9E,CA3BSva,EAAAwa,GAAA,eA6BT,SAASC,GAAO7R,EAAO/F,EAAS,CAC9BA,EAAUA,GAAW,CAAC,EAEtB,IAAIoJ,EAAQ,IAAIoJ,GAAMxS,CAAO,EAExBoJ,EAAM,QAAQoO,GAAuBzR,EAAOqD,CAAK,EAEtD,IAAI9F,EAAQyC,EAMZ,OAJIqD,EAAM,WACR9F,EAAQ8F,EAAM,SAAS,KAAK,CAAE,GAAI9F,CAAM,EAAG,GAAIA,CAAK,GAGlDkT,GAAUpN,EAAO,EAAG9F,EAAO,GAAM,EAAI,EAAU8F,EAAM,KAAO;AAAA,EAEzD,EACT,CAhBSjM,EAAAya,GAAA,UAkBT,IAAIC,GAASD,GAETE,GAAS,CACZ,KAAMD,EACP,EAEA,SAASE,GAAQC,EAAMC,EAAI,CACzB,OAAO,UAAY,CACjB,MAAM,IAAI,MAAM,iBAAmBD,EAAO,sCAC1BC,EAAK,yCAAyC,CAChE,CACF,CALS9a,EAAA4a,GAAA,WAQT,IAAIG,GAAsB9W,EACtB+W,GAAsB7W,GACtB8W,GAAsBhW,GACtBiW,GAAsBlU,GACtBmU,GAAsBlU,GACtBmU,GAAsBjR,GACtBkR,GAAsBpI,GAAO,KAC7BqI,GAAsBrI,GAAO,QAC7BsI,GAAsBZ,GAAO,KAC7Ba,GAAsB9Z,EAGtB+Z,GAAQ,CACV,OAAWzS,GACX,MAAWjC,GACX,IAAWrD,GACX,KAAW4B,GACX,MAAWwE,GACX,IAAWI,GACX,UAAWhC,GACX,KAAWxC,GACX,IAAWY,GACX,MAAW8B,GACX,KAAWqB,GACX,IAAWzE,GACX,IAAWD,EACb,EAGI2W,GAAsBd,GAAQ,WAAY,MAAM,EAChDe,GAAsBf,GAAQ,cAAe,SAAS,EACtDgB,GAAsBhB,GAAQ,WAAY,MAAM,EAEhDiB,GAAS,CACZ,KAAMd,GACN,OAAQC,GACR,gBAAiBC,GACjB,YAAaC,GACb,YAAaC,GACb,eAAgBC,GAChB,KAAMC,GACN,QAASC,GACT,KAAMC,GACN,cAAeC,GACf,MAAOC,GACP,SAAUC,GACV,YAAaC,GACb,SAAUC,EACX,ECvwHA,IAAAE,GAA0B,gBAInB,IAAMC,GAA2B,uBAC3BC,GAA0B,sBAC1BC,GAAiB,2DAExBC,GAAMC,kBAAoC,EAW5CC,GAEJ,eAAsBC,GAAmBC,EAA4C,CACnF,IAAMC,EAAOD,GAAa,MAAO,KAEjC,GAAIC,EAAM,CACR,IAAMC,EAAaC,GAAK,KAAKF,CAAI,EACjC,GACEC,EAAW,eAAe,iBAAiB,mBACzCJ,IAAoB,eAAe,iBAAiB,mBACtDI,EAAW,eAAe,iBAAiB,0BACzCJ,IAAoB,eAAe,iBAAiB,yBACtD,CACAA,GAAqBI,EAErB,IAAME,EAAoB,QAAM,QAAI,QAAK,GAAG,EAAE,YAAYX,EAAwB,EAAE,IAAI,EAClFY,EAAmB,QAAM,QAAI,QAAK,GAAG,EAAE,YAAYX,EAAuB,EAAE,IAAI,EAEtFE,GAAI,KAAK,CAAE,yBAAAH,EAAyB,EAAG,+CAA+C,EACtF,MAAMa,GACJb,GACAW,EAAkB,MAClBT,GACAC,GACA,kBACF,EAEAA,GAAI,KAAK,CAAE,wBAAAF,EAAwB,EAAG,+CAA+C,EACrF,MAAMY,GACJZ,GACAW,EAAiB,MACjBV,GACAC,GACA,kBACF,CACF,CACF,CACF,CAnCsBW,EAAAR,GAAA,sBCtBtB,IAAAS,GAA0B,gBCJ1B,IAAMC,EAAY,CAAC,EACnB,QAASC,EAAI,EAAGA,EAAI,IAAK,EAAEA,EACvBD,EAAU,MAAMC,EAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC,EAE7C,SAASC,GAAgBC,EAAKC,EAAS,EAAG,CAC7C,OAAQJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EAC7BJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzBJ,EAAUG,EAAIC,EAAS,CAAC,CAAC,EACzB,IACAJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,EAC1BJ,EAAUG,EAAIC,EAAS,EAAE,CAAC,GAAG,YAAY,CACjD,CArBgBC,EAAAH,GAAA,mBCLhB,IAAAI,GAA+B,uBAC/B,IAAMC,GAAY,IAAI,WAAW,GAAG,EAChCC,GAAUD,GAAU,OACT,SAARE,IAAuB,CAC1B,OAAID,GAAUD,GAAU,OAAS,QAC7B,mBAAeA,EAAS,EACxBC,GAAU,GAEPD,GAAU,MAAMC,GAAUA,IAAW,EAAG,CACnD,CANwBE,EAAAD,GAAA,OCHxB,IAAAE,GAA2B,uBACpBC,GAAQ,CAAE,wBAAW,ECE5B,SAASC,GAAIC,EAASC,EAAKC,EAAQ,CAC/BF,EAAUA,GAAW,CAAC,EACtB,IAAMG,EAAOH,EAAQ,QAAUA,EAAQ,MAAM,GAAKI,GAAI,EACtD,GAAID,EAAK,OAAS,GACd,MAAM,IAAI,MAAM,mCAAmC,EAIvD,GAFAA,EAAK,CAAC,EAAKA,EAAK,CAAC,EAAI,GAAQ,GAC7BA,EAAK,CAAC,EAAKA,EAAK,CAAC,EAAI,GAAQ,IACzBF,EAAK,CAEL,GADAC,EAASA,GAAU,EACfA,EAAS,GAAKA,EAAS,GAAKD,EAAI,OAChC,MAAM,IAAI,WAAW,mBAAmBC,CAAM,IAAIA,EAAS,EAAE,0BAA0B,EAE3F,QAASG,EAAI,EAAGA,EAAI,GAAI,EAAEA,EACtBJ,EAAIC,EAASG,CAAC,EAAIF,EAAKE,CAAC,EAE5B,OAAOJ,CACX,CACA,OAAOK,GAAgBH,CAAI,CAC/B,CAnBSI,EAAAR,GAAA,OAoBT,SAASS,GAAGR,EAASC,EAAKC,EAAQ,CAC9B,OAAIO,GAAO,YAAc,CAACR,GAAO,CAACD,EACvBS,GAAO,WAAW,EAEtBV,GAAIC,EAASC,EAAKC,CAAM,CACnC,CALSK,EAAAC,GAAA,MAMT,IAAOE,GAAQF,GJpBR,IAAMG,GAA6B,eAE7BC,GAAoC,WACpCC,GAA+B,0BAEtCC,GAAMC,mBAAqC,EAUjD,eAAsBC,GACpBC,EACAC,EAAyB,GACzB,CACAD,EAAO,KAAOA,EAAO,MAAQ,CAAC,EAG9B,OAAOA,EAAO,UAAU,eAEpB,CAACA,EAAO,KAAKN,EAA0B,GAAKO,KAC9CJ,GAAI,KAAK,uCAAuC,EAChDG,EAAO,KAAKN,EAA0B,EAAI,OAAO,KAAKQ,GAAO,CAAC,EAAE,SAAS,QAAQ,EACjF,QAAM,QAAI,QAAK,MAAM,EAAE,MAAMF,CAAM,EAEvC,CAdsBG,EAAAJ,GAAA,+BKftB,SAASK,GAAgBC,EAAc,CACrC,OAAOA,EAAK,CAAC,IAAM,KAAOA,EAAKA,EAAK,OAAS,CAAC,IAAM,GACtD,CAFSC,EAAAF,GAAA,mBAIT,IAAMG,GAAU,wBACVC,GAAkB,IAAI,IAA2B,CACrD,OAEE,OAAO,OAAOC,EAAM,EAAE,OACpBC,GAAKA,IAAM,4BAAmCA,IAAM,uBACtD,CACF,EACA,WAAsB,mDAA8D,CAAC,CACvF,CAAC,EAED,eAAsBC,GAAgBC,EAAwC,CAC5E,IAAMC,EAASD,EAAI,IACbE,EAAaD,EAAO,MAAM,YAAc,CAAC,EAG/C,GAAI,CAACE,EAAU,sBACTF,EAAO,UAAU,YAAcN,GACjC,OAAOK,EAAI,KACT,sBAAsBC,EAAO,UAAU,SAAS,sBAAsBA,EAAO,UAAU,IAAI,cAAcN,EAAO,GAClH,EAKJ,QAAWS,KAAKF,EAAY,CAC1B,IAAMG,EAAWT,GAAgB,IAAIQ,EAAE,QAAQ,IAAK,EACpD,QAAWN,KAAKM,EAAE,SAChB,GAAI,CAACC,EAAS,SAASP,CAAC,EAAG,CACzB,IAAMQ,EACJF,EAAE,QAAQ,OAAS,sBACrB,OAAOJ,EAAI,KACT,iBAAiBI,EAAE,QAAQ,IAAI,kBAAkBA,EAAE,QAAQ,IAAI,kBAAkBN,CAAC,OAAOA,CAAC,oCAAoCQ,CAAS,GACzI,CACF,CAEJ,CAGA,QAAWF,KAAKF,EAAY,CAC1B,GAAIV,GAAgBY,EAAE,QAAQ,IAAI,EAChC,OAAOJ,EAAI,KACT,yBAAyBI,EAAE,QAAQ,IAAI,mDACzC,EAGF,GAAI,CACF,IAAI,OAAOA,EAAE,QAAQ,IAAI,CAC3B,OAASG,EAAK,CACZ,OAAOP,EAAI,KAAK,sCAAsCI,EAAE,QAAQ,IAAI,KAAKG,CAAG,EAAE,CAChF,CACF,CAEA,OAAOP,EAAI,QAAQ,CACrB,CA3CsBN,EAAAK,GAAA,mBCnBtB,IAAAS,GAA0B,gBAYnB,IAAMC,GAAU,IAAI,IAGrBC,GAAMC,wBAA0C,EAQ/C,SAASC,GAAWC,EAAgB,CACzC,IAAMC,EAAaD,EAAG,QAAQ,QAAU,WAClCE,EAAYF,EAAG,QAAQ,QAAU,UAEjCG,EACJH,EAAG,UAAU,mBACbA,EAAG,QAAQ,QAAU,YACrBA,EAAG,QAAQ,QAAU,gBACjBI,EAAsBJ,EAAG,UAAU,aAAeA,EAAG,QAAQ,mBAInE,OAAKJ,GAAQ,IAAII,EAAG,SAAU,GAAI,EAM9BC,GACFJ,GAAI,MAAMG,EAAI,2BAA2B,EAClC,IAILG,GACFN,GAAI,MAAMG,EAAI,4BAA4B,EACnC,IAILE,GAAaE,GACfP,GAAI,MAAMG,EAAI,yEAAyE,EAChF,KAGTH,GAAI,MAAMG,EAAI,4EAA4E,EAEnF,KAxBLH,GAAI,MAAMG,EAAI,kEAAkE,EACzE,GAwBX,CAtCgBK,EAAAN,GAAA,cA8ChB,eAAsBO,GAAaN,EAAgBO,EAAmB,CACpEV,GAAI,MAAM,YAAYG,EAAG,UAAU,IAAI,IAAIA,EAAG,UAAU,SAAS,cAAcO,EAAO,KAAK,EAAE,EAI7F,IAAMC,EAA2E,CAAE,GAAGD,CAAO,EACvFE,EAAaC,GAA+BV,CAAE,EAChDS,IACFD,EAAe,mBAAqBC,GAItC,QAAM,QAAIE,EAAU,EAAE,YAAY,CAChC,SAAU,CACR,KAAMX,EAAG,SAAU,KACnB,UAAWA,EAAG,SAAU,SAC1B,EACA,OAAQQ,CACV,CAAC,EAGDZ,GAAQ,IAAII,EAAG,SAAU,GAAI,CAC/B,CAtBsBK,EAAAC,GAAA,gBA+BtB,eAAsBM,GAAWZ,EAAiBa,EAAgC,CAChFhB,GAAI,MAAM,WAAWG,EAAG,UAAU,IAAI,IAAIA,EAAG,UAAU,SAAS,WAAWa,EAAM,OAAO,EAAE,EAE1F,QAAM,QAAI,QAAK,SAAS,EAAE,OAAO,CAC/B,KAAM,UACN,OAAQ,uBACR,GAAGA,EAEH,SAAU,CACR,UAAWb,EAAG,SAAU,UACxB,aAAcA,EAAG,SAAU,IAC7B,EACA,eAAgB,CACd,WAAYA,EAAG,WACf,KAAMA,EAAG,KACT,KAAMA,EAAG,SAAU,KACnB,UAAWA,EAAG,SAAU,UACxB,IAAKA,EAAG,SAAU,GACpB,EACA,eAAgB,IAAI,KACpB,mBAAoB,mBACpB,kBAAmB,QAAQ,IAAI,QACjC,CAAC,CACH,CAvBsBK,EAAAO,GAAA,cA+BtB,eAAsBE,GACpBC,EACAf,EACA,CACA,IAAMgB,EAAWhB,EAAG,SACdiB,EAAa,GAAGD,EAAS,SAAS,IAAIA,EAAS,IAAI,GACrDT,EAGJ,GAAIQ,EAAI,SAAW,IAAK,CACtBlB,GAAI,KAAK,CAAE,IAAAkB,CAAI,EAAG,6CAA6C,EAC/D,MACF,CAGA,IAAMG,EAAkBH,EAAI,MAAM,SAAWA,EAAI,QAE3CI,EAAenB,EAAG,QAAQ,cAAgB,EAGhD,GAAImB,EAAe,EAAG,CACpB,IAAMC,EAAYD,EAAe,EACjCtB,GAAI,MAAM,CAAE,IAAAkB,CAAI,EAAG,0BAA0BK,CAAS,eAAeH,CAAU,eAAe,EAE9FV,EAAS,CACP,iBACA,WAAYc,GAAuB,EAAK,EACxC,aAAcD,CAChB,CACF,MACEvB,GAAI,MAAM,CAAE,IAAAkB,CAAI,EAAG,qBAAqBE,CAAU,qBAAqB,EAEvEV,EAAS,CACP,eACA,WAAYc,GAAuB,EAAK,EACxC,mBAAoBL,EAAS,WAC7B,aAAc,CAChB,EAIF,MAAMJ,GAAWZ,EAAI,CAAE,QAASkB,CAAgB,CAAC,EAGjDZ,GAAaN,EAAIO,CAAM,EAAE,MAAMe,GAAY,CAEzCzB,GAAI,MAAM,CAAE,IAAKyB,CAAS,EAAG,6BAA6BL,CAAU,SAAS,EACxEL,GAAWZ,EAAI,CAAE,QAASsB,EAAS,OAAQ,CAAC,CACnD,CAAC,CACH,CAjDsBjB,EAAAS,GAAA,iBAmDf,SAASO,GAAuBE,EAAiB,GAAM,CAC5D,MAAO,CACL,CACE,KAAM,QACN,OAAQA,IAAU,kBAClB,mBAAoB,IAAI,KACxB,QACEA,IAAU,GAAO,gCAAkC,oCACrD,OAAQ,wBACV,CACF,CACF,CAXgBlB,EAAAgB,GAAA,0BCtLhB,IAAAG,EAA6B,gBAM7B,IAAMC,GAAMC,kBAAoC,EAE1CC,GAAkB,kBAClBC,GAAgB,0BAChBC,GAAyB,+BAEnBC,QACVA,IAAA,QAAU,WAAV,UACAA,IAAA,QAAU,WAAV,UACAA,EAAA,KAAO,OAHGA,QAAA,IAYZ,eAAsBC,GAAYC,EAAiB,CAGjD,GAAI,CAACA,EAAI,UAAU,WAAa,CAACA,EAAI,SAAS,KAC5C,MAAM,IAAI,MAAM,uDAAuD,EAGzE,IAAMC,EAAW,QAAM,OAAI,OAAK,SAAS,EAAE,IAAID,EAAI,SAAS,SAAS,EAC/DE,EAAS,CAAE,GAAID,EAAS,UAAU,QAAU,CAAC,CAAG,EAChDE,EAAc,CAAE,GAAIF,EAAS,UAAU,aAAe,CAAC,CAAG,EAC1DG,EAAS,eAAeJ,EAAI,SAAS,IAAI,GACzCK,EAAoBC,GAAqBJ,CAAM,EAGhDC,EAAYN,EAAsB,IACrCM,EAAYN,EAAsB,EAAIQ,GAGxC,IAAIE,EAAmB,OACvBJ,EAAYC,CAAM,EAAI,OAGlBJ,EAAI,MAAM,SAAS,aAAa,OAAS,UAE3CO,EAAmBT,GAAW,QAG9BS,EAAmBT,GAAW,QAGhC,IAAMU,EAASC,GAAeP,EAAQK,EAAkBF,CAAiB,EAGzE,MAAMK,GACJV,EAAI,SAAS,UACbQ,EAAO,OACPL,EACAF,EAAS,UAAU,OACnBA,EAAS,UAAU,WACrB,EAEA,MAAMU,GAAoBX,EAAI,SAAS,UAAWQ,EAAO,kBAAmBD,CAAgB,CAC9F,CA1CsBK,EAAAb,GAAA,eAkDtB,eAAsBc,GAAiBb,EAAiB,CACtD,GAAI,CAACA,EAAI,UAAU,WAAa,CAACA,EAAI,SAAS,KAC5C,MAAM,IAAI,MAAM,uDAAuD,EAGzE,IAAMC,EAAW,QAAM,OAAI,OAAK,SAAS,EAAE,IAAID,EAAI,SAAS,SAAS,EAC/DE,EAAS,CAAE,GAAID,EAAS,UAAU,QAAU,CAAC,CAAG,EAChDE,EAAc,CAAE,GAAIF,EAAS,UAAU,aAAe,CAAC,CAAG,EAC1Da,EAAeR,GAAqBJ,CAAM,EAC1Ca,EAAqBZ,EAAYN,EAAsB,EAG7D,OAAOM,EAAY,eAAeH,EAAI,SAAS,IAAI,EAAE,EAIrD,IAAMgB,EAAmB,OAAO,KAAKb,CAAW,EAAE,KAAKc,GAAOA,EAAI,WAAW,cAAc,CAAC,EAGxFT,EACAQ,EAEFR,EAAS,CAAE,OAAAN,EAAQ,kBAAmB,EAAM,GAG5CM,EAASC,GAAeP,EAAQa,EAAoBD,CAAY,EAGhE,OAAOX,EAAYN,EAAsB,GAI3C,MAAMa,GACJV,EAAI,SAAS,UACbQ,EAAO,OACPL,EACAF,EAAS,UAAU,OACnBA,EAAS,UAAU,YACnB,sBAAsBD,EAAI,SAAS,SAAS,cAAcA,EAAI,SAAS,IAAI,SAC7E,EAGA,MAAMW,GAAoBX,EAAI,SAAS,UAAWQ,EAAO,kBAAmBO,CAAkB,CAChG,CA3CsBH,EAAAC,GAAA,oBAmDtB,eAAsBK,GAASC,EAAYC,EAAsB,CAE/D,IAAMC,EAAO,QAAM,OAAI,OAAK,GAAG,EAAE,YAAYF,CAAE,EAAE,IAAI,EAC/CG,EAAqC,CAAC,EAG5C,QAAWC,KAAOF,EAAK,MAAO,CAE5B,GAAIE,EAAI,UAAU,kBAAmB,CACnC9B,GAAI,MAAM,gBAAgB0B,CAAE,IAAII,EAAI,UAAU,IAAI,yBAAyB,EAC3E,QACF,CAGA,IAAMC,EACJD,EAAI,MAAM,YAAY,KAAK,GAAK,EAAE,OAAS,aAAa,GACxDA,EAAI,MAAM,gBAAgB,KAAK,GAAK,EAAE,OAAS,aAAa,EAG9D,GAAIH,GAAeI,EAAc,CAC/B/B,GAAI,MAAM,gBAAgB0B,CAAE,IAAII,EAAI,UAAU,IAAI,uBAAuB,EACzE,QACF,CAGA,GAAI,CAACH,GAAe,CAACI,EAAc,CACjC/B,GAAI,MAAM,gBAAgB0B,CAAE,IAAII,EAAI,UAAU,IAAI,sBAAsB,EACxE,QACF,CAGA,IAAME,EAAeF,EAAI,UAAU,iBAAiB,KAAKG,GAAOA,EAAI,UAAU,GAAG,KAAO,QACxFJ,EAAOG,CAAY,EAAIH,EAAOG,CAAY,GAAK,CAAC,EAChDhC,GAAI,MAAM,cAAc0B,CAAE,IAAII,EAAI,UAAU,IAAI,OAAOE,CAAY,iBAAiB,EACpFH,EAAOG,CAAY,EAAE,KAAKF,CAAG,CAC/B,CAGA,QAAWI,KAAS,OAAO,OAAOL,CAAM,EAAG,CAErCK,EAAM,CAAC,EAAE,UAAU,iBAAiB,KAAKD,GAAOA,EAAI,OAAS,aAAa,GAC5EC,EAAM,KAAK,CAACC,EAAGC,KAAOA,EAAE,UAAU,MAAQ,IAAI,cAAcD,EAAE,UAAU,MAAQ,EAAE,CAAC,EAGrF,QAAWL,KAAOI,EAAO,CACvB,IAAMG,EAASV,EAAc,SAAW,SACxC3B,GAAI,KAAK,gBAAgB0B,CAAE,IAAII,EAAI,UAAU,IAAI,OAAOO,CAAM,oBAAoB,EAClF,QAAM,OAAI,OAAK,GAAG,EAAE,OAAOP,CAAG,CAChC,CACF,CACF,CAlDsBX,EAAAM,GAAA,YA0Df,SAASZ,GAAqBJ,EAA4C,CAC/E,OAAOA,EAAOP,EAAe,IAAM,UAC/BG,GAAW,QACXI,EAAON,EAAa,IAAM,UACxBE,GAAW,QACX,MACR,CANgBc,EAAAN,GAAA,wBAmBhB,eAAsBI,GACpBqB,EACA7B,EACAC,EACA6B,EACAC,EACAC,EACkB,CAClB,IAAMC,EAAmB,CACvB,SAAU,CACR,KAAMJ,EACN,OAAA7B,EACA,YAAAC,CACF,CACF,EAEA,MAAI,CAAC,IAAE,OAAO6B,EAAgB9B,CAAM,GAAK,CAAC,IAAE,OAAO+B,EAAqB9B,CAAW,GACjFV,GAAI,MAAMyC,GAAc,iCAAiCH,CAAS,GAAG,EACrE,QAAM,OAAI,OAAK,SAAS,EAAE,MAAMI,EAAkB,CAAE,MAAO,EAAK,CAAC,EAC1D,KAEP1C,GAAI,MAAM,mCAAmCsC,CAAS,GAAG,EAClD,GAEX,CAxBsBnB,EAAAF,GAAA,yBAiCtB,eAAeC,GACboB,EACAK,EACA7B,EACe,CACX6B,IACF3C,GAAI,MACF,sBAAsBsC,CAAS,+CAA+CxB,CAAgB,eAChG,EACIA,IAAqBT,GAAW,QAClC,MAAMoB,GAASa,EAAW,EAAI,GACrBxB,IAAqBT,GAAW,SAAWS,IAAqB,SACzE,MAAMW,GAASa,EAAW,EAAK,EAGrC,CAfenB,EAAAD,GAAA,uBAyBR,SAASF,GACdP,EACAmC,EACAvB,EACgE,CAChE,IAAIwB,EAAoB,GAExB,OAAID,IAAgBvC,GAAW,SAC7BI,EAAOP,EAAe,EAAI,UAC1B,OAAOO,EAAON,EAAa,EAEvBkB,IAAiBhB,GAAW,UAC9BwC,EAAoB,KAEbD,IAAgBvC,GAAW,SACpCI,EAAON,EAAa,EAAI,UACxB,OAAOM,EAAOP,EAAe,EAEzBmB,IAAiBhB,GAAW,UAC9BwC,EAAoB,MAItB,OAAOpC,EAAOP,EAAe,EAC7B,OAAOO,EAAON,EAAa,EAEvBkB,IAAiBhB,GAAW,UAC9BwC,EAAoB,KAIjB,CAAE,OAAApC,EAAQ,kBAAAoC,CAAkB,CACrC,CAhCgB1B,EAAAH,GAAA,kBCpQhB,IAAA8B,GAAiC,gBCAjC,IAAAC,GAAiC,gBCE1B,IAAIC,GAAU,uDAEjB,QAAQ,IAAI,YAAc,QAC5BA,GAAU,yBAGL,IAAMC,GAAMC,qBAAuC,EAS1D,eAAsBC,GAAmBC,EAAwBC,EAAkC,CACjG,GAAI,CAACD,EAAS,GAAI,CAChB,GAAM,CAAE,OAAAE,EAAQ,WAAAC,EAAY,KAAAC,CAAK,EAAIJ,EAC/BK,EAAM,IAAI,MAAM,GAAGH,CAAM,KAAKC,CAAU,KAAKC,EAAO,KAAK,UAAUA,CAAI,EAAI,EAAE,EAAE,EACrF,MAAIH,GACFA,EAAQI,CAAG,EAEPA,CACR,CACF,CATsBC,EAAAP,GAAA,sBDLf,SAASQ,GAAmBC,EAAe,CAChD,OAAO,KAAK,MAAM,OAAO,KAAKA,EAAM,MAAM,GAAG,EAAE,CAAC,EAAG,QAAQ,EAAE,SAAS,CAAC,CACzE,CAFgBC,EAAAF,GAAA,sBAIhB,IAAMG,GAAkB,GAAGC,EAAO,4BAC5BC,GAAuB,GAAGD,EAAO,4CACjCE,GAAmB,WACnBC,GAAc,0BACdC,GAAyB,eAC3BC,GAA6B,KAc1B,SAASC,IAAmB,CACjCD,GAAc,IAChB,CAFgBP,EAAAQ,GAAA,oBAIhB,eAAsBC,IAA4B,CAChD,GAAIF,GACF,GAAI,CACF,IAAMG,EAAMZ,GAAmBS,EAAW,EAC1C,GAAIG,EAAI,KAAOA,EAAI,IAAM,KAAK,MAAM,KAAK,IAAI,EAAI,GAAI,EAAI,EAAG,OAAOH,EACrE,OAASI,EAAG,CACVC,GAAI,MAAMD,EAAG,8BAA8B,EAC3CJ,GAAc,IAChB,CAGF,IAAMM,EAAS,QAAM,QAAI,QAAK,MAAM,EAAE,YAAYT,EAAgB,EAAE,IAAIC,EAAW,EACnF,GAAI,CAACQ,EAAQ,MAAM,IAAI,MAAM,gBAAgB,EAC7C,IAAMC,EAAgBD,EAAO,OAAOP,EAAsB,EAC1D,GAAI,CAACQ,EAAe,MAAM,IAAI,MAAM,uBAAuB,EAE3D,IAAMC,EAAe,OAAO,KAAKD,EAAe,QAAQ,EAAE,SAAS,OAAO,EACpEE,EAAS,IAAI,gBACnBA,EAAO,OAAO,aAAc,oBAAoB,EAChDA,EAAO,OAAO,YAAaV,EAAsB,EACjDU,EAAO,OAAO,gBAAiBD,CAAY,EAE3C,IAAME,EAAW,QAAM,UAAmCd,GAAsB,CAC9E,OAAQ,OACR,QAAS,CAAE,eAAgB,mCAAoC,EAC/D,KAAMa,EAAO,SAAS,CACxB,CAAC,EACD,aAAME,GAAmBD,CAAQ,EACjCV,GAAcU,EAAS,KAAK,aACrBV,EACT,CA9BsBP,EAAAS,GAAA,6BAgCtB,eAAsBU,GAA0BC,EAAyB,CAGvE,OAFAR,GAAI,KAAK,uDAAuD,KAAK,UAAUQ,CAAM,CAAC,EAAE,EACjE,MAAMC,GAAeD,CAAM,EAEzCE,GAAkBF,CAAM,EAExBG,GAAkBH,CAAM,CAEnC,CARsBpB,EAAAmB,GAAA,6BAUtB,eAAsBI,GAAkBH,EAAyB,CAC/DR,GAAI,KAAK,sCAAsC,KAAK,UAAUQ,CAAM,CAAC,EAAE,EACvE,IAAMrB,EAAQ,MAAMU,GAA0B,EACxCQ,EAAW,QAAM,UAAMhB,GAAiB,CAC5C,OAAQ,OACR,QAAS,CAAE,eAAgB,mBAAoB,cAAe,UAAUF,CAAK,EAAG,EAChF,KAAM,KAAK,UAAUqB,CAAM,CAC7B,CAAC,EACD,aAAMF,GAAmBD,EAAU,IAAM,CACvCT,GAAiB,CACnB,CAAC,EACMa,GAAeD,CAAM,CAC9B,CAZsBpB,EAAAuB,GAAA,qBActB,eAAsBF,GAAeD,EAAyB,CAC5DR,GAAI,KAAK,qCAAqC,KAAK,UAAUQ,CAAM,CAAC,EAAE,EACtE,IAAMrB,EAAQ,MAAMU,GAA0B,EACxCe,EAAM,GAAGvB,EAAe,aAAa,mBAAmBmB,EAAO,QAAS,CAAC,GAKzEH,EAAW,QAAM,UAAsBO,EAAK,CAChD,OAAQ,MACR,QAAS,CAAE,eAAgB,mBAAoB,cAAe,UAAUzB,CAAK,EAAG,CAClF,CAAC,EACD,aAAMmB,GAAmBD,EAAU,IAAM,CACvCT,GAAiB,CACnB,CAAC,EACMS,EAAS,KAAK,CAAC,CACxB,CAhBsBjB,EAAAqB,GAAA,kBAkBtB,eAAsBC,GAAkBF,EAAyB,CAC/DR,GAAI,KAAK,sCAAsC,KAAK,UAAUQ,CAAM,CAAC,EAAE,EACvE,IAAMrB,EAAQ,MAAMU,GAA0B,EACxCgB,EAAW,MAAMJ,GAAeD,CAAM,EAC5C,GAAI,CAACK,GAAY,CAACA,EAAS,GACzB,MAAM,IAAI,MAAM,uCAAuCL,EAAO,QAAQ,EAAE,EAE1E,IAAMI,EAAM,GAAGvB,EAAe,IAAI,mBAAmBwB,EAAS,EAAE,CAAC,GAC3DR,EAAW,QAAM,UAAMO,EAAK,CAChC,OAAQ,MACR,QAAS,CAAE,eAAgB,mBAAoB,cAAe,UAAUzB,CAAK,EAAG,EAChF,KAAM,KAAK,UAAUqB,CAAM,CAC7B,CAAC,EACD,aAAMF,GAAmBD,EAAU,IAAM,CACvCT,GAAiB,CACnB,CAAC,EACMa,GAAeD,CAAM,CAC9B,CAjBsBpB,EAAAsB,GAAA,qBAmBtB,eAAsBI,GAAkBN,EAAyB,CAC/DR,GAAI,KAAK,sCAAsC,KAAK,UAAUQ,CAAM,CAAC,EAAE,EACvE,IAAMrB,EAAQ,MAAMU,GAA0B,EACxCgB,EAAW,MAAMJ,GAAeD,CAAM,EAC5C,GAAI,CAACK,GAAY,CAACA,EAAS,GACzB,MAAM,IAAI,MAAM,uCAAuCL,EAAO,QAAQ,EAAE,EAE1E,IAAMI,EAAM,GAAGvB,EAAe,IAAI,mBAAmBwB,EAAS,EAAE,CAAC,GAC3DR,EAAW,QAAM,UAAMO,EAAK,CAChC,OAAQ,SACR,QAAS,CAAE,eAAgB,mBAAoB,cAAe,UAAUzB,CAAK,EAAG,CAClF,CAAC,EACD,MAAMmB,GAAmBD,EAAU,IAAM,CACvCT,GAAiB,CACnB,CAAC,CACH,CAfsBR,EAAA0B,GAAA,qBEjGf,IAAMC,GAAa,CACxB,WACA,yBACA,aACA,qCACA,UACA,aACA,0BACA,WACA,kBACA,sBACA,eACA,4BACA,UACA,qBACA,mBACA,sBACA,OACA,4BACA,YACA,uBACA,WACA,kBACA,eACA,eACA,0BACA,SACA,yBACA,sBACA,wBACA,aACA,oBACF,EH3DA,IAAMC,GACJ,2FAGIC,GAAsB,IAAI,OAC9B,sEACA,IACF,EAGMC,GAAwB,IAAI,OAChC,sEACF,EAGMC,GAAgB,IAAI,OACxB,oEACF,EAGMC,GAAMC,qBAAuC,EASnD,eAAsBC,GAASC,EAAiB,CAE9C,IAAMC,EAAaD,EAAI,MAAM,KAAO,CAAC,EAC/BE,EAA+B,IAAI,IACnCC,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EAE5D,QAAWI,KAAaH,EAAY,CAClC,IAAMI,EAAS,MAAMC,GAAWF,EAAWJ,CAAG,EAC9CE,EAAQ,IAAIG,EAAO,SAAUA,CAAM,CACrC,CAGA,GAAI,CACF,MAAME,GAAgBP,EAAK,CAAC,GAAGE,EAAQ,KAAK,CAAC,CAAC,CAChD,OAASM,EAAG,CACVX,GAAI,MAAMW,EAAG,2CAA2CR,EAAI,SAAU,IAAK,KAAKQ,CAAC,EAAE,CACrF,CAGA,GAAI,CACF,MAAMC,EAAaN,EAAYH,EAAI,SAAU,UAAYA,EAAI,SAAU,KAAO,QAAK,OAAQH,EAAG,CAChG,OAASW,EAAG,CACVX,GAAI,MAAMW,EAAG,+CAA+CR,EAAI,SAAU,IAAK,KAAKQ,CAAC,EAAE,CACzF,CAEA,OAAON,CACT,CA1BsBQ,EAAAX,GAAA,YAkCtB,eAAsBQ,GAAgBP,EAAiBW,EAAuB,CAAC,EAAG,CAGhF,IAAMC,GADiBZ,EAAI,QAAQ,YAAc,CAAC,GAClB,OAAOK,GAAU,CAACM,EAAW,SAASN,CAAM,CAAC,EAC7E,QAAWQ,KAAOD,EAChB,GAAI,CACF,MAAME,GAAkB,CAAE,SAAUD,CAAI,CAAC,CAC3C,OAASE,EAAK,CACZ,MAAAlB,GAAI,KACFG,EAAI,SACJ,2BAA2Ba,CAAG,aAAab,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,YAAYe,EAAI,OAAO,EACjH,EACM,IAAI,MACR,2BAA2BF,CAAG,aAAab,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,YAAYe,EAAI,OAAO,EACjH,CACF,CAEJ,CAjBsBL,EAAAH,GAAA,mBAyBf,SAASS,GAAmBC,EAA2B,CAC5D,IAAMZ,EAA0B,CAAC,EAGjC,QAAWa,KAAOC,GACZD,KAAOD,IACRZ,EAAmCa,CAAG,EAAID,EAAIC,CAAgB,GAKnE,OAAAb,EAAO,WAAaA,EAAO,YAAc,CAAC,EAEtCY,EAAI,QAAQ,MACdZ,EAAO,WAAW,iBAAiB,EAAI,KAAK,UAAUY,EAAI,MAAM,EAEhEZ,EAAO,WAAW,iBAAiB,EAAI,GAIlCA,CACT,CArBgBK,EAAAM,GAAA,sBAuBhB,eAAsBV,GACpB,CAAE,WAAAc,EAAY,eAAAC,EAAgB,GAAGjB,CAAU,EAC3CJ,EACAsB,EAAU,GACV,CACAzB,GAAI,MAAMG,EAAI,SAAU,8BAA8BI,EAAU,QAAQ,EAAE,EAG1E,IAAMmB,EAAO,cAAcnB,EAAU,QAAQ,GACzCC,EAASW,GAAmBZ,CAAS,EAEzC,GAAI,CACFC,EAAS,MAAMmB,GAA0BnB,CAAM,CACjD,OAASU,EAAK,CACZ,IAAMU,EACJ,kDAAkDpB,EAAO,QAAQ,cAC9DL,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,YAAYe,EAAI,OAAO,GAGzE,GAAIO,EACF,MAAAzB,GAAI,MAAM,GAAG4B,CAAG,iBAAiB,EAE3B,IAAI,MAAMA,CAAG,EAGnB5B,GAAI,MAAM,GAAG4B,CAAG,eAAe,EAE/B,GAAI,CAEF,OAAO,MAAMnB,GAAW,CAAE,WAAAc,EAAY,eAAAC,EAAgB,GAAGjB,CAAU,EAAGJ,EAAK,EAAI,CACjF,OAAS0B,EAAU,CAEjB,IAAMC,EACJ,gDAAgDtB,EAAO,QAAQ,cAC5DL,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,YAAY0B,EAAS,OAAO,GAC9E,MAAA7B,GAAI,MAAM8B,CAAQ,EAEZ,IAAI,MAAMF,CAAG,CACrB,CAEJ,CAUA,GAPA,OAAOpB,EAAO,wBAEVA,EAAO,WAAa,SACtBA,EAAO,mBAAqB,MAAMuB,GAAmB,GAInD,CAACvB,EAAO,aAAc,CACxB,IAAMF,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtD6B,EAAsBC,EAAqBV,GAAcG,CAAI,EAG7DQ,EAAuC,CAC3C,cAAe/B,EAAI,SAAU,MAAQ,GACrC,iBAAkBG,CACpB,EAGIC,EAAU,cACZ,OAAO,OAAO2B,EAAc3B,EAAU,YAAY,EAIpD,IAAM4B,EAA4C,CAAC,EAG/C5B,EAAU,mBACZ,OAAO,OAAO4B,EAAmB5B,EAAU,iBAAiB,EAG9D,QAAM,QAAI,QAAK,MAAM,EAAE,MAAM,CAC3B,SAAU,CACR,UAAWJ,EAAI,SAAU,UAEzB,KAAM6B,EACN,OAAQE,EACR,YAAaC,EAGb,gBAAiBC,EAAYjC,CAAG,CAClC,EACA,KAAMkC,GAAmB7B,EAAQgB,CAAc,CACjD,CAAC,CACH,CAEA,OAAOhB,CACT,CAzFsBK,EAAAJ,GAAA,cA2Ff,SAAS4B,GAAmB7B,EAAgBgB,EAA4C,CAC7F,GAAIA,EACF,OAAAxB,GAAI,MAAM,qCAAqCQ,EAAO,QAAQ,EAAE,EAEzD8B,GAAad,EAAgBhB,CAAM,EAG5C,IAAM+B,EAAoC,CAAC,EAE3CvC,GAAI,MAAM,iCAAiCQ,EAAO,QAAQ,EAAE,EAG5D,OAAW,CAACa,EAAKmB,CAAK,IAAK,OAAO,QAAQhC,CAAM,EAAG,CAEjD,IAAMiC,EAAY,OAAOD,GAAU,SAAW,KAAK,UAAUA,CAAK,EAAI,OAAOA,CAAK,EAGlFD,EAAUlB,CAAG,EAAI,OAAO,KAAKoB,CAAS,EAAE,SAAS,QAAQ,CAC3D,CAEA,OAAOF,CACT,CArBgB1B,EAAAwB,GAAA,sBAuBhB,eAAsBN,IAAqB,CACzC,IAAMW,EAAO,QAAM,UAAc9C,EAAiB,EAElD,GAAK8C,EAAK,GAIV,OAAOC,GAA8BD,EAAK,IAAI,CAChD,CARsB7B,EAAAkB,GAAA,sBAUf,SAASY,GAA8BC,EAAmB,CAE/D,OADkCA,EAAU,MAAM9C,EAAqB,IAAI,CAAC,GAAK,IAChD,MAAMC,EAAa,IAAI,CAAC,GAAK,EAChE,CAHgBc,EAAA8B,GAAA,iCAYhB,SAASL,GAAad,EAA2ChB,EAAgB,CAC/E,IAAM+B,EAAoC,CAAC,EAG3C,OAAW,CAAClB,EAAKmB,CAAK,IAAK,OAAO,QAAQhB,CAAc,EAAG,CAEzD,IAAMqB,EAAYL,EAAM,QACtB3C,GACA,CAACiD,EAAQC,EAAyB1B,EAAK2B,IAAS,CAE9C,IAAMR,EAAQhC,EAAOuC,CAAS,EAG9B,OAAI1B,EACK,OAAOmB,EAAMnB,CAAG,GAAK,EAAE,EAI5B2B,EACK,KAAK,UAAUR,CAAK,EAItBA,IAAU,OAAY,OAAOA,CAAK,EAAI,EAC/C,CACF,EAGAD,EAAUlB,CAAG,EAAI,OAAO,KAAKwB,CAAS,EAAE,SAAS,QAAQ,CAC3D,CAGA,OAAON,CACT,CAjCS1B,EAAAyB,GAAA,gBI9PT,IAAAW,GAAoB,gBASpB,IAAMC,GAAMC,uBAAyC,EAQrD,eAAsBC,GAAWC,EAAiBC,EAAmB,CACnE,IAAMC,EAAUF,EAAI,SAAU,KACxBG,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDI,EAAYC,EAAYL,CAAG,EAEjCH,GAAI,MAAM,+BAA+BK,CAAO,EAAE,EAGlD,IAAMI,EAAcN,EAAI,MAAM,SAAW,CAAC,EAGpCO,EAAmC,CAAC,EAE1C,GAAI,CACF,QAAWC,KAAWF,EACpB,GAAIE,EAAQ,OAAS,aAAiB,CACpC,IAAMC,EAAUC,GAAmBF,EAASP,EAAWC,EAASC,EAAYC,CAAS,EAErFP,GAAI,MAAMY,EAAS,uBAAuBA,EAAQ,UAAU,IAAI,EAAE,EAGlE,QAAM,QAAIE,EAAoB,EAAE,MAAMF,EAAS,CAAE,MAAO,EAAK,CAAC,EAE9DF,EAAS,KAAKE,CAAO,CACvB,CAGF,MAAMG,EAAaT,EAAYF,EAAWC,EAASS,GAAsBd,EAAG,CAC9E,OAASgB,EAAK,CACZ,MAAM,IAAI,MAAM,qCAAqCX,CAAO,YAAY,KAAK,UAAUW,CAAG,CAAC,EAAE,CAC/F,CAGA,MAAO,CAAC,GAAGN,EAAS,IAAIO,GAAKA,EAAE,SAAU,IAAK,CAAC,CACjD,CAlCsBC,EAAAhB,GAAA,cAoCf,SAASW,GACdF,EACAP,EACAC,EACAC,EACAC,EACA,CACA,GAAM,CAAE,SAAAY,EAAU,YAAAC,EAAa,SAAAC,CAAS,EAAIV,EA6B5C,MA3BsC,CACpC,SAAU,CACR,KAHSW,GAAoBjB,EAASM,CAAO,EAI7C,UAAAP,EACA,OAAQ,CACN,cAAeC,EACf,iBAAkBC,CACpB,EACA,gBAAiBC,CACnB,EACA,KAAM,CACJ,oBAAqB,CACnB,CACE,KAAMc,EACN,KAAMV,EAAQ,MAAQ,WACtB,cAAeA,EAAQ,aACzB,CACF,EACA,SAAU,CACR,YAAaS,GAAeD,CAC9B,EAEA,uBACER,EAAQ,wBAA0B,qBACtC,CACF,CAGF,CArCgBO,EAAAL,GAAA,sBCtDhB,IAAAU,GAAoB,gBAWpB,IAAMC,GAAMC,uBAAyC,EAQrD,eAAsBC,GAAeC,EAAiBC,EAAmB,CACvE,IAAMC,EAAUF,EAAI,SAAU,KACxBG,GAAcH,EAAI,UAAU,YAAc,GAAG,SAAS,EACtDI,EAAYC,EAAYL,CAAG,EAEjCH,GAAI,MAAM,mCAAmCK,CAAO,EAAE,EAGtD,IAAMI,EAAcN,EAAI,MAAM,SAAW,CAAC,EAGpCO,EAAuC,CAAC,EAE9C,GAAI,CACF,QAAWC,KAAWF,EACpB,GAAIE,EAAQ,OAAS,aAAiB,CACpC,IAAMC,EAAUC,GAAuBF,EAASP,EAAWC,EAASC,EAAYC,CAAS,EAEzFP,GAAI,MAAMY,EAAS,2BAA2BA,EAAQ,UAAU,IAAI,EAAE,EAGtE,QAAM,QAAIE,EAAwB,EAAE,MAAMF,EAAS,CAAE,MAAO,EAAK,CAAC,EAElEF,EAAS,KAAKE,CAAO,CACvB,CAGF,MAAMG,EAAaT,EAAYF,EAAWC,EAASS,GAA0Bd,EAAG,CAClF,OAASgB,EAAK,CACZ,MAAM,IAAI,MACR,yCAAyCX,CAAO,YAAY,KAAK,UAAUW,CAAG,CAAC,EACjF,CACF,CAGA,MAAO,CAAC,GAAGN,EAAS,IAAIO,GAAKA,EAAE,SAAU,IAAK,CAAC,CACjD,CApCsBC,EAAAhB,GAAA,kBAsCf,SAASW,GACdF,EACAP,EACAC,EACAC,EACAC,EACA,CACA,GAAM,CAAE,SAAAY,EAAU,SAAAC,CAAS,EAAIT,EA6B/B,MA3B0C,CACxC,SAAU,CACR,KAHSU,GAAoBhB,EAASM,CAAO,EAI7C,UAAAP,EACA,OAAQ,CACN,cAAeC,EACf,iBAAkBC,CACpB,EACA,gBAAiBC,CACnB,EACA,KAAM,CACJ,UAAW,CACT,CACE,KAAMa,EACN,KAAMT,EAAQ,MAAQ,WACtB,cAAeA,EAAQ,aACzB,CACF,EACA,SAAU,CACR,YAAaQ,CACf,EAEA,uBACER,EAAQ,wBAA0B,qBACtC,CACF,CAGF,CArCgBO,EAAAL,GAAA,0BCzDhB,IAAAS,GAAoB,gBAuBpB,IAAMC,GAAMC,oBAAsC,EAQlD,SAASC,GAAoBC,EAA0B,CACrD,IAAMC,EAAWD,EAAQ,aAAeA,EAAQ,UAAY,CAAC,EACvDE,EAAWF,EAAQ,YAAY,SAAS,GAAK,eAC7CG,EACJF,EAAS,KAAQ,QAAQ,QAAS,EAAE,IACnCA,EAAS,wBAAwB,EAC9BA,EAAS,wBAAwB,EAAE,QAAQ,QAAS,EAAE,EAAI,YAC1D,UACH,OAAO,OAAOA,CAAQ,EAAE,KAAK,GAAG,GAAK,YACxC,MAAO,WAAWC,CAAQ,IAAIC,CAAQ,EACxC,CAVSC,EAAAL,GAAA,uBAiBT,SAASM,GAAkBC,EAAqB,CAC9C,GAAM,CAAE,YAAAC,EAAa,SAAAN,EAAU,gBAAAO,EAAiB,gBAAAC,EAAiB,eAAAC,CAAe,EAAIJ,EAYpF,MAAO,WAVLC,GACA,CACE,OAAO,OAAON,GAAY,CAAE,QAAS,UAAW,CAAC,EAAE,KAAK,GAAG,EAC3DO,GAAmB,CACjBC,GAAmB,UACnB,OAAO,OAAOC,GAAkB,CAAE,QAAS,UAAW,CAAC,EAAE,KAAK,GAAG,CACnE,CACF,EACG,KAAK,EACL,KAAK,GAAG,CACa,EAC5B,CAdSN,EAAAC,GAAA,qBAmBT,SAASM,GAAmBL,EAAsB,CAChD,IAAMM,EAAgBN,EAAK,YAAcA,EAAK,KACxCO,EAAUP,EAAK,SAAW,OAAO,OAAOA,EAAK,QAAQ,EAAE,KAAK,GAAG,EAAI,MACnEQ,EAAUR,EAAK,SAAW,SAChC,MAAO,WAAWM,CAAa,IAAIC,CAAO,UAAUC,CAAO,UAC7D,CALSV,EAAAO,GAAA,sBAUT,SAASI,GAAiBT,EAAaU,EAA2D,CAChG,IAAMC,EAAkB,CAAC,EACrBX,EAAK,OAAS,QAAWW,EAAM,KAAKX,EAAK,KAAK,SAAS,CAAC,EACxDA,EAAK,OAAOW,EAAM,KAAK,GAAGX,EAAK,MAAM,IAAIY,GAAKA,EAAE,SAAS,CAAC,CAAC,EAE/D,IAAIC,EAAiB,CAAC,EAEhBC,EAAcd,EAAK,sBAAsB,KAAK,EAC9Ce,EAAcf,EAAK,iBAAiB,KAAK,EAE/C,GAAIc,EAEFD,EAAS,CACP,WAAY,CAAC,oBAFJE,GAAeL,CAEW,OAAOV,EAAK,oBAAoB,EAAE,CACvE,UACSA,EAAK,WACda,EAAS,CAAE,SAAU,CAACb,EAAK,UAAU,CAAE,UAC9BA,EAAK,gBACd,OAAQA,EAAK,gBAAiB,CAC5B,oBACEa,EAAS,CAAE,SAAU,CAACG,EAAO,CAAE,EAC/B,MACF,cACEH,EAAS,CACP,SAAUI,GAAQ,EACf,IAAKC,GAAyCA,EAAK,SAAS,IAAI,EAChE,OAAQC,GAAyB,OAAOA,GAAS,QAAQ,CAC9D,EACA,MACF,gBACEN,EAAS,CACP,SAAUO,GAAU,EACjB,IAAKF,GAAyCA,EAAK,SAAS,IAAI,EAChE,OAAQC,GAAyB,OAAOA,GAAS,QAAQ,CAC9D,EACA,MACF,qBACEN,EAAS,CAAE,WAAY,CAACH,CAAY,CAAE,EACtC,MACF,eACEG,EAAS,CAAC,EACV,KACJ,MACSb,EAAK,kBAAoB,IAAMA,EAAK,kBAAoB,IACjEa,EAAS,CAAC,EACDb,EAAK,kBACda,EAAS,CAAE,WAAY,CAACb,EAAK,eAAe,CAAE,GAEhD,MAAO,CAAE,OAAAa,EAAQ,MAAAF,CAAM,CACzB,CAjDSb,EAAAW,GAAA,oBAsDT,SAASY,GAAkBrB,EAAmD,CAC5E,IAAMW,EAAkB,CAAC,EACnBL,EAAgBN,EAAK,YAAcA,EAAK,KAC1CM,IAAkB,QACpBK,EAAM,KAAKL,EAAc,SAAS,CAAC,EAErC,IAAME,EAAUR,EAAK,SAAW,SAIhC,MAAO,CAAE,OAHM,CACb,WAAY,CAAC,0BAA0BQ,CAAO,eAAeA,CAAO,iBAAiB,CACvF,EACiB,MAAAG,CAAM,CACzB,CAXSb,EAAAuB,GAAA,qBAgBT,SAASC,GAAQC,EAAsB,CACrC,OAAO,OAAO,KAAKA,CAAG,EAAE,SAAW,CACrC,CAFSzB,EAAAwB,GAAA,WAQT,SAASE,GACPC,EACAC,EACA/B,EACAkB,EACAF,EACAgB,EACqB,CACrB,IAAMC,EAAkB,CAAC,EACpBN,GAAQT,CAAM,IACjBe,EAAU,KAAO,CAAC,CAAE,OAAAf,CAAO,CAAC,GAE1BF,EAAM,OAAS,IACjBiB,EAAU,GAAK,CAAC,CAAE,UAAW,CAAE,MAAAjB,CAAM,CAAE,CAAC,GAG1C,IAAMkB,EAAUH,EAAI,UAAU,MAAQ,UAChChB,EAAegB,EAAI,UAAU,WAAa,UAC1CI,EAAaJ,EAAI,UAAU,YAAY,SAAS,GAAK,IAE3D,MAAO,CACL,WAAY,4BACZ,KAAM,sBACN,SAAU,CACR,KAAMD,EACN,UAAWf,EACX,OAAQ,CACN,cAAemB,EACf,iBAAkBC,EAClB,UAAW,UACX,GAAGH,CACL,EACA,gBAAiBI,EAAYL,CAAG,CAClC,EACA,KAAM,CACJ,eACA,GAAI/B,EAAW,CAAE,SAAU,CAAE,YAAaA,CAAS,CAAE,EAAI,CAAC,EAC1D,MAAO,CAACiC,CAAS,CACnB,CACF,CACF,CAxCS9B,EAAA0B,GAAA,mBAgDT,eAAsBQ,GACpBN,EACAhB,EACAuB,EACgC,CAChC,IAAMJ,EAAUH,EAAI,UAAU,MAAQ,UAChCI,EAAaJ,EAAI,UAAU,YAAY,SAAS,GAAK,IAC3DnC,GAAI,KACF,yDAAyDsC,CAAO,mBAAmBnB,CAAY,iBAAiBoB,CAAU,IAC5H,EAEA,IAAMI,EAAkC,CAAC,EAGzC,GAAIR,EAAI,MAAM,SAAS,MACrB,QAAW1B,KAAQ0B,EAAI,KAAK,QAAQ,MAAO,CACzC,GAAI1B,EAAK,YAAc,SAAU,SAEjC,IAAMmC,EAAMC,GAAsBV,EAAK1B,EAAK,QAAQ,EAC9C,CAAE,OAAAa,EAAQ,MAAAF,CAAM,EAAIF,GAAiBT,EAAMU,CAAY,EAE7D,GAAIyB,EAAK,CAEP,IAAME,EAAeC,EAAgBH,EAAI,QAAQ,EAC3CI,EAAmB,CAAE,wBAAyBF,CAAa,EAE3DZ,EAAae,EACjB,WAAWX,CAAO,UAAU9B,GAAkBC,CAAI,CAAC,IAAIqC,CAAY,EACrE,EAEMV,EAAuD3B,EAAK,gBAC9D,CAAE,gBAAiBA,EAAK,gBAAiB,eAAgBqC,CAAa,EACtE,CAAE,eAAgBA,CAAa,EAE7BI,EAAajB,GACjBC,EACAC,EACAa,EACA1B,EACAF,EACAgB,CACF,EACAO,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,qCAAqCkD,EAAW,UAAU,IAAI,EAAE,CAC5E,KAAO,CAEL,IAAMhB,EAAae,EAAqB,WAAWX,CAAO,IAAI9B,GAAkBC,CAAI,CAAC,EAAE,EACjF2B,EAAuD3B,EAAK,gBAC9D,CAAE,gBAAiBA,EAAK,eAAgB,EACxC,OACEyC,EAAajB,GACjBC,EACAC,EACA1B,EAAK,SACLa,EACAF,EACAgB,CACF,EACAO,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,4BAA4BkD,EAAW,UAAU,IAAI,EAAE,CACnE,CACF,CAIF,GAAIf,EAAI,MAAM,SAAS,OACrB,QAAW1B,KAAQ0B,EAAI,KAAK,QAAQ,OAAQ,CAC1C,IAAMS,EAAMC,GAAsBV,EAAK1B,EAAK,QAAQ,EAEpD,GAAImC,EAAK,CAEP,IAAME,EAAeC,EAAgBH,EAAI,QAAQ,EAC3C,CAAE,OAAAtB,CAAO,EAAIQ,GAAkBrB,CAAI,EACnC0C,EAAgB1C,EAAK,KAAO,CAACA,EAAK,KAAK,SAAS,CAAC,EAAI,CAAC,EAE5D,GAAI0C,EAAc,OAAS,EAAG,CAC5B,IAAMC,EACJ,OAAO,QAAQ3C,EAAK,UAAY,CAAC,CAAC,EAC/B,IAAI,CAAC,CAAC4C,EAAGC,CAAC,IAAM,GAAGD,CAAC,IAAIC,CAAC,EAAE,EAC3B,KAAK,GAAG,GAAK,MAEZpB,EAAae,EACjB,WAAWX,CAAO,YAAY7B,EAAK,MAAQ,MAAM,IAAI2C,CAAW,IAAIN,CAAY,EAClF,EAGMI,EAAajB,GACjBC,EACAC,EAHuB,CAAE,wBAAyBW,CAAa,EAK/DxB,EACA6B,CACF,EACAR,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,+BAA+BkD,EAAW,UAAU,IAAI,EAAE,CACtE,MACElD,GAAI,KACF,CACE,SAAUS,EAAK,SACf,QAAS6B,CACX,EACA,2CACF,CAEJ,KAAO,CAEL,GAAM,CAAE,OAAAhB,EAAQ,MAAAF,CAAM,EAAIU,GAAkBrB,CAAI,EAC1CyB,EAAae,EAAqB,WAAWX,CAAO,IAAIxB,GAAmBL,CAAI,CAAC,EAAE,EAClFyC,EAAajB,GAAgBC,EAAYC,EAAK1B,EAAK,SAAUa,EAAQF,CAAK,EAChFuB,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,sBAAsBkD,EAAW,UAAU,IAAI,EAAE,CAC7D,CACF,CAIF,GAAIf,EAAI,MAAM,QACZ,QAAWhC,KAAWgC,EAAI,KAAK,QAAS,CACtC,IAAM/B,EAAWD,EAAQ,aAAeA,EAAQ,SAC1CmB,EAAiB,CAAE,WAAY,CAACiC,EAAoB,CAAE,EACtDnC,EAAkB,CAACjB,EAAQ,WAAW,SAAS,CAAC,EAGhDyC,EAAMC,GAAsBV,EAAK/B,CAAQ,EAE/C,GAAIwC,EAAK,CAEP,IAAME,EAAeC,EAAgBH,EAAI,QAAQ,EAC3CI,EAAmB,CAAE,wBAAyBF,CAAa,EAE3DZ,EAAae,EACjB,WAAWX,CAAO,YAAYpC,GAAoBC,CAAO,CAAC,IAAI2C,CAAY,EAC5E,EAEMI,EAAajB,GAAgBC,EAAYC,EAAKa,EAAkB1B,EAAQF,EAAO,CACnF,eAAgB0B,CAClB,CAAC,EACDH,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,uCAAuCkD,EAAW,UAAU,IAAI,EAAE,CAC9E,KAAO,CAEL,IAAMhB,EAAae,EACjB,WAAWX,CAAO,IAAIpC,GAAoBC,CAAO,CAAC,EACpD,EACM+C,EAAajB,GAAgBC,EAAYC,EAAK/B,EAAUkB,EAAQF,CAAK,EAC3EuB,EAAS,KAAKO,CAAU,EACxBlD,GAAI,MAAM,8BAA8BkD,EAAW,UAAU,IAAI,EAAE,CACrE,CACF,CAIF,GAAIf,EAAI,MAAM,KAAOqB,GAAyBrB,CAAG,EAC/C,QAAWS,KAAOT,EAAI,KAAK,IAAK,CAC9B,GAAI,CAACS,EAAI,0BAA2B,SAEpC,IAAME,EAAeC,EAAgBH,EAAI,QAAQ,EAC3Ca,EAAcb,EAAI,0BAGlBc,EAAaC,GAAkCxB,EAAKW,EAAcW,CAAW,EACnFd,EAAS,KAAKe,CAAU,CAC1B,CAMF,GAAIhB,IAAckB,GAAW,QAAS,CACpC,IAAMC,EAAkBZ,EACtB,WAAWX,CAAO,wCACpB,EACMwB,EAAc7B,GAClB4B,EACA1B,EACA,CAAC,EACD,CAAE,WAAY,CAACoB,EAAoB,CAAE,EACrC,CAAC,OAAO,CACV,EACAZ,EAAS,KAAKmB,CAAW,EACzB9D,GAAI,MACF,yDAAyD8D,EAAY,UAAU,IAAI,EACrF,CACF,CAGA,QAAWC,KAAUpB,EACnB,GAAI,CACF,QAAM,QAAIqB,CAAmB,EAAE,MAAMD,EAAQ,CAAE,MAAO,EAAK,CAAC,EAC5D/D,GAAI,MACF,+BAA+B+D,EAAO,UAAU,IAAI,iBAAiBA,EAAO,UAAU,SAAS,EACjG,CACF,OAASE,EAAK,CACZ,MAAAjE,GAAI,MACFiE,EACA,sCAAsCF,EAAO,UAAU,IAAI,iBAAiBA,EAAO,UAAU,SAAS,EACxG,EACME,CACR,CAGF,aAAMC,EAAa3B,EAAYpB,EAAcmB,EAAS0B,EAAqBhE,GAAK,CAC9E,UAAW,SACb,CAAC,EAEM2C,CACT,CA9MsBpC,EAAAkC,GAAA,iCAsNf,SAASI,GACdV,EACA/B,EACA,CACA,MAAI,CAACA,GAAY+B,EAAI,MAAM,SAAS,aAAa,OAAS,UACxD,OAGyBgC,GAAsBhC,CAAG,EAC1B,KAAKiC,GAAU,CACvC,IAAMpB,EAAmBoB,EAAO,0BAGhC,OAAI,OAAO,KAAKpB,CAAiB,EAAE,SAAW,EACrC,GAIF,OAAO,QAAQA,CAAiB,EAAE,MAAM,CAAC,CAACqB,EAAKC,CAAK,IAAMlE,EAASiE,CAAG,IAAMC,CAAK,CAC1F,CAAC,CACH,CApBgB/D,EAAAsC,GAAA,yBA2BT,SAASc,GACdxB,EACAW,EACAW,EACqB,CACrB,IAAMnB,EAAUH,EAAI,UAAU,MAAQ,UAIhC4B,EAA8B,CAClC,WAAY,4BACZ,KAAM,sBACN,SAAU,CACR,KAPed,EAAqB,4BAA4BH,CAAY,EAAE,EAQ9E,UAAWX,EAAI,UAAU,UACzB,OAAQ,CACN,cAAeG,EACf,iBAAkBH,EAAI,UAAU,YAAY,SAAS,GAAK,IAC1D,UAAW,UACX,uBAAwBW,CAC1B,EACA,gBAAiBN,EAAYL,CAAG,CAClC,EACA,KAAM,CACJ,cACA,MAAO,CACL,CACE,KAAM,CACJ,CACE,OAAQ,CACN,cAAe,CAAC,oBAAoBA,EAAI,UAAU,SAAS,OAAOW,CAAY,EAAE,CAClF,CACF,CACF,CACF,CACF,CACF,CACF,EAIA,OAAIW,GAAe,OAAO,KAAKA,CAAW,EAAE,OAAS,IACnDM,EAAO,KAAM,SAAW,CACtB,YAAaN,CACf,GAGKM,CACT,CAhDgBxD,EAAAoD,GAAA,qCC5bhB,IAAAY,GAA0B,gBCGnB,IAAMC,GAAiBC,EAACC,GAAsB,CACnD,IAAMC,EAASC,EAASF,EAAW,CACjC,mBACA,YAAa,yBACb,gBAAiB,cACjB,eAAgB,CACd,UAAW,UACb,EACA,KAAM,EACR,CAAC,EAGD,OAAAC,EAAO,KAAM,OAAQ,CAAC,EAAE,MAAO,CAAC,EAAE,SAAW,MAEtCA,CACT,EAf8B,kBCAvB,IAAME,GAAoBC,EAAA,CAC/BC,EACAC,EACAC,IACG,CACH,IAAMC,EAAS,CACb,mBACA,YAAaF,EAAW,4BAA4BA,CAAQ,GAAK,uBACjE,gBAAiB,eACjB,eAAgB,CACd,MAAO,OACT,EACA,KAAM,MAEN,GAAIC,GAAe,CAAE,SAAUA,CAAY,CAC7C,EAEA,OAAOE,EAASJ,EAAWG,CAAM,CACnC,EAlBiC,qBCA1B,IAAME,GAAgCC,EAACC,GAC5CC,EAASD,EAAW,CAClB,oBACA,YAAa,qBACb,gBAAiB,aACjB,eAAgB,CACd,IAAK,YACP,EACA,KAAM,KACR,CAAC,EAT0C,iCCCtC,SAASE,GAAeC,EAAuC,CACpE,MAAO,CACL,WAAY,uBACZ,KAAM,gBACN,SAAU,CACR,KAAM,UACN,UAAAA,CACF,EACA,KAAM,CACJ,YAAa,CAAC,EACd,YAAa,CAAC,UAAW,QAAQ,EACjC,QAAS,CAAC,EACV,OAAQ,CAAC,CACX,CACF,CACF,CAfgBC,EAAAF,GAAA,kBCAT,IAAMG,GAA2BC,EAACC,GACvCC,EAASD,EAAW,CAClB,oBACA,YAAa,uBACb,WAAY,kBACd,CAAC,EALqC,4BLgBjC,SAASE,GAAmBC,EAAiBC,EAAmC,CACrF,IAAMC,EAAqBC,GAAsBH,CAAG,EAEpD,GAAI,GAACC,GAAaC,EAAmB,SAAW,GAEhD,OAAOA,EAAmB,KAAKE,GAAO,CACpC,IAAMC,EAAWD,EAAI,0BAGrB,OAAI,OAAO,KAAKC,CAAS,EAAE,SAAW,EAC7B,GAIF,OAAO,QAAQA,CAAS,EAAE,MAC/B,CAAC,CAACC,EAAKC,CAAK,IAAMD,KAAOL,GAAaA,EAAUK,CAAG,IAAMC,CAC3D,CACF,CAAC,CACH,CAlBgBC,EAAAT,GAAA,sBAqBhB,IAAMU,GAAMC,oBAAsC,EAKlD,eAAsBC,GAAgBX,EAAiBY,EAAmBC,EAAmB,CAC3F,IAAMC,EAAiBd,EAAI,MAAM,SAAS,OAAS,CAAC,EAC9Ce,EAAUf,EAAI,SAAU,KAGxBgB,GAAchB,EAAI,UAAU,YAAc,GAAG,SAAS,EAE5DS,GAAI,MAAMT,EAAI,SAAU,6CAA6CgB,CAAU,EAAE,EAGjF,IAAMC,EAAW,CAEfC,GAAeN,CAAS,EAGxBO,GAAeP,CAAS,CAC1B,EAGIC,IAAc,YAChBI,EAAS,KAAKG,GAAkBR,CAAS,CAAC,EAC1CK,EAAS,KAAKI,GAA8BT,CAAS,CAAC,GAIpDC,IAAc,WAChBI,EAAS,KAAKK,GAAyBV,CAAS,CAAC,EAInD,QAAWW,KAAUT,EAAgB,CAEnC,GAAIS,EAAO,YAAc,WAAqBA,EAAO,SAAU,CAE7D,IAAMC,EAAiBzB,GAAmBC,EAAKuB,EAAO,QAAQ,EACxDE,EAAeD,EAAiBE,EAAgBF,EAAe,QAAQ,EAAI,OAG7EC,IACFF,EAAO,SAAWI,GAAe3B,EAAKuB,EAAO,SAAUE,CAAY,EAEvE,CAEA,IAAMG,EAAkBC,EAASjB,EAAWW,EAAQV,CAAiB,EACrEI,EAAS,KAAKW,CAAe,CAC/B,CAGA,IAAME,EAAa9B,EAAI,MAAM,SAAS,QAAU,CAAC,EAEjD,QAAW+B,KAAUD,EAAW,OAAOE,GAAO,CAACA,EAAI,cAAc,cAAc,EAAG,CAChF,GAAM,CAAE,QAAAC,WAA0B,KAAAC,EAAM,SAAA7B,EAAW,CAAC,EAAG,WAAA8B,CAAW,EAAIJ,EAChEK,EAAaD,GAAcD,EAG3BV,EAAiBzB,GAAmBC,EAAKK,CAAQ,EACjDoB,EAAeD,EAAiBE,EAAgBF,EAAe,QAAQ,EAAI,OAG3Ea,EAAcZ,EAAeE,GAAe3B,EAAKK,EAAUoB,CAAY,EAAIpB,EAG3EkB,GAAgB,CACpB,oBAEA,SAAUc,EACV,gBAAiB,SAASJ,CAAO,WACjC,eAAgB,CACd,IAAK,GAAGA,CAAO,iBACjB,EACA,KAAMG,EACN,YAAa,GAAGA,CAAU,IAAI,OAAO,OAAO/B,CAAQ,EAAE,KAAK,GAAG,CAAC,UAAU4B,CAAO,UAClF,EAGML,GAAkBC,EAASjB,EAAWW,GAAQV,CAAiB,EACrEI,EAAS,KAAKW,EAAe,CAC/B,CAGA,IAAMU,EAAOnC,GAAsBH,CAAG,EAEtC,QAAWI,KAAOkC,EAAM,CACtB,IAAMb,EAAeC,EAAgBtB,EAAI,QAAQ,EAC3CmC,EAAiBZ,GAAe3B,EAAKI,EAAI,0BAA4BqB,CAAY,EAEjFF,EAAgB,CACpB,mBACA,SAAUgB,EACV,gBAAiB,cACjB,eAAgB,CAAE,yBAA0B,aAAc,EAC1D,KAAM,MACN,YAAa,GAAGC,EAAqBpC,EAAI,QAAQ,CAAC,qBACpD,EAGMwB,EAAkBC,EAASjB,EAAWW,EAAQV,CAAiB,EACrEI,EAAS,KAAKW,CAAe,EAE7B,IAAMa,EAAwB,CAC5B,mBACA,SAAUF,EACV,gBAAiB,WACjB,eAAgB,CAAE,yBAA0B,UAAW,EACvD,KAAM,KACN,YAAa,GAAGC,EAAqBpC,EAAI,QAAQ,CAAC,uBACpD,EAGMsC,EAA0Bb,EAASjB,EAAW6B,EAAgB5B,CAAiB,EAIrF,GAHAI,EAAS,KAAKyB,CAAuB,EAGjCC,GAAyB3C,CAAG,EAAG,CACjC,IAAMyB,EAAeC,EAAgBtB,EAAI,QAAQ,EAC3CwC,EAAcxC,EAAI,0BAGlByC,GAAezB,GAAkBR,EAAWR,EAAI,SAAUmC,CAAc,EAG9EM,GAAa,SAAW,CACtB,GAAGA,GAAa,SAChB,OAAQ,CACN,GAAGA,GAAa,UAAU,OAC1B,iBAAkBzC,EAAI,QACxB,CACF,EACAa,EAAS,KAAK4B,EAAY,EAG1B5B,EAAS,KACPY,EAASjB,EAAW,CAClB,mBACA,SAAU,CAAE,wBAAyBa,CAAa,EAClD,eAAgBmB,EAChB,YAAa,sBAAsBnB,CAAY,SACjD,CAAC,CACH,EAGAR,EAAS,KACPY,EAASjB,EAAW,CAClB,oBACA,SAAUgC,EACV,eAAgB,CAAE,wBAAyBnB,CAAa,EACxD,YAAa,sBAAsBA,CAAY,cACjD,CAAC,CACH,EAGAR,EAAS,KACPY,EAASjB,EAAW,CAClB,oBACA,SAAU,CAAE,wBAAyBa,CAAa,EAClD,gBAAiB,aACjB,eAAgB,CAAE,IAAK,YAAa,EACpC,MAAO,CACL,KACF,EACA,YAAa,0CAA0CA,CAAY,EACrE,CAAC,CACH,CACF,CACF,CAGA,IAAMqB,EAAc9C,EAAI,MAAM,SAAW,CAAC,EAE1C,QAAW+C,KAAWD,EAAa,CACjC,GAAM,CAAE,SAAAzC,EAAU,WAAA8B,EAAY,YAAAE,CAAY,EAAIU,EAGxCvB,EAAiBzB,GAAmBC,EAAKK,CAAQ,EACjDoB,EAAeD,EAAiBE,EAAgBF,EAAe,QAAQ,EAAI,OAG3EwB,EAAgBvB,EAClBE,GAAe3B,EAAKqC,GAAehC,EAAUoB,CAAY,EACxDY,GAAehC,EAGdkB,EAAgB,CACpB,oBACA,SAAUyB,EACV,gBAAiB,aACjB,eAAgB,CACd,IAAK,YACP,EACA,KAAMb,EAEN,YAAa,GAAGA,CAAU,IAAI,OAAO,OAAO9B,CAAQ,CAAC,UACvD,EAEMuB,EAAkBC,EAASjB,EAAWW,EAAQV,CAAiB,EACrEI,EAAS,KAAKW,CAAe,CAC/B,CAGA,OAAW,CAACqB,EAAK1B,CAAM,IAAKN,EAAS,QAAQ,EAAG,CAe9C,GAbAM,EAAO,SAAWA,EAAO,UAAY,CAAC,EACtCA,EAAO,SAAS,OAASA,EAAO,UAAU,QAAU,CAAC,EACrDA,EAAO,SAAS,OAAO,aAAa,EAAIR,EACxCQ,EAAO,SAAS,OAAO,gBAAgB,EAAIP,EAGvCiC,EAAM,EACR1B,EAAO,SAAS,KAAO,QAAQR,CAAO,IAAIQ,EAAO,SAAS,IAAI,GAE9DA,EAAO,SAAS,KAAO,SAASR,CAAO,IAAIQ,EAAO,SAAS,IAAI,GAI7DA,EAAO,MAAM,QACf,QAAW2B,KAAW3B,EAAO,KAAK,QAE5B2B,EAAQ,OAASA,EAAQ,MAAM,KAAKhB,GAAQA,EAAK,WAAa,KAAK,GACrEgB,EAAQ,MAAM,KAAK,CAAE,KAAM,KAAM,CAAC,UAG7B3B,EAAO,MAAM,OACtB,QAAW4B,KAAU5B,EAAO,KAAK,OAG7BA,EAAO,UAAU,SAAS,eAAe,IAAM,aAC/CA,EAAO,UAAU,SAAS,eAAe,IAAM,WAC/CA,EAAO,UAAU,SAAS,eAAe,IAAM,iBAK7C4B,EAAO,OAASA,EAAO,MAAM,KAAKjB,GAAQA,EAAK,WAAa,KAAK,GACnEiB,EAAO,MAAM,KAAK,CAAE,KAAM,KAAM,CAAC,EAMvC5B,EAAO,SAAS,KAAOiB,EAAqBjB,EAAO,SAAS,IAAI,EAGhEA,EAAO,SAAS,gBAAkB6B,EAAYpD,CAAG,EAGjD,GAAI,CACF,QAAM,QAAI,QAAK,aAAa,EAAE,MAAMuB,EAAQ,CAAE,MAAO,EAAK,CAAC,CAC7D,OAAS8B,EAAK,CACZ,IAAIC,EAAUD,EAAI,MAAM,SAAW,gDACnC,MACEE,EAAU,aACVhC,EAAO,SAAS,OAAO,eAAe,IAAM,YAE5C+B,GACE,mFAGFC,EAAU,cAAc,OAAS,GACjChC,EAAO,SAAS,OAAO,eAAe,IAAM,cAE5C+B,GACE,qFAEE,IAAI,MAAMA,CAAO,CACzB,CACF,CAEA,aAAME,EAAaxC,EAAYJ,EAAWG,EAAS,QAAK,cAAeN,EAAG,EAGnEQ,CACT,CA/QsBT,EAAAG,GAAA,mBMnBtB,IAAM8C,EAAMC,wBAA0C,EAQtD,eAAsBC,GAAkBC,EAAiB,CACvD,IAAMC,EAAWD,EAAI,SACf,CAAE,UAAAE,EAAW,KAAAC,CAAK,EAAIF,EAM5B,GAJAJ,EAAI,KACF,sBAAsBK,CAAS,IAAIC,CAAI,mBAAmBH,EAAI,QAAQ,KAAK,yBAAyBA,EAAI,QAAQ,kBAAkB,mBAAmBA,EAAI,QAAQ,YAAY,EAC/K,EAEII,GAAWJ,CAAG,EAAG,CACnBH,EAAI,KACF,oBAAoBK,CAAS,IAAIC,CAAI,mBAAmBH,EAAI,QAAQ,KAAK,yBAAyBA,EAAI,QAAQ,kBAAkB,mBAAmBA,EAAI,QAAQ,YAAY,EAC7K,EACA,MACF,CAKA,GAFAK,GAAQL,CAAG,EAEPA,EAAI,QAAQ,cAAgBA,EAAI,QAAQ,aAAe,EAAG,CAE5D,IAAMM,EAAiB,GAAKN,EAAI,OAAO,aAEvCH,EAAI,KACFI,EACA,WAAWK,CAAc,sCAAsCJ,CAAS,IAAIC,CAAI,mBAAmBH,EAAI,QAAQ,KAAK,yBAAyBA,EAAI,QAAQ,kBAAkB,mBAAmBA,EAAI,QAAQ,YAAY,EACxN,EAEA,MAAMO,GAAWP,EAAK,CACpB,QAAS,WAAWM,CAAc,kCACpC,CAAC,EAGD,MAAM,IAAI,QAAQE,GAAW,WAAWA,EAASF,EAAiB,GAAI,CAAC,CACzE,CAEA,GAAI,CACF,MAAMG,GAAaT,EAAK,CAAE,gBAAsB,WAAYU,GAAuB,EAAK,CAAE,CAAC,EAC3F,MAAMC,GAAqBX,CAAG,CAChC,OAASY,EAAK,CACZ,MAAMC,GAAcD,EAAKZ,CAAG,CAC9B,CACF,CAzCsBc,EAAAf,GAAA,qBA+CtB,eAAeY,GAAqBX,EAAgC,CAClE,IAAMC,EAAWD,EAAI,SACf,CAAE,UAAAE,CAAU,EAAID,EAGhBc,EAAYf,EAAI,MAAM,SAAS,aAAa,MAAQ,UAGpDgB,EAAS,MAAMC,GAAgBjB,EAAKE,EAAYa,CAAS,EACzDG,EAAU,MAAMC,GAA8BnB,EAAKE,EAAYa,CAAS,EAG9E,MAAMK,GAAYpB,CAAG,EAErB,IAAIqB,EAAsB,CAAC,EACvBC,EAAa,IAAI,IACjBC,EAA0C,CAAC,EAE/C,GAAIC,EAAU,mBAEZF,EAAa,MAAMG,GAASzB,CAAG,EAC/BuB,EAAqB,MAAMG,GAAY1B,EAAKsB,CAAU,UAC7CtB,EAAI,MAAM,IACnB,MAAAH,EAAI,MAAM,iFAAiF,EACrF,IAAI,MACR,iFACF,EAIFwB,EAAY,MAAMM,GAAe3B,EAAKE,CAAU,EAGhD,IAAI0B,EAAoB,EACpBb,IAAc,WAAgBf,EAAI,MAAM,SAAS,QACnD4B,EAAoBC,GAA2B7B,EAAI,KAAM,QAAS,KAAM,EAAE,QAI5E,IAAM8B,EAAqB,CAAC,EAC5BA,EAAS,KAAK,GAAI,MAAMC,GAAW/B,EAAKE,CAAU,CAAE,EACpD4B,EAAS,KAAK,GAAI,MAAME,GAAehC,EAAKE,CAAU,CAAE,EAGxD,MAAM+B,GAAkBjC,EAAKE,CAAU,EAEvC,MAAMO,GAAaT,EAAK,CACtB,cACA,WAAYU,GAAuB,EAAI,EACvC,WAAY,CAAC,GAAGY,EAAW,KAAK,CAAC,EACjC,mBAAAC,EACA,UAAAF,EACA,SAAAS,EACA,mBAAoBd,EAAO,OAC3B,yBAA0BE,EAAQ,OAASK,EAAmB,OAAS,EAAIK,EAC3E,SAAUb,EACV,mBAAoBd,EAAS,WAC7B,aAAc,CAChB,CAAC,CACH,CA3Dea,EAAAH,GAAA,wBAoEf,eAAsBuB,GAAiBlC,EAAiB,CAEtD,GAAIA,EAAI,QAAQ,QAAU,YAAkBA,EAAI,QAAQ,QAAU,gBAEhE,OAAAH,EAAI,MACF,0BAA0BG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,0CACzE,EACO,GAIT,GAAIA,EAAI,QAAQ,QAAU,SAAeA,EAAI,QAAQ,QAAU,SAC7D,OAAAH,EAAI,MACF,+BAA+BG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,qDAC9E,EACO,GAGTH,EAAI,MAAM,iCAAiCG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,EAAE,EAG1F,MAAMS,GAAaT,EAAK,CAAE,gBAAsB,CAAC,EAGjD,GAAI,CACF,MAAMO,GAAWP,EAAK,CACpB,QAAS,yDACT,OAAQ,oBACR,KAAM,QACR,CAAC,EAED,MAAMmC,EAAerB,EAAA,gBAAoC,CACvD,OAAOsB,GAAiBpC,CAAG,CAC7B,EAFqB,sBAElBH,CAAG,CACR,OAASwC,EAAG,CACV,OAAAxC,EAAI,MACF,qEAAqEG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,KAAKqC,EAAE,OAAO,EAClI,EACA,MAAM9B,GAAWP,EAAK,CACpB,QAAS,iDAAiDqC,EAAE,OAAO,gHACnE,OAAQ,gBACR,KAAM,SACR,CAAC,EACD,MAAM5B,GAAaT,EAAK,CAAE,qBAA2B,CAAC,EAC/C,EACT,CAGA,GAAI,CACF,MAAMO,GAAWP,EAAK,CACpB,QAAS,iDACT,OAAQ,oBACR,KAAM,QACR,CAAC,EAED,MAAMmC,EAAerB,EAAA,gBAA0C,CAC7D,IAAMwB,EAAkBtC,EAAI,MAAM,SAAS,aAAa,MAAQ,UAChE,OAAOuC,GAAwBvC,EAAK,CAAC,EAAGsC,EAAiBA,CAAe,CAC1E,EAHqB,4BAGlBzC,CAAG,CACR,OAASwC,EAAG,CACV,OAAAxC,EAAI,MACF,oEAAoEG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,KAAKqC,EAAE,OAAO,EACjI,EACA,MAAM9B,GAAWP,EAAK,CACpB,QAAS,gDAAgDqC,EAAE,OAAO,kFAClE,OAAQ,gBACR,KAAM,SACR,CAAC,EACD,MAAM5B,GAAaT,EAAK,CAAE,qBAA2B,CAAC,EAC/C,EACT,CAGA,GAAI,CACF,MAAMO,GAAWP,EAAK,CACpB,QAAS,mCACT,OAAQ,oBACR,KAAM,QACR,CAAC,EAED,MAAMmC,EAAerB,EAAA,gBAAmC,CACtD,OAAO0B,GAAgBxC,EAAK,CAAC,CAAC,CAChC,EAFqB,qBAElBH,CAAG,CACR,OAASwC,EAAG,CACV,OAAAxC,EAAI,MACF,sDAAsDG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,KAAKqC,EAAE,OAAO,EACnH,EACA,MAAM9B,GAAWP,EAAK,CACpB,QAAS,kCAAkCqC,EAAE,OAAO,oDACpD,OAAQ,gBACR,KAAM,SACR,CAAC,EACD,MAAM5B,GAAaT,EAAK,CAAE,qBAA2B,CAAC,EAC/C,EACT,CAGA,GAAI,CACF,MAAMO,GAAWP,EAAK,CACpB,QAAS,0CACT,OAAQ,oBACR,KAAM,QACR,CAAC,EAED,MAAMmC,EAAerB,EAAA,gBAA8C,CACjE,MAAM2B,GACJ,OACAC,GAAa1C,CAAG,kBAEhBA,EAAI,MAAM,SAAS,aAAa,MAAQ,SAC1C,CACF,EAPqB,gCAOlBH,CAAG,CACR,OAASwC,EAAG,CACV,OAAAxC,EAAI,MACF,kEAAkEG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,KAAKqC,EAAE,OAAO,EAC/H,EACA,MAAM9B,GAAWP,EAAK,CACpB,QAAS,8CAA8CqC,EAAE,OAAO,GAChE,OAAQ,gBACR,KAAM,SACR,CAAC,EACD,MAAM5B,GAAaT,EAAK,CAAE,qBAA2B,CAAC,EAC/C,EACT,CAIA,OAAAH,EAAI,MAAM,WAAWG,EAAI,UAAU,SAAS,IAAIA,EAAI,UAAU,IAAI,uBAAuB,EAClF,EACT,CAjIsBc,EAAAoB,GAAA,oBvEnGtB,IAAMS,GAAMC,YAA8B,EAIrCC,EAAU,aACbC,EAAK,IAAE,aAAa,EACjB,mBAAmB,EACnB,YAAY,SAAS,EACrB,SAAS,YAAY,EACrB,UAAUC,EAAoC,EAInDD,EAAK,IAAE,OAAO,EACX,mBAAmB,EACnB,YAAY,SAAS,EACrB,SAAS,YAAY,EACrB,UAAUE,EAA8B,EAG3CF,EAAK,IAAE,OAAO,EACX,mBAAmB,EACnB,OAAOG,GAAOC,GAAiBD,EAAI,GAAG,CAAC,EAG1CH,EAAK,IAAE,GAAG,EACP,mBAAmB,EACnB,OAAOG,GAAOE,GAAaF,EAAI,GAAG,CAAC,EAGtCH,EAAKM,EAAU,EACZ,mBAAmB,EAEnB,SAASC,EAAS,EAElB,UAAUC,EAAiB,EAE3B,SAASC,EAAgB,EAG5BT,EAAKU,EAAY,EAAE,mBAAmB,EAAE,SAASC,EAAe,EAGhEX,EAAKM,EAAU,EACZ,mBAAmB,EACnB,YAAY,UAAU,EACtB,SAAS,UAAU,EACnB,MAAM,IAAM,CAEXT,GAAI,KAAK,+EAA+E,EACxFE,EAAU,mBAAqB,EACjC,CAAC,EACHC,EAAKM,EAAU,EACZ,UAAU,EACV,YAAY,UAAU,EACtB,SAAS,UAAU,EACnB,MAAM,IAAM,CACXT,GAAI,KAAK,yEAAyE,EAClFE,EAAU,mBAAqB,EACjC,CAAC,EAGCA,EAAU,cAAc,SAAW,GACrCC,EAAK,IAAE,IAAI,EAAE,mBAAmB,EAAE,UAAUY,EAA+B,EAIzEb,EAAU,cAAc,SAAW,GACrCC,EAAK,IAAE,IAAI,EAAE,UAAU,EAAE,UAAUa,EAAyB,EAI9Db,EAAK,IAAE,MAAM,EACV,mBAAmB,EACnB,YAAY,aAAa,EACzB,SAAS,qBAAqB,EAC9B,UAAUc,GAAUC,GAAgBD,GAA2B,CAAC,EAGnEd,EAAKgB,EAAa,EACf,mBAAmB,EACnB,SAASC,EAAiB,EAC1B,UAAUC,GAAOC,GAAUD,GAAwB,CAAC,EAGvDlB,EAAK,IAAE,SAAS,EACb,mBAAmB,EACnB,YAAY,aAAa,EACzB,SAAS,cAAc,EACvB,UAAUoB,EAA+B,EAG5CpB,EAAK,IAAE,MAAM,EACV,mBAAmB,EACnB,YAAYqB,EAAiC,EAC7C,SAASC,EAA4B,EACrC,UAAUC,GAAKC,GAA4BD,EAAG,EAAK,CAAC,EAGvDvB,EAAK,IAAE,MAAM,EACV,mBAAmB,EACnB,UAAU,qBAAsB,MAAM,EACtC,UAAUyB,EAAkB,EAG/BzB,EAAK,IAAE,MAAM,EAAE,UAAU,EAAE,UAAU,qBAAsB,MAAM,EAAE,UAAU0B,EAAkB,EAG/F1B,EAAK,IAAE,SAAS,EACb,mBAAmB,EACnB,UAAU,qBAAsB,MAAM,EACtC,UAAU2B,EAAqB,EAGlC3B,EAAK,IAAE,SAAS,EACb,UAAU,EACV,UAAU,qBAAsB,MAAM,EACtC,UAAU4B,EAAqB,EAGlC5B,EAAK,IAAE,SAAS,EACb,UAAU,EACV,YAAY,cAAc,EAC1B,SAAS,OAAO,EAChB,UAAU6B,EAAkB,EwE/K/B,IAAAC,GAA0B,gBAQnB,IAAMC,GAAMC,qBAAuC,EAE1D,eAAsBC,IAA4B,CAChD,GAAI,QAAQ,IAAI,kBAAoB,QAAU,QAAQ,IAAI,YAAc,MAAO,CAE7E,QAAM,QAAI,QAAK,SAAS,EAAE,MAAM,CAC9B,SAAU,CACR,KAAMC,EACR,CACF,CAAC,EAGD,GAAI,CACF,QAAM,QAAI,QAAK,MAAM,EAClB,YAAYA,EAAiC,EAC7C,IAAIC,EAA4B,EACnCJ,GAAI,KAAK,mDAAmD,CAC9D,MAAQ,CACNA,GAAI,KAAK,qDAAqD,EAC9D,GAAI,CAQF,MAAMK,GAPS,CACb,SAAU,CACR,UAAWF,GACX,KAAMC,EACR,EACA,KAAM,QACR,EAC0C,EAAK,CACjD,OAASE,EAAK,CACZ,MAAAN,GAAI,MAAMM,EAAK,0CAA0C,EACnDA,CACR,CACF,CACF,CACF,CAhCsBC,EAAAL,GAAA,6BCVtB,IAAAM,GAA2B,6DAC3BC,GAAoB,gBAmBpB,IAAMC,GAAMC,wBAA0C,EACtD,eAAsBC,IAAoB,CAGxC,GAFAC,GAAa,KAAK,EAEd,QAAQ,IAAI,kBAAoB,SAAW,QAAQ,IAAI,YAAc,MAAO,CAC9E,IAAMC,KAAU,QAAIC,EAAU,EAAE,MAAM,MAAOC,EAAKC,IAAU,CAC1DP,GAAI,MAAM,sBAAsBM,EAAI,UAAU,IAAI,kBAAkBC,CAAK,EAAE,EAE3EC,GAAgBF,EAAKC,CAAK,CAC5B,EAAGE,EAAQ,EAEXT,GAAI,MAAM,2BAA2B,EACrCU,GAA2BN,EAASJ,GAAK,YAAY,EACrD,MAAMI,EAAQ,MAAM,CACtB,CACF,CAdsBO,EAAAT,GAAA,qBAgBf,SAASM,GAAgBF,EAAiBC,EAAmB,CAClE,OAAQA,EAAO,CACb,KAAK,cAAW,MAChB,KAAK,cAAW,SACdJ,GAAa,IAAIG,CAAG,EACpB,MAEF,KAAK,cAAW,QACdH,GAAa,OAAOG,CAAG,EACvB,KACJ,CACF,CAXgBK,EAAAH,GAAA,mBCrChB,IAAAI,GAA0B,gBCEnB,IAAMC,GAA8C,CACzD,KAAM,WACN,OAAQ,GACR,QAAS,GACT,OAAQ,CACN,gBAAiB,CACf,KAAM,SACN,WAAY,CACV,KAAM,CACJ,KAAM,SACN,SAAU,CAAC,YAAY,EACvB,WAAY,CACV,WAAY,CACV,KAAM,QACN,SAAU,EACV,YAAa,oBACb,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAY,SAAS,EAChC,WAAY,CACV,MAAO,CACL,KAAM,SACN,YAAa,oDACf,EACA,YAAa,CACX,KAAM,SACN,YAAa,4CACf,EACA,SAAU,CACR,YAAa,iCACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,KAAM,CACJ,yBACA,2BACA,qBACA,yBACA,sBACA,qBACA,uBACA,wBACA,wBACA,oBACA,gCACA,gCACA,gCACA,oBACA,oBACA,kBACA,sBACA,qBACF,CACF,CACF,EACA,QAAS,CACP,YAAa,8CACb,KAAM,SACN,SAAU,CAAC,YAAa,MAAM,EAC9B,WAAY,CACV,UAAW,CACT,KAAM,QACR,EACA,KAAM,CACJ,KAAM,QACR,EACA,KAAM,CACJ,KAAM,SACN,KAAM,CAAC,MAAO,SAAS,EACvB,QAAS,KACX,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,CACF,ECjFA,IAAMC,GAAgB,CAAC,CAAE,SAAU,CAAC,OAAO,CAAE,EAAG,CAAE,SAAU,CAAC,QAAQ,CAAE,EAAG,CAAE,SAAU,CAAC,OAAO,CAAE,CAAC,EAC3FC,GAAgB,CACpB,MAAO,CACL,CACE,IAAK,CACH,MAAOD,EACT,CACF,EACA,GAAGA,EACL,EACA,WAAY,CACV,MAAO,CACL,KAAM,QACR,EACA,OAAQ,CACN,KAAM,QACR,EACA,MAAO,CACL,YAAa,2EACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EAEaE,GAAkC,CAC7C,YAAa,wCACb,WAAY,CACV,WAAY,CACV,YAAa,+CACb,WAAY,CACV,iBAAkB,CAChB,YACE,4GACF,SAAU,GACV,KAAM,SACR,EACA,aAAc,CACZ,YAAa,sEACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,aAAc,CACZ,YAAa,uDACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,YAAa,CACX,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,aAAc,CACZ,YAAa,8CACb,MAAOD,GACP,KAAM,OACR,EACA,cAAe,CACb,YAAa,kEACb,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,OAAQ,CACN,YAAa,uEACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,eAAgB,CACd,YACE,0FACF,WAAY,CACV,KAAM,CACJ,YAAa,8CACb,MAAO,CACL,CACE,IAAK,CACH,MAAO,CACL,CACE,SAAU,CAAC,QAAQ,CACrB,EACA,CACE,SAAU,CAAC,OAAO,CACpB,CACF,CACF,CACF,EACA,CACE,SAAU,CAAC,QAAQ,CACrB,EACA,CACE,SAAU,CAAC,OAAO,CACpB,CACF,EACA,WAAY,CACV,MAAO,CACL,YAAa,yCACb,OAAQ,SACR,KAAM,QACR,EACA,OAAQ,CACN,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,OAAQ,CACN,YAAa,qDACb,KAAM,SACR,CACF,EACA,SAAU,CAAC,QAAQ,EACnB,KAAM,QACR,EACA,QAAS,CACP,WAAY,CACV,QAAS,CACP,WAAY,CACV,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,EACA,OAAQ,CACN,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,SAAU,CACR,WAAY,CACV,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,EACA,OAAQ,CACN,MAAO,CACL,KAAM,QACR,EACA,KAAM,OACR,EACA,IAAK,CACH,qBAAsB,CACpB,KAAM,QACR,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,MAAO,CACL,YACE,sGACF,MAAO,CACL,WAAY,CACV,cAAe,CACb,YAAa,uEACb,KAAM,SACR,EACA,OAAQA,GACR,KAAM,CACJ,YAAa,gCACb,KAAM,QACR,EACA,YAAa,CACX,qBAAsBA,GACtB,YAAa,iCACb,KAAM,QACR,EACA,IAAKA,EACP,EACA,SAAU,CAAC,MAAM,EACjB,KAAM,QACR,EACA,KAAM,OACR,EACA,QAAS,CACP,YAAa,2CACb,WAAY,CACV,UAAW,CACT,YAAa,qDACb,KAAM,QACR,EACA,IAAK,CACH,YAAa,uEACb,KAAM,QACR,EACA,gBAAiB,CACf,YAAa,gEACb,WAAY,CACV,MAAO,CACL,YACE,2EACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,yEACb,KAAM,QACR,CACF,EACA,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,SAAU,CACR,YACE,0FACF,MAAO,CACL,CACE,IAAK,CACH,MAAO,CACL,CACE,SAAU,CAAC,MAAM,CACnB,EACA,CACE,SAAU,CAAC,YAAY,CACzB,CACF,CACF,CACF,EACA,CACE,SAAU,CAAC,MAAM,CACnB,EACA,CACE,SAAU,CAAC,YAAY,CACzB,CACF,EACA,WAAY,CACV,UAAW,CACT,YACE,kFACF,KAAM,QACR,EACA,KAAM,CACJ,YAAa,wEACb,QAAS,WACT,QAAS,EACT,KAAM,SACR,EACA,WAAY,CACV,YACE;AAAA;AAAA,yDACF,KAAM,CAAC,wBAAyB,mBAAmB,EACnD,KAAM,QACR,EACA,aAAc,CACZ,YACE,iFACF,QAAS,WACT,QAAS,EACT,KAAM,SACR,EACA,OAAQ,CACN,YAAa,0EACb,KAAM,QACR,EACA,IAAK,CACH,YAAa,wEACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EACA,QAAS,CACP,YAAa,kCACb,WAAY,CACV,SAAU,CACR,YAAa,uDACb,OAAQ,QACR,KAAM,SACR,EACA,cAAe,CACb,YACE,uFACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,0DACb,KAAM,QACR,EACA,sBAAuB,CACrB,YAAa,wEACb,SAAU,GACV,KAAM,SACR,CACF,EACA,KAAM,QACR,EACA,OAAQ,CACN,YACE,0FACF,OAAQ,QACR,KAAM,SACR,EACA,QAAS,CACP,YAAa,kDACb,KAAM,QACR,CACF,EACA,KAAM,QACR,EClUA,IAAME,GAAyC,CAC7C,YAAa,0BACb,KAAM,SACN,WAAY,CACV,YAAa,CACX,YACE,+FACF,KAAM,SACN,WAAY,CACV,IAAK,CACH,YAAa,oEACb,KAAM,QACR,EACA,KAAM,CACJ,YACE,kHACF,KAAM,QACR,EACA,SAAU,CACR,YAAa,wDACb,KAAM,SACR,CACF,EACA,SAAU,CAAC,KAAK,CAClB,EACA,KAAM,CACJ,YACE,sHACF,KAAM,QACR,CACF,EACA,SAAU,CAAC,aAAa,CAC1B,EAEMC,GAAQ,CACZ,YAAa,qEACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAW,EACtB,WAAY,CACV,OAAQ,CACN,YAAa,oCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,YAAa,CACX,KAAM,SACN,YAAa,uEACf,EACA,UAAW,CACT,YAAa,+BACb,KAAM,CAAC,UAAW,QAAQ,EAC1B,KAAM,QACR,EACA,SAAU,CACR,YACE,kHACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YACE,+FACF,KAAM,QACR,EACA,eAAgB,CACd,YAAa,0DACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YAAa,kDACb,KAAM,SACN,KAAM,CAAC,UAAW,YAAa,iBAAkB,gBAAiB,UAAU,CAC9E,EACA,WAAY,CACV,YAAa,+BACb,KAAM,QACR,EACA,WAAY,CACV,YAAa,sCACb,KAAM,QACR,EACA,eAAgB,CACd,YAAa,wCACb,KAAM,SACN,KAAM,CAAC,MAAO,MAAM,CACtB,EACA,KAAM,CACJ,YAAa,6CACb,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,MAAO,CACL,YAAa,oDACb,KAAM,QACN,MAAO,CACL,QAAS,EACT,QAAS,MACT,KAAM,QACR,CACF,EACA,qBAAsB,CACpB,YACE,oIAEF,KAAM,QACR,EACA,eAAgB,CACd,YACE,6HAEF,KAAM,QACR,EAEA,UAAW,CACT,YAAa,2BACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YAAa,iCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,CACF,CACF,CACF,EAEMC,GAAS,CACb,KAAM,QACN,YAAa,uCACb,MAAO,CACL,KAAM,SACN,SAAU,CAAC,MAAM,EACjB,MAAO,CACL,CACE,SAAU,CAAC,UAAW,YAAa,MAAM,CAC3C,EACA,CACE,SAAU,CAAC,UAAW,WAAY,MAAM,CAC1C,EACA,CACE,SAAU,CAAC,cAAc,CAC3B,CACF,EACA,WAAY,CACV,YAAa,CACX,KAAM,SACN,YACE,sFACJ,EACA,KAAM,CACJ,YAAa,wCACb,KAAM,QACR,EACA,QAAS,CACP,YAAa,qEACb,KAAM,SACN,QAAS,QACX,EACA,OAAQ,CACN,YACE,8GACF,KAAM,QACR,EACA,QAAS,CACP,YAAa,oCACb,KAAM,QACR,EACA,KAAM,CACJ,YAAa,4BACb,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,SAAU,CACR,YACE,yGACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,WAAY,CACV,YACE,8KACF,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,aAAAC,GAEA,MAAO,CACL,YAAa,qCACb,GAAGA,GAAa,YAAY,KAC9B,EACA,UAAW,CACT,YAAa,2BACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,CACF,CACF,CACF,EAEMC,GAAc,CAClB,YAAa,6CACb,KAAM,SACN,WAAY,CACV,KAAM,CACJ,KAAM,SACN,KAAM,CAAC,UAAW,SAAS,EAC3B,QAAS,UACT,YAAa,6EACf,CACF,CACF,EAEMC,GAAU,CACd,YAAa,+CACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAY,WAAY,YAAY,EAC/C,WAAY,CACV,YAAa,CACX,KAAM,SACN,YACE,uFACJ,EACA,SAAU,CACR,YAAa,uCACb,KAAM,QACR,EACA,WAAY,CACV,YACE,4FACF,QAAS,EACT,QAAS,MACT,KAAM,QACR,EACA,SAAU,CACR,YAAa,sDACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,YAAa,CACX,YACE,oJACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,KAAM,CACJ,YAAa,qEACb,KAAM,QACR,EACA,KAAM,CACJ,YACE,8FACF,KAAM,CAAC,aAAc,gBAAgB,EACrC,KAAM,QACR,EACA,uBAAwB,CACtB,YACE,gHAEF,KAAM,CACJ,uBACA,uBACA,kBACA,sBACA,qBACF,EACA,KAAM,QACR,EACA,cAAeL,EACjB,CACF,CACF,EAEMM,GAAM,CACV,YAAa,mCACb,KAAM,QACN,MAAO,CACL,KAAM,SACN,SAAU,CAAC,WAAY,MAAM,EAC7B,WAAY,CACV,0BAA2B,CACzB,YACE,gHACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,WAAY,CACV,YAAa,oDACb,KAAM,QACR,EACA,aAAc,CACZ,YACE,oFACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,kBAAmB,CACjB,YACE,yGACF,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,eAAgB,CACd,YAAa,sCAEb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,SAAU,CACR,YAAa,+DACb,KAAM,QACR,EACA,OAAQ,CACN,YAAa,8DACb,KAAM,QACR,EACA,KAAM,CACJ,YAAa,uCACb,KAAM,QACR,EACA,YAAa,CACX,YACE,mFACF,KAAM,QACR,EACA,QAAS,CACP,YACE,wFACF,KAAM,QACR,EACA,SAAU,CACR,YACE,0GACF,KAAM,QACR,EACA,SAAU,CACR,YAAa,0EACb,KAAM,SACN,KAAM,CAAC,iBAAkB,MAAM,CACjC,EACA,WAAY,CACV,YAAa,uCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,EACA,gBAAiB,CACf,YAAa,8CACb,KAAM,QACN,QAAS,CAAC,EACV,MAAO,CACL,KAAM,SACN,SAAU,CAAC,OAAQ,WAAY,gBAAgB,EAC/C,WAAY,CACV,KAAM,CACJ,YAAa,qBACb,KAAM,QACR,EACA,SAAU,CACR,YAAa,yBACb,KAAM,SACN,KAAM,CAAC,iBAAkB,MAAM,CACjC,EACA,eAAgB,CACd,YAAa,qCACb,KAAM,QACR,EACA,gBAAiB,CACf,YAAa,mDACb,KAAM,UACN,QAAS,EACX,EACA,OAAQ,CACN,YAAa,wCACb,KAAM,SACN,qBAAsB,CACpB,KAAM,QACR,CACF,CACF,CACF,CACF,EACA,QAAS,CACP,YAAa,qCACb,KAAM,QACR,EACA,aAAc,CACZ,YACE,0IACF,KAAM,QACN,MAAO,CACL,KAAM,QACR,EACA,SAAU,CACZ,EACA,WAAY,CACV,YACE,yKACF,KAAM,QACN,MAAO,CACL,KAAM,QACR,CACF,EACA,QAAS,CACP,YAAa,oCACb,KAAM,UACN,QAAS,EACX,EACA,uBAAwB,CACtB,YACE,+FACF,KAAM,UACN,QAAS,EACX,EACA,oBAAqB,CACnB,YACE,6FACF,KAAM,UACN,QAAS,EACX,EACA,uBAAwB,CACtB,YACE,yFACF,KAAM,UACN,QAAS,EACX,EACA,aAAc,CACZ,YAAa,yEACb,KAAM,UACN,QAAS,EACX,EACA,wBAAyB,CACvB,YAAa,gCACb,KAAM,SACN,KAAM,CAAC,gBAAiB,YAAY,CACtC,EACA,oBAAqB,CACnB,YAAa,wBACb,KAAM,QACN,MAAO,CACL,KAAM,QACR,CACF,EACA,OAAQ,CACN,YAAa,4BACb,KAAM,SACN,WAAY,CACV,MAAO,CAC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",
  "names": ["import_pepr", "package_default", "import_pepr", "setupLogger", "component", "logLevel", "__name", "import_pepr", "import_pepr", "operator", "Store", "When", "import_pepr", "import_kubernetes_fluent_client", "Package", "__name", "Package", "import_kubernetes_fluent_client", "Exemption", "__name", "Policy", "Exemption", "import_kubernetes_fluent_client", "ClusterConfig", "__name", "ClusterConfig", "import_kubernetes_fluent_client", "VirtualService", "__name", "VirtualService", "import_kubernetes_fluent_client", "ServiceEntry", "__name", "ServiceEntry", "import_kubernetes_fluent_client", "PodMonitor", "__name", "PodMonitor", "import_kubernetes_fluent_client", "ServiceMonitor", "__name", "ServiceMonitor", "import_kubernetes_fluent_client", "AuthorizationPolicy", "__name", "AuthorizationPolicy", "import_kubernetes_fluent_client", "RequestAuthentication", "__name", "import_kubernetes_fluent_client", "DestinationRule", "__name", "DestinationRule", "import_kubernetes_fluent_client", "Gateway", "__name", "Gateway", "import_kubernetes_fluent_client", "Sidecar", "__name", "Sidecar", "import_kubernetes_fluent_client", "K8sGateway", "__name", "K8sGateway", "Gateway", "import_shared_types", "import_pepr", "import_crypto", "import_kubernetes_fluent_client", "import_pepr", "PROMETHEUS_PRINCIPAL", "watchCfg", "registerWatchEventHandlers", "watcher", "log", "watchName", "eventHandlers", "err", "retryCount", "event", "handler", "__name", "sanitizeResourceName", "name", "getOwnerRef", "cr", "uid", "purgeOrphans", "generation", "namespace", "pkgName", "kind", "additionalLabels", "query", "key", "value", "resources", "resource", "retryWithDelay", "fn", "retries", "delayMs", "attempt", "error", "resolve", "isBase64", "str", "createEvent", "resourceKind", "validateNamespace", "missingAllowed", "e", "getAuthserviceClients", "pkg", "sso", "validateCfgUpdate", "req", "validateCfg", "e", "__name", "cfg", "isBase64", "certBlocks", "certPem", "index", "import_pepr", "CA_BUNDLE_CONFIGMAP_LABEL", "DEFAULT_CONFIGMAP_NAME", "DEFAULT_CONFIGMAP_KEY", "log", "setupLogger", "caBundleConfigMap", "pkg", "namespace", "pkgName", "generation", "ownerRefs", "getOwnerRef", "configMapName", "configMapKey", "configMapLabels", "configMapAnnotations", "caBundleContent", "buildCABundleContent", "configMapManifest", "purgeOrphans", "err", "__name", "certs", "UDSConfig", "userCerts", "dodCerts", "publicCerts", "cert", "updateAllCaBundleConfigMaps", "packages", "Package", "import_pepr", "import_pepr", "log", "setupLogger", "packageNamespaceMap", "ssoIndex", "init", "__name", "add", "pkg", "logger", "namespace", "name", "namespaceMap", "isUpdate", "clients", "client", "clientId", "remove", "nsSet", "hasKey", "getPkgName", "findPackagesWithSsoClientId", "getAmbientPackages", "result", "getPackageByNamespace", "PackageStore", "import_pepr", "generateAmbientEgressAuthorizationPolicy", "host", "pkgName", "namespace", "generation", "ownerRefs", "serviceEntryName", "serviceAccount", "source", "generateAmbientEgressAuthorizationPolicyName", "__name", "sanitizeResourceName", "import_pepr", "import_pepr", "import_pepr", "generateIngressServiceEntry", "expose", "namespace", "pkgName", "generation", "ownerRefs", "gateway", "host", "name", "generateSEName", "domain", "UDSConfig", "fqdn", "serviceEntryPort", "serviceEntryEndpoint", "__name", "sanitizeResourceName", "generateLocalEgressServiceEntry", "hostResource", "istioMode", "portProtocol", "generateLocalEgressSEName", "ports", "pp", "serviceEntry", "egressWaypointName", "ambientEgressNamespace", "generateSharedServiceEntry", "resource", "generateSharedEgressSEName", "annotations", "pkgId", "getSharedAnnotationKey", "sidecarEgressNamespace", "sharedEgressPkgId", "ppString", "import_pepr", "generateIngressVirtualService", "expose", "namespace", "pkgName", "generation", "ownerRefs", "gateway", "host", "port", "service", "advancedHTTP", "name", "generateVSName", "domain", "UDSConfig", "fqdn", "http", "route", "payload", "__name", "description", "matchHash", "nameSuffix", "sanitizeResourceName", "generateEgressVirtualService", "resource", "generateEgressVSName", "annotations", "pkgId", "getSharedAnnotationKey", "httpRoutes", "tlsRoutes", "portProtocol", "protocol", "generateVirtualServiceRoutes", "sidecarEgressNamespace", "sharedEgressPkgId", "generateGatewayName", "meshMatch", "gatewayMatch", "warnMatchingExistingVirtualServices", "virtualServices", "VirtualService", "vs", "vsHost", "errText", "log", "log", "setupLogger", "istioResources", "pkg", "namespace", "pkgName", "generation", "ownerRefs", "getOwnerRef", "exposeList", "hosts", "serviceEntryNames", "expose", "vsPayload", "generateIngressVirtualService", "VirtualService", "h", "sePayload", "generateIngressServiceEntry", "ServiceEntry", "istioEgressResources", "purgeOrphans", "Sidecar", "AuthorizationPolicy", "__name", "istioMode", "pkgId", "getPackageId", "hostResourceMap", "createHostResourceMap", "allowList", "egressRequestedFromNetwork", "validateNamespace", "ambientEgressNamespace", "e", "errText", "createAmbientWorkloadEgressResources", "validateEgressGateway", "createSidecarWorkloadEgressResources", "reconcileSharedEgressResources", "getSharedAnnotationKey", "generateEgressGateway", "host", "resource", "generation", "name", "generateGatewayName", "annotations", "pkgId", "getSharedAnnotationKey", "servers", "portProtocol", "port", "protocol", "server", "generateGatewayServer", "sidecarEgressNamespace", "sharedEgressPkgId", "__name", "warnMatchingExistingGateways", "gateways", "Gateway", "gw", "srv", "srvHost", "errText", "log", "sanitizeResourceName", "generateEgressSidecar", "selector", "pkgName", "namespace", "generation", "ownerRefs", "generateSidecarName", "__name", "selectorString", "key", "value", "sanitizeResourceName", "sidecarEgressNamespace", "sharedEgressPkgId", "applySidecarEgressResources", "packageEgress", "generation", "egressResources", "remapEgressResources", "applyPromises", "host", "resource", "hostPromise", "applyHostResources", "__name", "purgeSidecarEgressResources", "purgeOrphans", "Gateway", "log", "VirtualService", "ServiceEntry", "e", "errText", "pkgId", "hostResourceMap", "portProtocols", "portProtocol", "pp", "warnMatchingExistingGateways", "warnMatchingExistingVirtualServices", "resourcePromises", "gatewayPromise", "gateway", "generateEgressGateway", "virtualServicePromise", "virtualService", "generateEgressVirtualService", "serviceEntryPromise", "serviceEntry", "generateSharedServiceEntry", "validateEgressGateway", "validateNamespace", "ports", "p", "createSidecarWorkloadEgressResources", "egressRequested", "pkgName", "namespace", "ownerRefs", "generateLocalEgressServiceEntry", "selectedWorkloads", "allow", "uniqueWorkloads", "workload", "sidecar", "generateEgressSidecar", "Sidecar", "inMemoryPackageMap", "sidecarLock", "sidecarLockQueue", "inMemoryAmbientPackageMap", "ambientLock", "ambientLockQueue", "reconciliationMutex", "lastReconciliationPackages", "sidecarGeneration", "ambientGeneration", "reconcileSharedEgressResources", "hostResourceMap", "pkgId", "action", "istioMode", "updateInMemoryPackageMap", "updateInMemoryAmbientPackageMap", "performEgressReconciliationWithMutex", "__name", "performEgressReconciliation", "e", "log", "updateLastReconciliationPackages", "errors", "validateNamespace", "sidecarEgressNamespace", "applySidecarEgressResources", "purgeSidecarEgressResources", "errText", "ambientEgressNamespace", "packageSet", "applyAmbientEgressResources", "purgeAmbientEgressResources", "aggregatedMessage", "err", "resolve", "validateProtocolConflicts", "removeMapResources", "nextResolve", "newPackageMap", "validatePortProtocolConflicts", "currentPackageMap", "newHostResourceMap", "newPkgId", "existingHostPortProtocols", "host", "hostResource", "portProtocol", "key", "existing", "errorMsg", "calculatedPackageMap", "portProtocolList", "pp", "newHost", "newHostResource", "createHostResourceMap", "pkg", "allow", "hostPortsProtocol", "getHostPortsProtocol", "port", "protocol", "ports", "packageMap", "egressRequestedFromNetwork", "allowList", "ambientEgressNamespace", "sharedEgressPkgId", "applyAmbientEgressResources", "packageList", "generation", "waypoint", "createEgressWaypointGateway", "waypointName", "log", "K8sGateway", "waitForWaypointPodHealthy", "__name", "purgeAmbientEgressResources", "purgeOrphans", "e", "errText", "createAmbientWorkloadEgressResources", "hostResourceMap", "egressRequested", "pkgName", "namespace", "ownerRefs", "host", "serviceEntry", "generateLocalEgressServiceEntry", "ServiceEntry", "allow", "hostPortsProtocol", "getHostPortsProtocol", "ports", "protocol", "portsProtocol", "port", "authPolicy", "generateAmbientEgressAuthorizationPolicy", "generateLocalEgressSEName", "AuthorizationPolicy", "WAYPOINT_SUFFIX", "shouldUseAmbientWaypoint", "__name", "pkg", "hasAuthserviceSSO", "s", "getWaypointName", "id", "waypointName", "getPodSelector", "selector", "serviceMatchesSelector", "svc", "svcSelector", "k", "v", "matchesLabels", "labels", "egressWaypointName", "ISTIO_WAYPOINT_LABEL", "UDS_MANAGED_LABEL", "HEALTH_OPTS", "setupAmbientWaypoint", "pkg", "client", "namespace", "name", "error", "log", "waypointId", "waypointName", "getWaypointName", "createWaypointGateway", "waitForWaypointPodHealthy", "reconcileExistingResources", "errorMessage", "__name", "gateway", "K8sGateway", "getOwnerRef", "applyError", "isWaypointPodHealthy", "pod", "cs", "start", "intervalMs", "timeoutMs", "attempts", "elapsed", "resolve", "reconcileService", "svc", "PackageStore", "matchingSso", "getAuthserviceClients", "sso", "serviceMatchesSelector", "reconcilePod", "matchesLabels", "podDisplayName", "cleanupWaypointLabels", "cleanupPodsWithWaypointLabel", "cleanupServicesWithWaypointLabel", "pods", "podName", "services", "svcName", "ssoClient", "matchingServices", "matchingPods", "createEgressWaypointGateway", "pkgs", "generation", "annotations", "pkgId", "getSharedAnnotationKey", "ambientEgressNamespace", "sharedEgressPkgId", "import_pepr", "operationMap", "setPolicyTarget", "spec", "isAmbient", "waypointName", "labelSelector", "__name", "buildNonMetricsOperations", "monitorExemptions", "entries", "portToPaths", "ex", "paths", "port", "arrPaths", "monitorPorts", "buildMetricsOperations", "authserviceAuthorizationPolicy", "name", "namespace", "nonMetricsOps", "unauthenticatedWhen", "rules", "policy", "sanitizeResourceName", "jwtAuthZAuthorizationPolicy", "metricsOps", "ssoJwtSource", "UDSConfig", "prometheusOrSsoJwtSource", "PROMETHEUS_PRINCIPAL", "authNRequestAuthentication", "updatePolicy", "event", "pkg", "operation", "generation", "ownerReferences", "getOwnerRef", "computeMonitorExemptions", "updateMetadata", "resource", "AuthorizationPolicy", "RequestAuthentication", "e", "msg", "log", "purgeOrphanPolicies", "pkgName", "kind", "purgeOrphans", "computeMonitorExemptions", "pkg", "labelSelector", "monitors", "out", "m", "sel", "matchesLabels", "__name", "import_crypto", "import_pepr", "pendingSecretFetch", "inMemorySecret", "pendingPackages", "lastSuccessfulSecret", "debounceTimer", "DEBOUNCE_DURATION", "operatorConfig", "initializeOperatorConfig", "UDSConfig", "log", "__name", "setupAuthserviceSecret", "secret", "updateAuthServiceSecret", "buildInitialSecret", "err", "config", "buildChain", "setAuthserviceConfig", "getAuthserviceConfig", "authserviceConfig", "checksum", "resolve", "reject", "base64EncodedConfig", "hash", "encodeConfig", "applySecret", "checksumDeployment", "p", "e", "c", "log", "setupLogger", "lock", "authservice", "pkg", "clients", "istioMode", "previousMeshMode", "isAmbient", "authServiceClients", "getAuthserviceClients", "newAuthserviceClients", "sso", "setupAmbientWaypoint", "client", "fullWaypointName", "getWaypointName", "reconcileAuthservice", "purgeAuthserviceClients", "purgeOrphans", "K8sGateway", "__name", "currentMeshMode", "prevClients", "meshModeChanged", "removedClients", "oldClient", "c", "cleanupWaypointLabels", "updatedWaypointClients", "newClient", "isAddOrRemoveClientEvent", "event", "labelSelector", "waypointName", "updateConfig", "updatePolicy", "config", "getAuthserviceConfig", "buildConfig", "setAuthserviceConfig", "e", "updateAuthServiceSecret", "chains", "chain", "buildChain", "update", "hostname", "UDSConfig", "operatorConfig", "import_pepr", "META_IP", "cloudMetadata", "anywhere", "META_IP", "anywhereInCluster", "log", "setupLogger", "nodeSet", "nodeNameToIPMap", "authorizationPolicyExists", "initAllNodesTarget", "UDSConfig", "nodeCidr", "updateKubeNodesNetworkPolicies", "updateKubeNodesAuthorizationPolicies", "nodes", "retryWithDelay", "fetchKubernetesNodes", "node", "ip", "getNodeInternalIP", "nodeName", "err", "__name", "kubeNodes", "policies", "buildNodePolicies", "anywhere", "updateKubeNodesFromCreateUpdate", "oldIP", "updateKubeNodesFromDelete", "newNodes", "netPols", "netPol", "updateRequired", "oldNodes", "message", "newIpBlocks", "peer", "cidr", "authPols", "AuthorizationPolicy", "summary", "pol", "rule", "oldIpBlocks", "nodeIPs", "format32cidr", "addr", "configLog", "setupLogger", "UDSConfig", "getConfigLogMessage", "action", "step", "resourceName", "isLoad", "__name", "shouldUpdateClusterResources", "shouldSkip", "cr", "isPending", "isCurrentGeneration", "configLog", "decodeSecret", "secret", "decodedData", "key", "decodedValue", "e", "handleCfgSecret", "cfg", "updateClusterResources", "decodedCfgData", "UDSConfig", "performAuthserviceUpdate", "shouldUpdateCaBundleConfigMaps", "caBundle", "dodCerts", "publicCerts", "handleCABundleUpdate", "caCertsConfigMap", "caBundleConfigMapsNeedUpdate", "updateAllCaBundleConfigMaps", "handleCfg", "ClusterConfig", "expose", "policy", "networking", "initAPIServerCIDR", "areKubeNodeCidrsEqual", "initAllNodesTarget", "loadUDSConfig", "cfgSecret", "validateCfg", "redactConfig", "authserviceRedisUri", "certs", "newCidrs", "currentCidrs", "sortedNewCidrs", "sortedCurrentCidrs", "cidr", "index", "reason", "authserviceUpdate", "reconcileAuthservice", "handleUDSCACertsConfigMapUpdate", "configMap", "currentCaBundle", "error", "startConfigWatch", "watcher", "phase", "watchCfg", "registerWatchEventHandlers", "log", "setupLogger", "apiServerPeers", "authorizationPolicyExists", "initAPIServerCIDR", "svc", "retryWithDelay", "fetchKubernetesService", "UDSConfig", "updateAPIServerCIDR", "slice", "fetchKubernetesEndpointSlice", "error", "__name", "kubeAPI", "anywhere", "updateAPIServerCIDRFromEndpointSlice", "err", "updateAPIServerCIDRFromService", "k8sApiIP", "peers", "endpoints", "e", "addr", "cidr", "updateKubeAPINetworkPolicies", "updateKubeAPIAuthorizationPolicies", "newPeers", "netPols", "netPol", "updateRequired", "oldPeers", "message", "newIpBlocks", "peer", "authPols", "AuthorizationPolicy", "summary", "pol", "rule", "oldIpBlocks", "import_crypto", "import_pepr", "import_pepr", "reloadPods", "namespace", "pods", "message", "log", "reason", "handledControllers", "standalonePodsToEvict", "pod", "phase", "controllerRef", "ref", "controllerKey", "handleReplicaSetOwner", "restartController", "error", "evictStandalonePods", "__name", "replicaSetName", "getReplicaSet", "deploymentOwner", "retryWithDelay", "controllerKind", "name", "controllerKindName", "k", "getController", "controller", "applyControllerAnnotation", "createControllerEvent", "createEvent", "groups", "controlledBy", "group", "evictPod", "err", "deletePod", "deleteErr", "log", "setupLogger", "secretChecksumCache", "configMapChecksumCache", "computeResourceChecksum", "data", "sortedKeys", "hash", "key", "__name", "discoverSecretConsumers", "namespace", "secretName", "pod", "volume", "source", "container", "env", "envFrom", "parseSelectorString", "value", "result", "pairs", "pair", "val", "discoverConfigMapConsumers", "configMapName", "handleResourceUpdate", "resource", "checksumCache", "discoverResourceConsumers", "resourceType", "name", "cacheKey", "currentChecksum", "previousChecksum", "podsToReload", "selectorStr", "selector", "errorMsg", "podQuery", "getPodsWithSelector", "retryWithDelay", "error", "getPodsUsingResource", "reloadPods", "handleResourceDelete", "handleSecretUpdate", "secret", "handleSecretDelete", "handleConfigMapUpdate", "configMap", "handleConfigMapDelete", "generateMonitorName", "pkgName", "monitor", "selector", "portName", "description", "nameSuffix", "sanitizeResourceName", "__name", "intraNamespace", "remoteCidr", "cidr", "__name", "egressGateway", "sidecarEgressNamespace", "egressWaypoint", "ambientEgressNamespace", "isWildcardNamespace", "namespace", "__name", "getPeers", "policy", "istioMode", "peers", "kubeAPI", "kubeNodes", "cloudMetadata", "intraNamespace", "anywhere", "anywhereInCluster", "peer", "remoteCidr", "egressWaypoint", "egressGateway", "generate", "generated", "generateName", "ports", "port", "name", "migrate", "pkg", "exposeList", "expose", "allowList", "allow", "migrateStatus", "__name", "buildMigratedAuthserviceStatus", "raw", "first", "ssoList", "id", "match", "s", "migrateAuthserviceStatus", "migrated", "current", "invalidNamespaces", "validator", "req", "pkg", "migrate", "pkgName", "ns", "deletionTimestamp", "istioMode", "PackageStore", "existingPkgName", "isStandardGateway", "__name", "g", "Gateway", "exposeList", "virtualServiceNames", "expose", "sanitizeResourceName", "name", "generateVSName", "networkPolicy", "networkPolicyNames", "policy", "generateName", "ssoClients", "clientIDs", "allowedClientAttributes", "client", "namespacesWithClientId", "attr", "monitors", "podMonitorNames", "svcMonitorNames", "monitor", "monitorName", "generateMonitorName", "isNothing", "subject", "__name", "isObject", "toArray", "sequence", "extend", "target", "source", "index", "length", "key", "sourceKeys", "repeat", "string", "count", "result", "cycle", "isNegativeZero", "number", "isNothing_1", "isObject_1", "toArray_1", "repeat_1", "isNegativeZero_1", "extend_1", "common", "formatError", "exception", "compact", "where", "message", "YAMLException$1", "reason", "mark", "getLine", "buffer", "lineStart", "lineEnd", "position", "maxLineLength", "head", "tail", "maxHalfLength", "padStart", "max", "makeSnippet", "options", "re", "lineStarts", "lineEnds", "match", "foundLineNo", "i", "line", "lineNoLength", "snippet", "TYPE_CONSTRUCTOR_OPTIONS", "YAML_NODE_KINDS", "compileStyleAliases", "map", "style", "alias", "Type$1", "tag", "name", "data", "type", "compileList", "schema", "currentType", "newIndex", "previousType", "previousIndex", "compileMap", "collectType", "Schema$1", "definition", "implicit", "explicit", "type$1", "str", "seq", "failsafe", "resolveYamlNull", "constructYamlNull", "isNull", "object", "_null", "resolveYamlBoolean", "constructYamlBoolean", "isBoolean", "bool", "isHexCode", "c", "isOctCode", "isDecCode", "resolveYamlInteger", "hasDigits", "ch", "constructYamlInteger", "value", "sign", "isInteger", "int", "obj", "YAML_FLOAT_PATTERN", "resolveYamlFloat", "constructYamlFloat", "SCIENTIFIC_WITHOUT_DOT", "representYamlFloat", "res", "isFloat", "float", "json", "core", "YAML_DATE_REGEXP", "YAML_TIMESTAMP_REGEXP", "resolveYamlTimestamp", "constructYamlTimestamp", "year", "month", "day", "hour", "minute", "second", "fraction", "delta", "tz_hour", "tz_minute", "date", "representYamlTimestamp", "timestamp", "resolveYamlMerge", "merge", "BASE64_MAP", "resolveYamlBinary", "code", "idx", "bitlen", "constructYamlBinary", "tailbits", "input", "bits", "representYamlBinary", "isBinary", "binary", "_hasOwnProperty$3", "_toString$2", "resolveYamlOmap", "objectKeys", "pair", "pairKey", "pairHasKey", "constructYamlOmap", "omap", "_toString$1", "resolveYamlPairs", "keys", "constructYamlPairs", "pairs", "_hasOwnProperty$2", "resolveYamlSet", "constructYamlSet", "set", "_default", "_hasOwnProperty$1", "CONTEXT_FLOW_IN", "CONTEXT_FLOW_OUT", "CONTEXT_BLOCK_IN", "CONTEXT_BLOCK_OUT", "CHOMPING_CLIP", "CHOMPING_STRIP", "CHOMPING_KEEP", "PATTERN_NON_PRINTABLE", "PATTERN_NON_ASCII_LINE_BREAKS", "PATTERN_FLOW_INDICATORS", "PATTERN_TAG_HANDLE", "PATTERN_TAG_URI", "_class", "is_EOL", "is_WHITE_SPACE", "is_WS_OR_EOL", "is_FLOW_INDICATOR", "fromHexCode", "lc", "escapedHexLen", "fromDecimalCode", "simpleEscapeSequence", "charFromCodepoint", "setProperty", "simpleEscapeCheck", "simpleEscapeMap", "State$1", "generateError", "state", "throwError", "throwWarning", "directiveHandlers", "args", "major", "minor", "handle", "prefix", "captureSegment", "start", "end", "checkJson", "_position", "_length", "_character", "_result", "mergeMappings", "destination", "overridableKeys", "quantity", "storeMappingPair", "keyTag", "keyNode", "valueNode", "startLine", "startLineStart", "startPos", "readLineBreak", "skipSeparationSpace", "allowComments", "checkIndent", "lineBreaks", "testDocumentSeparator", "writeFoldedLines", "readPlainScalar", "nodeIndent", "withinFlowCollection", "preceding", "following", "captureStart", "captureEnd", "hasPendingContent", "_line", "_lineStart", "_lineIndent", "_kind", "readSingleQuotedScalar", "readDoubleQuotedScalar", "hexLength", "hexResult", "tmp", "readFlowCollection", "readNext", "_pos", "_tag", "_anchor", "terminator", "isPair", "isExplicitPair", "isMapping", "composeNode", "readBlockScalar", "folding", "chomping", "didReadContent", "detectedIndent", "textIndent", "emptyLines", "atMoreIndented", "readBlockSequence", "detected", "readBlockMapping", "flowIndent", "allowCompact", "_keyLine", "_keyLineStart", "_keyPos", "atExplicitKey", "readTagProperty", "isVerbatim", "isNamed", "tagHandle", "tagName", "readAnchorProperty", "readAlias", "parentIndent", "nodeContext", "allowToSeek", "allowBlockStyles", "allowBlockScalars", "allowBlockCollections", "indentStatus", "atNewLine", "hasContent", "typeIndex", "typeQuantity", "typeList", "blockIndent", "readDocument", "documentStart", "directiveName", "directiveArgs", "hasDirectives", "loadDocuments", "nullpos", "loadAll$1", "iterator", "documents", "load$1", "loadAll_1", "load_1", "loader", "_toString", "_hasOwnProperty", "CHAR_BOM", "CHAR_TAB", "CHAR_LINE_FEED", "CHAR_CARRIAGE_RETURN", "CHAR_SPACE", "CHAR_EXCLAMATION", "CHAR_DOUBLE_QUOTE", "CHAR_SHARP", "CHAR_PERCENT", "CHAR_AMPERSAND", "CHAR_SINGLE_QUOTE", "CHAR_ASTERISK", "CHAR_COMMA", "CHAR_MINUS", "CHAR_COLON", "CHAR_EQUALS", "CHAR_GREATER_THAN", "CHAR_QUESTION", "CHAR_COMMERCIAL_AT", "CHAR_LEFT_SQUARE_BRACKET", "CHAR_RIGHT_SQUARE_BRACKET", "CHAR_GRAVE_ACCENT", "CHAR_LEFT_CURLY_BRACKET", "CHAR_VERTICAL_LINE", "CHAR_RIGHT_CURLY_BRACKET", "ESCAPE_SEQUENCES", "DEPRECATED_BOOLEANS_SYNTAX", "DEPRECATED_BASE60_SYNTAX", "compileStyleMap", "encodeHex", "character", "QUOTING_TYPE_SINGLE", "QUOTING_TYPE_DOUBLE", "State", "indentString", "spaces", "ind", "next", "generateNextLine", "level", "testImplicitResolving", "isWhitespace", "isPrintable", "isNsCharOrWhitespace", "isPlainSafe", "prev", "inblock", "cIsNsCharOrWhitespace", "cIsNsChar", "isPlainSafeFirst", "isPlainSafeLast", "codePointAt", "pos", "first", "needIndentIndicator", "leadingSpaceRe", "STYLE_PLAIN", "STYLE_SINGLE", "STYLE_LITERAL", "STYLE_FOLDED", "STYLE_DOUBLE", "chooseScalarStyle", "singleLineOnly", "indentPerLevel", "lineWidth", "testAmbiguousType", "quotingType", "forceQuotes", "char", "prevChar", "hasLineBreak", "hasFoldableLine", "shouldTrackWidth", "previousLineBreak", "plain", "writeScalar", "iskey", "indent", "testAmbiguity", "blockHeader", "dropEndingNewline", "foldString", "escapeString", "indentIndicator", "clip", "keep", "chomp", "width", "lineRe", "nextLF", "foldLine", "prevMoreIndented", "moreIndented", "breakRe", "curr", "escapeSeq", "writeFlowSequence", "writeNode", "writeBlockSequence", "writeFlowMapping", "objectKeyList", "objectKey", "objectValue", "pairBuffer", "writeBlockMapping", "explicitPair", "detectType", "block", "isblockseq", "tagStr", "objectOrArray", "duplicateIndex", "duplicate", "getDuplicateReferences", "objects", "duplicatesIndexes", "inspectNode", "dump$1", "dump_1", "dumper", "renamed", "from", "to", "Type", "Schema", "FAILSAFE_SCHEMA", "JSON_SCHEMA", "CORE_SCHEMA", "DEFAULT_SCHEMA", "load", "loadAll", "dump", "YAMLException", "types", "safeLoad", "safeLoadAll", "safeDump", "jsYaml", "import_pepr", "TENANT_GATEWAY_NAMESPACE", "ADMIN_GATEWAY_NAMESPACE", "RESTART_REASON", "log", "setupLogger", "lastSeenMeshConfig", "restartGatewayPods", "istioConfig", "mesh", "meshConfig", "jsYaml", "tenantGatewayPods", "adminGatewayPods", "reloadPods", "__name", "import_pepr", "byteToHex", "i", "unsafeStringify", "arr", "offset", "__name", "import_node_crypto", "rnds8Pool", "poolPtr", "rng", "__name", "import_node_crypto", "native_default", "_v4", "options", "buf", "offset", "rnds", "rng", "i", "unsafeStringify", "__name", "v4", "native_default", "v4_default", "KEYCLOAK_CLIENT_SECRET_KEY", "KEYCLOAK_CLIENTS_SECRET_NAMESPACE", "KEYCLOAK_CLIENTS_SECRET_NAME", "log", "setupLogger", "updateKeycloakClientsSecret", "config", "forceRotation", "v4_default", "__name", "checkForSlashes", "name", "__name", "validNs", "kindToPolicyMap", "Policy", "p", "exemptValidator", "req", "exempt", "exemptions", "UDSConfig", "e", "policies", "validKind", "err", "import_pepr", "uidSeen", "log", "setupLogger", "shouldSkip", "cr", "isRetrying", "isPending", "isRemoving", "isCurrentGeneration", "__name", "updateStatus", "status", "migratedStatus", "normalized", "buildMigratedAuthserviceStatus", "Package", "writeEvent", "event", "handleFailure", "err", "metadata", "identifier", "detailedMessage", "retryAttempt", "currRetry", "getReadinessConditions", "finalErr", "ready", "import_pepr", "log", "setupLogger", "INJECTION_LABEL", "AMBIENT_LABEL", "ISTIO_STATE_ANNOTATION", "IstioState", "enableIstio", "pkg", "sourceNS", "labels", "annotations", "pkgKey", "currentIstioState", "getCurrentIstioState", "targetIstioState", "result", "getIstioLabels", "applyNamespaceUpdates", "restartPodsIfNeeded", "__name", "cleanupNamespace", "currentState", "originalIstioState", "hasOtherPackages", "key", "killPods", "ns", "wantSidecar", "pods", "groups", "pod", "foundSidecar", "controlledBy", "ref", "group", "a", "b", "action", "namespace", "originalLabels", "originalAnnotations", "logMessage", "updatedNamespace", "shouldRestart", "targetState", "shouldRestartPods", "import_pepr", "import_pepr", "baseUrl", "log", "setupLogger", "throwErrorIfNeeded", "response", "onError", "status", "statusText", "data", "err", "__name", "parseKeycloakToken", "token", "__name", "clientsAdminUrl", "baseUrl", "clientCredentialsUrl", "SECRET_NAMESPACE", "SECRET_NAME", "UDS_OPERATOR_CLIENT_ID", "cachedToken", "resetCachedToken", "credentialsGetAccessToken", "jwt", "e", "log", "secret", "encodedSecret", "clientSecret", "params", "response", "throwErrorIfNeeded", "credentialsCreateOrUpdate", "client", "credentialsGet", "credentialsUpdate", "credentialsCreate", "url", "existing", "credentialsDelete", "clientKeys", "samlDescriptorUrl", "secretTemplateRegex", "idpSSODescriptorRegex", "x509CertRegex", "log", "setupLogger", "keycloak", "pkg", "clientReqs", "clients", "generation", "clientReq", "client", "syncClient", "purgeSSOClients", "e", "purgeOrphans", "__name", "newClients", "toRemove", "ref", "credentialsDelete", "err", "convertSsoToClient", "sso", "key", "clientKeys", "secretName", "secretTemplate", "isRetry", "name", "credentialsCreateOrUpdate", "msg", "retryErr", "retryMsg", "getSamlCertificate", "sanitizedSecretName", "sanitizeResourceName", "secretLabels", "secretAnnotations", "getOwnerRef", "generateSecretData", "templateData", "stringMap", "value", "processed", "resp", "extractSamlCertificateFromXML", "xmlString", "templated", "_match", "fieldName", "json", "import_pepr", "log", "setupLogger", "podMonitor", "pkg", "namespace", "pkgName", "generation", "ownerRefs", "getOwnerRef", "monitorList", "payloads", "monitor", "payload", "generatePodMonitor", "PodMonitor", "purgeOrphans", "err", "m", "__name", "selector", "podSelector", "portName", "generateMonitorName", "import_pepr", "log", "setupLogger", "serviceMonitor", "pkg", "namespace", "pkgName", "generation", "ownerRefs", "getOwnerRef", "monitorList", "payloads", "monitor", "payload", "generateServiceMonitor", "ServiceMonitor", "purgeOrphans", "err", "m", "__name", "selector", "portName", "generateMonitorName", "import_pepr", "log", "setupLogger", "generateMonitorName", "monitor", "selector", "portPart", "baseName", "__name", "generateAllowName", "rule", "description", "remoteGenerated", "remoteNamespace", "remoteSelector", "generateExposeName", "effectivePort", "selPart", "gateway", "processAllowRule", "pkgNamespace", "ports", "p", "source", "hasRemoteSA", "hasRemoteNS", "META_IP", "kubeAPI", "peer", "cidr", "kubeNodes", "processExposeRule", "isEmpty", "obj", "buildAuthPolicy", "policyName", "pkg", "additionalLabels", "ruleEntry", "pkgName", "generation", "getOwnerRef", "generateAuthorizationPolicies", "istioMode", "policies", "sso", "findMatchingSsoClient", "waypointName", "getWaypointName", "waypointSelector", "sanitizeResourceName", "authPolicy", "waypointPorts", "labelString", "k", "v", "PROMETHEUS_PRINCIPAL", "shouldUseAmbientWaypoint", "appSelector", "denyPolicy", "createDenyAllExceptWaypointPolicy", "IstioState", "extraPolicyName", "extraPolicy", "policy", "AuthorizationPolicy", "err", "purgeOrphans", "getAuthserviceClients", "client", "key", "value", "import_pepr", "allowEgressDNS", "__name", "namespace", "netPol", "generate", "allowEgressIstiod", "__name", "namespace", "clientId", "podSelector", "policy", "generate", "allowIngressSidecarMonitoring", "__name", "namespace", "generate", "defaultDenyAll", "namespace", "__name", "allowAmbientHealthprobes", "__name", "namespace", "generate", "findMatchingClient", "pkg", "podLabels", "authserviceClients", "getAuthserviceClients", "sso", "selector", "key", "value", "__name", "log", "setupLogger", "networkPolicies", "namespace", "istioMode", "customPolicies", "pkgName", "generation", "policies", "defaultDenyAll", "allowEgressDNS", "allowEgressIstiod", "allowIngressSidecarMonitoring", "allowAmbientHealthprobes", "policy", "matchingClient", "waypointName", "getWaypointName", "getPodSelector", "generatedPolicy", "generate", "exposeList", "expose", "exp", "gateway", "port", "targetPort", "policyPort", "podSelector", "ssos", "netpolSelector", "sanitizeResourceName", "keycloakPolicy", "keycloakGeneratedPolicy", "shouldUseAmbientWaypoint", "appSelector", "istiodPolicy", "monitorList", "monitor", "allowSelector", "idx", "ingress", "egress", "getOwnerRef", "err", "message", "UDSConfig", "purgeOrphans", "log", "setupLogger", "packageReconciler", "pkg", "metadata", "namespace", "name", "shouldSkip", "migrate", "backOffSeconds", "writeEvent", "resolve", "updateStatus", "getReadinessConditions", "reconcilePackageFlow", "err", "handleFailure", "__name", "istioMode", "netPol", "networkPolicies", "authPol", "generateAuthorizationPolicies", "enableIstio", "endpoints", "ssoClients", "authserviceClients", "UDSConfig", "keycloak", "authservice", "istioResources", "numEgressAuthPols", "egressRequestedFromNetwork", "monitors", "podMonitor", "serviceMonitor", "caBundleConfigMap", "packageFinalizer", "retryWithDelay", "cleanupNamespace", "e", "currentMeshMode", "purgeAuthserviceClients", "purgeSSOClients", "reconcileSharedEgressResources", "getPackageId", "log", "setupLogger", "UDSConfig", "When", "updateAPIServerCIDRFromEndpointSlice", "updateAPIServerCIDRFromService", "req", "reconcileService", "reconcilePod", "Package", "validator", "packageReconciler", "packageFinalizer", "Exemption", "exemptValidator", "updateKubeNodesFromCreateUpdate", "updateKubeNodesFromDelete", "secret", "handleCfgSecret", "ClusterConfig", "validateCfgUpdate", "cfg", "handleCfg", "handleUDSCACertsConfigMapUpdate", "KEYCLOAK_CLIENTS_SECRET_NAMESPACE", "KEYCLOAK_CLIENTS_SECRET_NAME", "s", "updateKeycloakClientsSecret", "handleSecretUpdate", "handleSecretDelete", "handleConfigMapUpdate", "handleConfigMapDelete", "restartGatewayPods", "import_pepr", "log", "setupLogger", "setupKeycloakClientSecret", "KEYCLOAK_CLIENTS_SECRET_NAMESPACE", "KEYCLOAK_CLIENTS_SECRET_NAME", "updateKeycloakClientsSecret", "err", "__name", "import_shared_types", "import_pepr", "log", "setupLogger", "startPackageWatch", "PackageStore", "watcher", "Package", "pkg", "phase", "processPackages", "watchCfg", "registerWatchEventHandlers", "__name", "import_pepr", "v1alpha1", "matchRequired", "matchTemplate", "advancedHTTP", "AuthorizationSchema", "allow", "expose", "advancedHTTP", "serviceMesh", "monitor", "sso", "caBundle", "v1alpha1", "log", "setupLogger", "registerCRDs", "v1alpha1", "log", "err", "__name", "import_pepr", "patches", "import_pepr", "log", "setupLogger", "policyExemptionMap", "policyOwnerMap", "init", "p", "Policy", "__name", "getByPolicy", "policy", "setByPolicy", "matchers", "addMatcher", "matcher", "owner", "storedMatcher", "add", "exemption", "logger", "remove", "e", "policies", "prevExemption", "filteredList", "m", "ExemptionStore", "import_shared_types", "processExemptions", "exemption", "phase", "ExemptionStore", "__name", "import_pepr", "import_pepr", "containers", "policies", "When", "log", "setupLogger", "zarfRegistry", "ISTIO_IMAGE_FLAVOR_CONFIGS", "parseImageRef", "imageRef", "trimmed", "imageWithoutTag", "parts", "firstPart", "isRegistry", "registry", "repository", "error", "__name", "validateIstioImage", "imageString", "parsed", "config", "volumes", "request", "securityContextContainers", "excludeIstioInit", "c", "isIstioInitContainer", "securityContextMessage", "msg", "authorized", "ctx", "violations", "authMsg", "a", "container", "isIstioProxyContainer", "p", "transform", "policy", "annotateMutation", "key", "valStr", "arr", "safePolicyName", "log", "setupLogger", "isExempt", "request", "policy", "exemptList", "ExemptionStore", "resourceName", "resourceNamespace", "exempt", "__name", "exemptionAnnotationPrefix", "markExemption", "containers", "When", "markExemption", "request", "isExempt", "violations", "checkIstioSidecarOverrides", "pod", "blockedAnnotations", "annotations", "annotation", "a", "b", "__name", "podContainers", "checkIstioTrafficInterceptionOverrides", "namespace", "labels", "blockedTrafficAnnotations", "blockedTrafficLabels", "annotationViolations", "key", "isIstioWaypointPod", "container", "isIstioProxyContainer", "arg", "labelViolations", "value", "checkIstioAmbientOverrides", "ambientBlockedAnnotations", "isPodUsingIstioUserID", "violatingContainer", "findContainerUsingIstioUserID", "podSecurityCtx", "containerCtx", "import_pepr", "containers", "When", "markExemption", "request", "isExempt", "podSpec", "checkNoHostNamespaces", "pod", "__name", "containerList", "checkNoHostPorts", "c", "p", "checkNotExternalNameService", "serviceSpec", "checkNotNodePortService", "import_pepr", "containers", "When", "request", "markExemption", "exemptionAnnotationPrefix", "setPrivilegeEscalation", "annotateMutation", "isExempt", "violations", "validatePrivilegeEscalation", "securityContextContainers", "securityContextMessage", "wasMutated", "container", "__name", "c", "setNonRootUserSettings", "podCtx", "isRootSecurityContext", "pod", "metadata", "runAsUser", "runAsGroup", "fsGroup", "ctx", "isRunAsRoot", "isRunAsRootUser", "hasRootSupplementalGroups", "authorized", "validateProcMount", "allowedTypes", "isPodViolation", "validateSeccompProfile", "message", "podSecurityContext", "podSeccompType", "validateSELinuxOptions", "seLinuxOptions", "validateSELinuxTypes", "authorizedTypes", "podSeLinuxType", "setAllContainersDropAllCapabilities", "findContainersWithoutDropAllCapability", "requiredCapability", "validateContainerCapabilities", "allowedCapabilities", "cap", "import_pepr", "containers", "When", "markExemption", "request", "isExempt", "isValid", "invalidVolume", "validateVolumeTypes", "volumes", "allowedVolumeTypes", "volume", "volumeType", "key", "__name", "validateHostPathVolumes", "c", "mount", "log", "setupLogger", "startExemptionWatch", "ExemptionStore", "watcher", "Exemption", "exemption", "phase", "processExemptions", "watchCfg", "registerWatchEventHandlers", "__name", "import_pepr", "log", "setupLogger", "prometheus", "When", "mutateServiceMonitor", "sm", "__name", "ServiceMonitor", "mutatePodMonitor", "pm", "PodMonitor", "log", "setupLogger", "loadUDSConfig", "registerCRDs", "startConfigWatch", "startExemptionWatch", "startPackageWatch", "initAPIServerCIDR", "initAllNodesTarget", "setupAuthserviceSecret", "setupKeycloakClientSecret", "package_default", "operator", "policies", "prometheus", "patches", "err"]
}
