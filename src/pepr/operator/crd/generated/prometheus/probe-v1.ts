/**
 * Copyright 2026 Defense Unicorns
 * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial
 */

// This file is auto-generated by kubernetes-fluent-client, do not edit manually
import { GenericKind, RegisterKind } from "kubernetes-fluent-client";
/**
 * The `Probe` custom resource definition (CRD) defines how to scrape metrics from prober
 * exporters such as the [blackbox
 * exporter](https://github.com/prometheus/blackbox_exporter).
 *
 * The `Probe` resource needs 2 pieces of information:
 * * The list of probed addresses which can be defined statically or by discovering
 * Kubernetes Ingress objects.
 * * The prober which exposes the availability of probed endpoints (over various protocols
 * such HTTP, TCP, ICMP, ...) as Prometheus metrics.
 *
 * `Prometheus` and `PrometheusAgent` objects select `Probe` objects using label and
 * namespace selectors.
 */
export class Probe extends GenericKind {
  /**
   * APIVersion defines the versioned schema of this representation of an object.
   * Servers should convert recognized schemas to the latest internal value, and
   * may reject unrecognized values.
   * More info:
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   */
  declare apiVersion?: string;
  /**
   * Kind is a string value representing the REST resource this object represents.
   * Servers may infer this from the endpoint the client submits requests to.
   * Cannot be updated.
   * In CamelCase.
   * More info:
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   */
  declare kind?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  declare metadata?: { [key: string]: any };
  /**
   * spec defines the specification of desired Ingress selection for target discovery by
   * Prometheus.
   */
  spec?: Spec;
  /**
   * status defines the status subresource. It is under active development and is updated only
   * when the
   * "StatusForConfigurationResources" feature gate is enabled.
   *
   * Most recent observed status of the Probe. Read-only.
   * More info:
   *
   * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   */
  status?: Status;
}

/**
 * spec defines the specification of desired Ingress selection for target discovery by
 * Prometheus.
 */
export interface Spec {
  /**
   * authorization configures the Authorization header credentials used by
   * the client.
   *
   * Cannot be set at the same time as `basicAuth`, `bearerTokenSecret` or `oauth2`.
   */
  authorization?: Authorization;
  /**
   * basicAuth defines the Basic Authentication credentials used by the
   * client.
   *
   * Cannot be set at the same time as `authorization`, `bearerTokenSecret` or `oauth2`.
   */
  basicAuth?: BasicAuth;
  /**
   * bearerTokenSecret defines a key of a Secret containing the bearer token
   * used by the client for authentication. The secret needs to be in the
   * same namespace as the custom resource and readable by the Prometheus
   * Operator.
   *
   * Cannot be set at the same time as `authorization`, `basicAuth` or `oauth2`.
   *
   * Deprecated: use `authorization` instead.
   */
  bearerTokenSecret?: BearerTokenSecret;
  /**
   * convertClassicHistogramsToNHCB defines whether to convert all scraped classic histograms
   * into a native histogram with custom buckets.
   * It requires Prometheus >= v3.0.0.
   */
  convertClassicHistogramsToNHCB?: boolean;
  /**
   * enableHttp2 can be used to disable HTTP2.
   */
  enableHttp2?: boolean;
  /**
   * fallbackScrapeProtocol defines the protocol to use if a scrape returns blank,
   * unparseable, or otherwise invalid Content-Type.
   *
   * It requires Prometheus >= v3.0.0.
   */
  fallbackScrapeProtocol?: FallbackScrapeProtocol;
  /**
   * followRedirects defines whether the client should follow HTTP 3xx
   * redirects.
   */
  followRedirects?: boolean;
  /**
   * interval at which targets are probed using the configured prober.
   * If not specified Prometheus' global scrape interval is used.
   */
  interval?: string;
  /**
   * jobName assigned to scraped metrics by default.
   */
  jobName?: string;
  /**
   * keepDroppedTargets defines the per-scrape limit on the number of targets dropped by
   * relabeling
   * that will be kept in memory. 0 means no limit.
   *
   * It requires Prometheus >= v2.47.0.
   */
  keepDroppedTargets?: number;
  /**
   * labelLimit defines the per-scrape limit on number of labels that will be accepted for a
   * sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   */
  labelLimit?: number;
  /**
   * labelNameLengthLimit defines the per-scrape limit on length of labels name that will be
   * accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   */
  labelNameLengthLimit?: number;
  /**
   * labelValueLengthLimit defines the per-scrape limit on length of labels value that will be
   * accepted for a sample.
   * Only valid in Prometheus versions 2.27.0 and newer.
   */
  labelValueLengthLimit?: number;
  /**
   * metricRelabelings defines the RelabelConfig to apply to samples before ingestion.
   */
  metricRelabelings?: MetricRelabeling[];
  /**
   * module to use for probing specifying how to probe the target.
   * Example module configuring in the blackbox exporter:
   * https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
   */
  module?: string;
  /**
   * nativeHistogramBucketLimit defines ff there are more than this many buckets in a native
   * histogram,
   * buckets will be merged to stay within the limit.
   * It requires Prometheus >= v2.45.0.
   */
  nativeHistogramBucketLimit?: number;
  /**
   * nativeHistogramMinBucketFactor defines if the growth factor of one bucket to the next is
   * smaller than this,
   * buckets will be merged to increase the factor sufficiently.
   * It requires Prometheus >= v2.50.0.
   */
  nativeHistogramMinBucketFactor?: number | string;
  /**
   * oauth2 defines the OAuth2 settings used by the client.
   *
   * It requires Prometheus >= 2.27.0.
   *
   * Cannot be set at the same time as `authorization`, `basicAuth` or `bearerTokenSecret`.
   */
  oauth2?: Oauth2;
  /**
   * params defines the list of HTTP query parameters for the scrape.
   * Please note that the `.spec.module` field takes precedence over the `module` parameter
   * from this list when both are defined.
   * The module name must be added using Module under ProbeSpec.
   */
  params?: Param[];
  /**
   * prober defines the specification for the prober to use for probing targets.
   * The prober.URL parameter is required. Targets cannot be probed if left empty.
   */
  prober?: Prober;
  /**
   * sampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   */
  sampleLimit?: number;
  /**
   * scrapeClass defines the scrape class to apply.
   */
  scrapeClass?: string;
  /**
   * scrapeClassicHistograms defines whether to scrape a classic histogram that is also
   * exposed as a native histogram.
   * It requires Prometheus >= v2.45.0.
   *
   * Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms`
   * field in the Prometheus configuration.
   */
  scrapeClassicHistograms?: boolean;
  /**
   * scrapeNativeHistograms defines whether to enable scraping of native histograms.
   * It requires Prometheus >= v3.8.0.
   */
  scrapeNativeHistograms?: boolean;
  /**
   * scrapeProtocols defines the protocols to negotiate during a scrape. It tells clients the
   * protocols supported by Prometheus in order of preference (from most to least preferred).
   *
   * If unset, Prometheus uses its default value.
   *
   * It requires Prometheus >= v2.49.0.
   */
  scrapeProtocols?: FallbackScrapeProtocol[];
  /**
   * scrapeTimeout defines the timeout for scraping metrics from the Prometheus exporter.
   * If not specified, the Prometheus global scrape timeout is used.
   * The value cannot be greater than the scrape interval otherwise the operator will reject
   * the resource.
   */
  scrapeTimeout?: string;
  /**
   * targetLimit defines a limit on the number of scraped targets that will be accepted.
   */
  targetLimit?: number;
  /**
   * targets defines a set of static or dynamically discovered targets to probe.
   */
  targets?: Targets;
  /**
   * tlsConfig defines the TLS configuration used by the client.
   */
  tlsConfig?: SpecTLSConfig;
}

/**
 * authorization configures the Authorization header credentials used by
 * the client.
 *
 * Cannot be set at the same time as `basicAuth`, `bearerTokenSecret` or `oauth2`.
 */
export interface Authorization {
  /**
   * credentials defines a key of a Secret in the namespace that contains the credentials for
   * authentication.
   */
  credentials?: Credentials;
  /**
   * type defines the authentication type. The value is case-insensitive.
   *
   * "Basic" is not a supported value.
   *
   * Default: "Bearer"
   */
  type?: string;
}

/**
 * credentials defines a key of a Secret in the namespace that contains the credentials for
 * authentication.
 */
export interface Credentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * basicAuth defines the Basic Authentication credentials used by the
 * client.
 *
 * Cannot be set at the same time as `authorization`, `bearerTokenSecret` or `oauth2`.
 */
export interface BasicAuth {
  /**
   * password defines a key of a Secret containing the password for
   * authentication.
   */
  password?: Password;
  /**
   * username defines a key of a Secret containing the username for
   * authentication.
   */
  username?: Username;
}

/**
 * password defines a key of a Secret containing the password for
 * authentication.
 */
export interface Password {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * username defines a key of a Secret containing the username for
 * authentication.
 */
export interface Username {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * bearerTokenSecret defines a key of a Secret containing the bearer token
 * used by the client for authentication. The secret needs to be in the
 * same namespace as the custom resource and readable by the Prometheus
 * Operator.
 *
 * Cannot be set at the same time as `authorization`, `basicAuth` or `oauth2`.
 *
 * Deprecated: use `authorization` instead.
 */
export interface BearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * fallbackScrapeProtocol defines the protocol to use if a scrape returns blank,
 * unparseable, or otherwise invalid Content-Type.
 *
 * It requires Prometheus >= v3.0.0.
 *
 * ScrapeProtocol represents a protocol used by Prometheus for scraping metrics.
 * Supported values are:
 * * `OpenMetricsText0.0.1`
 * * `OpenMetricsText1.0.0`
 * * `PrometheusProto`
 * * `PrometheusText0.0.4`
 * * `PrometheusText1.0.0`
 */
export enum FallbackScrapeProtocol {
  OpenMetricsText001 = "OpenMetricsText0.0.1",
  OpenMetricsText100 = "OpenMetricsText1.0.0",
  PrometheusProto = "PrometheusProto",
  PrometheusText004 = "PrometheusText0.0.4",
  PrometheusText100 = "PrometheusText1.0.0",
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 */
export interface MetricRelabeling {
  /**
   * action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   */
  action?: Action;
  /**
   * modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   */
  modulus?: number;
  /**
   * regex defines the regular expression against which the extracted value is matched.
   */
  regex?: string;
  /**
   * replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   */
  replacement?: string;
  /**
   * separator defines the string between concatenated SourceLabels.
   */
  separator?: string;
  /**
   * sourceLabels defines the source labels select values from existing labels. Their content
   * is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   */
  sourceLabels?: string[];
  /**
   * targetLabel defines the label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   */
  targetLabel?: string;
}

/**
 * action to perform based on the regex matching.
 *
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
 * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
 *
 * Default: "Replace"
 */
export enum Action {
  ActionDrop = "Drop",
  ActionKeep = "Keep",
  ActionLowercase = "Lowercase",
  ActionReplace = "Replace",
  ActionUppercase = "Uppercase",
  Drop = "drop",
  DropEqual = "DropEqual",
  Dropequal = "dropequal",
  HashMod = "HashMod",
  Hashmod = "hashmod",
  Keep = "keep",
  KeepEqual = "KeepEqual",
  Keepequal = "keepequal",
  LabelDrop = "LabelDrop",
  LabelKeep = "LabelKeep",
  LabelMap = "LabelMap",
  Labeldrop = "labeldrop",
  Labelkeep = "labelkeep",
  Labelmap = "labelmap",
  Lowercase = "lowercase",
  Replace = "replace",
  Uppercase = "uppercase",
}

/**
 * oauth2 defines the OAuth2 settings used by the client.
 *
 * It requires Prometheus >= 2.27.0.
 *
 * Cannot be set at the same time as `authorization`, `basicAuth` or `bearerTokenSecret`.
 */
export interface Oauth2 {
  /**
   * clientId defines a key of a Secret or ConfigMap containing the
   * OAuth2 client's ID.
   */
  clientId: ClientID;
  /**
   * clientSecret defines a key of a Secret containing the OAuth2
   * client's secret.
   */
  clientSecret: ClientSecret;
  /**
   * endpointParams configures the HTTP parameters to append to the token
   * URL.
   */
  endpointParams?: { [key: string]: string };
  /**
   * noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain
   * names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  noProxy?: string;
  /**
   * proxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  proxyConnectHeader?: { [key: string]: Oauth2ProxyConnectHeader[] };
  /**
   * proxyFromEnvironment defines whether to use the proxy configuration defined by
   * environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  proxyFromEnvironment?: boolean;
  /**
   * proxyUrl defines the HTTP proxy server to use.
   */
  proxyUrl?: string;
  /**
   * scopes defines the OAuth2 scopes used for the token request.
   */
  scopes?: string[];
  /**
   * tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
   * It requires Prometheus >= v2.43.0.
   */
  tlsConfig?: Oauth2TLSConfig;
  /**
   * tokenUrl defines the URL to fetch the token from.
   */
  tokenUrl: string;
}

/**
 * clientId defines a key of a Secret or ConfigMap containing the
 * OAuth2 client's ID.
 */
export interface ClientID {
  /**
   * configMap defines the ConfigMap containing data to use for the targets.
   */
  configMap?: ClientIDConfigMap;
  /**
   * secret defines the Secret containing data to use for the targets.
   */
  secret?: ClientIDSecret;
}

/**
 * configMap defines the ConfigMap containing data to use for the targets.
 */
export interface ClientIDConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * secret defines the Secret containing data to use for the targets.
 */
export interface ClientIDSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * clientSecret defines a key of a Secret containing the OAuth2
 * client's secret.
 */
export interface ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * SecretKeySelector selects a key of a Secret.
 */
export interface Oauth2ProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
 * It requires Prometheus >= v2.43.0.
 */
export interface Oauth2TLSConfig {
  /**
   * ca defines the Certificate authority used when verifying server certificates.
   */
  ca?: PurpleCA;
  /**
   * cert defines the Client certificate to present when doing client-authentication.
   */
  cert?: PurpleCERT;
  /**
   * insecureSkipVerify defines how to disable target certificate validation.
   */
  insecureSkipVerify?: boolean;
  /**
   * keySecret defines the Secret containing the client key file for the targets.
   */
  keySecret?: PurpleKeySecret;
  /**
   * maxVersion defines the maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
   */
  maxVersion?: Version;
  /**
   * minVersion defines the minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
   */
  minVersion?: Version;
  /**
   * serverName is used to verify the hostname for the targets.
   */
  serverName?: string;
}

/**
 * ca defines the Certificate authority used when verifying server certificates.
 */
export interface PurpleCA {
  /**
   * configMap defines the ConfigMap containing data to use for the targets.
   */
  configMap?: PurpleConfigMap;
  /**
   * secret defines the Secret containing data to use for the targets.
   */
  secret?: PurpleSecret;
}

/**
 * configMap defines the ConfigMap containing data to use for the targets.
 */
export interface PurpleConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * secret defines the Secret containing data to use for the targets.
 */
export interface PurpleSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * cert defines the Client certificate to present when doing client-authentication.
 */
export interface PurpleCERT {
  /**
   * configMap defines the ConfigMap containing data to use for the targets.
   */
  configMap?: FluffyConfigMap;
  /**
   * secret defines the Secret containing data to use for the targets.
   */
  secret?: FluffySecret;
}

/**
 * configMap defines the ConfigMap containing data to use for the targets.
 */
export interface FluffyConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * secret defines the Secret containing data to use for the targets.
 */
export interface FluffySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * keySecret defines the Secret containing the client key file for the targets.
 */
export interface PurpleKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * maxVersion defines the maximum acceptable TLS version.
 *
 * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
 *
 * minVersion defines the minimum acceptable TLS version.
 *
 * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
 */
export enum Version {
  Tls10 = "TLS10",
  Tls11 = "TLS11",
  Tls12 = "TLS12",
  Tls13 = "TLS13",
}

/**
 * ProbeParam defines specification of extra parameters for a Probe.
 */
export interface Param {
  /**
   * name defines the parameter name
   */
  name: string;
  /**
   * values defines the parameter values
   */
  values?: string[];
}

/**
 * prober defines the specification for the prober to use for probing targets.
 * The prober.URL parameter is required. Targets cannot be probed if left empty.
 */
export interface Prober {
  /**
   * noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain
   * names
   * that should be excluded from proxying. IP and domain names can
   * contain port numbers.
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  noProxy?: string;
  /**
   * path to collect metrics from.
   * Defaults to `/probe`.
   */
  path?: string;
  /**
   * proxyConnectHeader optionally specifies headers to send to
   * proxies during CONNECT requests.
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  proxyConnectHeader?: { [key: string]: ProberProxyConnectHeader[] };
  /**
   * proxyFromEnvironment defines whether to use the proxy configuration defined by
   * environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
   *
   * It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
   */
  proxyFromEnvironment?: boolean;
  /**
   * proxyUrl defines the HTTP proxy server to use.
   */
  proxyUrl?: string;
  /**
   * scheme defines the HTTP scheme to use when scraping the prober.
   */
  scheme?: Scheme;
  /**
   * url defines the address of the prober.
   *
   * Unlike what the name indicates, the value should be in the form of
   * `address:port` without any scheme which should be specified in the
   * `scheme` field.
   */
  url: string;
}

/**
 * SecretKeySelector selects a key of a Secret.
 */
export interface ProberProxyConnectHeader {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * scheme defines the HTTP scheme to use when scraping the prober.
 */
export enum Scheme {
  HTTP = "http",
  HTTPS = "https",
  SchemeHTTP = "HTTP",
  SchemeHTTPS = "HTTPS",
}

/**
 * targets defines a set of static or dynamically discovered targets to probe.
 */
export interface Targets {
  /**
   * ingress defines the Ingress objects to probe and the relabeling
   * configuration.
   * If `staticConfig` is also defined, `staticConfig` takes precedence.
   */
  ingress?: Ingress;
  /**
   * staticConfig defines the static list of targets to probe and the
   * relabeling configuration.
   * If `ingress` is also defined, `staticConfig` takes precedence.
   * More info:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
   */
  staticConfig?: StaticConfig;
}

/**
 * ingress defines the Ingress objects to probe and the relabeling
 * configuration.
 * If `staticConfig` is also defined, `staticConfig` takes precedence.
 */
export interface Ingress {
  /**
   * namespaceSelector defines from which namespaces to select Ingress objects.
   */
  namespaceSelector?: NamespaceSelector;
  /**
   * relabelingConfigs to apply to the label set of the target before it gets
   * scraped.
   * The original ingress address is available via the
   * `__tmp_prometheus_ingress_address` label. It can be used to customize the
   * probed URL.
   * The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
   * More info:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   */
  relabelingConfigs?: IngressRelabelingConfig[];
  /**
   * selector to select the Ingress objects.
   */
  selector?: Selector;
}

/**
 * namespaceSelector defines from which namespaces to select Ingress objects.
 */
export interface NamespaceSelector {
  /**
   * any defines the boolean describing whether all namespaces are selected in contrast to a
   * list restricting them.
   */
  any?: boolean;
  /**
   * matchNames defines the list of namespace names to select from.
   */
  matchNames?: string[];
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 */
export interface IngressRelabelingConfig {
  /**
   * action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   */
  action?: Action;
  /**
   * modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   */
  modulus?: number;
  /**
   * regex defines the regular expression against which the extracted value is matched.
   */
  regex?: string;
  /**
   * replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   */
  replacement?: string;
  /**
   * separator defines the string between concatenated SourceLabels.
   */
  separator?: string;
  /**
   * sourceLabels defines the source labels select values from existing labels. Their content
   * is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   */
  sourceLabels?: string[];
  /**
   * targetLabel defines the label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   */
  targetLabel?: string;
}

/**
 * selector to select the Ingress objects.
 */
export interface Selector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   */
  matchExpressions?: MatchExpression[];
  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   */
  matchLabels?: { [key: string]: string };
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator
 * that
 * relates the key and values.
 */
export interface MatchExpression {
  /**
   * key is the label key that the selector applies to.
   */
  key: string;
  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   */
  operator: string;
  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   */
  values?: string[];
}

/**
 * staticConfig defines the static list of targets to probe and the
 * relabeling configuration.
 * If `ingress` is also defined, `staticConfig` takes precedence.
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
 */
export interface StaticConfig {
  /**
   * labels defines all labels assigned to all metrics scraped from the targets.
   */
  labels?: { [key: string]: string };
  /**
   * relabelingConfigs defines relabelings to be apply to the label set of the targets before
   * it gets
   * scraped.
   * More info:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   */
  relabelingConfigs?: StaticConfigRelabelingConfig[];
  /**
   * static defines the list of hosts to probe.
   */
  static?: string[];
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
 * scraped samples and remote write samples.
 *
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 */
export interface StaticConfigRelabelingConfig {
  /**
   * action to perform based on the regex matching.
   *
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
   * `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
   *
   * Default: "Replace"
   */
  action?: Action;
  /**
   * modulus to take of the hash of the source label values.
   *
   * Only applicable when the action is `HashMod`.
   */
  modulus?: number;
  /**
   * regex defines the regular expression against which the extracted value is matched.
   */
  regex?: string;
  /**
   * replacement value against which a Replace action is performed if the
   * regular expression matches.
   *
   * Regex capture groups are available.
   */
  replacement?: string;
  /**
   * separator defines the string between concatenated SourceLabels.
   */
  separator?: string;
  /**
   * sourceLabels defines the source labels select values from existing labels. Their content
   * is
   * concatenated using the configured Separator and matched against the
   * configured regular expression.
   */
  sourceLabels?: string[];
  /**
   * targetLabel defines the label to which the resulting string is written in a replacement.
   *
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
   * `KeepEqual` and `DropEqual` actions.
   *
   * Regex capture groups are available.
   */
  targetLabel?: string;
}

/**
 * tlsConfig defines the TLS configuration used by the client.
 */
export interface SpecTLSConfig {
  /**
   * ca defines the Certificate authority used when verifying server certificates.
   */
  ca?: FluffyCA;
  /**
   * cert defines the Client certificate to present when doing client-authentication.
   */
  cert?: FluffyCERT;
  /**
   * insecureSkipVerify defines how to disable target certificate validation.
   */
  insecureSkipVerify?: boolean;
  /**
   * keySecret defines the Secret containing the client key file for the targets.
   */
  keySecret?: FluffyKeySecret;
  /**
   * maxVersion defines the maximum acceptable TLS version.
   *
   * It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
   */
  maxVersion?: Version;
  /**
   * minVersion defines the minimum acceptable TLS version.
   *
   * It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
   */
  minVersion?: Version;
  /**
   * serverName is used to verify the hostname for the targets.
   */
  serverName?: string;
}

/**
 * ca defines the Certificate authority used when verifying server certificates.
 */
export interface FluffyCA {
  /**
   * configMap defines the ConfigMap containing data to use for the targets.
   */
  configMap?: TentacledConfigMap;
  /**
   * secret defines the Secret containing data to use for the targets.
   */
  secret?: TentacledSecret;
}

/**
 * configMap defines the ConfigMap containing data to use for the targets.
 */
export interface TentacledConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * secret defines the Secret containing data to use for the targets.
 */
export interface TentacledSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * cert defines the Client certificate to present when doing client-authentication.
 */
export interface FluffyCERT {
  /**
   * configMap defines the ConfigMap containing data to use for the targets.
   */
  configMap?: StickyConfigMap;
  /**
   * secret defines the Secret containing data to use for the targets.
   */
  secret?: StickySecret;
}

/**
 * configMap defines the ConfigMap containing data to use for the targets.
 */
export interface StickyConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * secret defines the Secret containing data to use for the targets.
 */
export interface StickySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * keySecret defines the Secret containing the client key file for the targets.
 */
export interface FluffyKeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * status defines the status subresource. It is under active development and is updated only
 * when the
 * "StatusForConfigurationResources" feature gate is enabled.
 *
 * Most recent observed status of the Probe. Read-only.
 * More info:
 *
 * https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 */
export interface Status {
  /**
   * bindings defines the list of workload resources (Prometheus, PrometheusAgent, ThanosRuler
   * or Alertmanager) which select the configuration resource.
   */
  bindings?: Binding[];
}

/**
 * WorkloadBinding is a link between a configuration resource and a workload resource.
 */
export interface Binding {
  /**
   * conditions defines the current state of the configuration resource when bound to the
   * referenced Workload object.
   */
  conditions?: Condition[];
  /**
   * group defines the group of the referenced resource.
   */
  group: Group;
  /**
   * name defines the name of the referenced object.
   */
  name: string;
  /**
   * namespace defines the namespace of the referenced object.
   */
  namespace: string;
  /**
   * resource defines the type of resource being referenced (e.g. Prometheus, PrometheusAgent,
   * ThanosRuler or Alertmanager).
   */
  resource: Resource;
}

/**
 * ConfigResourceCondition describes the status of configuration resources linked to
 * Prometheus, PrometheusAgent, Alertmanager or ThanosRuler.
 */
export interface Condition {
  /**
   * lastTransitionTime defines the time of the last update to the current status property.
   */
  lastTransitionTime: Date;
  /**
   * message defines the human-readable message indicating details for the condition's last
   * transition.
   */
  message?: string;
  /**
   * observedGeneration defines the .metadata.generation that the
   * condition was set based upon. For instance, if `.metadata.generation` is
   * currently 12, but the `.status.conditions[].observedGeneration` is 9, the
   * condition is out of date with respect to the current state of the object.
   */
  observedGeneration?: number;
  /**
   * reason for the condition's last transition.
   */
  reason?: string;
  /**
   * status of the condition.
   */
  status: string;
  /**
   * type of the condition being reported.
   * Currently, only "Accepted" is supported.
   */
  type: Type;
}

/**
 * type of the condition being reported.
 * Currently, only "Accepted" is supported.
 */
export enum Type {
  Accepted = "Accepted",
}

/**
 * group defines the group of the referenced resource.
 */
export enum Group {
  MonitoringCoreosCOM = "monitoring.coreos.com",
}

/**
 * resource defines the type of resource being referenced (e.g. Prometheus, PrometheusAgent,
 * ThanosRuler or Alertmanager).
 */
export enum Resource {
  Alertmanagers = "alertmanagers",
  Prometheusagents = "prometheusagents",
  Prometheuses = "prometheuses",
  Thanosrulers = "thanosrulers",
}

RegisterKind(Probe, {
  group: "monitoring.coreos.com",
  version: "v1",
  kind: "Probe",
  plural: "probes",
});
