// This file is auto-generated by kubernetes-fluent-client, do not edit manually

import { GenericKind, RegisterKind } from "kubernetes-fluent-client";

export class Package extends GenericKind {
  spec?: Spec;
  status?: Status;
}

export interface Spec {
  /**
   * Network configuration for the package
   */
  network?: Network;
}

/**
 * Network configuration for the package
 */
export interface Network {
  /**
   * Allow specific traffic (namespace will have a default-deny policy)
   */
  allow?: Allow[];
  /**
   * Expose a service on an Istio Gateway
   */
  expose?: Expose[];
}

export interface Allow {
  /**
   * A description of the policy, this will become part of the policy name
   */
  description?: string;
  /**
   * The direction of the traffic
   */
  direction: Direction;
  /**
   * The labels to apply to the policy
   */
  labels?: { [key: string]: string };
  /**
   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all
   * pods in the namespace
   */
  podLabels?: { [key: string]: string };
  /**
   * The port to allow (protocol is always TCP)
   */
  port?: number;
  /**
   * A list of ports to allow (protocol is always TCP)
   */
  ports?: number[];
  /**
   * Custom generated remote selector for the policy
   */
  remoteGenerated?: RemoteGenerated;
  /**
   * The remote namespace to allow traffic to/from. Use * or empty string to allow all
   * namespaces
   */
  remoteNamespace?: string;
  /**
   * The remote pod selector labels to allow traffic to/from
   */
  remotePodLabels?: { [key: string]: string };
}

/**
 * The direction of the traffic
 */
export enum Direction {
  Egress = "Egress",
  Ingress = "Ingress",
}

/**
 * Custom generated remote selector for the policy
 */
export enum RemoteGenerated {
  Anywhere = "Anywhere",
  CloudMetadata = "CloudMetadata",
  IntraNamespace = "IntraNamespace",
  KubeAPI = "KubeAPI",
}

export interface Expose {
  /**
   * A description of this expose entry, this will become part of the VirtualService name
   */
  description?: string;
  /**
   * The name of the gateway to expose the service on (default: tenant)
   */
  gateway?: Gateway;
  /**
   * The hostname to expose the service on
   */
  host: string;
  /**
   * Match the incoming request based on custom rules. Not permitted when using the
   * passthrough gateway.
   */
  match?: Match[];
  /**
   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all
   * pods in the namespace
   */
  podLabels: { [key: string]: string };
  /**
   * The port number to expose
   */
  port: number;
  /**
   * The name of the service to expose
   */
  service: string;
  /**
   * The service targetPort (pod port). This defaults to port and is only required if the
   * service port is different from the pod port (so the NetworkPolicy can be generated
   * correctly).
   */
  targetPort?: number;
}

/**
 * The name of the gateway to expose the service on (default: tenant)
 */
export enum Gateway {
  Admin = "admin",
  Passthrough = "passthrough",
  Tenant = "tenant",
}

export interface Match {
  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   */
  ignoreUriCase?: boolean;
  method?: Method;
  /**
   * The name assigned to a match.
   */
  name: string;
  /**
   * Query parameters for matching.
   */
  queryParams?: { [key: string]: QueryParam };
  uri?: URI;
}

export interface Method {
  exact?: string;
  prefix?: string;
  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface QueryParam {
  exact?: string;
  prefix?: string;
  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface URI {
  exact?: string;
  prefix?: string;
  /**
   * RE2 style regex-based match (https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface Status {
  endpoints?: string[];
  networkPolicyCount?: number;
  observedGeneration?: number;
  phase?: Phase;
}

export enum Phase {
  Failed = "Failed",
  Pending = "Pending",
  Ready = "Ready",
}

RegisterKind(Package, {
  group: "uds.dev",
  version: "v1alpha1",
  kind: "Package",
});
