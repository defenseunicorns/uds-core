/**
 * Copyright 2026 Defense Unicorns
 * SPDX-License-Identifier: AGPL-3.0-or-later OR LicenseRef-Defense-Unicorns-Commercial
 */

// This file is auto-generated by kubernetes-fluent-client, do not edit manually
import { GenericKind, RegisterKind } from "kubernetes-fluent-client";
export class Package extends GenericKind {
  spec?: Spec;
  status?: StatusObject;
}

export interface Spec {
  /**
   * CA bundle configuration for the package
   */
  caBundle?: CABundle;
  /**
   * Create Service or Pod Monitor configurations
   */
  monitor?: Monitor[];
  /**
   * Network configuration for the package
   */
  network?: Network;
  /**
   * Create SSO client configurations
   */
  sso?: Sso[];
}

/**
 * CA bundle configuration for the package
 */
export interface CABundle {
  /**
   * ConfigMap configuration for CA bundle
   */
  configMap?: ConfigMap;
}

/**
 * ConfigMap configuration for CA bundle
 */
export interface ConfigMap {
  /**
   * Additional annotations to apply to the generated ConfigMap (default: {})
   */
  annotations?: { [key: string]: string };
  /**
   * The key name inside the ConfigMap (default: ca-bundle.pem)
   */
  key?: string;
  /**
   * Additional labels to apply to the generated ConfigMap (default: {})
   */
  labels?: { [key: string]: string };
  /**
   * The name of the ConfigMap to create (default: uds-trust-bundle)
   */
  name?: string;
}

export interface Monitor {
  /**
   * Authorization settings.
   */
  authorization?: Authorization;
  /**
   * A description of this monitor entry, this will become part of the ServiceMonitor name
   */
  description?: string;
  /**
   * The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise
   * invalid Content-Type
   */
  fallbackScrapeProtocol?: FallbackScrapeProtocol;
  /**
   * The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the
   * default.
   */
  kind?: Kind;
  /**
   * HTTP path from which to scrape for metrics, defaults to `/metrics`
   */
  path?: string;
  /**
   * Selector for Pods targeted by the selected Services (so the NetworkPolicy can be
   * generated correctly). Defaults to `selector` when not specified.
   */
  podSelector?: { [key: string]: string };
  /**
   * The port name for the serviceMonitor
   */
  portName: string;
  /**
   * Selector for Services that expose metrics to scrape
   */
  selector: { [key: string]: string };
  /**
   * The service targetPort. This is required so the NetworkPolicy can be generated correctly.
   */
  targetPort: number;
}

/**
 * Authorization settings.
 */
export interface Authorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for
   * authentication.
   */
  credentials: Credentials;
  /**
   * Defines the authentication type. The value is case-insensitive. "Basic" is not a
   * supported value. Default: "Bearer"
   */
  type?: string;
}

/**
 * Selects a key of a Secret in the namespace that contains the credentials for
 * authentication.
 */
export interface Credentials {
  /**
   * The key of the secret to select from. Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * The protocol for Prometheus to use if a scrape returns a blank, unparsable, or otherwise
 * invalid Content-Type
 */
export enum FallbackScrapeProtocol {
  OpenMetricsText001 = "OpenMetricsText0.0.1",
  OpenMetricsText100 = "OpenMetricsText1.0.0",
  PrometheusProto = "PrometheusProto",
  PrometheusText004 = "PrometheusText0.0.4",
  PrometheusText100 = "PrometheusText1.0.0",
}

/**
 * The type of monitor to create; PodMonitor or ServiceMonitor. ServiceMonitor is the
 * default.
 */
export enum Kind {
  PodMonitor = "PodMonitor",
  ServiceMonitor = "ServiceMonitor",
}

/**
 * Network configuration for the package
 */
export interface Network {
  /**
   * Allow specific traffic (namespace will have a default-deny policy)
   */
  allow?: Allow[];
  /**
   * Expose a service on an Istio Gateway
   */
  expose?: Expose[];
  /**
   * Service Mesh configuration for the package
   */
  serviceMesh?: ServiceMesh;
}

export interface Allow {
  /**
   * A description of the policy, this will become part of the policy name
   */
  description?: string;
  /**
   * The direction of the traffic
   */
  direction: Direction;
  /**
   * The labels to apply to the policy
   */
  labels?: { [key: string]: string };
  /**
   * Deprecated: use selector
   */
  podLabels?: { [key: string]: string };
  /**
   * The port to allow (protocol is always TCP)
   */
  port?: number;
  /**
   * A list of ports to allow (protocol is always TCP)
   */
  ports?: number[];
  /**
   * Custom generated policy CIDR
   */
  remoteCidr?: string;
  /**
   * Custom generated remote selector for the policy
   */
  remoteGenerated?: RemoteGenerated;
  /**
   * Remote host to allow traffic out to
   */
  remoteHost?: string;
  /**
   * The remote namespace to allow traffic to/from. Use * or empty string to allow all
   * namespaces
   */
  remoteNamespace?: string;
  /**
   * Deprecated: use remoteSelector
   */
  remotePodLabels?: { [key: string]: string };
  /**
   * Protocol used for external connection
   */
  remoteProtocol?: RemoteProtocol;
  /**
   * The remote pod selector labels to allow traffic to/from
   */
  remoteSelector?: { [key: string]: string };
  /**
   * The remote service account to restrict incoming traffic from within the remote
   * namespace.           Only valid for Ingress rules.
   */
  remoteServiceAccount?: string;
  /**
   * Labels to match pods in the namespace to apply the policy to. Leave empty to apply to all
   * pods in the namespace
   */
  selector?: { [key: string]: string };
  /**
   * The service account to restrict outgoing traffic from within the package
   * namespace.           Only valid for Egress rules.
   */
  serviceAccount?: string;
}

/**
 * The direction of the traffic
 */
export enum Direction {
  Egress = "Egress",
  Ingress = "Ingress",
}

/**
 * Custom generated remote selector for the policy
 */
export enum RemoteGenerated {
  Anywhere = "Anywhere",
  CloudMetadata = "CloudMetadata",
  IntraNamespace = "IntraNamespace",
  KubeAPI = "KubeAPI",
  KubeNodes = "KubeNodes",
}

/**
 * Protocol used for external connection
 */
export enum RemoteProtocol {
  HTTP = "HTTP",
  TLS = "TLS",
}

export interface Expose {
  /**
   * Advanced HTTP settings for the route.
   */
  advancedHTTP?: AdvancedHTTP;
  /**
   * A description of this expose entry, this will become part of the VirtualService name
   */
  description?: string;
  /**
   * The domain to expose the service on, only valid for additional gateways (not tenant,
   * admin, or passthrough)
   */
  domain?: string;
  /**
   * The name of the gateway to expose the service on (default: tenant)
   */
  gateway?: string;
  /**
   * The hostname to expose the service on
   */
  host: string;
  /**
   * Match conditions to be satisfied for the rule to be activated. Not permitted when using
   * the passthrough gateway.
   */
  match?: ExposeMatch[];
  /**
   * Deprecated: use selector
   */
  podLabels?: { [key: string]: string };
  /**
   * The port number to expose
   */
  port?: number;
  /**
   * Selector for Pods targeted by the selected Services (so the NetworkPolicy can be
   * generated correctly).
   */
  selector?: { [key: string]: string };
  /**
   * The name of the service to expose
   */
  service?: string;
  /**
   * The service targetPort. This defaults to port and is only required if the service port is
   * different from the target port (so the NetworkPolicy can be generated correctly).
   */
  targetPort?: number;
  /**
   * Uptime monitoring configuration for this exposed service. Presence of checks.paths
   * enables monitoring.
   */
  uptime?: Uptime;
}

/**
 * Advanced HTTP settings for the route.
 */
export interface AdvancedHTTP {
  /**
   * Cross-Origin Resource Sharing policy (CORS).
   */
  corsPolicy?: CorsPolicy;
  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   */
  directResponse?: DirectResponse;
  headers?: Headers;
  /**
   * Match conditions to be satisfied for the rule to be activated. Not permitted when using
   * the passthrough gateway.
   */
  match?: AdvancedHTTPMatch[];
  /**
   * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
   */
  redirect?: Redirect;
  /**
   * Retry policy for HTTP requests.
   */
  retries?: Retries;
  /**
   * Rewrite HTTP URIs and Authority headers.
   */
  rewrite?: Rewrite;
  /**
   * Timeout for HTTP requests, default is disabled.
   */
  timeout?: string;
}

/**
 * Cross-Origin Resource Sharing policy (CORS).
 */
export interface CorsPolicy {
  /**
   * Indicates whether the caller is allowed to send the actual request (not the preflight)
   * using credentials.
   */
  allowCredentials?: boolean;
  /**
   * List of HTTP headers that can be used when requesting the resource.
   */
  allowHeaders?: string[];
  /**
   * List of HTTP methods allowed to access the resource.
   */
  allowMethods?: string[];
  allowOrigin?: string[];
  /**
   * String patterns that match allowed origins.
   */
  allowOrigins?: AllowOrigin[];
  /**
   * A list of HTTP headers that the browsers are allowed to access.
   */
  exposeHeaders?: string[];
  /**
   * Specifies how long the results of a preflight request can be cached.
   */
  maxAge?: string;
  /**
   * Indicates whether preflight requests not matching the configured allowed origin shouldn't
   * be forwarded to the upstream.
   *
   * Valid Options: FORWARD, IGNORE
   */
  unmatchedPreflights?: UnmatchedPreflights;
}

export interface AllowOrigin {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * Indicates whether preflight requests not matching the configured allowed origin shouldn't
 * be forwarded to the upstream.
 *
 * Valid Options: FORWARD, IGNORE
 */
export enum UnmatchedPreflights {
  Forward = "FORWARD",
  Ignore = "IGNORE",
  Unspecified = "UNSPECIFIED",
}

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 */
export interface DirectResponse {
  /**
   * Specifies the content of the response body.
   */
  body?: Body;
  /**
   * Specifies the HTTP response status to be returned.
   */
  status: number;
}

/**
 * Specifies the content of the response body.
 */
export interface Body {
  /**
   * response body as base64 encoded bytes.
   */
  bytes?: string;
  string?: string;
}

export interface Headers {
  request?: Request;
  response?: Response;
}

export interface Request {
  add?: { [key: string]: string };
  remove?: string[];
  set?: { [key: string]: string };
}

export interface Response {
  add?: { [key: string]: string };
  remove?: string[];
  set?: { [key: string]: string };
}

export interface AdvancedHTTPMatch {
  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   */
  headers?: { [key: string]: PurpleHeader };
  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   */
  ignoreUriCase?: boolean;
  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  method?: PurpleMethod;
  /**
   * The name assigned to a match.
   */
  name?: string;
  /**
   * Specifies the ports on the host that is being addressed.
   */
  port?: number;
  /**
   * Query parameters for matching.
   */
  queryParams?: { [key: string]: PurpleQueryParam };
  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  scheme?: PurpleScheme;
  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  uri?: PurpleURI;
  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   */
  withoutHeaders?: { [key: string]: PurpleWithoutHeader };
}

export interface PurpleHeader {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface PurpleMethod {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface PurpleQueryParam {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface PurpleScheme {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface PurpleURI {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface PurpleWithoutHeader {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * A HTTP rule can either return a direct_response, redirect or forward (default) traffic.
 */
export interface Redirect {
  /**
   * On a redirect, overwrite the Authority/Host portion of the URL with this value.
   */
  authority?: string;
  /**
   * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80
   * for HTTP and 443 for HTTPS.
   *
   * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
   */
  derivePort?: DerivePort;
  /**
   * On a redirect, overwrite the port portion of the URL with this value.
   */
  port?: number;
  /**
   * On a redirect, Specifies the HTTP status code to use in the redirect response.
   */
  redirectCode?: number;
  /**
   * On a redirect, overwrite the scheme portion of the URL with this value.
   */
  scheme?: string;
  /**
   * On a redirect, overwrite the Path portion of the URL with this value.
   */
  uri?: string;
}

/**
 * On a redirect, dynamically set the port: * FROM_PROTOCOL_DEFAULT: automatically set to 80
 * for HTTP and 443 for HTTPS.
 *
 * Valid Options: FROM_PROTOCOL_DEFAULT, FROM_REQUEST_PORT
 */
export enum DerivePort {
  FromProtocolDefault = "FROM_PROTOCOL_DEFAULT",
  FromRequestPort = "FROM_REQUEST_PORT",
}

/**
 * Retry policy for HTTP requests.
 */
export interface Retries {
  /**
   * Number of retries to be allowed for a given request.
   */
  attempts?: number;
  /**
   * Specifies the minimum duration between retry attempts.
   */
  backoff?: string;
  /**
   * Timeout per attempt for a given request, including the initial call and any retries.
   */
  perTryTimeout?: string;
  /**
   * Flag to specify whether the retries should ignore previously tried hosts during retry.
   */
  retryIgnorePreviousHosts?: boolean;
  /**
   * Specifies the conditions under which retry takes place.
   */
  retryOn?: string;
  /**
   * Flag to specify whether the retries should retry to other localities.
   */
  retryRemoteLocalities?: boolean;
}

/**
 * Rewrite HTTP URIs and Authority headers.
 */
export interface Rewrite {
  /**
   * rewrite the Authority/Host header with this value.
   */
  authority?: string;
  /**
   * rewrite the path (or the prefix) portion of the URI with this value.
   */
  uri?: string;
  /**
   * rewrite the path portion of the URI with the specified regex.
   */
  uriRegexRewrite?: URIRegexRewrite;
}

/**
 * rewrite the path portion of the URI with the specified regex.
 */
export interface URIRegexRewrite {
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  match?: string;
  /**
   * The string that should replace into matching portions of original URI.
   */
  rewrite?: string;
}

export interface ExposeMatch {
  /**
   * The header keys must be lowercase and use hyphen as the separator, e.g.
   */
  headers?: { [key: string]: FluffyHeader };
  /**
   * Flag to specify whether the URI matching should be case-insensitive.
   */
  ignoreUriCase?: boolean;
  /**
   * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  method?: FluffyMethod;
  /**
   * The name assigned to a match.
   */
  name?: string;
  /**
   * Specifies the ports on the host that is being addressed.
   */
  port?: number;
  /**
   * Query parameters for matching.
   */
  queryParams?: { [key: string]: FluffyQueryParam };
  /**
   * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  scheme?: FluffyScheme;
  /**
   * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for
   * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
   * style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  uri?: FluffyURI;
  /**
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   */
  withoutHeaders?: { [key: string]: FluffyWithoutHeader };
}

export interface FluffyHeader {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * HTTP Method values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface FluffyMethod {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface FluffyQueryParam {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * URI Scheme values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface FluffyScheme {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * URI to match values are case-sensitive and formatted as follows: - `exact: "value"` for
 * exact string match - `prefix: "value"` for prefix-based match - `regex: "value"` for [RE2
 * style regex-based match](https://github.com/google/re2/wiki/Syntax).
 */
export interface FluffyURI {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

export interface FluffyWithoutHeader {
  exact?: string;
  prefix?: string;
  /**
   * [RE2 style regex-based match](https://github.com/google/re2/wiki/Syntax).
   */
  regex?: string;
}

/**
 * Uptime monitoring configuration for this exposed service. Presence of checks.paths
 * enables monitoring.
 */
export interface Uptime {
  /**
   * HTTP probe checks configuration for blackbox-exporter. Defining paths enables uptime
   * monitoring.
   */
  checks?: Checks;
}

/**
 * HTTP probe checks configuration for blackbox-exporter. Defining paths enables uptime
 * monitoring.
 */
export interface Checks {
  /**
   * List of paths to check for uptime monitoring, appended to the host.
   */
  paths: string[];
}

/**
 * Service Mesh configuration for the package
 */
export interface ServiceMesh {
  /**
   * Set the service mesh mode for this package (namespace), defaults to ambient
   */
  mode?: Mode;
}

/**
 * Set the service mesh mode for this package (namespace), defaults to ambient
 *
 * The current service mesh mode for this package
 */
export enum Mode {
  Ambient = "ambient",
  Sidecar = "sidecar",
}

export interface Sso {
  /**
   * This URL will be used for every binding to both the SP's Assertion Consumer and Single
   * Logout Services.
   */
  adminUrl?: string;
  /**
   * Always list this client in the Account UI, even if the user does not have an active
   * session.
   */
  alwaysDisplayInConsole?: boolean;
  /**
   * Specifies attributes for the client.
   */
  attributes?: { [key: string]: string };
  /**
   * Default URL to use when the auth server needs to redirect or link back to the client.
   */
  baseUrl?: string;
  /**
   * The client authenticator type
   */
  clientAuthenticatorType?: ClientAuthenticatorType;
  /**
   * The client identifier registered with the identity provider.
   */
  clientId: string;
  /**
   * Default client scopes
   */
  defaultClientScopes?: string[];
  /**
   * A description for the client, can be a URL to an image to replace the login logo
   */
  description?: string;
  /**
   * Labels to match pods to automatically protect with authservice. Leave empty to disable
   * authservice protection
   */
  enableAuthserviceSelector?: { [key: string]: string };
  /**
   * Whether the SSO client is enabled
   */
  enabled?: boolean;
  /**
   * The client SSO group type
   */
  groups?: Groups;
  /**
   * Specifies display name of the client
   */
  name: string;
  /**
   * Specifies the protocol of the client, either 'openid-connect' or 'saml'
   */
  protocol?: Protocol;
  /**
   * Protocol Mappers to configure on the client
   */
  protocolMappers?: ProtocolMapper[];
  /**
   * Defines whether the client requires a client secret for authentication
   */
  publicClient?: boolean;
  /**
   * Valid URI pattern a browser can redirect to after a successful login. Simple wildcards
   * are allowed such as 'https://unicorns.uds.dev/*'
   */
  redirectUris?: string[];
  /**
   * Root URL appended to relative URLs
   */
  rootUrl?: string;
  /**
   * The OAuth/OIDC client secret value sent to Keycloak. Typically left blank and
   * auto-generated by Keycloak. Not to be confused with secretConfig, which configures the
   * Kubernetes Secret resource.
   */
  secret?: string;
  /**
   * Deprecated: use secretConfig.annotations
   */
  secretAnnotations?: { [key: string]: string };
  /**
   * Configuration for the generated Kubernetes Secret
   */
  secretConfig?: SecretConfig;
  /**
   * Deprecated: use secretConfig.labels
   */
  secretLabels?: { [key: string]: string };
  /**
   * Deprecated: use secretConfig.name
   */
  secretName?: string;
  /**
   * Deprecated: use secretConfig.template
   */
  secretTemplate?: { [key: string]: string };
  /**
   * Enables the client credentials grant based authentication via OpenID Connect protocol.
   */
  serviceAccountsEnabled?: boolean;
  /**
   * Enables the standard OpenID Connect redirect based authentication with authorization code.
   */
  standardFlowEnabled?: boolean;
  /**
   * Allowed CORS origins. To permit all origins of Valid Redirect URIs, add '+'. This does
   * not include the '*' wildcard though. To permit all origins, explicitly add '*'.
   */
  webOrigins?: string[];
}

/**
 * The client authenticator type
 */
export enum ClientAuthenticatorType {
  ClientJwt = "client-jwt",
  ClientSecret = "client-secret",
}

/**
 * The client SSO group type
 */
export interface Groups {
  /**
   * List of groups allowed to access the client
   */
  anyOf?: string[];
}

/**
 * Specifies the protocol of the client, either 'openid-connect' or 'saml'
 *
 * Protocol of the mapper
 */
export enum Protocol {
  OpenidConnect = "openid-connect",
  Saml = "saml",
}

export interface ProtocolMapper {
  /**
   * Configuration options for the mapper.
   */
  config?: { [key: string]: string };
  /**
   * Whether user consent is required for this mapper
   */
  consentRequired?: boolean;
  /**
   * Name of the mapper
   */
  name: string;
  /**
   * Protocol of the mapper
   */
  protocol: Protocol;
  /**
   * Protocol Mapper type of the mapper
   */
  protocolMapper: string;
}

/**
 * Configuration for the generated Kubernetes Secret
 */
export interface SecretConfig {
  /**
   * Additional annotations to apply to the generated secret, can be used for pod reloading
   * with a selector
   */
  annotations?: { [key: string]: string };
  /**
   * Additional labels to apply to the generated secret, can be used for pod reloading
   */
  labels?: { [key: string]: string };
  /**
   * The name of the secret to store the client secret
   */
  name?: string;
  /**
   * A template for the generated secret
   */
  template?: { [key: string]: string };
}

export interface StatusObject {
  authorizationPolicyCount?: number;
  authserviceClients?: AuthserviceClient[];
  /**
   * Status conditions following Kubernetes-style conventions
   */
  conditions?: Condition[];
  endpoints?: string[];
  /**
   * The current service mesh mode for this package
   */
  meshMode?: Mode;
  monitors?: string[];
  networkPolicyCount?: number;
  observedGeneration?: number;
  phase?: Phase;
  probes?: string[];
  retryAttempt?: number;
  ssoClients?: string[];
}

export interface AuthserviceClient {
  clientId: string;
  selector?: { [key: string]: string };
}

export interface Condition {
  /**
   * The last time the condition transitioned from one status to another
   */
  lastTransitionTime: Date;
  /**
   * A human-readable message indicating details about the transition
   */
  message: string;
  /**
   * Represents the .metadata.generation that the condition was set based upon
   */
  observedGeneration?: number;
  /**
   * A programmatic identifier indicating the reason for the condition's last transition
   */
  reason: string;
  /**
   * Status of the condition, one of True, False, Unknown
   */
  status: StatusEnum;
  /**
   * Type of condition in CamelCase or in foo.example.com/CamelCase format
   */
  type: string;
}

/**
 * Status of the condition, one of True, False, Unknown
 */
export enum StatusEnum {
  False = "False",
  True = "True",
  Unknown = "Unknown",
}

export enum Phase {
  Failed = "Failed",
  Pending = "Pending",
  Ready = "Ready",
  RemovalFailed = "RemovalFailed",
  Removing = "Removing",
  Retrying = "Retrying",
}

RegisterKind(Package, {
  group: "uds.dev",
  version: "v1alpha1",
  kind: "Package",
  plural: "packages",
});
