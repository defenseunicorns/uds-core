// This file is auto-generated by kubernetes-fluent-client, do not edit manually

import { GenericKind, RegisterKind } from "kubernetes-fluent-client";

/**
 * ServiceMonitor defines monitoring for a set of services.
 */
export class ServiceMonitor extends GenericKind {
  /**
   * Specification of desired Service selection for target discovery by Prometheus.
   */
  spec: Spec;
}

/**
 * Specification of desired Service selection for target discovery by Prometheus.
 */
export interface Spec {
  /**
   * Attaches node metadata to discovered targets. Requires Prometheus v2.37.0 and above.
   */
  attachMetadata?: AttachMetadata;
  /**
   * A list of endpoints allowed as part of this ServiceMonitor.
   */
  endpoints: Endpoint[];
  /**
   * JobLabel selects the label from the associated Kubernetes service which will be used as
   * the `job` label for all metrics.
   * For example: If in `ServiceMonitor.spec.jobLabel: foo` and in
   * `Service.metadata.labels.foo: bar`, then the `job="bar"` label is added to all metrics.
   * If the value of this field is empty or if the label doesn't exist for the given Service,
   * the `job` label of the metrics defaults to the name of the Kubernetes Service.
   */
  jobLabel?: string;
  /**
   * Per-scrape limit on the number of targets dropped by relabeling that will be kept in
   * memory. 0 means no limit.
   * It requires Prometheus >= v2.47.0.
   */
  keepDroppedTargets?: number;
  /**
   * Per-scrape limit on number of labels that will be accepted for a sample. Only valid in
   * Prometheus versions 2.27.0 and newer.
   */
  labelLimit?: number;
  /**
   * Per-scrape limit on length of labels name that will be accepted for a sample. Only valid
   * in Prometheus versions 2.27.0 and newer.
   */
  labelNameLengthLimit?: number;
  /**
   * Per-scrape limit on length of labels value that will be accepted for a sample. Only valid
   * in Prometheus versions 2.27.0 and newer.
   */
  labelValueLengthLimit?: number;
  /**
   * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
   */
  namespaceSelector?: NamespaceSelector;
  /**
   * PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
   */
  podTargetLabels?: string[];
  /**
   * SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
   */
  sampleLimit?: number;
  /**
   * Selector to select Endpoints objects.
   */
  selector: Selector;
  /**
   * TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics.
   */
  targetLabels?: string[];
  /**
   * TargetLimit defines a limit on the number of scraped targets that will be accepted.
   */
  targetLimit?: number;
}

/**
 * Attaches node metadata to discovered targets. Requires Prometheus v2.37.0 and above.
 */
export interface AttachMetadata {
  /**
   * When set to true, Prometheus must have permissions to get Nodes.
   */
  node?: boolean;
}

/**
 * Endpoint defines a scrapeable endpoint serving Prometheus metrics.
 */
export interface Endpoint {
  /**
   * Authorization section for this endpoint
   */
  authorization?: Authorization;
  /**
   * BasicAuth allow an endpoint to authenticate over basic authentication More info:
   * https://prometheus.io/docs/operating/configuration/#endpoints
   */
  basicAuth?: BasicAuth;
  /**
   * File to read bearer token for scraping targets.
   */
  bearerTokenFile?: string;
  /**
   * Secret to mount to read bearer token for scraping targets. The secret needs to be in the
   * same namespace as the service monitor and accessible by the Prometheus Operator.
   */
  bearerTokenSecret?: BearerTokenSecret;
  /**
   * Whether to enable HTTP2.
   */
  enableHttp2?: boolean;
  /**
   * Drop pods that are not running. (Failed, Succeeded). Enabled by default. More info:
   * https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
   */
  filterRunning?: boolean;
  /**
   * FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
   */
  followRedirects?: boolean;
  /**
   * HonorLabels chooses the metric's labels on collisions with target labels.
   */
  honorLabels?: boolean;
  /**
   * HonorTimestamps controls whether Prometheus respects the timestamps present in scraped
   * data.
   */
  honorTimestamps?: boolean;
  /**
   * Interval at which metrics should be scraped If not specified Prometheus' global scrape
   * interval is used.
   */
  interval?: string;
  /**
   * MetricRelabelConfigs to apply to samples before ingestion.
   */
  metricRelabelings?: MetricRelabeling[];
  /**
   * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
   */
  oauth2?: Oauth2;
  /**
   * Optional HTTP URL parameters
   */
  params?: { [key: string]: string[] };
  /**
   * HTTP path to scrape for metrics. If empty, Prometheus uses the default value (e.g.
   * `/metrics`).
   */
  path?: string;
  /**
   * Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
   */
  port?: string;
  /**
   * ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
   */
  proxyUrl?: string;
  /**
   * RelabelConfigs to apply to samples before scraping. Prometheus Operator automatically
   * adds relabelings for a few standard Kubernetes fields. The original scrape job's name is
   * available via the `__tmp_prometheus_job_name` label. More info:
   * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
   */
  relabelings?: Relabeling[];
  /**
   * HTTP scheme to use for scraping. `http` and `https` are the expected values unless you
   * rewrite the `__scheme__` label via relabeling. If empty, Prometheus uses the default
   * value `http`.
   */
  scheme?: Scheme;
  /**
   * Timeout after which the scrape is ended If not specified, the Prometheus global scrape
   * timeout is used unless it is less than `Interval` in which the latter is used.
   */
  scrapeTimeout?: string;
  /**
   * Name or number of the target port of the Pod behind the Service, the port must be
   * specified with container port property. Mutually exclusive with port.
   */
  targetPort?: number | string;
  /**
   * TLS configuration to use when scraping the endpoint
   */
  tlsConfig?: TLSConfig;
}

/**
 * Authorization section for this endpoint
 */
export interface Authorization {
  /**
   * Selects a key of a Secret in the namespace that contains the credentials for
   * authentication.
   */
  credentials?: Credentials;
  /**
   * Defines the authentication type. The value is case-insensitive.
   * "Basic" is not a supported value.
   * Default: "Bearer"
   */
  type?: string;
}

/**
 * Selects a key of a Secret in the namespace that contains the credentials for
 * authentication.
 */
export interface Credentials {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * BasicAuth allow an endpoint to authenticate over basic authentication More info:
 * https://prometheus.io/docs/operating/configuration/#endpoints
 */
export interface BasicAuth {
  /**
   * The secret in the service monitor namespace that contains the password for authentication.
   */
  password?: Password;
  /**
   * The secret in the service monitor namespace that contains the username for authentication.
   */
  username?: Username;
}

/**
 * The secret in the service monitor namespace that contains the password for authentication.
 */
export interface Password {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * The secret in the service monitor namespace that contains the username for authentication.
 */
export interface Username {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * Secret to mount to read bearer token for scraping targets. The secret needs to be in the
 * same namespace as the service monitor and accessible by the Prometheus Operator.
 */
export interface BearerTokenSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped
 * samples and remote write samples.
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 */
export interface MetricRelabeling {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and
   * `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   */
  action?: Action;
  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   */
  modulus?: number;
  /**
   * Regular expression against which the extracted value is matched.
   */
  regex?: string;
  /**
   * Replacement value against which a Replace action is performed if the regular expression
   * matches.
   * Regex capture groups are available.
   */
  replacement?: string;
  /**
   * Separator is the string between concatenated SourceLabels.
   */
  separator?: string;
  /**
   * The source labels select values from existing labels. Their content is concatenated using
   * the configured Separator and matched against the configured regular expression.
   */
  sourceLabels?: string[];
  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and
   * `DropEqual` actions.
   * Regex capture groups are available.
   */
  targetLabel?: string;
}

/**
 * Action to perform based on the regex matching.
 * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and
 * `KeepEqual` actions require Prometheus >= v2.41.0.
 * Default: "Replace"
 */
export enum Action {
  ActionDrop = "Drop",
  ActionKeep = "Keep",
  ActionLowercase = "Lowercase",
  ActionReplace = "Replace",
  ActionUppercase = "Uppercase",
  Drop = "drop",
  DropEqual = "DropEqual",
  Dropequal = "dropequal",
  HashMod = "HashMod",
  Hashmod = "hashmod",
  Keep = "keep",
  KeepEqual = "KeepEqual",
  Keepequal = "keepequal",
  LabelDrop = "LabelDrop",
  LabelKeep = "LabelKeep",
  LabelMap = "LabelMap",
  Labeldrop = "labeldrop",
  Labelkeep = "labelkeep",
  Labelmap = "labelmap",
  Lowercase = "lowercase",
  Replace = "replace",
  Uppercase = "uppercase",
}

/**
 * OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
 */
export interface Oauth2 {
  /**
   * The secret or configmap containing the OAuth2 client id
   */
  clientId: ClientID;
  /**
   * The secret containing the OAuth2 client secret
   */
  clientSecret: ClientSecret;
  /**
   * Parameters to append to the token URL
   */
  endpointParams?: { [key: string]: string };
  /**
   * OAuth2 scopes used for the token request
   */
  scopes?: string[];
  /**
   * The URL to fetch the token from
   */
  tokenUrl: string;
}

/**
 * The secret or configmap containing the OAuth2 client id
 */
export interface ClientID {
  /**
   * ConfigMap containing data to use for the targets.
   */
  configMap?: ClientIDConfigMap;
  /**
   * Secret containing data to use for the targets.
   */
  secret?: ClientIDSecret;
}

/**
 * ConfigMap containing data to use for the targets.
 */
export interface ClientIDConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * Secret containing data to use for the targets.
 */
export interface ClientIDSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * The secret containing the OAuth2 client secret
 */
export interface ClientSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * RelabelConfig allows dynamic rewriting of the label set for targets, alerts, scraped
 * samples and remote write samples.
 * More info:
 * https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
 */
export interface Relabeling {
  /**
   * Action to perform based on the regex matching.
   * `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0. `DropEqual` and
   * `KeepEqual` actions require Prometheus >= v2.41.0.
   * Default: "Replace"
   */
  action?: Action;
  /**
   * Modulus to take of the hash of the source label values.
   * Only applicable when the action is `HashMod`.
   */
  modulus?: number;
  /**
   * Regular expression against which the extracted value is matched.
   */
  regex?: string;
  /**
   * Replacement value against which a Replace action is performed if the regular expression
   * matches.
   * Regex capture groups are available.
   */
  replacement?: string;
  /**
   * Separator is the string between concatenated SourceLabels.
   */
  separator?: string;
  /**
   * The source labels select values from existing labels. Their content is concatenated using
   * the configured Separator and matched against the configured regular expression.
   */
  sourceLabels?: string[];
  /**
   * Label to which the resulting string is written in a replacement.
   * It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`, `KeepEqual` and
   * `DropEqual` actions.
   * Regex capture groups are available.
   */
  targetLabel?: string;
}

/**
 * HTTP scheme to use for scraping. `http` and `https` are the expected values unless you
 * rewrite the `__scheme__` label via relabeling. If empty, Prometheus uses the default
 * value `http`.
 */
export enum Scheme {
  HTTP = "http",
  HTTPS = "https",
}

/**
 * TLS configuration to use when scraping the endpoint
 */
export interface TLSConfig {
  /**
   * Certificate authority used when verifying server certificates.
   */
  ca?: CA;
  /**
   * Path to the CA cert in the Prometheus container to use for the targets.
   */
  caFile?: string;
  /**
   * Client certificate to present when doing client-authentication.
   */
  cert?: CERT;
  /**
   * Path to the client cert file in the Prometheus container for the targets.
   */
  certFile?: string;
  /**
   * Disable target certificate validation.
   */
  insecureSkipVerify?: boolean;
  /**
   * Path to the client key file in the Prometheus container for the targets.
   */
  keyFile?: string;
  /**
   * Secret containing the client key file for the targets.
   */
  keySecret?: KeySecret;
  /**
   * Used to verify the hostname for the targets.
   */
  serverName?: string;
}

/**
 * Certificate authority used when verifying server certificates.
 */
export interface CA {
  /**
   * ConfigMap containing data to use for the targets.
   */
  configMap?: CAConfigMap;
  /**
   * Secret containing data to use for the targets.
   */
  secret?: CASecret;
}

/**
 * ConfigMap containing data to use for the targets.
 */
export interface CAConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * Secret containing data to use for the targets.
 */
export interface CASecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * Client certificate to present when doing client-authentication.
 */
export interface CERT {
  /**
   * ConfigMap containing data to use for the targets.
   */
  configMap?: CERTConfigMap;
  /**
   * Secret containing data to use for the targets.
   */
  secret?: CERTSecret;
}

/**
 * ConfigMap containing data to use for the targets.
 */
export interface CERTConfigMap {
  /**
   * The key to select.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the ConfigMap or its key must be defined
   */
  optional?: boolean;
}

/**
 * Secret containing data to use for the targets.
 */
export interface CERTSecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * Secret containing the client key file for the targets.
 */
export interface KeySecret {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   */
  key: string;
  /**
   * Name of the referent. More info:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add
   * other useful fields. apiVersion, kind, uid?
   */
  name?: string;
  /**
   * Specify whether the Secret or its key must be defined
   */
  optional?: boolean;
}

/**
 * Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
 */
export interface NamespaceSelector {
  /**
   * Boolean describing whether all namespaces are selected in contrast to a list restricting
   * them.
   */
  any?: boolean;
  /**
   * List of namespace names to select from.
   */
  matchNames?: string[];
}

/**
 * Selector to select Endpoints objects.
 */
export interface Selector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   */
  matchExpressions?: MatchExpression[];
  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is
   * equivalent to an element of matchExpressions, whose key field is "key", the operator is
   * "In", and the values array contains only "value". The requirements are ANDed.
   */
  matchLabels?: { [key: string]: string };
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 */
export interface MatchExpression {
  /**
   * key is the label key that the selector applies to.
   */
  key: string;
  /**
   * operator represents a key's relationship to a set of values. Valid operators are In,
   * NotIn, Exists and DoesNotExist.
   */
  operator: string;
  /**
   * values is an array of string values. If the operator is In or NotIn, the values array
   * must be non-empty. If the operator is Exists or DoesNotExist, the values array must be
   * empty. This array is replaced during a strategic merge patch.
   */
  values?: string[];
}

RegisterKind(ServiceMonitor, {
  group: "monitoring.coreos.com",
  version: "v1",
  kind: "ServiceMonitor",
});
